import {
  require_prop_types
} from "./chunk-B6EY22UA.js";
import {
  require_react_dom
} from "./chunk-TKS5FRHW.js";
import {
  init_emotion_is_prop_valid_esm,
  isPropValid
} from "./chunk-6X5AV63Z.js";
import {
  require_jsx_runtime
} from "./chunk-NJLIVH7H.js";
import {
  require_react
} from "./chunk-HUL2CLQT.js";
import {
  __commonJS,
  __publicField,
  __toESM
} from "./chunk-EWTE5DHJ.js";

// node_modules/use-sync-external-store/cjs/use-sync-external-store-with-selector.development.js
var require_use_sync_external_store_with_selector_development = __commonJS({
  "node_modules/use-sync-external-store/cjs/use-sync-external-store-with-selector.development.js"(exports) {
    "use strict";
    (function() {
      function is(x3, y3) {
        return x3 === y3 && (0 !== x3 || 1 / x3 === 1 / y3) || x3 !== x3 && y3 !== y3;
      }
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
      var React171 = require_react(), objectIs = "function" === typeof Object.is ? Object.is : is, useSyncExternalStore = React171.useSyncExternalStore, useRef20 = React171.useRef, useEffect26 = React171.useEffect, useMemo26 = React171.useMemo, useDebugValue4 = React171.useDebugValue;
      exports.useSyncExternalStoreWithSelector = function(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
        var instRef = useRef20(null);
        if (null === instRef.current) {
          var inst = { hasValue: false, value: null };
          instRef.current = inst;
        } else inst = instRef.current;
        instRef = useMemo26(
          function() {
            function memoizedSelector(nextSnapshot) {
              if (!hasMemo) {
                hasMemo = true;
                memoizedSnapshot = nextSnapshot;
                nextSnapshot = selector(nextSnapshot);
                if (void 0 !== isEqual && inst.hasValue) {
                  var currentSelection = inst.value;
                  if (isEqual(currentSelection, nextSnapshot))
                    return memoizedSelection = currentSelection;
                }
                return memoizedSelection = nextSnapshot;
              }
              currentSelection = memoizedSelection;
              if (objectIs(memoizedSnapshot, nextSnapshot))
                return currentSelection;
              var nextSelection = selector(nextSnapshot);
              if (void 0 !== isEqual && isEqual(currentSelection, nextSelection))
                return memoizedSnapshot = nextSnapshot, currentSelection;
              memoizedSnapshot = nextSnapshot;
              return memoizedSelection = nextSelection;
            }
            var hasMemo = false, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
            return [
              function() {
                return memoizedSelector(getSnapshot());
              },
              null === maybeGetServerSnapshot ? void 0 : function() {
                return memoizedSelector(maybeGetServerSnapshot());
              }
            ];
          },
          [getSnapshot, getServerSnapshot, selector, isEqual]
        );
        var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);
        useEffect26(
          function() {
            inst.hasValue = true;
            inst.value = value;
          },
          [value]
        );
        useDebugValue4(value);
        return value;
      };
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    })();
  }
});

// node_modules/use-sync-external-store/with-selector.js
var require_with_selector = __commonJS({
  "node_modules/use-sync-external-store/with-selector.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_use_sync_external_store_with_selector_development();
    }
  }
});

// node_modules/bezier-easing/src/index.js
var require_src = __commonJS({
  "node_modules/bezier-easing/src/index.js"(exports, module) {
    var NEWTON_ITERATIONS = 4;
    var NEWTON_MIN_SLOPE = 1e-3;
    var SUBDIVISION_PRECISION = 1e-7;
    var SUBDIVISION_MAX_ITERATIONS = 10;
    var kSplineTableSize = 11;
    var kSampleStepSize = 1 / (kSplineTableSize - 1);
    var float32ArraySupported = typeof Float32Array === "function";
    function A3(aA1, aA2) {
      return 1 - 3 * aA2 + 3 * aA1;
    }
    function B4(aA1, aA2) {
      return 3 * aA2 - 6 * aA1;
    }
    function C3(aA1) {
      return 3 * aA1;
    }
    function calcBezier(aT, aA1, aA2) {
      return ((A3(aA1, aA2) * aT + B4(aA1, aA2)) * aT + C3(aA1)) * aT;
    }
    function getSlope(aT, aA1, aA2) {
      return 3 * A3(aA1, aA2) * aT * aT + 2 * B4(aA1, aA2) * aT + C3(aA1);
    }
    function binarySubdivide(aX, aA, aB, mX1, mX2) {
      var currentX, currentT, i2 = 0;
      do {
        currentT = aA + (aB - aA) / 2;
        currentX = calcBezier(currentT, mX1, mX2) - aX;
        if (currentX > 0) {
          aB = currentT;
        } else {
          aA = currentT;
        }
      } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i2 < SUBDIVISION_MAX_ITERATIONS);
      return currentT;
    }
    function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
      for (var i2 = 0; i2 < NEWTON_ITERATIONS; ++i2) {
        var currentSlope = getSlope(aGuessT, mX1, mX2);
        if (currentSlope === 0) {
          return aGuessT;
        }
        var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
        aGuessT -= currentX / currentSlope;
      }
      return aGuessT;
    }
    function LinearEasing(x3) {
      return x3;
    }
    module.exports = function bezier(mX1, mY1, mX2, mY2) {
      if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {
        throw new Error("bezier x values must be in [0, 1] range");
      }
      if (mX1 === mY1 && mX2 === mY2) {
        return LinearEasing;
      }
      var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
      for (var i2 = 0; i2 < kSplineTableSize; ++i2) {
        sampleValues[i2] = calcBezier(i2 * kSampleStepSize, mX1, mX2);
      }
      function getTForX(aX) {
        var intervalStart = 0;
        var currentSample = 1;
        var lastSample = kSplineTableSize - 1;
        for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
          intervalStart += kSampleStepSize;
        }
        --currentSample;
        var dist2 = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
        var guessForT = intervalStart + dist2 * kSampleStepSize;
        var initialSlope = getSlope(guessForT, mX1, mX2);
        if (initialSlope >= NEWTON_MIN_SLOPE) {
          return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
        } else if (initialSlope === 0) {
          return guessForT;
        } else {
          return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
        }
      }
      return function BezierEasing2(x3) {
        if (x3 === 0) {
          return 0;
        }
        if (x3 === 1) {
          return 1;
        }
        return calcBezier(getTForX(x3), mY1, mY2);
      };
    };
  }
});

// node_modules/shallowequal/index.js
var require_shallowequal = __commonJS({
  "node_modules/shallowequal/index.js"(exports, module) {
    module.exports = function shallowEqual2(objA, objB, compare, compareContext) {
      var ret = compare ? compare.call(compareContext, objA, objB) : void 0;
      if (ret !== void 0) {
        return !!ret;
      }
      if (objA === objB) {
        return true;
      }
      if (typeof objA !== "object" || !objA || typeof objB !== "object" || !objB) {
        return false;
      }
      var keysA = Object.keys(objA);
      var keysB = Object.keys(objB);
      if (keysA.length !== keysB.length) {
        return false;
      }
      var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);
      for (var idx = 0; idx < keysA.length; idx++) {
        var key = keysA[idx];
        if (!bHasOwnProperty(key)) {
          return false;
        }
        var valueA = objA[key];
        var valueB = objB[key];
        ret = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;
        if (ret === false || ret === void 0 && valueA !== valueB) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/@mui/utils/node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/@mui/utils/node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    (function() {
      function typeOf(object) {
        if ("object" === typeof object && null !== object) {
          var $$typeof = object.$$typeof;
          switch ($$typeof) {
            case REACT_ELEMENT_TYPE:
              switch (object = object.type, object) {
                case REACT_FRAGMENT_TYPE:
                case REACT_PROFILER_TYPE:
                case REACT_STRICT_MODE_TYPE:
                case REACT_SUSPENSE_TYPE:
                case REACT_SUSPENSE_LIST_TYPE:
                case REACT_VIEW_TRANSITION_TYPE:
                  return object;
                default:
                  switch (object = object && object.$$typeof, object) {
                    case REACT_CONTEXT_TYPE:
                    case REACT_FORWARD_REF_TYPE:
                    case REACT_LAZY_TYPE:
                    case REACT_MEMO_TYPE:
                      return object;
                    case REACT_CONSUMER_TYPE:
                      return object;
                    default:
                      return $$typeof;
                  }
              }
            case REACT_PORTAL_TYPE:
              return $$typeof;
          }
        }
      }
      var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
      Symbol.for("react.provider");
      var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
      exports.ContextConsumer = REACT_CONSUMER_TYPE;
      exports.ContextProvider = REACT_CONTEXT_TYPE;
      exports.Element = REACT_ELEMENT_TYPE;
      exports.ForwardRef = REACT_FORWARD_REF_TYPE;
      exports.Fragment = REACT_FRAGMENT_TYPE;
      exports.Lazy = REACT_LAZY_TYPE;
      exports.Memo = REACT_MEMO_TYPE;
      exports.Portal = REACT_PORTAL_TYPE;
      exports.Profiler = REACT_PROFILER_TYPE;
      exports.StrictMode = REACT_STRICT_MODE_TYPE;
      exports.Suspense = REACT_SUSPENSE_TYPE;
      exports.SuspenseList = REACT_SUSPENSE_LIST_TYPE;
      exports.isContextConsumer = function(object) {
        return typeOf(object) === REACT_CONSUMER_TYPE;
      };
      exports.isContextProvider = function(object) {
        return typeOf(object) === REACT_CONTEXT_TYPE;
      };
      exports.isElement = function(object) {
        return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
      };
      exports.isForwardRef = function(object) {
        return typeOf(object) === REACT_FORWARD_REF_TYPE;
      };
      exports.isFragment = function(object) {
        return typeOf(object) === REACT_FRAGMENT_TYPE;
      };
      exports.isLazy = function(object) {
        return typeOf(object) === REACT_LAZY_TYPE;
      };
      exports.isMemo = function(object) {
        return typeOf(object) === REACT_MEMO_TYPE;
      };
      exports.isPortal = function(object) {
        return typeOf(object) === REACT_PORTAL_TYPE;
      };
      exports.isProfiler = function(object) {
        return typeOf(object) === REACT_PROFILER_TYPE;
      };
      exports.isStrictMode = function(object) {
        return typeOf(object) === REACT_STRICT_MODE_TYPE;
      };
      exports.isSuspense = function(object) {
        return typeOf(object) === REACT_SUSPENSE_TYPE;
      };
      exports.isSuspenseList = function(object) {
        return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
      };
      exports.isValidElementType = function(type) {
        return "string" === typeof type || "function" === typeof type || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || "object" === typeof type && null !== type && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE || void 0 !== type.getModuleId) ? true : false;
      };
      exports.typeOf = typeOf;
    })();
  }
});

// node_modules/@mui/utils/node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/@mui/utils/node_modules/react-is/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development();
    }
  }
});

// node_modules/@mui/x-charts/esm/constants/index.js
var DEFAULT_X_AXIS_KEY = "DEFAULT_X_AXIS_KEY";
var DEFAULT_Y_AXIS_KEY = "DEFAULT_Y_AXIS_KEY";
var DEFAULT_ROTATION_AXIS_KEY = "DEFAULT_ROTATION_AXIS_KEY";
var DEFAULT_RADIUS_AXIS_KEY = "DEFAULT_RADIUS_AXIS_KEY";
var DEFAULT_MARGINS = {
  top: 20,
  bottom: 20,
  left: 20,
  right: 20
};
var DEFAULT_AXIS_SIZE_WIDTH = 45;
var DEFAULT_AXIS_SIZE_HEIGHT = 25;
var AXIS_LABEL_DEFAULT_HEIGHT = 20;

// node_modules/@mui/x-charts/esm/context/ChartProvider/ChartProvider.js
var React14 = __toESM(require_react(), 1);

// node_modules/@mui/x-charts/esm/internals/store/useCharts.js
var React7 = __toESM(require_react(), 1);

// node_modules/@mui/utils/esm/useId/useId.js
var React = __toESM(require_react(), 1);
var globalId = 0;
function useGlobalId(idOverride) {
  const [defaultId, setDefaultId] = React.useState(idOverride);
  const id = idOverride || defaultId;
  React.useEffect(() => {
    if (defaultId == null) {
      globalId += 1;
      setDefaultId(`mui-${globalId}`);
    }
  }, [defaultId]);
  return id;
}
var safeReact = {
  ...React
};
var maybeReactUseId = safeReact.useId;
function useId(idOverride) {
  if (maybeReactUseId !== void 0) {
    const reactId = maybeReactUseId();
    return idOverride ?? reactId;
  }
  return useGlobalId(idOverride);
}

// node_modules/@mui/x-charts/esm/internals/plugins/utils/ChartStore.js
var ChartStore = class {
  constructor(value) {
    this.value = void 0;
    this.listeners = void 0;
    this.subscribe = (fn2) => {
      this.listeners.add(fn2);
      return () => {
        this.listeners.delete(fn2);
      };
    };
    this.getSnapshot = () => {
      return this.value;
    };
    this.update = (updater) => {
      const newState = updater(this.value);
      if (newState !== this.value) {
        this.value = newState;
        this.listeners.forEach((l2) => l2(newState));
      }
    };
    this.value = value;
    this.listeners = /* @__PURE__ */ new Set();
  }
};

// node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r3 in t) ({}).hasOwnProperty.call(t, r3) && (n[r3] = t[r3]);
    }
    return n;
  }, _extends.apply(null, arguments);
}

// node_modules/@mui/x-charts/esm/internals/plugins/corePlugins/useChartAnimation/useChartAnimation.js
var React3 = __toESM(require_react(), 1);

// node_modules/@mui/utils/esm/useEnhancedEffect/useEnhancedEffect.js
var React2 = __toESM(require_react(), 1);
var useEnhancedEffect = typeof window !== "undefined" ? React2.useLayoutEffect : React2.useEffect;
var useEnhancedEffect_default = useEnhancedEffect;

// node_modules/@mui/x-charts/esm/internals/plugins/corePlugins/useChartAnimation/useChartAnimation.js
var useChartAnimation = ({
  params,
  store
}) => {
  React3.useEffect(() => {
    store.update((prevState) => {
      return _extends({}, prevState, {
        animation: _extends({}, prevState.animation, {
          skip: params.skipAnimation
        })
      });
    });
  }, [store, params.skipAnimation]);
  const disableAnimation = React3.useCallback(() => {
    let disableCalled = false;
    store.update((prevState) => _extends({}, prevState, {
      animation: _extends({}, prevState.animation, {
        skipAnimationRequests: prevState.animation.skipAnimationRequests + 1
      })
    }));
    return () => {
      if (disableCalled) {
        return;
      }
      disableCalled = true;
      store.update((prevState) => _extends({}, prevState, {
        animation: _extends({}, prevState.animation, {
          skipAnimationRequests: prevState.animation.skipAnimationRequests - 1
        })
      }));
    };
  }, [store]);
  useEnhancedEffect_default(() => {
    const isAnimationDisabledEnvironment = typeof window === "undefined" || !(window == null ? void 0 : window.matchMedia);
    if (isAnimationDisabledEnvironment) {
      return void 0;
    }
    let disableAnimationCleanup;
    const handleMediaChange = (event) => {
      if (event.matches) {
        disableAnimationCleanup = disableAnimation();
      } else {
        disableAnimationCleanup == null ? void 0 : disableAnimationCleanup();
      }
    };
    const mql = window.matchMedia("(prefers-reduced-motion)");
    handleMediaChange(mql);
    mql.addEventListener("change", handleMediaChange);
    return () => {
      mql.removeEventListener("change", handleMediaChange);
    };
  }, [disableAnimation, store]);
  return {
    instance: {
      disableAnimation
    }
  };
};
useChartAnimation.params = {
  skipAnimation: true
};
useChartAnimation.getDefaultizedParams = ({
  params
}) => _extends({}, params, {
  skipAnimation: params.skipAnimation ?? false
});
useChartAnimation.getInitialState = ({
  skipAnimation
}) => {
  const isAnimationDisabledEnvironment = typeof window === "undefined" || !(window == null ? void 0 : window.matchMedia);
  const disableAnimations = false ? isAnimationDisabledEnvironment : false;
  return {
    animation: {
      skip: skipAnimation,
      // By initializing the skipAnimationRequests to 1, we ensure that the animation is always skipped
      skipAnimationRequests: disableAnimations ? 1 : 0
    }
  };
};

// node_modules/reselect/dist/reselect.mjs
var runIdentityFunctionCheck = (resultFunc, inputSelectorsResults, outputSelectorResult) => {
  if (inputSelectorsResults.length === 1 && inputSelectorsResults[0] === outputSelectorResult) {
    let isInputSameAsOutput = false;
    try {
      const emptyObject = {};
      if (resultFunc(emptyObject) === emptyObject)
        isInputSameAsOutput = true;
    } catch {
    }
    if (isInputSameAsOutput) {
      let stack = void 0;
      try {
        throw new Error();
      } catch (e) {
        ;
        ({ stack } = e);
      }
      console.warn(
        "The result function returned its own inputs without modification. e.g\n`createSelector([state => state.todos], todos => todos)`\nThis could lead to inefficient memoization and unnecessary re-renders.\nEnsure transformation logic is in the result function, and extraction logic is in the input selectors.",
        { stack }
      );
    }
  }
};
var runInputStabilityCheck = (inputSelectorResultsObject, options, inputSelectorArgs) => {
  const { memoize: memoize2, memoizeOptions } = options;
  const { inputSelectorResults, inputSelectorResultsCopy } = inputSelectorResultsObject;
  const createAnEmptyObject = memoize2(() => ({}), ...memoizeOptions);
  const areInputSelectorResultsEqual = createAnEmptyObject.apply(null, inputSelectorResults) === createAnEmptyObject.apply(null, inputSelectorResultsCopy);
  if (!areInputSelectorResultsEqual) {
    let stack = void 0;
    try {
      throw new Error();
    } catch (e) {
      ;
      ({ stack } = e);
    }
    console.warn(
      "An input selector returned a different result when passed same arguments.\nThis means your output selector will likely run more frequently than intended.\nAvoid returning a new reference inside your input selector, e.g.\n`createSelector([state => state.todos.map(todo => todo.id)], todoIds => todoIds.length)`",
      {
        arguments: inputSelectorArgs,
        firstInputs: inputSelectorResults,
        secondInputs: inputSelectorResultsCopy,
        stack
      }
    );
  }
};
var globalDevModeChecks = {
  inputStabilityCheck: "once",
  identityFunctionCheck: "once"
};
var NOT_FOUND = Symbol("NOT_FOUND");
function assertIsFunction(func, errorMessage = `expected a function, instead received ${typeof func}`) {
  if (typeof func !== "function") {
    throw new TypeError(errorMessage);
  }
}
function assertIsObject(object, errorMessage = `expected an object, instead received ${typeof object}`) {
  if (typeof object !== "object") {
    throw new TypeError(errorMessage);
  }
}
function assertIsArrayOfFunctions(array2, errorMessage = `expected all items to be functions, instead received the following types: `) {
  if (!array2.every((item) => typeof item === "function")) {
    const itemTypes = array2.map(
      (item) => typeof item === "function" ? `function ${item.name || "unnamed"}()` : typeof item
    ).join(", ");
    throw new TypeError(`${errorMessage}[${itemTypes}]`);
  }
}
var ensureIsArray = (item) => {
  return Array.isArray(item) ? item : [item];
};
function getDependencies(createSelectorArgs) {
  const dependencies = Array.isArray(createSelectorArgs[0]) ? createSelectorArgs[0] : createSelectorArgs;
  assertIsArrayOfFunctions(
    dependencies,
    `createSelector expects all input-selectors to be functions, but received the following types: `
  );
  return dependencies;
}
function collectInputSelectorResults(dependencies, inputSelectorArgs) {
  const inputSelectorResults = [];
  const { length: length2 } = dependencies;
  for (let i2 = 0; i2 < length2; i2++) {
    inputSelectorResults.push(dependencies[i2].apply(null, inputSelectorArgs));
  }
  return inputSelectorResults;
}
var getDevModeChecksExecutionInfo = (firstRun, devModeChecks) => {
  const { identityFunctionCheck, inputStabilityCheck } = {
    ...globalDevModeChecks,
    ...devModeChecks
  };
  return {
    identityFunctionCheck: {
      shouldRun: identityFunctionCheck === "always" || identityFunctionCheck === "once" && firstRun,
      run: runIdentityFunctionCheck
    },
    inputStabilityCheck: {
      shouldRun: inputStabilityCheck === "always" || inputStabilityCheck === "once" && firstRun,
      run: runInputStabilityCheck
    }
  };
};
var REDUX_PROXY_LABEL = Symbol();
var proto = Object.getPrototypeOf({});
function createSingletonCache(equals) {
  let entry;
  return {
    get(key) {
      if (entry && equals(entry.key, key)) {
        return entry.value;
      }
      return NOT_FOUND;
    },
    put(key, value) {
      entry = { key, value };
    },
    getEntries() {
      return entry ? [entry] : [];
    },
    clear() {
      entry = void 0;
    }
  };
}
function createLruCache(maxSize, equals) {
  let entries = [];
  function get(key) {
    const cacheIndex = entries.findIndex((entry) => equals(key, entry.key));
    if (cacheIndex > -1) {
      const entry = entries[cacheIndex];
      if (cacheIndex > 0) {
        entries.splice(cacheIndex, 1);
        entries.unshift(entry);
      }
      return entry.value;
    }
    return NOT_FOUND;
  }
  function put(key, value) {
    if (get(key) === NOT_FOUND) {
      entries.unshift({ key, value });
      if (entries.length > maxSize) {
        entries.pop();
      }
    }
  }
  function getEntries() {
    return entries;
  }
  function clear() {
    entries = [];
  }
  return { get, put, getEntries, clear };
}
var referenceEqualityCheck = (a3, b2) => a3 === b2;
function createCacheKeyComparator(equalityCheck) {
  return function areArgumentsShallowlyEqual(prev2, next2) {
    if (prev2 === null || next2 === null || prev2.length !== next2.length) {
      return false;
    }
    const { length: length2 } = prev2;
    for (let i2 = 0; i2 < length2; i2++) {
      if (!equalityCheck(prev2[i2], next2[i2])) {
        return false;
      }
    }
    return true;
  };
}
function lruMemoize(func, equalityCheckOrOptions) {
  const providedOptions = typeof equalityCheckOrOptions === "object" ? equalityCheckOrOptions : { equalityCheck: equalityCheckOrOptions };
  const {
    equalityCheck = referenceEqualityCheck,
    maxSize = 1,
    resultEqualityCheck
  } = providedOptions;
  const comparator = createCacheKeyComparator(equalityCheck);
  let resultsCount = 0;
  const cache2 = maxSize <= 1 ? createSingletonCache(comparator) : createLruCache(maxSize, comparator);
  function memoized() {
    let value = cache2.get(arguments);
    if (value === NOT_FOUND) {
      value = func.apply(null, arguments);
      resultsCount++;
      if (resultEqualityCheck) {
        const entries = cache2.getEntries();
        const matchingEntry = entries.find(
          (entry) => resultEqualityCheck(entry.value, value)
        );
        if (matchingEntry) {
          value = matchingEntry.value;
          resultsCount !== 0 && resultsCount--;
        }
      }
      cache2.put(arguments, value);
    }
    return value;
  }
  memoized.clearCache = () => {
    cache2.clear();
    memoized.resetResultsCount();
  };
  memoized.resultsCount = () => resultsCount;
  memoized.resetResultsCount = () => {
    resultsCount = 0;
  };
  return memoized;
}
var StrongRef = class {
  constructor(value) {
    this.value = value;
  }
  deref() {
    return this.value;
  }
};
var Ref = typeof WeakRef !== "undefined" ? WeakRef : StrongRef;
var UNTERMINATED = 0;
var TERMINATED = 1;
function createCacheNode() {
  return {
    s: UNTERMINATED,
    v: void 0,
    o: null,
    p: null
  };
}
function weakMapMemoize(func, options = {}) {
  let fnNode = createCacheNode();
  const { resultEqualityCheck } = options;
  let lastResult;
  let resultsCount = 0;
  function memoized() {
    var _a;
    let cacheNode = fnNode;
    const { length: length2 } = arguments;
    for (let i2 = 0, l2 = length2; i2 < l2; i2++) {
      const arg2 = arguments[i2];
      if (typeof arg2 === "function" || typeof arg2 === "object" && arg2 !== null) {
        let objectCache = cacheNode.o;
        if (objectCache === null) {
          cacheNode.o = objectCache = /* @__PURE__ */ new WeakMap();
        }
        const objectNode = objectCache.get(arg2);
        if (objectNode === void 0) {
          cacheNode = createCacheNode();
          objectCache.set(arg2, cacheNode);
        } else {
          cacheNode = objectNode;
        }
      } else {
        let primitiveCache = cacheNode.p;
        if (primitiveCache === null) {
          cacheNode.p = primitiveCache = /* @__PURE__ */ new Map();
        }
        const primitiveNode = primitiveCache.get(arg2);
        if (primitiveNode === void 0) {
          cacheNode = createCacheNode();
          primitiveCache.set(arg2, cacheNode);
        } else {
          cacheNode = primitiveNode;
        }
      }
    }
    const terminatedNode = cacheNode;
    let result;
    if (cacheNode.s === TERMINATED) {
      result = cacheNode.v;
    } else {
      result = func.apply(null, arguments);
      resultsCount++;
      if (resultEqualityCheck) {
        const lastResultValue = ((_a = lastResult == null ? void 0 : lastResult.deref) == null ? void 0 : _a.call(lastResult)) ?? lastResult;
        if (lastResultValue != null && resultEqualityCheck(lastResultValue, result)) {
          result = lastResultValue;
          resultsCount !== 0 && resultsCount--;
        }
        const needsWeakRef = typeof result === "object" && result !== null || typeof result === "function";
        lastResult = needsWeakRef ? new Ref(result) : result;
      }
    }
    terminatedNode.s = TERMINATED;
    terminatedNode.v = result;
    return result;
  }
  memoized.clearCache = () => {
    fnNode = createCacheNode();
    memoized.resetResultsCount();
  };
  memoized.resultsCount = () => resultsCount;
  memoized.resetResultsCount = () => {
    resultsCount = 0;
  };
  return memoized;
}
function createSelectorCreator(memoizeOrOptions, ...memoizeOptionsFromArgs) {
  const createSelectorCreatorOptions = typeof memoizeOrOptions === "function" ? {
    memoize: memoizeOrOptions,
    memoizeOptions: memoizeOptionsFromArgs
  } : memoizeOrOptions;
  const createSelector22 = (...createSelectorArgs) => {
    let recomputations = 0;
    let dependencyRecomputations = 0;
    let lastResult;
    let directlyPassedOptions = {};
    let resultFunc = createSelectorArgs.pop();
    if (typeof resultFunc === "object") {
      directlyPassedOptions = resultFunc;
      resultFunc = createSelectorArgs.pop();
    }
    assertIsFunction(
      resultFunc,
      `createSelector expects an output function after the inputs, but received: [${typeof resultFunc}]`
    );
    const combinedOptions = {
      ...createSelectorCreatorOptions,
      ...directlyPassedOptions
    };
    const {
      memoize: memoize2,
      memoizeOptions = [],
      argsMemoize = weakMapMemoize,
      argsMemoizeOptions = [],
      devModeChecks = {}
    } = combinedOptions;
    const finalMemoizeOptions = ensureIsArray(memoizeOptions);
    const finalArgsMemoizeOptions = ensureIsArray(argsMemoizeOptions);
    const dependencies = getDependencies(createSelectorArgs);
    const memoizedResultFunc = memoize2(function recomputationWrapper() {
      recomputations++;
      return resultFunc.apply(
        null,
        arguments
      );
    }, ...finalMemoizeOptions);
    let firstRun = true;
    const selector = argsMemoize(function dependenciesChecker() {
      dependencyRecomputations++;
      const inputSelectorResults = collectInputSelectorResults(
        dependencies,
        arguments
      );
      lastResult = memoizedResultFunc.apply(null, inputSelectorResults);
      if (true) {
        const { identityFunctionCheck, inputStabilityCheck } = getDevModeChecksExecutionInfo(firstRun, devModeChecks);
        if (identityFunctionCheck.shouldRun) {
          identityFunctionCheck.run(
            resultFunc,
            inputSelectorResults,
            lastResult
          );
        }
        if (inputStabilityCheck.shouldRun) {
          const inputSelectorResultsCopy = collectInputSelectorResults(
            dependencies,
            arguments
          );
          inputStabilityCheck.run(
            { inputSelectorResults, inputSelectorResultsCopy },
            { memoize: memoize2, memoizeOptions: finalMemoizeOptions },
            arguments
          );
        }
        if (firstRun)
          firstRun = false;
      }
      return lastResult;
    }, ...finalArgsMemoizeOptions);
    return Object.assign(selector, {
      resultFunc,
      memoizedResultFunc,
      dependencies,
      dependencyRecomputations: () => dependencyRecomputations,
      resetDependencyRecomputations: () => {
        dependencyRecomputations = 0;
      },
      lastResult: () => lastResult,
      recomputations: () => recomputations,
      resetRecomputations: () => {
        recomputations = 0;
      },
      memoize: memoize2,
      argsMemoize
    });
  };
  Object.assign(createSelector22, {
    withTypes: () => createSelector22
  });
  return createSelector22;
}
var createSelector = createSelectorCreator(weakMapMemoize);
var createStructuredSelector = Object.assign(
  (inputSelectorsObject, selectorCreator = createSelector) => {
    assertIsObject(
      inputSelectorsObject,
      `createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ${typeof inputSelectorsObject}`
    );
    const inputSelectorKeys = Object.keys(inputSelectorsObject);
    const dependencies = inputSelectorKeys.map(
      (key) => inputSelectorsObject[key]
    );
    const structuredSelector = selectorCreator(
      dependencies,
      (...inputSelectorResults) => {
        return inputSelectorResults.reduce((composition, value, index2) => {
          composition[inputSelectorKeys[index2]] = value;
          return composition;
        }, {});
      }
    );
    return structuredSelector;
  },
  { withTypes: () => createStructuredSelector }
);

// node_modules/@mui/x-charts/esm/internals/plugins/utils/selectors.js
var reselectCreateSelector = createSelectorCreator({
  memoize: lruMemoize,
  memoizeOptions: {
    maxSize: 1,
    equalityCheck: Object.is
  }
});
var cache = /* @__PURE__ */ new WeakMap();
var createSelector2 = (...createSelectorArgs) => {
  const selector = (state, selectorArgs) => {
    const cacheKey = state.cacheKey;
    let cacheForCurrentChartInstance = cache.get(cacheKey);
    if (!cacheForCurrentChartInstance) {
      cacheForCurrentChartInstance = /* @__PURE__ */ new Map();
      cache.set(cacheKey, cacheForCurrentChartInstance);
    }
    const cachedSelector = cacheForCurrentChartInstance.get(createSelectorArgs);
    if (cachedSelector) {
      return cachedSelector(state, selectorArgs);
    }
    const fn2 = reselectCreateSelector(...createSelectorArgs);
    cacheForCurrentChartInstance.set(createSelectorArgs, fn2);
    return fn2(state, selectorArgs);
  };
  return selector;
};

// node_modules/@mui/x-charts/esm/internals/plugins/corePlugins/useChartAnimation/useChartAnimation.selectors.js
var selectorChartAnimationState = (state) => state.animation;
var selectorChartSkipAnimation = createSelector2(selectorChartAnimationState, (state) => state.skip || state.skipAnimationRequests > 0);

// node_modules/@mui/x-charts/esm/internals/plugins/corePlugins/useChartDimensions/useChartDimensions.js
var React4 = __toESM(require_react(), 1);

// node_modules/@mui/utils/esm/ownerDocument/ownerDocument.js
function ownerDocument(node2) {
  return node2 && node2.ownerDocument || document;
}

// node_modules/@mui/utils/esm/ownerWindow/ownerWindow.js
function ownerWindow(node2) {
  const doc = ownerDocument(node2);
  return doc.defaultView || window;
}

// node_modules/@mui/x-charts/esm/internals/constants.js
var ZOOM_SLIDER_MARGIN = 4;
var ZOOM_SLIDER_SIZE = 20 + 2 * ZOOM_SLIDER_MARGIN;

// node_modules/@mui/x-charts/esm/internals/plugins/featurePlugins/useChartCartesianAxis/useChartCartesianAxisLayout.selectors.js
var selectorChartCartesianAxisState = (state) => state.cartesianAxis;
var selectorChartRawXAxis = createSelector2(selectorChartCartesianAxisState, (axis) => axis == null ? void 0 : axis.x);
var selectorChartRawYAxis = createSelector2(selectorChartCartesianAxisState, (axis) => axis == null ? void 0 : axis.y);

// node_modules/@mui/x-charts/esm/internals/plugins/featurePlugins/useChartCartesianAxis/useChartAxisSize.selectors.js
var selectorChartLeftAxisSize = createSelector2([selectorChartRawYAxis], (yAxis) => (yAxis ?? []).reduce((acc, axis) => {
  var _a;
  return axis.position === "left" ? acc + (axis.width || 0) + (((_a = axis.zoom) == null ? void 0 : _a.slider.enabled) ? ZOOM_SLIDER_SIZE : 0) : acc;
}, 0));
var selectorChartRightAxisSize = createSelector2([selectorChartRawYAxis], (yAxis) => (yAxis ?? []).reduce((acc, axis) => {
  var _a;
  return axis.position === "right" ? acc + (axis.width || 0) + (((_a = axis.zoom) == null ? void 0 : _a.slider.enabled) ? ZOOM_SLIDER_SIZE : 0) : acc;
}, 0));
var selectorChartTopAxisSize = createSelector2([selectorChartRawXAxis], (xAxis) => (xAxis ?? []).reduce((acc, axis) => {
  var _a;
  return axis.position === "top" ? acc + (axis.height || 0) + (((_a = axis.zoom) == null ? void 0 : _a.slider.enabled) ? ZOOM_SLIDER_SIZE : 0) : acc;
}, 0));
var selectorChartBottomAxisSize = createSelector2([selectorChartRawXAxis], (xAxis) => (xAxis ?? []).reduce((acc, axis) => {
  var _a;
  return axis.position === "bottom" ? acc + (axis.height || 0) + (((_a = axis.zoom) == null ? void 0 : _a.slider.enabled) ? ZOOM_SLIDER_SIZE : 0) : acc;
}, 0));

// node_modules/@mui/x-charts/esm/internals/plugins/corePlugins/useChartDimensions/useChartDimensions.selectors.js
var selectorChartDimensionsState = (state) => state.dimensions;
var selectorChartMargin = createSelector2(selectorChartDimensionsState, (dimensionsState) => dimensionsState.margin);
var selectorChartWidth = createSelector2(selectorChartDimensionsState, (dimensionsState) => dimensionsState.width);
var selectorChartHeight = createSelector2(selectorChartDimensionsState, (dimensionsState) => dimensionsState.height);
var selectorChartTopMargin = createSelector2(selectorChartMargin, (margin2) => margin2.top);
var selectorChartRightMargin = createSelector2(selectorChartMargin, (margin2) => margin2.right);
var selectorChartBottomMargin = createSelector2(selectorChartMargin, (margin2) => margin2.bottom);
var selectorChartLeftMargin = createSelector2(selectorChartMargin, (margin2) => margin2.left);
var selectorChartDrawingArea = createSelector2(selectorChartWidth, selectorChartHeight, selectorChartTopMargin, selectorChartRightMargin, selectorChartBottomMargin, selectorChartLeftMargin, selectorChartTopAxisSize, selectorChartRightAxisSize, selectorChartBottomAxisSize, selectorChartLeftAxisSize, (width2, height2, marginTop, marginRight, marginBottom, marginLeft, axisSizeTop, axisSizeRight, axisSizeBottom, axisSizeLeft) => ({
  width: width2 - marginLeft - marginRight - axisSizeLeft - axisSizeRight,
  left: marginLeft + axisSizeLeft,
  right: marginRight + axisSizeRight,
  height: height2 - marginTop - marginBottom - axisSizeTop - axisSizeBottom,
  top: marginTop + axisSizeTop,
  bottom: marginBottom + axisSizeBottom
}));
var selectorChartPropsSize = createSelector2(selectorChartDimensionsState, (dimensionsState) => ({
  width: dimensionsState.propsWidth,
  height: dimensionsState.propsHeight
}));
var selectorChartContainerSize = createSelector2(selectorChartWidth, selectorChartHeight, (width2, height2) => ({
  width: width2,
  height: height2
}));

// node_modules/@mui/x-charts/esm/internals/defaultizeMargin.js
function defaultizeMargin(input, defaultMargin2) {
  if (typeof input === "number") {
    return {
      top: input,
      bottom: input,
      left: input,
      right: input
    };
  }
  if (defaultMargin2) {
    return _extends({}, defaultMargin2, input);
  }
  return input;
}

// node_modules/@mui/x-charts/esm/internals/plugins/corePlugins/useChartDimensions/useChartDimensions.js
var MAX_COMPUTE_RUN = 10;
var useChartDimensions = ({
  params,
  store,
  svgRef
}) => {
  const hasInSize = params.width !== void 0 && params.height !== void 0;
  const stateRef = React4.useRef({
    displayError: false,
    initialCompute: true,
    computeRun: 0
  });
  const [innerWidth, setInnerWidth] = React4.useState(0);
  const [innerHeight, setInnerHeight] = React4.useState(0);
  const computeSize = React4.useCallback(() => {
    const mainEl = svgRef == null ? void 0 : svgRef.current;
    if (!mainEl) {
      return {};
    }
    const win = ownerWindow(mainEl);
    const computedStyle = win.getComputedStyle(mainEl);
    const newHeight = Math.floor(parseFloat(computedStyle.height)) || 0;
    const newWidth = Math.floor(parseFloat(computedStyle.width)) || 0;
    store.update((prev2) => {
      if (prev2.dimensions.width === newWidth && prev2.dimensions.height === newHeight) {
        return prev2;
      }
      return _extends({}, prev2, {
        dimensions: {
          margin: {
            top: params.margin.top,
            right: params.margin.right,
            bottom: params.margin.bottom,
            left: params.margin.left
          },
          width: params.width ?? newWidth,
          height: params.height ?? newHeight,
          propsWidth: params.width,
          propsHeight: params.height
        }
      });
    });
    return {
      height: newHeight,
      width: newWidth
    };
  }, [
    store,
    svgRef,
    params.height,
    params.width,
    // Margin is an object, so we need to include all the properties to prevent infinite loops.
    params.margin.left,
    params.margin.right,
    params.margin.top,
    params.margin.bottom
  ]);
  React4.useEffect(() => {
    store.update((prev2) => {
      const width2 = params.width ?? prev2.dimensions.width;
      const height2 = params.height ?? prev2.dimensions.height;
      return _extends({}, prev2, {
        dimensions: {
          margin: {
            top: params.margin.top,
            right: params.margin.right,
            bottom: params.margin.bottom,
            left: params.margin.left
          },
          width: width2,
          height: height2,
          propsHeight: params.height,
          propsWidth: params.width
        }
      });
    });
  }, [
    store,
    params.height,
    params.width,
    // Margin is an object, so we need to include all the properties to prevent infinite loops.
    params.margin.left,
    params.margin.right,
    params.margin.top,
    params.margin.bottom
  ]);
  React4.useEffect(() => {
    stateRef.current.displayError = true;
  }, []);
  useEnhancedEffect_default(() => {
    if (hasInSize || !stateRef.current.initialCompute || stateRef.current.computeRun > MAX_COMPUTE_RUN) {
      return;
    }
    const computedSize = computeSize();
    if (computedSize.width !== innerWidth || computedSize.height !== innerHeight) {
      stateRef.current.computeRun += 1;
      if (computedSize.width !== void 0) {
        setInnerWidth(computedSize.width);
      }
      if (computedSize.height !== void 0) {
        setInnerHeight(computedSize.height);
      }
    } else if (stateRef.current.initialCompute) {
      stateRef.current.initialCompute = false;
    }
  }, [innerHeight, innerWidth, computeSize, hasInSize]);
  useEnhancedEffect_default(() => {
    if (hasInSize) {
      return () => {
      };
    }
    computeSize();
    const elementToObserve = svgRef.current;
    if (typeof ResizeObserver === "undefined") {
      return () => {
      };
    }
    let animationFrame;
    const observer = new ResizeObserver(() => {
      animationFrame = requestAnimationFrame(() => {
        computeSize();
      });
    });
    if (elementToObserve) {
      observer.observe(elementToObserve);
    }
    return () => {
      if (animationFrame) {
        cancelAnimationFrame(animationFrame);
      }
      if (elementToObserve) {
        observer.unobserve(elementToObserve);
      }
    };
  }, [computeSize, hasInSize, svgRef]);
  if (true) {
    if (stateRef.current.displayError && params.width === void 0 && innerWidth === 0) {
      console.error(`MUI X Charts: ChartContainer does not have \`width\` prop, and its container has no \`width\` defined.`);
      stateRef.current.displayError = false;
    }
    if (stateRef.current.displayError && params.height === void 0 && innerHeight === 0) {
      console.error(`MUI X Charts: ChartContainer does not have \`height\` prop, and its container has no \`height\` defined.`);
      stateRef.current.displayError = false;
    }
  }
  const isPointInside = React4.useCallback(({
    x: x3,
    y: y3
  }, options) => {
    if ((options == null ? void 0 : options.targetElement) && (options == null ? void 0 : options.targetElement.closest("[data-drawing-container]"))) {
      return true;
    }
    const drawingArea = selectorChartDrawingArea(store.value);
    const isInsideX = x3 >= drawingArea.left - 1 && x3 <= drawingArea.left + drawingArea.width;
    const isInsideY = y3 >= drawingArea.top - 1 && y3 <= drawingArea.top + drawingArea.height;
    if ((options == null ? void 0 : options.direction) === "x") {
      return isInsideX;
    }
    if ((options == null ? void 0 : options.direction) === "y") {
      return isInsideY;
    }
    return isInsideX && isInsideY;
  }, [store.value]);
  return {
    instance: {
      isPointInside
    }
  };
};
useChartDimensions.params = {
  width: true,
  height: true,
  margin: true
};
useChartDimensions.getDefaultizedParams = ({
  params
}) => _extends({}, params, {
  margin: defaultizeMargin(params.margin, DEFAULT_MARGINS)
});
useChartDimensions.getInitialState = ({
  width: width2,
  height: height2,
  margin: margin2
}) => {
  return {
    dimensions: {
      margin: margin2,
      width: width2 ?? 0,
      height: height2 ?? 0,
      propsWidth: width2,
      propsHeight: height2
    }
  };
};

// node_modules/@mui/x-charts/esm/internals/plugins/corePlugins/useChartId/useChartId.js
var React5 = __toESM(require_react(), 1);

// node_modules/@mui/x-charts/esm/internals/plugins/corePlugins/useChartId/useChartId.utils.js
var globalChartDefaultId = 0;
var createChartDefaultId = () => {
  globalChartDefaultId += 1;
  return `mui-chart-${globalChartDefaultId}`;
};

// node_modules/@mui/x-charts/esm/internals/plugins/corePlugins/useChartId/useChartId.js
var useChartId = ({
  params,
  store
}) => {
  React5.useEffect(() => {
    store.update((prevState) => {
      if (params.id === void 0 || params.id === prevState.id.providedChartId && prevState.id.chartId !== void 0) {
        return prevState;
      }
      return _extends({}, prevState, {
        id: _extends({}, prevState.id, {
          chartId: params.id ?? createChartDefaultId()
        })
      });
    });
  }, [store, params.id]);
  return {};
};
useChartId.params = {
  id: true
};
useChartId.getInitialState = ({
  id
}) => ({
  id: {
    chartId: id,
    providedChartId: id
  }
});

// node_modules/@mui/x-charts/esm/internals/plugins/corePlugins/useChartId/useChartId.selectors.js
var selectorChartIdState = (state) => state.id;
var selectorChartId = createSelector2(selectorChartIdState, (idState) => idState.chartId);

// node_modules/@mui/x-charts/esm/internals/plugins/corePlugins/useChartSeries/useChartSeries.js
var React6 = __toESM(require_react(), 1);

// node_modules/@mui/x-charts/esm/colorPalettes/categorical/rainbowSurge.js
var rainbowSurgePaletteLight = ["#4254FB", "#FFB422", "#FA4F58", "#0DBEFF", "#22BF75", "#FA83B4", "#FF7511"];
var rainbowSurgePaletteDark = ["#495AFB", "#FFC758", "#F35865", "#30C8FF", "#44CE8D", "#F286B3", "#FF8C39"];
var rainbowSurgePalette = (mode2) => mode2 === "dark" ? rainbowSurgePaletteDark : rainbowSurgePaletteLight;

// node_modules/@mui/x-charts/esm/colorPalettes/categorical/blueberryTwilight.js
var blueberryTwilightPaletteLight = ["#02B2AF", "#2E96FF", "#B800D8", "#60009B", "#2731C8", "#03008D"];
var blueberryTwilightPaletteDark = ["#02B2AF", "#72CCFF", "#DA00FF", "#9001CB", "#2E96FF", "#3B48E0"];
var blueberryTwilightPalette = (mode2) => mode2 === "dark" ? blueberryTwilightPaletteDark : blueberryTwilightPaletteLight;

// node_modules/@mui/x-charts/esm/colorPalettes/categorical/mangoFusion.js
var mangoFusionPaletteLight = ["#173A5E", "#00A3A0", "#C91B63", "#EF5350", "#FFA726", "#B800D8", "#60009B", "#2E96FF", "#2731C8", "#03008D"];
var mangoFusionPaletteDark = ["#41698F", "#19D0CD", "#DE196B", "#FC5F5C", "#FFD771", "#DA00FF", "#9001CB", "#72CCFF", "#2E96FF", "#3B48E0"];
var mangoFusionPalette = (mode2) => mode2 === "dark" ? mangoFusionPaletteDark : mangoFusionPaletteLight;

// node_modules/@mui/x-charts/esm/colorPalettes/categorical/cheerfulFiesta.js
var cheerfulFiestaPaletteDark = ["#0059B2", "#2E96FF", "#FFC24C", "#FF9F0E", "#F38200", "#2ABFDE", "#1F94AD", "#BD2C38", "#FF3143", "#FF8282"];
var cheerfulFiestaPaletteLight = ["#003A75", "#007FFF", "#FFC24C", "#FF9D09", "#CA6C00", "#127D94", "#1F94AD", "#C82634", "#FF3143", "#FF7E7E"];
var cheerfulFiestaPalette = (mode2) => mode2 === "dark" ? cheerfulFiestaPaletteDark : cheerfulFiestaPaletteLight;

// node_modules/@mui/x-charts/esm/colorPalettes/sequential/strawberrySky.js
var strawberrySkyPaletteLight = ["#6877FF", "#694FFD", "#A94FFD", "#DA4FFD", "#F050A5", "#FF5E6C"];
var strawberrySkyPaletteDark = strawberrySkyPaletteLight;
var strawberrySkyPalette = (mode2) => mode2 === "dark" ? strawberrySkyPaletteDark : strawberrySkyPaletteLight;

// node_modules/@mui/x-charts/esm/colorPalettes/sequential/blue.js
var bluePaletteLight = ["#BDDEFF", "#99CCFF", "#66B2FF", "#2E96FF", "#0064D6", "#0D47A1", "#0A367B", "#072555"];
var bluePaletteDark = bluePaletteLight;
var bluePalette = (mode2) => mode2 === "dark" ? bluePaletteDark : bluePaletteLight;

// node_modules/@mui/x-charts/esm/colorPalettes/sequential/cyan.js
var cyanPaletteLight = ["#CFE9E8", "#A3DAD8", "#7ED0CE", "#44BDBA", "#299896", "#137370", "#0E5A58", "#073938"];
var cyanPaletteDark = cyanPaletteLight;
var cyanPalette = (mode2) => mode2 === "dark" ? cyanPaletteDark : cyanPaletteLight;

// node_modules/@mui/x-charts/esm/colorPalettes/sequential/green.js
var greenPaletteLight = ["#CDEBDD", "#B2E2CB", "#8FD8B5", "#54C690", "#31B375", "#359F6D", "#0F7746", "#065731"];
var greenPaletteDark = greenPaletteLight;
var greenPalette = (mode2) => mode2 === "dark" ? greenPaletteDark : greenPaletteLight;

// node_modules/@mui/x-charts/esm/colorPalettes/sequential/orange.js
var orangePaletteLight = ["#FBDBC3", "#F9BD92", "#F99F5D", "#FF7A19", "#FD620B", "#E15100", "#AC3E00", "#822F00"];
var orangePaletteDark = orangePaletteLight;
var orangePalette = (mode2) => mode2 === "dark" ? orangePaletteDark : orangePaletteLight;

// node_modules/@mui/x-charts/esm/colorPalettes/sequential/pink.js
var pinkPaletteLight = ["#F7D2E1", "#F6BED5", "#F4A0C3", "#F6619F", "#EE448B", "#E32977", "#B6215F", "#8B1F4C"];
var pinkPaletteDark = pinkPaletteLight;
var pinkPalette = (mode2) => mode2 === "dark" ? pinkPaletteDark : pinkPaletteLight;

// node_modules/@mui/x-charts/esm/colorPalettes/sequential/purple.js
var purplePaletteLight = ["#CAD4EE", "#98ADE5", "#577EE3", "#4254FB", "#2638DF", "#222FA6", "#111C7F", "#091159"];
var purplePaletteDark = purplePaletteLight;
var purplePalette = (mode2) => mode2 === "dark" ? purplePaletteDark : purplePaletteLight;

// node_modules/@mui/x-charts/esm/colorPalettes/sequential/red.js
var redPaletteLight = ["#FAE0E0", "#F7C0BF", "#F3A2A0", "#EF5350", "#E53935", "#DC2B27", "#860B08", "#560503 "];
var redPaletteDark = redPaletteLight;
var redPalette = (mode2) => mode2 === "dark" ? redPaletteDark : redPaletteLight;

// node_modules/@mui/x-charts/esm/colorPalettes/sequential/yellow.js
var yellowPaletteLight = ["#FBEFD6", "#F5DEB0", "#F3CD80", "#FAC14F", "#FFB219", "#EF9801", "#DA7D0B", "#AB6208"];
var yellowPaletteDark = yellowPaletteLight;
var yellowPalette = (mode2) => mode2 === "dark" ? yellowPaletteDark : yellowPaletteLight;

// node_modules/@mui/x-charts/esm/internals/plugins/corePlugins/useChartSeries/processSeries.js
var preprocessSeries = ({
  series,
  colors,
  seriesConfig: seriesConfig5,
  dataset
}) => {
  const seriesGroups = {};
  series.forEach((seriesData, seriesIndex) => {
    var _a;
    const seriesWithDefaultValues = seriesConfig5[seriesData.type].getSeriesWithDefaultValues(seriesData, seriesIndex, colors);
    const id = seriesWithDefaultValues.id;
    if (seriesGroups[seriesData.type] === void 0) {
      seriesGroups[seriesData.type] = {
        series: {},
        seriesOrder: []
      };
    }
    if (((_a = seriesGroups[seriesData.type]) == null ? void 0 : _a.series[id]) !== void 0) {
      throw new Error(`MUI X Charts: series' id "${id}" is not unique.`);
    }
    seriesGroups[seriesData.type].series[id] = seriesWithDefaultValues;
    seriesGroups[seriesData.type].seriesOrder.push(id);
  });
  const processedSeries = {};
  Object.keys(seriesConfig5).forEach((type) => {
    var _a, _b;
    const group2 = seriesGroups[type];
    if (group2 !== void 0) {
      processedSeries[type] = ((_b = (_a = seriesConfig5[type]) == null ? void 0 : _a.seriesProcessor) == null ? void 0 : _b.call(_a, group2, dataset)) ?? seriesGroups[type];
    }
  });
  return processedSeries;
};

// node_modules/@mui/x-charts/esm/internals/plugins/corePlugins/useChartSeries/useChartSeries.js
var useChartSeries = ({
  params,
  store,
  seriesConfig: seriesConfig5
}) => {
  const {
    series,
    dataset,
    theme,
    colors
  } = params;
  const isFirstRender = React6.useRef(true);
  React6.useEffect(() => {
    if (isFirstRender.current) {
      isFirstRender.current = false;
      return;
    }
    store.update((prev2) => _extends({}, prev2, {
      series: _extends({}, prev2.series, {
        processedSeries: preprocessSeries({
          series,
          colors: typeof colors === "function" ? colors(theme) : colors,
          seriesConfig: seriesConfig5,
          dataset
        })
      })
    }));
  }, [colors, dataset, series, theme, seriesConfig5, store]);
  return {};
};
useChartSeries.params = {
  dataset: true,
  series: true,
  colors: true,
  theme: true
};
var EMPTY_ARRAY = [];
useChartSeries.getDefaultizedParams = ({
  params
}) => {
  var _a;
  return _extends({}, params, {
    series: ((_a = params.series) == null ? void 0 : _a.length) ? params.series : EMPTY_ARRAY,
    colors: params.colors ?? rainbowSurgePalette,
    theme: params.theme ?? "light"
  });
};
useChartSeries.getInitialState = ({
  series = [],
  colors,
  theme,
  dataset
}, _2, seriesConfig5) => {
  return {
    series: {
      seriesConfig: seriesConfig5,
      processedSeries: preprocessSeries({
        series,
        colors: typeof colors === "function" ? colors(theme) : colors,
        seriesConfig: seriesConfig5,
        dataset
      })
    }
  };
};

// node_modules/@mui/x-charts/esm/internals/plugins/corePlugins/useChartSeries/useChartSeries.selectors.js
var selectorChartSeriesState = (state) => state.series;
var selectorChartSeriesProcessed = createSelector2(selectorChartSeriesState, (seriesState) => seriesState.processedSeries);
var selectorChartSeriesConfig = createSelector2(selectorChartSeriesState, (seriesState) => seriesState.seriesConfig);

// node_modules/@mui/x-charts/esm/internals/plugins/corePlugins/corePlugins.js
var CHART_CORE_PLUGINS = [useChartId, useChartDimensions, useChartSeries, useChartAnimation];

// node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
function _objectWithoutPropertiesLoose(r3, e) {
  if (null == r3) return {};
  var t = {};
  for (var n in r3) if ({}.hasOwnProperty.call(r3, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r3[n];
  }
  return t;
}

// node_modules/@mui/x-charts/esm/internals/store/extractPluginParamsFromProps.js
var _excluded = ["apiRef"];
var extractPluginParamsFromProps = (_ref) => {
  let {
    plugins
  } = _ref, props = _objectWithoutPropertiesLoose(_ref.props, _excluded);
  const paramsLookup = {};
  plugins.forEach((plugin) => {
    Object.assign(paramsLookup, plugin.params);
  });
  const pluginParams = {};
  Object.keys(props).forEach((propName) => {
    const prop = props[propName];
    if (paramsLookup[propName]) {
      pluginParams[propName] = prop;
    }
  });
  const defaultizedPluginParams = plugins.reduce((acc, plugin) => {
    if (plugin.getDefaultizedParams) {
      return plugin.getDefaultizedParams({
        params: acc
      });
    }
    return acc;
  }, pluginParams);
  return defaultizedPluginParams;
};

// node_modules/@mui/x-charts/esm/internals/store/useCharts.js
var globalId2 = 0;
function useCharts(inPlugins, props, seriesConfig5) {
  const chartId = useId();
  const plugins = React7.useMemo(() => [...CHART_CORE_PLUGINS, ...inPlugins], [inPlugins]);
  const pluginParams = extractPluginParamsFromProps({
    plugins,
    props
  });
  pluginParams.id = pluginParams.id ?? chartId;
  const instanceRef = React7.useRef({});
  const instance = instanceRef.current;
  const publicAPI = useChartApiInitialization(props.apiRef);
  const innerChartRootRef = React7.useRef(null);
  const innerSvgRef = React7.useRef(null);
  const storeRef = React7.useRef(null);
  if (storeRef.current == null) {
    globalId2 += 1;
    const initialState = {
      cacheKey: {
        id: globalId2
      }
    };
    plugins.forEach((plugin) => {
      if (plugin.getInitialState) {
        Object.assign(initialState, plugin.getInitialState(pluginParams, initialState, seriesConfig5));
      }
    });
    storeRef.current = new ChartStore(initialState);
  }
  const runPlugin = (plugin) => {
    const pluginResponse = plugin({
      instance,
      params: pluginParams,
      plugins,
      store: storeRef.current,
      svgRef: innerSvgRef,
      chartRootRef: innerChartRootRef,
      seriesConfig: seriesConfig5
    });
    if (pluginResponse.publicAPI) {
      Object.assign(publicAPI.current, pluginResponse.publicAPI);
    }
    if (pluginResponse.instance) {
      Object.assign(instance, pluginResponse.instance);
    }
  };
  plugins.forEach(runPlugin);
  const contextValue = React7.useMemo(() => ({
    store: storeRef.current,
    publicAPI: publicAPI.current,
    instance,
    svgRef: innerSvgRef,
    chartRootRef: innerChartRootRef
  }), [instance, publicAPI]);
  return {
    contextValue
  };
}
function initializeInputApiRef(inputApiRef) {
  if (inputApiRef.current == null) {
    inputApiRef.current = {};
  }
  return inputApiRef;
}
function useChartApiInitialization(inputApiRef) {
  const fallbackPublicApiRef = React7.useRef({});
  if (inputApiRef) {
    return initializeInputApiRef(inputApiRef);
  }
  return fallbackPublicApiRef;
}

// node_modules/@mui/x-charts/esm/context/ChartProvider/ChartContext.js
var React8 = __toESM(require_react(), 1);
var ChartContext = React8.createContext(null);
if (true) {
  ChartContext.displayName = "ChartContext";
}

// node_modules/@mui/x-charts/esm/internals/plugins/featurePlugins/useChartCartesianAxis/useChartCartesianAxis.js
var React11 = __toESM(require_react(), 1);

// node_modules/@mui/x-internals/esm/warning/warning.js
var warnedOnceCache = /* @__PURE__ */ new Set();
function warnOnce(message, gravity = "warning") {
  if (false) {
    return;
  }
  const cleanMessage = Array.isArray(message) ? message.join("\n") : message;
  if (!warnedOnceCache.has(cleanMessage)) {
    warnedOnceCache.add(cleanMessage);
    if (gravity === "error") {
      console.error(cleanMessage);
    } else {
      console.warn(cleanMessage);
    }
  }
}

// node_modules/@mui/x-charts/esm/internals/store/useSelector.js
var import_with_selector = __toESM(require_with_selector(), 1);
var defaultCompare = Object.is;
var useSelector = (store, selector, args = void 0, equals = defaultCompare) => {
  const selectorWithArgs = (state) => selector(state, args);
  return (0, import_with_selector.useSyncExternalStoreWithSelector)(store.subscribe, store.getSnapshot, store.getSnapshot, selectorWithArgs, equals);
};

// node_modules/@mui/x-charts/esm/internals/plugins/featurePlugins/useChartCartesianAxis/defaultizeZoom.js
var defaultZoomOptions = {
  minStart: 0,
  maxEnd: 100,
  step: 5,
  minSpan: 10,
  maxSpan: 100,
  panning: true,
  filterMode: "keep",
  slider: {
    enabled: false
  }
};
var defaultizeZoom = (zoom, axisId, axisDirection) => {
  if (!zoom) {
    return void 0;
  }
  if (zoom === true) {
    return _extends({
      axisId,
      axisDirection
    }, defaultZoomOptions);
  }
  return _extends({
    axisId,
    axisDirection
  }, defaultZoomOptions, zoom, {
    slider: _extends({}, defaultZoomOptions.slider, zoom.slider)
  });
};

// node_modules/@mui/x-charts/esm/internals/plugins/featurePlugins/useChartCartesianAxis/defaultizeAxis.js
function defaultizeXAxis(inAxes, dataset) {
  const offsets = {
    top: 0,
    bottom: 0,
    none: 0
  };
  const inputAxes = inAxes && inAxes.length > 0 ? inAxes : [{
    id: DEFAULT_X_AXIS_KEY,
    scaleType: "linear"
  }];
  const parsedAxes = inputAxes.map((axisConfig, index2) => {
    var _a;
    const dataKey = axisConfig.dataKey;
    const defaultPosition = index2 === 0 ? "bottom" : "none";
    const position3 = axisConfig.position ?? defaultPosition;
    const defaultHeight = DEFAULT_AXIS_SIZE_HEIGHT + (axisConfig.label ? AXIS_LABEL_DEFAULT_HEIGHT : 0);
    const id = axisConfig.id ?? `defaultized-x-axis-${index2}`;
    const sharedConfig = _extends({
      offset: offsets[position3]
    }, axisConfig, {
      id,
      position: position3,
      height: axisConfig.height ?? defaultHeight,
      zoom: defaultizeZoom(axisConfig.zoom, id, "x")
    });
    if (position3 !== "none") {
      offsets[position3] += sharedConfig.height;
      if ((_a = sharedConfig.zoom) == null ? void 0 : _a.slider.enabled) {
        offsets[position3] += ZOOM_SLIDER_SIZE;
      }
    }
    if (dataKey === void 0 || axisConfig.data !== void 0) {
      return sharedConfig;
    }
    if (dataset === void 0) {
      throw new Error(`MUI X Charts: x-axis uses \`dataKey\` but no \`dataset\` is provided.`);
    }
    return _extends({}, sharedConfig, {
      data: dataset.map((d) => d[dataKey])
    });
  });
  return parsedAxes;
}
function defaultizeYAxis(inAxes, dataset) {
  const offsets = {
    right: 0,
    left: 0,
    none: 0
  };
  const inputAxes = inAxes && inAxes.length > 0 ? inAxes : [{
    id: DEFAULT_Y_AXIS_KEY,
    scaleType: "linear"
  }];
  const parsedAxes = inputAxes.map((axisConfig, index2) => {
    var _a;
    const dataKey = axisConfig.dataKey;
    const defaultPosition = index2 === 0 ? "left" : "none";
    const position3 = axisConfig.position ?? defaultPosition;
    const defaultWidth = DEFAULT_AXIS_SIZE_WIDTH + (axisConfig.label ? AXIS_LABEL_DEFAULT_HEIGHT : 0);
    const id = axisConfig.id ?? `defaultized-y-axis-${index2}`;
    const sharedConfig = _extends({
      offset: offsets[position3]
    }, axisConfig, {
      id,
      position: position3,
      width: axisConfig.width ?? defaultWidth,
      zoom: defaultizeZoom(axisConfig.zoom, id, "y")
    });
    if (position3 !== "none") {
      offsets[position3] += sharedConfig.width;
      if ((_a = sharedConfig.zoom) == null ? void 0 : _a.slider.enabled) {
        offsets[position3] += ZOOM_SLIDER_SIZE;
      }
    }
    if (dataKey === void 0 || axisConfig.data !== void 0) {
      return sharedConfig;
    }
    if (dataset === void 0) {
      throw new Error(`MUI X Charts: y-axis uses \`dataKey\` but no \`dataset\` is provided.`);
    }
    return _extends({}, sharedConfig, {
      data: dataset.map((d) => d[dataKey])
    });
  });
  return parsedAxes;
}

// node_modules/d3-array/src/ascending.js
function ascending(a3, b2) {
  return a3 == null || b2 == null ? NaN : a3 < b2 ? -1 : a3 > b2 ? 1 : a3 >= b2 ? 0 : NaN;
}

// node_modules/d3-array/src/descending.js
function descending(a3, b2) {
  return a3 == null || b2 == null ? NaN : b2 < a3 ? -1 : b2 > a3 ? 1 : b2 >= a3 ? 0 : NaN;
}

// node_modules/d3-array/src/bisector.js
function bisector(f2) {
  let compare1, compare2, delta;
  if (f2.length !== 2) {
    compare1 = ascending;
    compare2 = (d, x3) => ascending(f2(d), x3);
    delta = (d, x3) => f2(d) - x3;
  } else {
    compare1 = f2 === ascending || f2 === descending ? f2 : zero;
    compare2 = f2;
    delta = f2;
  }
  function left3(a3, x3, lo = 0, hi = a3.length) {
    if (lo < hi) {
      if (compare1(x3, x3) !== 0) return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a3[mid], x3) < 0) lo = mid + 1;
        else hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function right3(a3, x3, lo = 0, hi = a3.length) {
    if (lo < hi) {
      if (compare1(x3, x3) !== 0) return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a3[mid], x3) <= 0) lo = mid + 1;
        else hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function center(a3, x3, lo = 0, hi = a3.length) {
    const i2 = left3(a3, x3, lo, hi - 1);
    return i2 > lo && delta(a3[i2 - 1], x3) > -delta(a3[i2], x3) ? i2 - 1 : i2;
  }
  return { left: left3, center, right: right3 };
}
function zero() {
  return 0;
}

// node_modules/d3-array/src/number.js
function number(x3) {
  return x3 === null ? NaN : +x3;
}

// node_modules/d3-array/src/bisect.js
var ascendingBisect = bisector(ascending);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;
var bisectCenter = bisector(number).center;
var bisect_default = bisectRight;

// node_modules/d3-array/src/blur.js
var blur2 = Blur2(blurf);
var blurImage = Blur2(blurfImage);
function Blur2(blur3) {
  return function(data, rx, ry = rx) {
    if (!((rx = +rx) >= 0)) throw new RangeError("invalid rx");
    if (!((ry = +ry) >= 0)) throw new RangeError("invalid ry");
    let { data: values3, width: width2, height: height2 } = data;
    if (!((width2 = Math.floor(width2)) >= 0)) throw new RangeError("invalid width");
    if (!((height2 = Math.floor(height2 !== void 0 ? height2 : values3.length / width2)) >= 0)) throw new RangeError("invalid height");
    if (!width2 || !height2 || !rx && !ry) return data;
    const blurx = rx && blur3(rx);
    const blury = ry && blur3(ry);
    const temp = values3.slice();
    if (blurx && blury) {
      blurh(blurx, temp, values3, width2, height2);
      blurh(blurx, values3, temp, width2, height2);
      blurh(blurx, temp, values3, width2, height2);
      blurv(blury, values3, temp, width2, height2);
      blurv(blury, temp, values3, width2, height2);
      blurv(blury, values3, temp, width2, height2);
    } else if (blurx) {
      blurh(blurx, values3, temp, width2, height2);
      blurh(blurx, temp, values3, width2, height2);
      blurh(blurx, values3, temp, width2, height2);
    } else if (blury) {
      blurv(blury, values3, temp, width2, height2);
      blurv(blury, temp, values3, width2, height2);
      blurv(blury, values3, temp, width2, height2);
    }
    return data;
  };
}
function blurh(blur3, T2, S2, w2, h) {
  for (let y3 = 0, n = w2 * h; y3 < n; ) {
    blur3(T2, S2, y3, y3 += w2, 1);
  }
}
function blurv(blur3, T2, S2, w2, h) {
  for (let x3 = 0, n = w2 * h; x3 < w2; ++x3) {
    blur3(T2, S2, x3, x3 + n, w2);
  }
}
function blurfImage(radius) {
  const blur3 = blurf(radius);
  return (T2, S2, start2, stop, step) => {
    start2 <<= 2, stop <<= 2, step <<= 2;
    blur3(T2, S2, start2 + 0, stop + 0, step);
    blur3(T2, S2, start2 + 1, stop + 1, step);
    blur3(T2, S2, start2 + 2, stop + 2, step);
    blur3(T2, S2, start2 + 3, stop + 3, step);
  };
}
function blurf(radius) {
  const radius0 = Math.floor(radius);
  if (radius0 === radius) return bluri(radius);
  const t = radius - radius0;
  const w2 = 2 * radius + 1;
  return (T2, S2, start2, stop, step) => {
    if (!((stop -= step) >= start2)) return;
    let sum4 = radius0 * S2[start2];
    const s0 = step * radius0;
    const s1 = s0 + step;
    for (let i2 = start2, j2 = start2 + s0; i2 < j2; i2 += step) {
      sum4 += S2[Math.min(stop, i2)];
    }
    for (let i2 = start2, j2 = stop; i2 <= j2; i2 += step) {
      sum4 += S2[Math.min(stop, i2 + s0)];
      T2[i2] = (sum4 + t * (S2[Math.max(start2, i2 - s1)] + S2[Math.min(stop, i2 + s1)])) / w2;
      sum4 -= S2[Math.max(start2, i2 - s0)];
    }
  };
}
function bluri(radius) {
  const w2 = 2 * radius + 1;
  return (T2, S2, start2, stop, step) => {
    if (!((stop -= step) >= start2)) return;
    let sum4 = radius * S2[start2];
    const s3 = step * radius;
    for (let i2 = start2, j2 = start2 + s3; i2 < j2; i2 += step) {
      sum4 += S2[Math.min(stop, i2)];
    }
    for (let i2 = start2, j2 = stop; i2 <= j2; i2 += step) {
      sum4 += S2[Math.min(stop, i2 + s3)];
      T2[i2] = sum4 / w2;
      sum4 -= S2[Math.max(start2, i2 - s3)];
    }
  };
}

// node_modules/internmap/src/index.js
var InternMap = class extends Map {
  constructor(entries, key = keyof) {
    super();
    Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });
    if (entries != null) for (const [key2, value] of entries) this.set(key2, value);
  }
  get(key) {
    return super.get(intern_get(this, key));
  }
  has(key) {
    return super.has(intern_get(this, key));
  }
  set(key, value) {
    return super.set(intern_set(this, key), value);
  }
  delete(key) {
    return super.delete(intern_delete(this, key));
  }
};
function intern_get({ _intern, _key }, value) {
  const key = _key(value);
  return _intern.has(key) ? _intern.get(key) : value;
}
function intern_set({ _intern, _key }, value) {
  const key = _key(value);
  if (_intern.has(key)) return _intern.get(key);
  _intern.set(key, value);
  return value;
}
function intern_delete({ _intern, _key }, value) {
  const key = _key(value);
  if (_intern.has(key)) {
    value = _intern.get(key);
    _intern.delete(key);
  }
  return value;
}
function keyof(value) {
  return value !== null && typeof value === "object" ? value.valueOf() : value;
}

// node_modules/d3-array/src/array.js
var array = Array.prototype;
var slice = array.slice;
var map = array.map;

// node_modules/d3-array/src/ticks.js
var e10 = Math.sqrt(50);
var e5 = Math.sqrt(10);
var e2 = Math.sqrt(2);
function tickSpec(start2, stop, count2) {
  const step = (stop - start2) / Math.max(0, count2), power = Math.floor(Math.log10(step)), error = step / Math.pow(10, power), factor = error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1;
  let i1, i2, inc;
  if (power < 0) {
    inc = Math.pow(10, -power) / factor;
    i1 = Math.round(start2 * inc);
    i2 = Math.round(stop * inc);
    if (i1 / inc < start2) ++i1;
    if (i2 / inc > stop) --i2;
    inc = -inc;
  } else {
    inc = Math.pow(10, power) * factor;
    i1 = Math.round(start2 / inc);
    i2 = Math.round(stop / inc);
    if (i1 * inc < start2) ++i1;
    if (i2 * inc > stop) --i2;
  }
  if (i2 < i1 && 0.5 <= count2 && count2 < 2) return tickSpec(start2, stop, count2 * 2);
  return [i1, i2, inc];
}
function ticks(start2, stop, count2) {
  stop = +stop, start2 = +start2, count2 = +count2;
  if (!(count2 > 0)) return [];
  if (start2 === stop) return [start2];
  const reverse2 = stop < start2, [i1, i2, inc] = reverse2 ? tickSpec(stop, start2, count2) : tickSpec(start2, stop, count2);
  if (!(i2 >= i1)) return [];
  const n = i2 - i1 + 1, ticks2 = new Array(n);
  if (reverse2) {
    if (inc < 0) for (let i3 = 0; i3 < n; ++i3) ticks2[i3] = (i2 - i3) / -inc;
    else for (let i3 = 0; i3 < n; ++i3) ticks2[i3] = (i2 - i3) * inc;
  } else {
    if (inc < 0) for (let i3 = 0; i3 < n; ++i3) ticks2[i3] = (i1 + i3) / -inc;
    else for (let i3 = 0; i3 < n; ++i3) ticks2[i3] = (i1 + i3) * inc;
  }
  return ticks2;
}
function tickIncrement(start2, stop, count2) {
  stop = +stop, start2 = +start2, count2 = +count2;
  return tickSpec(start2, stop, count2)[2];
}
function tickStep(start2, stop, count2) {
  stop = +stop, start2 = +start2, count2 = +count2;
  const reverse2 = stop < start2, inc = reverse2 ? tickIncrement(stop, start2, count2) : tickIncrement(start2, stop, count2);
  return (reverse2 ? -1 : 1) * (inc < 0 ? 1 / -inc : inc);
}

// node_modules/d3-array/src/range.js
function range(start2, stop, step) {
  start2 = +start2, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start2, start2 = 0, 1) : n < 3 ? 1 : +step;
  var i2 = -1, n = Math.max(0, Math.ceil((stop - start2) / step)) | 0, range2 = new Array(n);
  while (++i2 < n) {
    range2[i2] = start2 + i2 * step;
  }
  return range2;
}

// node_modules/d3-array/src/shuffle.js
var shuffle_default = shuffler(Math.random);
function shuffler(random) {
  return function shuffle(array2, i0 = 0, i1 = array2.length) {
    let m2 = i1 - (i0 = +i0);
    while (m2) {
      const i2 = random() * m2-- | 0, t = array2[m2 + i0];
      array2[m2 + i0] = array2[i2 + i0];
      array2[i2 + i0] = t;
    }
    return array2;
  };
}

// node_modules/d3-scale/src/init.js
function initRange(domain, range2) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(domain);
      break;
    default:
      this.range(range2).domain(domain);
      break;
  }
  return this;
}
function initInterpolator(domain, interpolator) {
  switch (arguments.length) {
    case 0:
      break;
    case 1: {
      if (typeof domain === "function") this.interpolator(domain);
      else this.range(domain);
      break;
    }
    default: {
      this.domain(domain);
      if (typeof interpolator === "function") this.interpolator(interpolator);
      else this.range(interpolator);
      break;
    }
  }
  return this;
}

// node_modules/d3-scale/src/ordinal.js
var implicit = Symbol("implicit");
function ordinal() {
  var index2 = new InternMap(), domain = [], range2 = [], unknown = implicit;
  function scale2(d) {
    let i2 = index2.get(d);
    if (i2 === void 0) {
      if (unknown !== implicit) return unknown;
      index2.set(d, i2 = domain.push(d) - 1);
    }
    return range2[i2 % range2.length];
  }
  scale2.domain = function(_2) {
    if (!arguments.length) return domain.slice();
    domain = [], index2 = new InternMap();
    for (const value of _2) {
      if (index2.has(value)) continue;
      index2.set(value, domain.push(value) - 1);
    }
    return scale2;
  };
  scale2.range = function(_2) {
    return arguments.length ? (range2 = Array.from(_2), scale2) : range2.slice();
  };
  scale2.unknown = function(_2) {
    return arguments.length ? (unknown = _2, scale2) : unknown;
  };
  scale2.copy = function() {
    return ordinal(domain, range2).unknown(unknown);
  };
  initRange.apply(scale2, arguments);
  return scale2;
}

// node_modules/d3-scale/src/band.js
function band() {
  var scale2 = ordinal().unknown(void 0), domain = scale2.domain, ordinalRange = scale2.range, r0 = 0, r1 = 1, step, bandwidth, round3 = false, paddingInner = 0, paddingOuter = 0, align = 0.5;
  delete scale2.unknown;
  function rescale() {
    var n = domain().length, reverse2 = r1 < r0, start2 = reverse2 ? r1 : r0, stop = reverse2 ? r0 : r1;
    step = (stop - start2) / Math.max(1, n - paddingInner + paddingOuter * 2);
    if (round3) step = Math.floor(step);
    start2 += (stop - start2 - step * (n - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);
    if (round3) start2 = Math.round(start2), bandwidth = Math.round(bandwidth);
    var values3 = range(n).map(function(i2) {
      return start2 + step * i2;
    });
    return ordinalRange(reverse2 ? values3.reverse() : values3);
  }
  scale2.domain = function(_2) {
    return arguments.length ? (domain(_2), rescale()) : domain();
  };
  scale2.range = function(_2) {
    return arguments.length ? ([r0, r1] = _2, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
  };
  scale2.rangeRound = function(_2) {
    return [r0, r1] = _2, r0 = +r0, r1 = +r1, round3 = true, rescale();
  };
  scale2.bandwidth = function() {
    return bandwidth;
  };
  scale2.step = function() {
    return step;
  };
  scale2.round = function(_2) {
    return arguments.length ? (round3 = !!_2, rescale()) : round3;
  };
  scale2.padding = function(_2) {
    return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_2), rescale()) : paddingInner;
  };
  scale2.paddingInner = function(_2) {
    return arguments.length ? (paddingInner = Math.min(1, _2), rescale()) : paddingInner;
  };
  scale2.paddingOuter = function(_2) {
    return arguments.length ? (paddingOuter = +_2, rescale()) : paddingOuter;
  };
  scale2.align = function(_2) {
    return arguments.length ? (align = Math.max(0, Math.min(1, _2)), rescale()) : align;
  };
  scale2.copy = function() {
    return band(domain(), [r0, r1]).round(round3).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);
  };
  return initRange.apply(rescale(), arguments);
}
function pointish(scale2) {
  var copy4 = scale2.copy;
  scale2.padding = scale2.paddingOuter;
  delete scale2.paddingInner;
  delete scale2.paddingOuter;
  scale2.copy = function() {
    return pointish(copy4());
  };
  return scale2;
}
function point() {
  return pointish(band.apply(null, arguments).paddingInner(1));
}

// node_modules/d3-color/src/define.js
function define_default(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}

// node_modules/d3-color/src/color.js
function Color() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*";
var reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var reHex = /^#([0-9a-f]{3,8})$/;
var reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`);
var reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`);
var reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`);
var reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`);
var reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`);
var reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define_default(Color, color, {
  copy(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHex8() {
  return this.rgb().formatHex8();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format2) {
  var m2, l2;
  format2 = (format2 + "").trim().toLowerCase();
  return (m2 = reHex.exec(format2)) ? (l2 = m2[1].length, m2 = parseInt(m2[1], 16), l2 === 6 ? rgbn(m2) : l2 === 3 ? new Rgb(m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, (m2 & 15) << 4 | m2 & 15, 1) : l2 === 8 ? rgba(m2 >> 24 & 255, m2 >> 16 & 255, m2 >> 8 & 255, (m2 & 255) / 255) : l2 === 4 ? rgba(m2 >> 12 & 15 | m2 >> 8 & 240, m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, ((m2 & 15) << 4 | m2 & 15) / 255) : null) : (m2 = reRgbInteger.exec(format2)) ? new Rgb(m2[1], m2[2], m2[3], 1) : (m2 = reRgbPercent.exec(format2)) ? new Rgb(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, 1) : (m2 = reRgbaInteger.exec(format2)) ? rgba(m2[1], m2[2], m2[3], m2[4]) : (m2 = reRgbaPercent.exec(format2)) ? rgba(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, m2[4]) : (m2 = reHslPercent.exec(format2)) ? hsla(m2[1], m2[2] / 100, m2[3] / 100, 1) : (m2 = reHslaPercent.exec(format2)) ? hsla(m2[1], m2[2] / 100, m2[3] / 100, m2[4]) : named.hasOwnProperty(format2) ? rgbn(named[format2]) : format2 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n) {
  return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba(r3, g2, b2, a3) {
  if (a3 <= 0) r3 = g2 = b2 = NaN;
  return new Rgb(r3, g2, b2, a3);
}
function rgbConvert(o2) {
  if (!(o2 instanceof Color)) o2 = color(o2);
  if (!o2) return new Rgb();
  o2 = o2.rgb();
  return new Rgb(o2.r, o2.g, o2.b, o2.opacity);
}
function rgb(r3, g2, b2, opacity) {
  return arguments.length === 1 ? rgbConvert(r3) : new Rgb(r3, g2, b2, opacity == null ? 1 : opacity);
}
function Rgb(r3, g2, b2, opacity) {
  this.r = +r3;
  this.g = +g2;
  this.b = +b2;
  this.opacity = +opacity;
}
define_default(Rgb, rgb, extend(Color, {
  brighter(k3) {
    k3 = k3 == null ? brighter : Math.pow(brighter, k3);
    return new Rgb(this.r * k3, this.g * k3, this.b * k3, this.opacity);
  },
  darker(k3) {
    k3 = k3 == null ? darker : Math.pow(darker, k3);
    return new Rgb(this.r * k3, this.g * k3, this.b * k3, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}
function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
  const a3 = clampa(this.opacity);
  return `${a3 === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a3 === 1 ? ")" : `, ${a3})`}`;
}
function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function clampi(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}
function hex(value) {
  value = clampi(value);
  return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h, s3, l2, a3) {
  if (a3 <= 0) h = s3 = l2 = NaN;
  else if (l2 <= 0 || l2 >= 1) h = s3 = NaN;
  else if (s3 <= 0) h = NaN;
  return new Hsl(h, s3, l2, a3);
}
function hslConvert(o2) {
  if (o2 instanceof Hsl) return new Hsl(o2.h, o2.s, o2.l, o2.opacity);
  if (!(o2 instanceof Color)) o2 = color(o2);
  if (!o2) return new Hsl();
  if (o2 instanceof Hsl) return o2;
  o2 = o2.rgb();
  var r3 = o2.r / 255, g2 = o2.g / 255, b2 = o2.b / 255, min4 = Math.min(r3, g2, b2), max4 = Math.max(r3, g2, b2), h = NaN, s3 = max4 - min4, l2 = (max4 + min4) / 2;
  if (s3) {
    if (r3 === max4) h = (g2 - b2) / s3 + (g2 < b2) * 6;
    else if (g2 === max4) h = (b2 - r3) / s3 + 2;
    else h = (r3 - g2) / s3 + 4;
    s3 /= l2 < 0.5 ? max4 + min4 : 2 - max4 - min4;
    h *= 60;
  } else {
    s3 = l2 > 0 && l2 < 1 ? 0 : h;
  }
  return new Hsl(h, s3, l2, o2.opacity);
}
function hsl(h, s3, l2, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s3, l2, opacity == null ? 1 : opacity);
}
function Hsl(h, s3, l2, opacity) {
  this.h = +h;
  this.s = +s3;
  this.l = +l2;
  this.opacity = +opacity;
}
define_default(Hsl, hsl, extend(Color, {
  brighter(k3) {
    k3 = k3 == null ? brighter : Math.pow(brighter, k3);
    return new Hsl(this.h, this.s, this.l * k3, this.opacity);
  },
  darker(k3) {
    k3 = k3 == null ? darker : Math.pow(darker, k3);
    return new Hsl(this.h, this.s, this.l * k3, this.opacity);
  },
  rgb() {
    var h = this.h % 360 + (this.h < 0) * 360, s3 = isNaN(h) || isNaN(this.s) ? 0 : this.s, l2 = this.l, m2 = l2 + (l2 < 0.5 ? l2 : 1 - l2) * s3, m1 = 2 * l2 - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a3 = clampa(this.opacity);
    return `${a3 === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a3 === 1 ? ")" : `, ${a3})`}`;
  }
}));
function clamph(value) {
  value = (value || 0) % 360;
  return value < 0 ? value + 360 : value;
}
function clampt(value) {
  return Math.max(0, Math.min(1, value || 0));
}
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
}

// node_modules/d3-color/src/math.js
var radians = Math.PI / 180;
var degrees = 180 / Math.PI;

// node_modules/d3-color/src/lab.js
var K = 18;
var Xn = 0.96422;
var Yn = 1;
var Zn = 0.82521;
var t0 = 4 / 29;
var t1 = 6 / 29;
var t2 = 3 * t1 * t1;
var t3 = t1 * t1 * t1;
function labConvert(o2) {
  if (o2 instanceof Lab) return new Lab(o2.l, o2.a, o2.b, o2.opacity);
  if (o2 instanceof Hcl) return hcl2lab(o2);
  if (!(o2 instanceof Rgb)) o2 = rgbConvert(o2);
  var r3 = rgb2lrgb(o2.r), g2 = rgb2lrgb(o2.g), b2 = rgb2lrgb(o2.b), y3 = xyz2lab((0.2225045 * r3 + 0.7168786 * g2 + 0.0606169 * b2) / Yn), x3, z2;
  if (r3 === g2 && g2 === b2) x3 = z2 = y3;
  else {
    x3 = xyz2lab((0.4360747 * r3 + 0.3850649 * g2 + 0.1430804 * b2) / Xn);
    z2 = xyz2lab((0.0139322 * r3 + 0.0971045 * g2 + 0.7141733 * b2) / Zn);
  }
  return new Lab(116 * y3 - 16, 500 * (x3 - y3), 200 * (y3 - z2), o2.opacity);
}
function lab(l2, a3, b2, opacity) {
  return arguments.length === 1 ? labConvert(l2) : new Lab(l2, a3, b2, opacity == null ? 1 : opacity);
}
function Lab(l2, a3, b2, opacity) {
  this.l = +l2;
  this.a = +a3;
  this.b = +b2;
  this.opacity = +opacity;
}
define_default(Lab, lab, extend(Color, {
  brighter(k3) {
    return new Lab(this.l + K * (k3 == null ? 1 : k3), this.a, this.b, this.opacity);
  },
  darker(k3) {
    return new Lab(this.l - K * (k3 == null ? 1 : k3), this.a, this.b, this.opacity);
  },
  rgb() {
    var y3 = (this.l + 16) / 116, x3 = isNaN(this.a) ? y3 : y3 + this.a / 500, z2 = isNaN(this.b) ? y3 : y3 - this.b / 200;
    x3 = Xn * lab2xyz(x3);
    y3 = Yn * lab2xyz(y3);
    z2 = Zn * lab2xyz(z2);
    return new Rgb(
      lrgb2rgb(3.1338561 * x3 - 1.6168667 * y3 - 0.4906146 * z2),
      lrgb2rgb(-0.9787684 * x3 + 1.9161415 * y3 + 0.033454 * z2),
      lrgb2rgb(0.0719453 * x3 - 0.2289914 * y3 + 1.4052427 * z2),
      this.opacity
    );
  }
}));
function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}
function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}
function lrgb2rgb(x3) {
  return 255 * (x3 <= 31308e-7 ? 12.92 * x3 : 1.055 * Math.pow(x3, 1 / 2.4) - 0.055);
}
function rgb2lrgb(x3) {
  return (x3 /= 255) <= 0.04045 ? x3 / 12.92 : Math.pow((x3 + 0.055) / 1.055, 2.4);
}
function hclConvert(o2) {
  if (o2 instanceof Hcl) return new Hcl(o2.h, o2.c, o2.l, o2.opacity);
  if (!(o2 instanceof Lab)) o2 = labConvert(o2);
  if (o2.a === 0 && o2.b === 0) return new Hcl(NaN, 0 < o2.l && o2.l < 100 ? 0 : NaN, o2.l, o2.opacity);
  var h = Math.atan2(o2.b, o2.a) * degrees;
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o2.a * o2.a + o2.b * o2.b), o2.l, o2.opacity);
}
function hcl(h, c3, l2, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c3, l2, opacity == null ? 1 : opacity);
}
function Hcl(h, c3, l2, opacity) {
  this.h = +h;
  this.c = +c3;
  this.l = +l2;
  this.opacity = +opacity;
}
function hcl2lab(o2) {
  if (isNaN(o2.h)) return new Lab(o2.l, 0, 0, o2.opacity);
  var h = o2.h * radians;
  return new Lab(o2.l, Math.cos(h) * o2.c, Math.sin(h) * o2.c, o2.opacity);
}
define_default(Hcl, hcl, extend(Color, {
  brighter(k3) {
    return new Hcl(this.h, this.c, this.l + K * (k3 == null ? 1 : k3), this.opacity);
  },
  darker(k3) {
    return new Hcl(this.h, this.c, this.l - K * (k3 == null ? 1 : k3), this.opacity);
  },
  rgb() {
    return hcl2lab(this).rgb();
  }
}));

// node_modules/d3-color/src/cubehelix.js
var A = -0.14861;
var B = 1.78277;
var C = -0.29227;
var D = -0.90649;
var E = 1.97294;
var ED = E * D;
var EB = E * B;
var BC_DA = B * C - D * A;
function cubehelixConvert(o2) {
  if (o2 instanceof Cubehelix) return new Cubehelix(o2.h, o2.s, o2.l, o2.opacity);
  if (!(o2 instanceof Rgb)) o2 = rgbConvert(o2);
  var r3 = o2.r / 255, g2 = o2.g / 255, b2 = o2.b / 255, l2 = (BC_DA * b2 + ED * r3 - EB * g2) / (BC_DA + ED - EB), bl = b2 - l2, k3 = (E * (g2 - l2) - C * bl) / D, s3 = Math.sqrt(k3 * k3 + bl * bl) / (E * l2 * (1 - l2)), h = s3 ? Math.atan2(k3, bl) * degrees - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s3, l2, o2.opacity);
}
function cubehelix(h, s3, l2, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s3, l2, opacity == null ? 1 : opacity);
}
function Cubehelix(h, s3, l2, opacity) {
  this.h = +h;
  this.s = +s3;
  this.l = +l2;
  this.opacity = +opacity;
}
define_default(Cubehelix, cubehelix, extend(Color, {
  brighter(k3) {
    k3 = k3 == null ? brighter : Math.pow(brighter, k3);
    return new Cubehelix(this.h, this.s, this.l * k3, this.opacity);
  },
  darker(k3) {
    k3 = k3 == null ? darker : Math.pow(darker, k3);
    return new Cubehelix(this.h, this.s, this.l * k3, this.opacity);
  },
  rgb() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * radians, l2 = +this.l, a3 = isNaN(this.s) ? 0 : this.s * l2 * (1 - l2), cosh2 = Math.cos(h), sinh2 = Math.sin(h);
    return new Rgb(
      255 * (l2 + a3 * (A * cosh2 + B * sinh2)),
      255 * (l2 + a3 * (C * cosh2 + D * sinh2)),
      255 * (l2 + a3 * (E * cosh2)),
      this.opacity
    );
  }
}));

// node_modules/d3-interpolate/src/basis.js
function basis(t13, v0, v1, v22, v3) {
  var t22 = t13 * t13, t32 = t22 * t13;
  return ((1 - 3 * t13 + 3 * t22 - t32) * v0 + (4 - 6 * t22 + 3 * t32) * v1 + (1 + 3 * t13 + 3 * t22 - 3 * t32) * v22 + t32 * v3) / 6;
}
function basis_default(values3) {
  var n = values3.length - 1;
  return function(t) {
    var i2 = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n), v1 = values3[i2], v22 = values3[i2 + 1], v0 = i2 > 0 ? values3[i2 - 1] : 2 * v1 - v22, v3 = i2 < n - 1 ? values3[i2 + 2] : 2 * v22 - v1;
    return basis((t - i2 / n) * n, v0, v1, v22, v3);
  };
}

// node_modules/d3-interpolate/src/basisClosed.js
function basisClosed_default(values3) {
  var n = values3.length;
  return function(t) {
    var i2 = Math.floor(((t %= 1) < 0 ? ++t : t) * n), v0 = values3[(i2 + n - 1) % n], v1 = values3[i2 % n], v22 = values3[(i2 + 1) % n], v3 = values3[(i2 + 2) % n];
    return basis((t - i2 / n) * n, v0, v1, v22, v3);
  };
}

// node_modules/d3-interpolate/src/constant.js
var constant_default = (x3) => () => x3;

// node_modules/d3-interpolate/src/color.js
function linear(a3, d) {
  return function(t) {
    return a3 + t * d;
  };
}
function exponential(a3, b2, y3) {
  return a3 = Math.pow(a3, y3), b2 = Math.pow(b2, y3) - a3, y3 = 1 / y3, function(t) {
    return Math.pow(a3 + t * b2, y3);
  };
}
function hue(a3, b2) {
  var d = b2 - a3;
  return d ? linear(a3, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant_default(isNaN(a3) ? b2 : a3);
}
function gamma(y3) {
  return (y3 = +y3) === 1 ? nogamma : function(a3, b2) {
    return b2 - a3 ? exponential(a3, b2, y3) : constant_default(isNaN(a3) ? b2 : a3);
  };
}
function nogamma(a3, b2) {
  var d = b2 - a3;
  return d ? linear(a3, d) : constant_default(isNaN(a3) ? b2 : a3);
}

// node_modules/d3-interpolate/src/rgb.js
var rgb_default = function rgbGamma(y3) {
  var color3 = gamma(y3);
  function rgb2(start2, end2) {
    var r3 = color3((start2 = rgb(start2)).r, (end2 = rgb(end2)).r), g2 = color3(start2.g, end2.g), b2 = color3(start2.b, end2.b), opacity = nogamma(start2.opacity, end2.opacity);
    return function(t) {
      start2.r = r3(t);
      start2.g = g2(t);
      start2.b = b2(t);
      start2.opacity = opacity(t);
      return start2 + "";
    };
  }
  rgb2.gamma = rgbGamma;
  return rgb2;
}(1);
function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length, r3 = new Array(n), g2 = new Array(n), b2 = new Array(n), i2, color3;
    for (i2 = 0; i2 < n; ++i2) {
      color3 = rgb(colors[i2]);
      r3[i2] = color3.r || 0;
      g2[i2] = color3.g || 0;
      b2[i2] = color3.b || 0;
    }
    r3 = spline(r3);
    g2 = spline(g2);
    b2 = spline(b2);
    color3.opacity = 1;
    return function(t) {
      color3.r = r3(t);
      color3.g = g2(t);
      color3.b = b2(t);
      return color3 + "";
    };
  };
}
var rgbBasis = rgbSpline(basis_default);
var rgbBasisClosed = rgbSpline(basisClosed_default);

// node_modules/d3-interpolate/src/numberArray.js
function numberArray_default(a3, b2) {
  if (!b2) b2 = [];
  var n = a3 ? Math.min(b2.length, a3.length) : 0, c3 = b2.slice(), i2;
  return function(t) {
    for (i2 = 0; i2 < n; ++i2) c3[i2] = a3[i2] * (1 - t) + b2[i2] * t;
    return c3;
  };
}
function isNumberArray(x3) {
  return ArrayBuffer.isView(x3) && !(x3 instanceof DataView);
}

// node_modules/d3-interpolate/src/array.js
function genericArray(a3, b2) {
  var nb = b2 ? b2.length : 0, na = a3 ? Math.min(nb, a3.length) : 0, x3 = new Array(na), c3 = new Array(nb), i2;
  for (i2 = 0; i2 < na; ++i2) x3[i2] = value_default(a3[i2], b2[i2]);
  for (; i2 < nb; ++i2) c3[i2] = b2[i2];
  return function(t) {
    for (i2 = 0; i2 < na; ++i2) c3[i2] = x3[i2](t);
    return c3;
  };
}

// node_modules/d3-interpolate/src/date.js
function date_default(a3, b2) {
  var d = /* @__PURE__ */ new Date();
  return a3 = +a3, b2 = +b2, function(t) {
    return d.setTime(a3 * (1 - t) + b2 * t), d;
  };
}

// node_modules/d3-interpolate/src/number.js
function number_default(a3, b2) {
  return a3 = +a3, b2 = +b2, function(t) {
    return a3 * (1 - t) + b2 * t;
  };
}

// node_modules/d3-interpolate/src/object.js
function object_default(a3, b2) {
  var i2 = {}, c3 = {}, k3;
  if (a3 === null || typeof a3 !== "object") a3 = {};
  if (b2 === null || typeof b2 !== "object") b2 = {};
  for (k3 in b2) {
    if (k3 in a3) {
      i2[k3] = value_default(a3[k3], b2[k3]);
    } else {
      c3[k3] = b2[k3];
    }
  }
  return function(t) {
    for (k3 in i2) c3[k3] = i2[k3](t);
    return c3;
  };
}

// node_modules/d3-interpolate/src/string.js
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var reB = new RegExp(reA.source, "g");
function zero2(b2) {
  return function() {
    return b2;
  };
}
function one(b2) {
  return function(t) {
    return b2(t) + "";
  };
}
function string_default(a3, b2) {
  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i2 = -1, s3 = [], q2 = [];
  a3 = a3 + "", b2 = b2 + "";
  while ((am = reA.exec(a3)) && (bm = reB.exec(b2))) {
    if ((bs = bm.index) > bi) {
      bs = b2.slice(bi, bs);
      if (s3[i2]) s3[i2] += bs;
      else s3[++i2] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s3[i2]) s3[i2] += bm;
      else s3[++i2] = bm;
    } else {
      s3[++i2] = null;
      q2.push({ i: i2, x: number_default(am, bm) });
    }
    bi = reB.lastIndex;
  }
  if (bi < b2.length) {
    bs = b2.slice(bi);
    if (s3[i2]) s3[i2] += bs;
    else s3[++i2] = bs;
  }
  return s3.length < 2 ? q2[0] ? one(q2[0].x) : zero2(b2) : (b2 = q2.length, function(t) {
    for (var i3 = 0, o2; i3 < b2; ++i3) s3[(o2 = q2[i3]).i] = o2.x(t);
    return s3.join("");
  });
}

// node_modules/d3-interpolate/src/value.js
function value_default(a3, b2) {
  var t = typeof b2, c3;
  return b2 == null || t === "boolean" ? constant_default(b2) : (t === "number" ? number_default : t === "string" ? (c3 = color(b2)) ? (b2 = c3, rgb_default) : string_default : b2 instanceof color ? rgb_default : b2 instanceof Date ? date_default : isNumberArray(b2) ? numberArray_default : Array.isArray(b2) ? genericArray : typeof b2.valueOf !== "function" && typeof b2.toString !== "function" || isNaN(b2) ? object_default : number_default)(a3, b2);
}

// node_modules/d3-interpolate/src/round.js
function round_default(a3, b2) {
  return a3 = +a3, b2 = +b2, function(t) {
    return Math.round(a3 * (1 - t) + b2 * t);
  };
}

// node_modules/d3-interpolate/src/transform/decompose.js
var degrees2 = 180 / Math.PI;
var identity2 = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function decompose_default(a3, b2, c3, d, e, f2) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a3 * a3 + b2 * b2)) a3 /= scaleX, b2 /= scaleX;
  if (skewX = a3 * c3 + b2 * d) c3 -= a3 * skewX, d -= b2 * skewX;
  if (scaleY = Math.sqrt(c3 * c3 + d * d)) c3 /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a3 * d < b2 * c3) a3 = -a3, b2 = -b2, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f2,
    rotate: Math.atan2(b2, a3) * degrees2,
    skewX: Math.atan(skewX) * degrees2,
    scaleX,
    scaleY
  };
}

// node_modules/d3-interpolate/src/transform/parse.js
var svgNode;
function parseCss(value) {
  const m2 = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m2.isIdentity ? identity2 : decompose_default(m2.a, m2.b, m2.c, m2.d, m2.e, m2.f);
}
function parseSvg(value) {
  if (value == null) return identity2;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return identity2;
  value = value.matrix;
  return decompose_default(value.a, value.b, value.c, value.d, value.e, value.f);
}

// node_modules/d3-interpolate/src/transform/index.js
function interpolateTransform(parse2, pxComma, pxParen, degParen) {
  function pop(s3) {
    return s3.length ? s3.pop() + " " : "";
  }
  function translate(xa, ya, xb, yb, s3, q2) {
    if (xa !== xb || ya !== yb) {
      var i2 = s3.push("translate(", null, pxComma, null, pxParen);
      q2.push({ i: i2 - 4, x: number_default(xa, xb) }, { i: i2 - 2, x: number_default(ya, yb) });
    } else if (xb || yb) {
      s3.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }
  function rotate(a3, b2, s3, q2) {
    if (a3 !== b2) {
      if (a3 - b2 > 180) b2 += 360;
      else if (b2 - a3 > 180) a3 += 360;
      q2.push({ i: s3.push(pop(s3) + "rotate(", null, degParen) - 2, x: number_default(a3, b2) });
    } else if (b2) {
      s3.push(pop(s3) + "rotate(" + b2 + degParen);
    }
  }
  function skewX(a3, b2, s3, q2) {
    if (a3 !== b2) {
      q2.push({ i: s3.push(pop(s3) + "skewX(", null, degParen) - 2, x: number_default(a3, b2) });
    } else if (b2) {
      s3.push(pop(s3) + "skewX(" + b2 + degParen);
    }
  }
  function scale2(xa, ya, xb, yb, s3, q2) {
    if (xa !== xb || ya !== yb) {
      var i2 = s3.push(pop(s3) + "scale(", null, ",", null, ")");
      q2.push({ i: i2 - 4, x: number_default(xa, xb) }, { i: i2 - 2, x: number_default(ya, yb) });
    } else if (xb !== 1 || yb !== 1) {
      s3.push(pop(s3) + "scale(" + xb + "," + yb + ")");
    }
  }
  return function(a3, b2) {
    var s3 = [], q2 = [];
    a3 = parse2(a3), b2 = parse2(b2);
    translate(a3.translateX, a3.translateY, b2.translateX, b2.translateY, s3, q2);
    rotate(a3.rotate, b2.rotate, s3, q2);
    skewX(a3.skewX, b2.skewX, s3, q2);
    scale2(a3.scaleX, a3.scaleY, b2.scaleX, b2.scaleY, s3, q2);
    a3 = b2 = null;
    return function(t) {
      var i2 = -1, n = q2.length, o2;
      while (++i2 < n) s3[(o2 = q2[i2]).i] = o2.x(t);
      return s3.join("");
    };
  };
}
var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

// node_modules/d3-interpolate/src/zoom.js
var epsilon2 = 1e-12;
function cosh(x3) {
  return ((x3 = Math.exp(x3)) + 1 / x3) / 2;
}
function sinh(x3) {
  return ((x3 = Math.exp(x3)) - 1 / x3) / 2;
}
function tanh(x3) {
  return ((x3 = Math.exp(2 * x3)) - 1) / (x3 + 1);
}
var zoom_default = function zoomRho(rho, rho2, rho4) {
  function zoom(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i2, S2;
    if (d2 < epsilon2) {
      S2 = Math.log(w1 / w0) / rho;
      i2 = function(t) {
        return [
          ux0 + t * dx,
          uy0 + t * dy,
          w0 * Math.exp(rho * t * S2)
        ];
      };
    } else {
      var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1), b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S2 = (r1 - r0) / rho;
      i2 = function(t) {
        var s3 = t * S2, coshr0 = cosh(r0), u5 = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s3 + r0) - sinh(r0));
        return [
          ux0 + u5 * dx,
          uy0 + u5 * dy,
          w0 * coshr0 / cosh(rho * s3 + r0)
        ];
      };
    }
    i2.duration = S2 * 1e3 * rho / Math.SQRT2;
    return i2;
  }
  zoom.rho = function(_2) {
    var _1 = Math.max(1e-3, +_2), _22 = _1 * _1, _4 = _22 * _22;
    return zoomRho(_1, _22, _4);
  };
  return zoom;
}(Math.SQRT2, 2, 4);

// node_modules/d3-interpolate/src/hsl.js
function hsl2(hue2) {
  return function(start2, end2) {
    var h = hue2((start2 = hsl(start2)).h, (end2 = hsl(end2)).h), s3 = nogamma(start2.s, end2.s), l2 = nogamma(start2.l, end2.l), opacity = nogamma(start2.opacity, end2.opacity);
    return function(t) {
      start2.h = h(t);
      start2.s = s3(t);
      start2.l = l2(t);
      start2.opacity = opacity(t);
      return start2 + "";
    };
  };
}
var hsl_default = hsl2(hue);
var hslLong = hsl2(nogamma);

// node_modules/d3-interpolate/src/hcl.js
function hcl2(hue2) {
  return function(start2, end2) {
    var h = hue2((start2 = hcl(start2)).h, (end2 = hcl(end2)).h), c3 = nogamma(start2.c, end2.c), l2 = nogamma(start2.l, end2.l), opacity = nogamma(start2.opacity, end2.opacity);
    return function(t) {
      start2.h = h(t);
      start2.c = c3(t);
      start2.l = l2(t);
      start2.opacity = opacity(t);
      return start2 + "";
    };
  };
}
var hcl_default = hcl2(hue);
var hclLong = hcl2(nogamma);

// node_modules/d3-interpolate/src/cubehelix.js
function cubehelix2(hue2) {
  return function cubehelixGamma(y3) {
    y3 = +y3;
    function cubehelix3(start2, end2) {
      var h = hue2((start2 = cubehelix(start2)).h, (end2 = cubehelix(end2)).h), s3 = nogamma(start2.s, end2.s), l2 = nogamma(start2.l, end2.l), opacity = nogamma(start2.opacity, end2.opacity);
      return function(t) {
        start2.h = h(t);
        start2.s = s3(t);
        start2.l = l2(Math.pow(t, y3));
        start2.opacity = opacity(t);
        return start2 + "";
      };
    }
    cubehelix3.gamma = cubehelixGamma;
    return cubehelix3;
  }(1);
}
var cubehelix_default = cubehelix2(hue);
var cubehelixLong = cubehelix2(nogamma);

// node_modules/d3-scale/src/constant.js
function constants(x3) {
  return function() {
    return x3;
  };
}

// node_modules/d3-scale/src/number.js
function number2(x3) {
  return +x3;
}

// node_modules/d3-scale/src/continuous.js
var unit = [0, 1];
function identity3(x3) {
  return x3;
}
function normalize(a3, b2) {
  return (b2 -= a3 = +a3) ? function(x3) {
    return (x3 - a3) / b2;
  } : constants(isNaN(b2) ? NaN : 0.5);
}
function clamper(a3, b2) {
  var t;
  if (a3 > b2) t = a3, a3 = b2, b2 = t;
  return function(x3) {
    return Math.max(a3, Math.min(b2, x3));
  };
}
function bimap(domain, range2, interpolate) {
  var d0 = domain[0], d1 = domain[1], r0 = range2[0], r1 = range2[1];
  if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
  else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
  return function(x3) {
    return r0(d0(x3));
  };
}
function polymap(domain, range2, interpolate) {
  var j2 = Math.min(domain.length, range2.length) - 1, d = new Array(j2), r3 = new Array(j2), i2 = -1;
  if (domain[j2] < domain[0]) {
    domain = domain.slice().reverse();
    range2 = range2.slice().reverse();
  }
  while (++i2 < j2) {
    d[i2] = normalize(domain[i2], domain[i2 + 1]);
    r3[i2] = interpolate(range2[i2], range2[i2 + 1]);
  }
  return function(x3) {
    var i3 = bisect_default(domain, x3, 1, j2) - 1;
    return r3[i3](d[i3](x3));
  };
}
function copy(source, target) {
  return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
}
function transformer() {
  var domain = unit, range2 = unit, interpolate = value_default, transform, untransform, unknown, clamp2 = identity3, piecewise2, output, input;
  function rescale() {
    var n = Math.min(domain.length, range2.length);
    if (clamp2 !== identity3) clamp2 = clamper(domain[0], domain[n - 1]);
    piecewise2 = n > 2 ? polymap : bimap;
    output = input = null;
    return scale2;
  }
  function scale2(x3) {
    return x3 == null || isNaN(x3 = +x3) ? unknown : (output || (output = piecewise2(domain.map(transform), range2, interpolate)))(transform(clamp2(x3)));
  }
  scale2.invert = function(y3) {
    return clamp2(untransform((input || (input = piecewise2(range2, domain.map(transform), number_default)))(y3)));
  };
  scale2.domain = function(_2) {
    return arguments.length ? (domain = Array.from(_2, number2), rescale()) : domain.slice();
  };
  scale2.range = function(_2) {
    return arguments.length ? (range2 = Array.from(_2), rescale()) : range2.slice();
  };
  scale2.rangeRound = function(_2) {
    return range2 = Array.from(_2), interpolate = round_default, rescale();
  };
  scale2.clamp = function(_2) {
    return arguments.length ? (clamp2 = _2 ? true : identity3, rescale()) : clamp2 !== identity3;
  };
  scale2.interpolate = function(_2) {
    return arguments.length ? (interpolate = _2, rescale()) : interpolate;
  };
  scale2.unknown = function(_2) {
    return arguments.length ? (unknown = _2, scale2) : unknown;
  };
  return function(t, u5) {
    transform = t, untransform = u5;
    return rescale();
  };
}
function continuous() {
  return transformer()(identity3, identity3);
}

// node_modules/d3-format/src/formatDecimal.js
function formatDecimal_default(x3) {
  return Math.abs(x3 = Math.round(x3)) >= 1e21 ? x3.toLocaleString("en").replace(/,/g, "") : x3.toString(10);
}
function formatDecimalParts(x3, p2) {
  if ((i2 = (x3 = p2 ? x3.toExponential(p2 - 1) : x3.toExponential()).indexOf("e")) < 0) return null;
  var i2, coefficient = x3.slice(0, i2);
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x3.slice(i2 + 1)
  ];
}

// node_modules/d3-format/src/exponent.js
function exponent_default(x3) {
  return x3 = formatDecimalParts(Math.abs(x3)), x3 ? x3[1] : NaN;
}

// node_modules/d3-format/src/formatGroup.js
function formatGroup_default(grouping, thousands) {
  return function(value, width2) {
    var i2 = value.length, t = [], j2 = 0, g2 = grouping[0], length2 = 0;
    while (i2 > 0 && g2 > 0) {
      if (length2 + g2 + 1 > width2) g2 = Math.max(1, width2 - length2);
      t.push(value.substring(i2 -= g2, i2 + g2));
      if ((length2 += g2 + 1) > width2) break;
      g2 = grouping[j2 = (j2 + 1) % grouping.length];
    }
    return t.reverse().join(thousands);
  };
}

// node_modules/d3-format/src/formatNumerals.js
function formatNumerals_default(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i2) {
      return numerals[+i2];
    });
  };
}

// node_modules/d3-format/src/formatSpecifier.js
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier(specifier) {
  if (!(match2 = re.exec(specifier))) throw new Error("invalid format: " + specifier);
  var match2;
  return new FormatSpecifier({
    fill: match2[1],
    align: match2[2],
    sign: match2[3],
    symbol: match2[4],
    zero: match2[5],
    width: match2[6],
    comma: match2[7],
    precision: match2[8] && match2[8].slice(1),
    trim: match2[9],
    type: match2[10]
  });
}
formatSpecifier.prototype = FormatSpecifier.prototype;
function FormatSpecifier(specifier) {
  this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
  this.align = specifier.align === void 0 ? ">" : specifier.align + "";
  this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === void 0 ? void 0 : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === void 0 ? "" : specifier.type + "";
}
FormatSpecifier.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};

// node_modules/d3-format/src/formatTrim.js
function formatTrim_default(s3) {
  out: for (var n = s3.length, i2 = 1, i0 = -1, i1; i2 < n; ++i2) {
    switch (s3[i2]) {
      case ".":
        i0 = i1 = i2;
        break;
      case "0":
        if (i0 === 0) i0 = i2;
        i1 = i2;
        break;
      default:
        if (!+s3[i2]) break out;
        if (i0 > 0) i0 = 0;
        break;
    }
  }
  return i0 > 0 ? s3.slice(0, i0) + s3.slice(i1 + 1) : s3;
}

// node_modules/d3-format/src/formatPrefixAuto.js
var prefixExponent;
function formatPrefixAuto_default(x3, p2) {
  var d = formatDecimalParts(x3, p2);
  if (!d) return x3 + "";
  var coefficient = d[0], exponent = d[1], i2 = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1, n = coefficient.length;
  return i2 === n ? coefficient : i2 > n ? coefficient + new Array(i2 - n + 1).join("0") : i2 > 0 ? coefficient.slice(0, i2) + "." + coefficient.slice(i2) : "0." + new Array(1 - i2).join("0") + formatDecimalParts(x3, Math.max(0, p2 + i2 - 1))[0];
}

// node_modules/d3-format/src/formatRounded.js
function formatRounded_default(x3, p2) {
  var d = formatDecimalParts(x3, p2);
  if (!d) return x3 + "";
  var coefficient = d[0], exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}

// node_modules/d3-format/src/formatTypes.js
var formatTypes_default = {
  "%": (x3, p2) => (x3 * 100).toFixed(p2),
  "b": (x3) => Math.round(x3).toString(2),
  "c": (x3) => x3 + "",
  "d": formatDecimal_default,
  "e": (x3, p2) => x3.toExponential(p2),
  "f": (x3, p2) => x3.toFixed(p2),
  "g": (x3, p2) => x3.toPrecision(p2),
  "o": (x3) => Math.round(x3).toString(8),
  "p": (x3, p2) => formatRounded_default(x3 * 100, p2),
  "r": formatRounded_default,
  "s": formatPrefixAuto_default,
  "X": (x3) => Math.round(x3).toString(16).toUpperCase(),
  "x": (x3) => Math.round(x3).toString(16)
};

// node_modules/d3-format/src/identity.js
function identity_default(x3) {
  return x3;
}

// node_modules/d3-format/src/locale.js
var map3 = Array.prototype.map;
var prefixes = ["y", "z", "a", "f", "p", "n", "", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function locale_default(locale3) {
  var group2 = locale3.grouping === void 0 || locale3.thousands === void 0 ? identity_default : formatGroup_default(map3.call(locale3.grouping, Number), locale3.thousands + ""), currencyPrefix = locale3.currency === void 0 ? "" : locale3.currency[0] + "", currencySuffix = locale3.currency === void 0 ? "" : locale3.currency[1] + "", decimal = locale3.decimal === void 0 ? "." : locale3.decimal + "", numerals = locale3.numerals === void 0 ? identity_default : formatNumerals_default(map3.call(locale3.numerals, String)), percent = locale3.percent === void 0 ? "%" : locale3.percent + "", minus = locale3.minus === void 0 ? "" : locale3.minus + "", nan = locale3.nan === void 0 ? "NaN" : locale3.nan + "";
  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);
    var fill = specifier.fill, align = specifier.align, sign2 = specifier.sign, symbol = specifier.symbol, zero3 = specifier.zero, width2 = specifier.width, comma = specifier.comma, precision = specifier.precision, trim2 = specifier.trim, type = specifier.type;
    if (type === "n") comma = true, type = "g";
    else if (!formatTypes_default[type]) precision === void 0 && (precision = 12), trim2 = true, type = "g";
    if (zero3 || fill === "0" && align === "=") zero3 = true, fill = "0", align = "=";
    var prefix2 = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";
    var formatType = formatTypes_default[type], maybeSuffix = /[defgprs%]/.test(type);
    precision = precision === void 0 ? 6 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format2(value) {
      var valuePrefix = prefix2, valueSuffix = suffix, i2, n, c3;
      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;
        var valueNegative = value < 0 || 1 / value < 0;
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
        if (trim2) value = formatTrim_default(value);
        if (valueNegative && +value === 0 && sign2 !== "+") valueNegative = false;
        valuePrefix = (valueNegative ? sign2 === "(" ? sign2 : minus : sign2 === "-" || sign2 === "(" ? "" : sign2) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign2 === "(" ? ")" : "");
        if (maybeSuffix) {
          i2 = -1, n = value.length;
          while (++i2 < n) {
            if (c3 = value.charCodeAt(i2), 48 > c3 || c3 > 57) {
              valueSuffix = (c3 === 46 ? decimal + value.slice(i2 + 1) : value.slice(i2)) + valueSuffix;
              value = value.slice(0, i2);
              break;
            }
          }
        }
      }
      if (comma && !zero3) value = group2(value, Infinity);
      var length2 = valuePrefix.length + value.length + valueSuffix.length, padding2 = length2 < width2 ? new Array(width2 - length2 + 1).join(fill) : "";
      if (comma && zero3) value = group2(padding2 + value, padding2.length ? width2 - valueSuffix.length : Infinity), padding2 = "";
      switch (align) {
        case "<":
          value = valuePrefix + value + valueSuffix + padding2;
          break;
        case "=":
          value = valuePrefix + padding2 + value + valueSuffix;
          break;
        case "^":
          value = padding2.slice(0, length2 = padding2.length >> 1) + valuePrefix + value + valueSuffix + padding2.slice(length2);
          break;
        default:
          value = padding2 + valuePrefix + value + valueSuffix;
          break;
      }
      return numerals(value);
    }
    format2.toString = function() {
      return specifier + "";
    };
    return format2;
  }
  function formatPrefix2(specifier, value) {
    var f2 = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3, k3 = Math.pow(10, -e), prefix2 = prefixes[8 + e / 3];
    return function(value2) {
      return f2(k3 * value2) + prefix2;
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix2
  };
}

// node_modules/d3-format/src/defaultLocale.js
var locale;
var format;
var formatPrefix;
defaultLocale({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function defaultLocale(definition) {
  locale = locale_default(definition);
  format = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}

// node_modules/d3-format/src/precisionFixed.js
function precisionFixed_default(step) {
  return Math.max(0, -exponent_default(Math.abs(step)));
}

// node_modules/d3-format/src/precisionPrefix.js
function precisionPrefix_default(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3 - exponent_default(Math.abs(step)));
}

// node_modules/d3-format/src/precisionRound.js
function precisionRound_default(step, max4) {
  step = Math.abs(step), max4 = Math.abs(max4) - step;
  return Math.max(0, exponent_default(max4) - exponent_default(step)) + 1;
}

// node_modules/d3-scale/src/tickFormat.js
function tickFormat(start2, stop, count2, specifier) {
  var step = tickStep(start2, stop, count2), precision;
  specifier = formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start2), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = precisionPrefix_default(step, value))) specifier.precision = precision;
      return formatPrefix(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = precisionRound_default(step, Math.max(Math.abs(start2), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = precisionFixed_default(step))) specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return format(specifier);
}

// node_modules/d3-scale/src/linear.js
function linearish(scale2) {
  var domain = scale2.domain;
  scale2.ticks = function(count2) {
    var d = domain();
    return ticks(d[0], d[d.length - 1], count2 == null ? 10 : count2);
  };
  scale2.tickFormat = function(count2, specifier) {
    var d = domain();
    return tickFormat(d[0], d[d.length - 1], count2 == null ? 10 : count2, specifier);
  };
  scale2.nice = function(count2) {
    if (count2 == null) count2 = 10;
    var d = domain();
    var i0 = 0;
    var i1 = d.length - 1;
    var start2 = d[i0];
    var stop = d[i1];
    var prestep;
    var step;
    var maxIter = 10;
    if (stop < start2) {
      step = start2, start2 = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }
    while (maxIter-- > 0) {
      step = tickIncrement(start2, stop, count2);
      if (step === prestep) {
        d[i0] = start2;
        d[i1] = stop;
        return domain(d);
      } else if (step > 0) {
        start2 = Math.floor(start2 / step) * step;
        stop = Math.ceil(stop / step) * step;
      } else if (step < 0) {
        start2 = Math.ceil(start2 * step) / step;
        stop = Math.floor(stop * step) / step;
      } else {
        break;
      }
      prestep = step;
    }
    return scale2;
  };
  return scale2;
}
function linear2() {
  var scale2 = continuous();
  scale2.copy = function() {
    return copy(scale2, linear2());
  };
  initRange.apply(scale2, arguments);
  return linearish(scale2);
}

// node_modules/d3-scale/src/nice.js
function nice2(domain, interval2) {
  domain = domain.slice();
  var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], t;
  if (x1 < x0) {
    t = i0, i0 = i1, i1 = t;
    t = x0, x0 = x1, x1 = t;
  }
  domain[i0] = interval2.floor(x0);
  domain[i1] = interval2.ceil(x1);
  return domain;
}

// node_modules/d3-scale/src/log.js
function transformLog(x3) {
  return Math.log(x3);
}
function transformExp(x3) {
  return Math.exp(x3);
}
function transformLogn(x3) {
  return -Math.log(-x3);
}
function transformExpn(x3) {
  return -Math.exp(-x3);
}
function pow10(x3) {
  return isFinite(x3) ? +("1e" + x3) : x3 < 0 ? 0 : x3;
}
function powp(base) {
  return base === 10 ? pow10 : base === Math.E ? Math.exp : (x3) => Math.pow(base, x3);
}
function logp(base) {
  return base === Math.E ? Math.log : base === 10 && Math.log10 || base === 2 && Math.log2 || (base = Math.log(base), (x3) => Math.log(x3) / base);
}
function reflect(f2) {
  return (x3, k3) => -f2(-x3, k3);
}
function loggish(transform) {
  const scale2 = transform(transformLog, transformExp);
  const domain = scale2.domain;
  let base = 10;
  let logs;
  let pows;
  function rescale() {
    logs = logp(base), pows = powp(base);
    if (domain()[0] < 0) {
      logs = reflect(logs), pows = reflect(pows);
      transform(transformLogn, transformExpn);
    } else {
      transform(transformLog, transformExp);
    }
    return scale2;
  }
  scale2.base = function(_2) {
    return arguments.length ? (base = +_2, rescale()) : base;
  };
  scale2.domain = function(_2) {
    return arguments.length ? (domain(_2), rescale()) : domain();
  };
  scale2.ticks = (count2) => {
    const d = domain();
    let u5 = d[0];
    let v3 = d[d.length - 1];
    const r3 = v3 < u5;
    if (r3) [u5, v3] = [v3, u5];
    let i2 = logs(u5);
    let j2 = logs(v3);
    let k3;
    let t;
    const n = count2 == null ? 10 : +count2;
    let z2 = [];
    if (!(base % 1) && j2 - i2 < n) {
      i2 = Math.floor(i2), j2 = Math.ceil(j2);
      if (u5 > 0) for (; i2 <= j2; ++i2) {
        for (k3 = 1; k3 < base; ++k3) {
          t = i2 < 0 ? k3 / pows(-i2) : k3 * pows(i2);
          if (t < u5) continue;
          if (t > v3) break;
          z2.push(t);
        }
      }
      else for (; i2 <= j2; ++i2) {
        for (k3 = base - 1; k3 >= 1; --k3) {
          t = i2 > 0 ? k3 / pows(-i2) : k3 * pows(i2);
          if (t < u5) continue;
          if (t > v3) break;
          z2.push(t);
        }
      }
      if (z2.length * 2 < n) z2 = ticks(u5, v3, n);
    } else {
      z2 = ticks(i2, j2, Math.min(j2 - i2, n)).map(pows);
    }
    return r3 ? z2.reverse() : z2;
  };
  scale2.tickFormat = (count2, specifier) => {
    if (count2 == null) count2 = 10;
    if (specifier == null) specifier = base === 10 ? "s" : ",";
    if (typeof specifier !== "function") {
      if (!(base % 1) && (specifier = formatSpecifier(specifier)).precision == null) specifier.trim = true;
      specifier = format(specifier);
    }
    if (count2 === Infinity) return specifier;
    const k3 = Math.max(1, base * count2 / scale2.ticks().length);
    return (d) => {
      let i2 = d / pows(Math.round(logs(d)));
      if (i2 * base < base - 0.5) i2 *= base;
      return i2 <= k3 ? specifier(d) : "";
    };
  };
  scale2.nice = () => {
    return domain(nice2(domain(), {
      floor: (x3) => pows(Math.floor(logs(x3))),
      ceil: (x3) => pows(Math.ceil(logs(x3)))
    }));
  };
  return scale2;
}
function log() {
  const scale2 = loggish(transformer()).domain([1, 10]);
  scale2.copy = () => copy(scale2, log()).base(scale2.base());
  initRange.apply(scale2, arguments);
  return scale2;
}

// node_modules/d3-scale/src/pow.js
function transformPow(exponent) {
  return function(x3) {
    return x3 < 0 ? -Math.pow(-x3, exponent) : Math.pow(x3, exponent);
  };
}
function transformSqrt(x3) {
  return x3 < 0 ? -Math.sqrt(-x3) : Math.sqrt(x3);
}
function transformSquare(x3) {
  return x3 < 0 ? -x3 * x3 : x3 * x3;
}
function powish(transform) {
  var scale2 = transform(identity3, identity3), exponent = 1;
  function rescale() {
    return exponent === 1 ? transform(identity3, identity3) : exponent === 0.5 ? transform(transformSqrt, transformSquare) : transform(transformPow(exponent), transformPow(1 / exponent));
  }
  scale2.exponent = function(_2) {
    return arguments.length ? (exponent = +_2, rescale()) : exponent;
  };
  return linearish(scale2);
}
function pow() {
  var scale2 = powish(transformer());
  scale2.copy = function() {
    return copy(scale2, pow()).exponent(scale2.exponent());
  };
  initRange.apply(scale2, arguments);
  return scale2;
}
function sqrt() {
  return pow.apply(null, arguments).exponent(0.5);
}

// node_modules/d3-scale/src/threshold.js
function threshold() {
  var domain = [0.5], range2 = [0, 1], unknown, n = 1;
  function scale2(x3) {
    return x3 != null && x3 <= x3 ? range2[bisect_default(domain, x3, 0, n)] : unknown;
  }
  scale2.domain = function(_2) {
    return arguments.length ? (domain = Array.from(_2), n = Math.min(domain.length, range2.length - 1), scale2) : domain.slice();
  };
  scale2.range = function(_2) {
    return arguments.length ? (range2 = Array.from(_2), n = Math.min(domain.length, range2.length - 1), scale2) : range2.slice();
  };
  scale2.invertExtent = function(y3) {
    var i2 = range2.indexOf(y3);
    return [domain[i2 - 1], domain[i2]];
  };
  scale2.unknown = function(_2) {
    return arguments.length ? (unknown = _2, scale2) : unknown;
  };
  scale2.copy = function() {
    return threshold().domain(domain).range(range2).unknown(unknown);
  };
  return initRange.apply(scale2, arguments);
}

// node_modules/d3-time/src/interval.js
var t02 = /* @__PURE__ */ new Date();
var t12 = /* @__PURE__ */ new Date();
function timeInterval(floori, offseti, count2, field) {
  function interval2(date2) {
    return floori(date2 = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+date2)), date2;
  }
  interval2.floor = (date2) => {
    return floori(date2 = /* @__PURE__ */ new Date(+date2)), date2;
  };
  interval2.ceil = (date2) => {
    return floori(date2 = new Date(date2 - 1)), offseti(date2, 1), floori(date2), date2;
  };
  interval2.round = (date2) => {
    const d0 = interval2(date2), d1 = interval2.ceil(date2);
    return date2 - d0 < d1 - date2 ? d0 : d1;
  };
  interval2.offset = (date2, step) => {
    return offseti(date2 = /* @__PURE__ */ new Date(+date2), step == null ? 1 : Math.floor(step)), date2;
  };
  interval2.range = (start2, stop, step) => {
    const range2 = [];
    start2 = interval2.ceil(start2);
    step = step == null ? 1 : Math.floor(step);
    if (!(start2 < stop) || !(step > 0)) return range2;
    let previous;
    do
      range2.push(previous = /* @__PURE__ */ new Date(+start2)), offseti(start2, step), floori(start2);
    while (previous < start2 && start2 < stop);
    return range2;
  };
  interval2.filter = (test) => {
    return timeInterval((date2) => {
      if (date2 >= date2) while (floori(date2), !test(date2)) date2.setTime(date2 - 1);
    }, (date2, step) => {
      if (date2 >= date2) {
        if (step < 0) while (++step <= 0) {
          while (offseti(date2, -1), !test(date2)) {
          }
        }
        else while (--step >= 0) {
          while (offseti(date2, 1), !test(date2)) {
          }
        }
      }
    });
  };
  if (count2) {
    interval2.count = (start2, end2) => {
      t02.setTime(+start2), t12.setTime(+end2);
      floori(t02), floori(t12);
      return Math.floor(count2(t02, t12));
    };
    interval2.every = (step) => {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval2 : interval2.filter(field ? (d) => field(d) % step === 0 : (d) => interval2.count(0, d) % step === 0);
    };
  }
  return interval2;
}

// node_modules/d3-time/src/millisecond.js
var millisecond = timeInterval(() => {
}, (date2, step) => {
  date2.setTime(+date2 + step);
}, (start2, end2) => {
  return end2 - start2;
});
millisecond.every = (k3) => {
  k3 = Math.floor(k3);
  if (!isFinite(k3) || !(k3 > 0)) return null;
  if (!(k3 > 1)) return millisecond;
  return timeInterval((date2) => {
    date2.setTime(Math.floor(date2 / k3) * k3);
  }, (date2, step) => {
    date2.setTime(+date2 + step * k3);
  }, (start2, end2) => {
    return (end2 - start2) / k3;
  });
};
var milliseconds = millisecond.range;

// node_modules/d3-time/src/duration.js
var durationSecond = 1e3;
var durationMinute = durationSecond * 60;
var durationHour = durationMinute * 60;
var durationDay = durationHour * 24;
var durationWeek = durationDay * 7;
var durationMonth = durationDay * 30;
var durationYear = durationDay * 365;

// node_modules/d3-time/src/second.js
var second = timeInterval((date2) => {
  date2.setTime(date2 - date2.getMilliseconds());
}, (date2, step) => {
  date2.setTime(+date2 + step * durationSecond);
}, (start2, end2) => {
  return (end2 - start2) / durationSecond;
}, (date2) => {
  return date2.getUTCSeconds();
});
var seconds = second.range;

// node_modules/d3-time/src/minute.js
var timeMinute = timeInterval((date2) => {
  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond);
}, (date2, step) => {
  date2.setTime(+date2 + step * durationMinute);
}, (start2, end2) => {
  return (end2 - start2) / durationMinute;
}, (date2) => {
  return date2.getMinutes();
});
var timeMinutes = timeMinute.range;
var utcMinute = timeInterval((date2) => {
  date2.setUTCSeconds(0, 0);
}, (date2, step) => {
  date2.setTime(+date2 + step * durationMinute);
}, (start2, end2) => {
  return (end2 - start2) / durationMinute;
}, (date2) => {
  return date2.getUTCMinutes();
});
var utcMinutes = utcMinute.range;

// node_modules/d3-time/src/hour.js
var timeHour = timeInterval((date2) => {
  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond - date2.getMinutes() * durationMinute);
}, (date2, step) => {
  date2.setTime(+date2 + step * durationHour);
}, (start2, end2) => {
  return (end2 - start2) / durationHour;
}, (date2) => {
  return date2.getHours();
});
var timeHours = timeHour.range;
var utcHour = timeInterval((date2) => {
  date2.setUTCMinutes(0, 0, 0);
}, (date2, step) => {
  date2.setTime(+date2 + step * durationHour);
}, (start2, end2) => {
  return (end2 - start2) / durationHour;
}, (date2) => {
  return date2.getUTCHours();
});
var utcHours = utcHour.range;

// node_modules/d3-time/src/day.js
var timeDay = timeInterval(
  (date2) => date2.setHours(0, 0, 0, 0),
  (date2, step) => date2.setDate(date2.getDate() + step),
  (start2, end2) => (end2 - start2 - (end2.getTimezoneOffset() - start2.getTimezoneOffset()) * durationMinute) / durationDay,
  (date2) => date2.getDate() - 1
);
var timeDays = timeDay.range;
var utcDay = timeInterval((date2) => {
  date2.setUTCHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setUTCDate(date2.getUTCDate() + step);
}, (start2, end2) => {
  return (end2 - start2) / durationDay;
}, (date2) => {
  return date2.getUTCDate() - 1;
});
var utcDays = utcDay.range;
var unixDay = timeInterval((date2) => {
  date2.setUTCHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setUTCDate(date2.getUTCDate() + step);
}, (start2, end2) => {
  return (end2 - start2) / durationDay;
}, (date2) => {
  return Math.floor(date2 / durationDay);
});
var unixDays = unixDay.range;

// node_modules/d3-time/src/week.js
function timeWeekday(i2) {
  return timeInterval((date2) => {
    date2.setDate(date2.getDate() - (date2.getDay() + 7 - i2) % 7);
    date2.setHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setDate(date2.getDate() + step * 7);
  }, (start2, end2) => {
    return (end2 - start2 - (end2.getTimezoneOffset() - start2.getTimezoneOffset()) * durationMinute) / durationWeek;
  });
}
var timeSunday = timeWeekday(0);
var timeMonday = timeWeekday(1);
var timeTuesday = timeWeekday(2);
var timeWednesday = timeWeekday(3);
var timeThursday = timeWeekday(4);
var timeFriday = timeWeekday(5);
var timeSaturday = timeWeekday(6);
var timeSundays = timeSunday.range;
var timeMondays = timeMonday.range;
var timeTuesdays = timeTuesday.range;
var timeWednesdays = timeWednesday.range;
var timeThursdays = timeThursday.range;
var timeFridays = timeFriday.range;
var timeSaturdays = timeSaturday.range;
function utcWeekday(i2) {
  return timeInterval((date2) => {
    date2.setUTCDate(date2.getUTCDate() - (date2.getUTCDay() + 7 - i2) % 7);
    date2.setUTCHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setUTCDate(date2.getUTCDate() + step * 7);
  }, (start2, end2) => {
    return (end2 - start2) / durationWeek;
  });
}
var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);
var utcSundays = utcSunday.range;
var utcMondays = utcMonday.range;
var utcTuesdays = utcTuesday.range;
var utcWednesdays = utcWednesday.range;
var utcThursdays = utcThursday.range;
var utcFridays = utcFriday.range;
var utcSaturdays = utcSaturday.range;

// node_modules/d3-time/src/month.js
var timeMonth = timeInterval((date2) => {
  date2.setDate(1);
  date2.setHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setMonth(date2.getMonth() + step);
}, (start2, end2) => {
  return end2.getMonth() - start2.getMonth() + (end2.getFullYear() - start2.getFullYear()) * 12;
}, (date2) => {
  return date2.getMonth();
});
var timeMonths = timeMonth.range;
var utcMonth = timeInterval((date2) => {
  date2.setUTCDate(1);
  date2.setUTCHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setUTCMonth(date2.getUTCMonth() + step);
}, (start2, end2) => {
  return end2.getUTCMonth() - start2.getUTCMonth() + (end2.getUTCFullYear() - start2.getUTCFullYear()) * 12;
}, (date2) => {
  return date2.getUTCMonth();
});
var utcMonths = utcMonth.range;

// node_modules/d3-time/src/year.js
var timeYear = timeInterval((date2) => {
  date2.setMonth(0, 1);
  date2.setHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setFullYear(date2.getFullYear() + step);
}, (start2, end2) => {
  return end2.getFullYear() - start2.getFullYear();
}, (date2) => {
  return date2.getFullYear();
});
timeYear.every = (k3) => {
  return !isFinite(k3 = Math.floor(k3)) || !(k3 > 0) ? null : timeInterval((date2) => {
    date2.setFullYear(Math.floor(date2.getFullYear() / k3) * k3);
    date2.setMonth(0, 1);
    date2.setHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setFullYear(date2.getFullYear() + step * k3);
  });
};
var timeYears = timeYear.range;
var utcYear = timeInterval((date2) => {
  date2.setUTCMonth(0, 1);
  date2.setUTCHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setUTCFullYear(date2.getUTCFullYear() + step);
}, (start2, end2) => {
  return end2.getUTCFullYear() - start2.getUTCFullYear();
}, (date2) => {
  return date2.getUTCFullYear();
});
utcYear.every = (k3) => {
  return !isFinite(k3 = Math.floor(k3)) || !(k3 > 0) ? null : timeInterval((date2) => {
    date2.setUTCFullYear(Math.floor(date2.getUTCFullYear() / k3) * k3);
    date2.setUTCMonth(0, 1);
    date2.setUTCHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setUTCFullYear(date2.getUTCFullYear() + step * k3);
  });
};
var utcYears = utcYear.range;

// node_modules/d3-time/src/ticks.js
function ticker(year, month, week, day, hour, minute) {
  const tickIntervals = [
    [second, 1, durationSecond],
    [second, 5, 5 * durationSecond],
    [second, 15, 15 * durationSecond],
    [second, 30, 30 * durationSecond],
    [minute, 1, durationMinute],
    [minute, 5, 5 * durationMinute],
    [minute, 15, 15 * durationMinute],
    [minute, 30, 30 * durationMinute],
    [hour, 1, durationHour],
    [hour, 3, 3 * durationHour],
    [hour, 6, 6 * durationHour],
    [hour, 12, 12 * durationHour],
    [day, 1, durationDay],
    [day, 2, 2 * durationDay],
    [week, 1, durationWeek],
    [month, 1, durationMonth],
    [month, 3, 3 * durationMonth],
    [year, 1, durationYear]
  ];
  function ticks2(start2, stop, count2) {
    const reverse2 = stop < start2;
    if (reverse2) [start2, stop] = [stop, start2];
    const interval2 = count2 && typeof count2.range === "function" ? count2 : tickInterval(start2, stop, count2);
    const ticks3 = interval2 ? interval2.range(start2, +stop + 1) : [];
    return reverse2 ? ticks3.reverse() : ticks3;
  }
  function tickInterval(start2, stop, count2) {
    const target = Math.abs(stop - start2) / count2;
    const i2 = bisector(([, , step2]) => step2).right(tickIntervals, target);
    if (i2 === tickIntervals.length) return year.every(tickStep(start2 / durationYear, stop / durationYear, count2));
    if (i2 === 0) return millisecond.every(Math.max(tickStep(start2, stop, count2), 1));
    const [t, step] = tickIntervals[target / tickIntervals[i2 - 1][2] < tickIntervals[i2][2] / target ? i2 - 1 : i2];
    return t.every(step);
  }
  return [ticks2, tickInterval];
}
var [utcTicks, utcTickInterval] = ticker(utcYear, utcMonth, utcSunday, unixDay, utcHour, utcMinute);
var [timeTicks, timeTickInterval] = ticker(timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute);

// node_modules/d3-time-format/src/locale.js
function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date2 = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date2.setFullYear(d.y);
    return date2;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}
function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date2 = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date2.setUTCFullYear(d.y);
    return date2;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}
function newDate(y3, m2, d) {
  return { y: y3, m: m2, d, H: 0, M: 0, S: 0, L: 0 };
}
function formatLocale(locale3) {
  var locale_dateTime = locale3.dateTime, locale_date = locale3.date, locale_time = locale3.time, locale_periods = locale3.periods, locale_weekdays = locale3.days, locale_shortWeekdays = locale3.shortDays, locale_months = locale3.months, locale_shortMonths = locale3.shortMonths;
  var periodRe = formatRe(locale_periods), periodLookup = formatLookup(locale_periods), weekdayRe = formatRe(locale_weekdays), weekdayLookup = formatLookup(locale_weekdays), shortWeekdayRe = formatRe(locale_shortWeekdays), shortWeekdayLookup = formatLookup(locale_shortWeekdays), monthRe = formatRe(locale_months), monthLookup = formatLookup(locale_months), shortMonthRe = formatRe(locale_shortMonths), shortMonthLookup = formatLookup(locale_shortMonths);
  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "g": formatYearISO,
    "G": formatFullYearISO,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "q": formatQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };
  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "g": formatUTCYearISO,
    "G": formatUTCFullYearISO,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "q": formatUTCQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };
  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "g": parseYear,
    "G": parseFullYear,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "q": parseQuarter,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);
  function newFormat(specifier, formats2) {
    return function(date2) {
      var string = [], i2 = -1, j2 = 0, n = specifier.length, c3, pad2, format2;
      if (!(date2 instanceof Date)) date2 = /* @__PURE__ */ new Date(+date2);
      while (++i2 < n) {
        if (specifier.charCodeAt(i2) === 37) {
          string.push(specifier.slice(j2, i2));
          if ((pad2 = pads[c3 = specifier.charAt(++i2)]) != null) c3 = specifier.charAt(++i2);
          else pad2 = c3 === "e" ? " " : "0";
          if (format2 = formats2[c3]) c3 = format2(date2, pad2);
          string.push(c3);
          j2 = i2 + 1;
        }
      }
      string.push(specifier.slice(j2, i2));
      return string.join("");
    };
  }
  function newParse(specifier, Z2) {
    return function(string) {
      var d = newDate(1900, void 0, 1), i2 = parseSpecifier(d, specifier, string += "", 0), week, day;
      if (i2 != string.length) return null;
      if ("Q" in d) return new Date(d.Q);
      if ("s" in d) return new Date(d.s * 1e3 + ("L" in d ? d.L : 0));
      if (Z2 && !("Z" in d)) d.Z = 0;
      if ("p" in d) d.H = d.H % 12 + d.p * 12;
      if (d.m === void 0) d.m = "q" in d ? d.q : 0;
      if ("V" in d) {
        if (d.V < 1 || d.V > 53) return null;
        if (!("w" in d)) d.w = 1;
        if ("Z" in d) {
          week = utcDate(newDate(d.y, 0, 1)), day = week.getUTCDay();
          week = day > 4 || day === 0 ? utcMonday.ceil(week) : utcMonday(week);
          week = utcDay.offset(week, (d.V - 1) * 7);
          d.y = week.getUTCFullYear();
          d.m = week.getUTCMonth();
          d.d = week.getUTCDate() + (d.w + 6) % 7;
        } else {
          week = localDate(newDate(d.y, 0, 1)), day = week.getDay();
          week = day > 4 || day === 0 ? timeMonday.ceil(week) : timeMonday(week);
          week = timeDay.offset(week, (d.V - 1) * 7);
          d.y = week.getFullYear();
          d.m = week.getMonth();
          d.d = week.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
      }
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      }
      return localDate(d);
    };
  }
  function parseSpecifier(d, specifier, string, j2) {
    var i2 = 0, n = specifier.length, m2 = string.length, c3, parse2;
    while (i2 < n) {
      if (j2 >= m2) return -1;
      c3 = specifier.charCodeAt(i2++);
      if (c3 === 37) {
        c3 = specifier.charAt(i2++);
        parse2 = parses[c3 in pads ? specifier.charAt(i2++) : c3];
        if (!parse2 || (j2 = parse2(d, string, j2)) < 0) return -1;
      } else if (c3 != string.charCodeAt(j2++)) {
        return -1;
      }
    }
    return j2;
  }
  function parsePeriod(d, string, i2) {
    var n = periodRe.exec(string.slice(i2));
    return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i2 + n[0].length) : -1;
  }
  function parseShortWeekday(d, string, i2) {
    var n = shortWeekdayRe.exec(string.slice(i2));
    return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i2 + n[0].length) : -1;
  }
  function parseWeekday(d, string, i2) {
    var n = weekdayRe.exec(string.slice(i2));
    return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i2 + n[0].length) : -1;
  }
  function parseShortMonth(d, string, i2) {
    var n = shortMonthRe.exec(string.slice(i2));
    return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i2 + n[0].length) : -1;
  }
  function parseMonth(d, string, i2) {
    var n = monthRe.exec(string.slice(i2));
    return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i2 + n[0].length) : -1;
  }
  function parseLocaleDateTime(d, string, i2) {
    return parseSpecifier(d, locale_dateTime, string, i2);
  }
  function parseLocaleDate(d, string, i2) {
    return parseSpecifier(d, locale_date, string, i2);
  }
  function parseLocaleTime(d, string, i2) {
    return parseSpecifier(d, locale_time, string, i2);
  }
  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }
  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }
  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }
  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }
  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }
  function formatQuarter(d) {
    return 1 + ~~(d.getMonth() / 3);
  }
  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }
  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }
  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }
  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }
  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }
  function formatUTCQuarter(d) {
    return 1 + ~~(d.getUTCMonth() / 3);
  }
  return {
    format: function(specifier) {
      var f2 = newFormat(specifier += "", formats);
      f2.toString = function() {
        return specifier;
      };
      return f2;
    },
    parse: function(specifier) {
      var p2 = newParse(specifier += "", false);
      p2.toString = function() {
        return specifier;
      };
      return p2;
    },
    utcFormat: function(specifier) {
      var f2 = newFormat(specifier += "", utcFormats);
      f2.toString = function() {
        return specifier;
      };
      return f2;
    },
    utcParse: function(specifier) {
      var p2 = newParse(specifier += "", true);
      p2.toString = function() {
        return specifier;
      };
      return p2;
    }
  };
}
var pads = { "-": "", "_": " ", "0": "0" };
var numberRe = /^\s*\d+/;
var percentRe = /^%/;
var requoteRe = /[\\^$*+?|[\]().{}]/g;
function pad(value, fill, width2) {
  var sign2 = value < 0 ? "-" : "", string = (sign2 ? -value : value) + "", length2 = string.length;
  return sign2 + (length2 < width2 ? new Array(width2 - length2 + 1).join(fill) + string : string);
}
function requote(s3) {
  return s3.replace(requoteRe, "\\$&");
}
function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}
function formatLookup(names) {
  return new Map(names.map((name, i2) => [name.toLowerCase(), i2]));
}
function parseWeekdayNumberSunday(d, string, i2) {
  var n = numberRe.exec(string.slice(i2, i2 + 1));
  return n ? (d.w = +n[0], i2 + n[0].length) : -1;
}
function parseWeekdayNumberMonday(d, string, i2) {
  var n = numberRe.exec(string.slice(i2, i2 + 1));
  return n ? (d.u = +n[0], i2 + n[0].length) : -1;
}
function parseWeekNumberSunday(d, string, i2) {
  var n = numberRe.exec(string.slice(i2, i2 + 2));
  return n ? (d.U = +n[0], i2 + n[0].length) : -1;
}
function parseWeekNumberISO(d, string, i2) {
  var n = numberRe.exec(string.slice(i2, i2 + 2));
  return n ? (d.V = +n[0], i2 + n[0].length) : -1;
}
function parseWeekNumberMonday(d, string, i2) {
  var n = numberRe.exec(string.slice(i2, i2 + 2));
  return n ? (d.W = +n[0], i2 + n[0].length) : -1;
}
function parseFullYear(d, string, i2) {
  var n = numberRe.exec(string.slice(i2, i2 + 4));
  return n ? (d.y = +n[0], i2 + n[0].length) : -1;
}
function parseYear(d, string, i2) {
  var n = numberRe.exec(string.slice(i2, i2 + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2e3), i2 + n[0].length) : -1;
}
function parseZone(d, string, i2) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i2, i2 + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i2 + n[0].length) : -1;
}
function parseQuarter(d, string, i2) {
  var n = numberRe.exec(string.slice(i2, i2 + 1));
  return n ? (d.q = n[0] * 3 - 3, i2 + n[0].length) : -1;
}
function parseMonthNumber(d, string, i2) {
  var n = numberRe.exec(string.slice(i2, i2 + 2));
  return n ? (d.m = n[0] - 1, i2 + n[0].length) : -1;
}
function parseDayOfMonth(d, string, i2) {
  var n = numberRe.exec(string.slice(i2, i2 + 2));
  return n ? (d.d = +n[0], i2 + n[0].length) : -1;
}
function parseDayOfYear(d, string, i2) {
  var n = numberRe.exec(string.slice(i2, i2 + 3));
  return n ? (d.m = 0, d.d = +n[0], i2 + n[0].length) : -1;
}
function parseHour24(d, string, i2) {
  var n = numberRe.exec(string.slice(i2, i2 + 2));
  return n ? (d.H = +n[0], i2 + n[0].length) : -1;
}
function parseMinutes(d, string, i2) {
  var n = numberRe.exec(string.slice(i2, i2 + 2));
  return n ? (d.M = +n[0], i2 + n[0].length) : -1;
}
function parseSeconds(d, string, i2) {
  var n = numberRe.exec(string.slice(i2, i2 + 2));
  return n ? (d.S = +n[0], i2 + n[0].length) : -1;
}
function parseMilliseconds(d, string, i2) {
  var n = numberRe.exec(string.slice(i2, i2 + 3));
  return n ? (d.L = +n[0], i2 + n[0].length) : -1;
}
function parseMicroseconds(d, string, i2) {
  var n = numberRe.exec(string.slice(i2, i2 + 6));
  return n ? (d.L = Math.floor(n[0] / 1e3), i2 + n[0].length) : -1;
}
function parseLiteralPercent(d, string, i2) {
  var n = percentRe.exec(string.slice(i2, i2 + 1));
  return n ? i2 + n[0].length : -1;
}
function parseUnixTimestamp(d, string, i2) {
  var n = numberRe.exec(string.slice(i2));
  return n ? (d.Q = +n[0], i2 + n[0].length) : -1;
}
function parseUnixTimestampSeconds(d, string, i2) {
  var n = numberRe.exec(string.slice(i2));
  return n ? (d.s = +n[0], i2 + n[0].length) : -1;
}
function formatDayOfMonth(d, p2) {
  return pad(d.getDate(), p2, 2);
}
function formatHour24(d, p2) {
  return pad(d.getHours(), p2, 2);
}
function formatHour12(d, p2) {
  return pad(d.getHours() % 12 || 12, p2, 2);
}
function formatDayOfYear(d, p2) {
  return pad(1 + timeDay.count(timeYear(d), d), p2, 3);
}
function formatMilliseconds(d, p2) {
  return pad(d.getMilliseconds(), p2, 3);
}
function formatMicroseconds(d, p2) {
  return formatMilliseconds(d, p2) + "000";
}
function formatMonthNumber(d, p2) {
  return pad(d.getMonth() + 1, p2, 2);
}
function formatMinutes(d, p2) {
  return pad(d.getMinutes(), p2, 2);
}
function formatSeconds(d, p2) {
  return pad(d.getSeconds(), p2, 2);
}
function formatWeekdayNumberMonday(d) {
  var day = d.getDay();
  return day === 0 ? 7 : day;
}
function formatWeekNumberSunday(d, p2) {
  return pad(timeSunday.count(timeYear(d) - 1, d), p2, 2);
}
function dISO(d) {
  var day = d.getDay();
  return day >= 4 || day === 0 ? timeThursday(d) : timeThursday.ceil(d);
}
function formatWeekNumberISO(d, p2) {
  d = dISO(d);
  return pad(timeThursday.count(timeYear(d), d) + (timeYear(d).getDay() === 4), p2, 2);
}
function formatWeekdayNumberSunday(d) {
  return d.getDay();
}
function formatWeekNumberMonday(d, p2) {
  return pad(timeMonday.count(timeYear(d) - 1, d), p2, 2);
}
function formatYear(d, p2) {
  return pad(d.getFullYear() % 100, p2, 2);
}
function formatYearISO(d, p2) {
  d = dISO(d);
  return pad(d.getFullYear() % 100, p2, 2);
}
function formatFullYear(d, p2) {
  return pad(d.getFullYear() % 1e4, p2, 4);
}
function formatFullYearISO(d, p2) {
  var day = d.getDay();
  d = day >= 4 || day === 0 ? timeThursday(d) : timeThursday.ceil(d);
  return pad(d.getFullYear() % 1e4, p2, 4);
}
function formatZone(d) {
  var z2 = d.getTimezoneOffset();
  return (z2 > 0 ? "-" : (z2 *= -1, "+")) + pad(z2 / 60 | 0, "0", 2) + pad(z2 % 60, "0", 2);
}
function formatUTCDayOfMonth(d, p2) {
  return pad(d.getUTCDate(), p2, 2);
}
function formatUTCHour24(d, p2) {
  return pad(d.getUTCHours(), p2, 2);
}
function formatUTCHour12(d, p2) {
  return pad(d.getUTCHours() % 12 || 12, p2, 2);
}
function formatUTCDayOfYear(d, p2) {
  return pad(1 + utcDay.count(utcYear(d), d), p2, 3);
}
function formatUTCMilliseconds(d, p2) {
  return pad(d.getUTCMilliseconds(), p2, 3);
}
function formatUTCMicroseconds(d, p2) {
  return formatUTCMilliseconds(d, p2) + "000";
}
function formatUTCMonthNumber(d, p2) {
  return pad(d.getUTCMonth() + 1, p2, 2);
}
function formatUTCMinutes(d, p2) {
  return pad(d.getUTCMinutes(), p2, 2);
}
function formatUTCSeconds(d, p2) {
  return pad(d.getUTCSeconds(), p2, 2);
}
function formatUTCWeekdayNumberMonday(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}
function formatUTCWeekNumberSunday(d, p2) {
  return pad(utcSunday.count(utcYear(d) - 1, d), p2, 2);
}
function UTCdISO(d) {
  var day = d.getUTCDay();
  return day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);
}
function formatUTCWeekNumberISO(d, p2) {
  d = UTCdISO(d);
  return pad(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p2, 2);
}
function formatUTCWeekdayNumberSunday(d) {
  return d.getUTCDay();
}
function formatUTCWeekNumberMonday(d, p2) {
  return pad(utcMonday.count(utcYear(d) - 1, d), p2, 2);
}
function formatUTCYear(d, p2) {
  return pad(d.getUTCFullYear() % 100, p2, 2);
}
function formatUTCYearISO(d, p2) {
  d = UTCdISO(d);
  return pad(d.getUTCFullYear() % 100, p2, 2);
}
function formatUTCFullYear(d, p2) {
  return pad(d.getUTCFullYear() % 1e4, p2, 4);
}
function formatUTCFullYearISO(d, p2) {
  var day = d.getUTCDay();
  d = day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);
  return pad(d.getUTCFullYear() % 1e4, p2, 4);
}
function formatUTCZone() {
  return "+0000";
}
function formatLiteralPercent() {
  return "%";
}
function formatUnixTimestamp(d) {
  return +d;
}
function formatUnixTimestampSeconds(d) {
  return Math.floor(+d / 1e3);
}

// node_modules/d3-time-format/src/defaultLocale.js
var locale2;
var timeFormat;
var timeParse;
var utcFormat;
var utcParse;
defaultLocale2({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function defaultLocale2(definition) {
  locale2 = formatLocale(definition);
  timeFormat = locale2.format;
  timeParse = locale2.parse;
  utcFormat = locale2.utcFormat;
  utcParse = locale2.utcParse;
  return locale2;
}

// node_modules/d3-time-format/src/isoFormat.js
var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";
function formatIsoNative(date2) {
  return date2.toISOString();
}
var formatIso = Date.prototype.toISOString ? formatIsoNative : utcFormat(isoSpecifier);

// node_modules/d3-time-format/src/isoParse.js
function parseIsoNative(string) {
  var date2 = new Date(string);
  return isNaN(date2) ? null : date2;
}
var parseIso = +/* @__PURE__ */ new Date("2000-01-01T00:00:00.000Z") ? parseIsoNative : utcParse(isoSpecifier);

// node_modules/d3-scale/src/time.js
function date(t) {
  return new Date(t);
}
function number3(t) {
  return t instanceof Date ? +t : +/* @__PURE__ */ new Date(+t);
}
function calendar(ticks2, tickInterval, year, month, week, day, hour, minute, second2, format2) {
  var scale2 = continuous(), invert = scale2.invert, domain = scale2.domain;
  var formatMillisecond = format2(".%L"), formatSecond = format2(":%S"), formatMinute = format2("%I:%M"), formatHour = format2("%I %p"), formatDay = format2("%a %d"), formatWeek = format2("%b %d"), formatMonth = format2("%B"), formatYear2 = format2("%Y");
  function tickFormat2(date2) {
    return (second2(date2) < date2 ? formatMillisecond : minute(date2) < date2 ? formatSecond : hour(date2) < date2 ? formatMinute : day(date2) < date2 ? formatHour : month(date2) < date2 ? week(date2) < date2 ? formatDay : formatWeek : year(date2) < date2 ? formatMonth : formatYear2)(date2);
  }
  scale2.invert = function(y3) {
    return new Date(invert(y3));
  };
  scale2.domain = function(_2) {
    return arguments.length ? domain(Array.from(_2, number3)) : domain().map(date);
  };
  scale2.ticks = function(interval2) {
    var d = domain();
    return ticks2(d[0], d[d.length - 1], interval2 == null ? 10 : interval2);
  };
  scale2.tickFormat = function(count2, specifier) {
    return specifier == null ? tickFormat2 : format2(specifier);
  };
  scale2.nice = function(interval2) {
    var d = domain();
    if (!interval2 || typeof interval2.range !== "function") interval2 = tickInterval(d[0], d[d.length - 1], interval2 == null ? 10 : interval2);
    return interval2 ? domain(nice2(d, interval2)) : scale2;
  };
  scale2.copy = function() {
    return copy(scale2, calendar(ticks2, tickInterval, year, month, week, day, hour, minute, second2, format2));
  };
  return scale2;
}
function time() {
  return initRange.apply(calendar(timeTicks, timeTickInterval, timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute, second, timeFormat).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}

// node_modules/d3-scale/src/utcTime.js
function utcTime() {
  return initRange.apply(calendar(utcTicks, utcTickInterval, utcYear, utcMonth, utcSunday, utcDay, utcHour, utcMinute, second, utcFormat).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
}

// node_modules/d3-scale/src/sequential.js
function transformer2() {
  var x0 = 0, x1 = 1, t03, t13, k10, transform, interpolator = identity3, clamp2 = false, unknown;
  function scale2(x3) {
    return x3 == null || isNaN(x3 = +x3) ? unknown : interpolator(k10 === 0 ? 0.5 : (x3 = (transform(x3) - t03) * k10, clamp2 ? Math.max(0, Math.min(1, x3)) : x3));
  }
  scale2.domain = function(_2) {
    return arguments.length ? ([x0, x1] = _2, t03 = transform(x0 = +x0), t13 = transform(x1 = +x1), k10 = t03 === t13 ? 0 : 1 / (t13 - t03), scale2) : [x0, x1];
  };
  scale2.clamp = function(_2) {
    return arguments.length ? (clamp2 = !!_2, scale2) : clamp2;
  };
  scale2.interpolator = function(_2) {
    return arguments.length ? (interpolator = _2, scale2) : interpolator;
  };
  function range2(interpolate) {
    return function(_2) {
      var r0, r1;
      return arguments.length ? ([r0, r1] = _2, interpolator = interpolate(r0, r1), scale2) : [interpolator(0), interpolator(1)];
    };
  }
  scale2.range = range2(value_default);
  scale2.rangeRound = range2(round_default);
  scale2.unknown = function(_2) {
    return arguments.length ? (unknown = _2, scale2) : unknown;
  };
  return function(t) {
    transform = t, t03 = t(x0), t13 = t(x1), k10 = t03 === t13 ? 0 : 1 / (t13 - t03);
    return scale2;
  };
}
function copy2(source, target) {
  return target.domain(source.domain()).interpolator(source.interpolator()).clamp(source.clamp()).unknown(source.unknown());
}
function sequential() {
  var scale2 = linearish(transformer2()(identity3));
  scale2.copy = function() {
    return copy2(scale2, sequential());
  };
  return initInterpolator.apply(scale2, arguments);
}

// node_modules/@mui/x-charts/esm/models/axis.js
function isBandScaleConfig(scaleConfig) {
  return scaleConfig.scaleType === "band";
}
function isPointScaleConfig(scaleConfig) {
  return scaleConfig.scaleType === "point";
}

// node_modules/@mui/x-charts/esm/internals/colorScale.js
function getSequentialColorScale(config) {
  if (config.type === "piecewise") {
    return threshold(config.thresholds, config.colors);
  }
  return sequential([config.min ?? 0, config.max ?? 100], config.color);
}
function getOrdinalColorScale(config) {
  if (config.values) {
    return ordinal(config.values, config.colors).unknown(config.unknownColor ?? null);
  }
  return ordinal(config.colors.map((_2, index2) => index2), config.colors).unknown(config.unknownColor ?? null);
}
function getColorScale(config) {
  return config.type === "ordinal" ? getOrdinalColorScale(config) : getSequentialColorScale(config);
}

// node_modules/@mui/x-charts/esm/hooks/useTicks.js
var React9 = __toESM(require_react(), 1);

// node_modules/@mui/x-charts/esm/internals/isBandScale.js
function isBandScale(scale2) {
  return scale2.bandwidth !== void 0;
}

// node_modules/@mui/x-charts/esm/internals/isInfinity.js
function isInfinity(v3) {
  return typeof v3 === "number" && !Number.isFinite(v3);
}

// node_modules/@mui/x-charts/esm/hooks/useTicks.js
function getTickNumber(params) {
  const {
    tickMaxStep,
    tickMinStep,
    tickNumber,
    range: range2,
    domain
  } = params;
  const maxTicks = tickMinStep === void 0 ? 999 : Math.floor(Math.abs(domain[1] - domain[0]) / tickMinStep);
  const minTicks = tickMaxStep === void 0 ? 2 : Math.ceil(Math.abs(domain[1] - domain[0]) / tickMaxStep);
  const defaultizedTickNumber = tickNumber ?? Math.floor(Math.abs(range2[1] - range2[0]) / 50);
  return Math.min(maxTicks, Math.max(minTicks, defaultizedTickNumber));
}
var offsetRatio = {
  start: 0,
  extremities: 0,
  end: 1,
  middle: 0.5
};
function useTicks(options) {
  const {
    scale: scale2,
    tickNumber,
    valueFormatter,
    tickInterval,
    tickPlacement = "extremities",
    tickLabelPlacement: tickLabelPlacementProp
  } = options;
  return React9.useMemo(() => {
    if (isBandScale(scale2)) {
      const domain2 = scale2.domain();
      const tickLabelPlacement2 = tickLabelPlacementProp ?? "middle";
      if (scale2.bandwidth() > 0) {
        const filteredDomain2 = typeof tickInterval === "function" && domain2.filter(tickInterval) || typeof tickInterval === "object" && tickInterval || domain2;
        return [...filteredDomain2.map((value) => ({
          value,
          formattedValue: (valueFormatter == null ? void 0 : valueFormatter(value, {
            location: "tick",
            scale: scale2
          })) ?? `${value}`,
          offset: scale2(value) - (scale2.step() - scale2.bandwidth()) / 2 + offsetRatio[tickPlacement] * scale2.step(),
          labelOffset: tickLabelPlacement2 === "tick" ? 0 : scale2.step() * (offsetRatio[tickLabelPlacement2] - offsetRatio[tickPlacement])
        })), ...tickPlacement === "extremities" ? [{
          formattedValue: void 0,
          offset: scale2.range()[1],
          labelOffset: 0
        }] : []];
      }
      const filteredDomain = typeof tickInterval === "function" && domain2.filter(tickInterval) || typeof tickInterval === "object" && tickInterval || domain2;
      return filteredDomain.map((value) => ({
        value,
        formattedValue: (valueFormatter == null ? void 0 : valueFormatter(value, {
          location: "tick",
          scale: scale2
        })) ?? `${value}`,
        offset: scale2(value),
        labelOffset: 0
      }));
    }
    const domain = scale2.domain();
    if (domain.some(isInfinity)) {
      return [];
    }
    const tickLabelPlacement = tickLabelPlacementProp;
    const ticks2 = typeof tickInterval === "object" ? tickInterval : scale2.ticks(tickNumber);
    return ticks2.map((value, i2) => {
      return {
        value,
        formattedValue: (valueFormatter == null ? void 0 : valueFormatter(value, {
          location: "tick",
          scale: scale2
        })) ?? scale2.tickFormat(tickNumber)(value),
        offset: scale2(value),
        // Allowing the label to be placed in the middle of a continuous scale is weird.
        // But it is useful in some cases, like funnel categories with a linear scale.
        labelOffset: tickLabelPlacement === "middle" ? scale2(ticks2[i2 - 1] ?? 0) - (scale2(value) + scale2(ticks2[i2 - 1] ?? 0)) / 2 : 0
      };
    });
  }, [scale2, tickInterval, tickNumber, valueFormatter, tickPlacement, tickLabelPlacementProp]);
}

// node_modules/@mui/x-charts/esm/internals/getScale.js
function getScale(scaleType, domain, range2) {
  switch (scaleType) {
    case "log":
      return log(domain, range2);
    case "pow":
      return pow(domain, range2);
    case "sqrt":
      return sqrt(domain, range2);
    case "time":
      return time(domain, range2);
    case "utc":
      return utcTime(domain, range2);
    default:
      return linear2(domain, range2);
  }
}

// node_modules/@mui/x-charts/esm/internals/plugins/featurePlugins/useChartCartesianAxis/zoom.js
var zoomScaleRange = (scaleRange, zoomRange) => {
  const rangeGap = scaleRange[1] - scaleRange[0];
  const zoomGap = zoomRange[1] - zoomRange[0];
  const min4 = scaleRange[0] - zoomRange[0] * rangeGap / zoomGap;
  const max4 = scaleRange[1] + (100 - zoomRange[1]) * rangeGap / zoomGap;
  return [min4, max4];
};

// node_modules/@mui/x-charts/esm/internals/configInit.js
var cartesianInstance;
var polarInstance;
var CartesianSeriesTypes = class {
  constructor() {
    this.types = /* @__PURE__ */ new Set();
    if (cartesianInstance) {
      throw new Error("You can only create one instance!");
    }
    cartesianInstance = this.types;
  }
  addType(value) {
    this.types.add(value);
  }
  getTypes() {
    return this.types;
  }
};
var PolarSeriesTypes = class {
  constructor() {
    this.types = /* @__PURE__ */ new Set();
    if (polarInstance) {
      throw new Error("You can only create one instance!");
    }
    polarInstance = this.types;
  }
  addType(value) {
    this.types.add(value);
  }
  getTypes() {
    return this.types;
  }
};
var cartesianSeriesTypes = new CartesianSeriesTypes();
cartesianSeriesTypes.addType("bar");
cartesianSeriesTypes.addType("line");
cartesianSeriesTypes.addType("scatter");
var polarSeriesTypes = new PolarSeriesTypes();
polarSeriesTypes.addType("radar");

// node_modules/@mui/x-charts/esm/internals/isCartesian.js
function isCartesianSeriesType(seriesType) {
  return cartesianSeriesTypes.getTypes().has(seriesType);
}

// node_modules/@mui/x-charts/esm/internals/plugins/featurePlugins/useChartCartesianAxis/getAxisExtremum.js
var axisExtremumCallback = (acc, chartType, axis, axisDirection, seriesConfig5, axisIndex, formattedSeries, getFilters) => {
  var _a;
  const getter = axisDirection === "x" ? seriesConfig5[chartType].xExtremumGetter : seriesConfig5[chartType].yExtremumGetter;
  const series = ((_a = formattedSeries[chartType]) == null ? void 0 : _a.series) ?? {};
  const [minChartTypeData, maxChartTypeData] = (getter == null ? void 0 : getter({
    series,
    axis,
    axisIndex,
    isDefaultAxis: axisIndex === 0,
    getFilters
  })) ?? [Infinity, -Infinity];
  const [minData, maxData] = acc;
  return [Math.min(minChartTypeData, minData), Math.max(maxChartTypeData, maxData)];
};
var getAxisExtremum = (axis, axisDirection, seriesConfig5, axisIndex, formattedSeries, getFilters) => {
  const charTypes = Object.keys(seriesConfig5).filter(isCartesianSeriesType);
  const extremums = charTypes.reduce((acc, charType) => axisExtremumCallback(acc, charType, axis, axisDirection, seriesConfig5, axisIndex, formattedSeries, getFilters), [Infinity, -Infinity]);
  if (Number.isNaN(extremums[0]) || Number.isNaN(extremums[1])) {
    return [Infinity, -Infinity];
  }
  return extremums;
};

// node_modules/@mui/x-charts/esm/internals/plugins/featurePlugins/useChartCartesianAxis/getAxisTriggerTooltip.js
var getAxisTriggerTooltip = (axisDirection, seriesConfig5, formattedSeries, defaultAxisId) => {
  const tooltipAxesIds = /* @__PURE__ */ new Set();
  const chartTypes = Object.keys(seriesConfig5).filter(isCartesianSeriesType);
  chartTypes.forEach((chartType) => {
    var _a, _b, _c;
    const series = ((_a = formattedSeries[chartType]) == null ? void 0 : _a.series) ?? {};
    const tooltipAxes = (_c = (_b = seriesConfig5[chartType]).axisTooltipGetter) == null ? void 0 : _c.call(_b, series);
    if (tooltipAxes === void 0) {
      return;
    }
    tooltipAxes.forEach(({
      axisId,
      direction
    }) => {
      if (direction === axisDirection) {
        tooltipAxesIds.add(axisId ?? defaultAxisId);
      }
    });
  });
  return tooltipAxesIds;
};

// node_modules/@mui/x-charts/esm/internals/plugins/featurePlugins/useChartCartesianAxis/computeAxisValue.js
function getRange(drawingArea, axisDirection, axis) {
  const range2 = axisDirection === "x" ? [drawingArea.left, drawingArea.left + drawingArea.width] : [drawingArea.top + drawingArea.height, drawingArea.top];
  return axis.reverse ? [range2[1], range2[0]] : range2;
}
var isDateData = (data) => (data == null ? void 0 : data[0]) instanceof Date;
function createDateFormatter(axis, range2) {
  const timeScale = time(axis.data, range2);
  return (v3, {
    location
  }) => location === "tick" ? timeScale.tickFormat(axis.tickNumber)(v3) : `${v3.toLocaleString()}`;
}
var DEFAULT_CATEGORY_GAP_RATIO = 0.2;
var DEFAULT_BAR_GAP_RATIO = 0.1;
function computeAxisValue({
  drawingArea,
  formattedSeries,
  axis: allAxis,
  seriesConfig: seriesConfig5,
  axisDirection,
  zoomMap,
  zoomOptions,
  getFilters
}) {
  if (allAxis === void 0) {
    return {
      axis: {},
      axisIds: []
    };
  }
  const axisIdsTriggeringTooltip = getAxisTriggerTooltip(axisDirection, seriesConfig5, formattedSeries, allAxis[0].id);
  const completeAxis = {};
  allAxis.forEach((eachAxis, axisIndex) => {
    const axis = eachAxis;
    const zoomOption = zoomOptions == null ? void 0 : zoomOptions[axis.id];
    const zoom = zoomMap == null ? void 0 : zoomMap.get(axis.id);
    const zoomRange = zoom ? [zoom.start, zoom.end] : [0, 100];
    const range2 = getRange(drawingArea, axisDirection, axis);
    const [minData, maxData] = getAxisExtremum(
      axis,
      axisDirection,
      seriesConfig5,
      axisIndex,
      formattedSeries,
      zoom === void 0 && !zoomOption ? getFilters : void 0
      // Do not apply filtering if zoom is already defined.
    );
    const triggerTooltip = !axis.ignoreTooltip && axisIdsTriggeringTooltip.has(axis.id);
    const data = axis.data ?? [];
    if (isBandScaleConfig(axis)) {
      const categoryGapRatio = axis.categoryGapRatio ?? DEFAULT_CATEGORY_GAP_RATIO;
      const barGapRatio = axis.barGapRatio ?? DEFAULT_BAR_GAP_RATIO;
      const scaleRange = axisDirection === "y" ? [range2[1], range2[0]] : range2;
      const zoomedRange2 = zoomScaleRange(scaleRange, zoomRange);
      completeAxis[axis.id] = _extends({
        offset: 0,
        height: 0,
        categoryGapRatio,
        barGapRatio,
        triggerTooltip
      }, axis, {
        data,
        scale: band(axis.data, zoomedRange2).paddingInner(categoryGapRatio).paddingOuter(categoryGapRatio / 2),
        tickNumber: axis.data.length,
        colorScale: axis.colorMap && (axis.colorMap.type === "ordinal" ? getOrdinalColorScale(_extends({
          values: axis.data
        }, axis.colorMap)) : getColorScale(axis.colorMap))
      });
      if (isDateData(axis.data)) {
        const dateFormatter = createDateFormatter(axis, scaleRange);
        completeAxis[axis.id].valueFormatter = axis.valueFormatter ?? dateFormatter;
      }
    }
    if (isPointScaleConfig(axis)) {
      const scaleRange = axisDirection === "y" ? [...range2].reverse() : range2;
      const zoomedRange2 = zoomScaleRange(scaleRange, zoomRange);
      completeAxis[axis.id] = _extends({
        offset: 0,
        height: 0,
        triggerTooltip
      }, axis, {
        data,
        scale: point(axis.data, zoomedRange2),
        tickNumber: axis.data.length,
        colorScale: axis.colorMap && (axis.colorMap.type === "ordinal" ? getOrdinalColorScale(_extends({
          values: axis.data
        }, axis.colorMap)) : getColorScale(axis.colorMap))
      });
      if (isDateData(axis.data)) {
        const dateFormatter = createDateFormatter(axis, scaleRange);
        completeAxis[axis.id].valueFormatter = axis.valueFormatter ?? dateFormatter;
      }
    }
    if (axis.scaleType === "band" || axis.scaleType === "point") {
      return;
    }
    const scaleType = axis.scaleType ?? "linear";
    const domainLimit = axis.domainLimit ?? "nice";
    const axisExtremums = [axis.min ?? minData, axis.max ?? maxData];
    if (typeof domainLimit === "function") {
      const {
        min: min4,
        max: max4
      } = domainLimit(minData, maxData);
      axisExtremums[0] = min4;
      axisExtremums[1] = max4;
    }
    const rawTickNumber = getTickNumber(_extends({}, axis, {
      range: range2,
      domain: axisExtremums
    }));
    const tickNumber = rawTickNumber / ((zoomRange[1] - zoomRange[0]) / 100);
    const zoomedRange = zoomScaleRange(range2, zoomRange);
    const scale2 = getScale(scaleType, axisExtremums, zoomedRange);
    const finalScale = domainLimit === "nice" ? scale2.nice(rawTickNumber) : scale2;
    const [minDomain, maxDomain] = finalScale.domain();
    const domain = [axis.min ?? minDomain, axis.max ?? maxDomain];
    completeAxis[axis.id] = _extends({
      offset: 0,
      height: 0,
      triggerTooltip
    }, axis, {
      data,
      scaleType,
      scale: finalScale.domain(domain),
      tickNumber,
      colorScale: axis.colorMap && getColorScale(axis.colorMap)
    });
  });
  return {
    axis: completeAxis,
    axisIds: allAxis.map(({
      id
    }) => id)
  };
}

// node_modules/@mui/x-charts/esm/internals/isDefined.js
function isDefined(value) {
  return value !== null && value !== void 0;
}

// node_modules/@mui/x-charts/esm/internals/plugins/featurePlugins/useChartCartesianAxis/createAxisFilterMapper.js
function createAxisFilterMapper({
  zoomMap,
  zoomOptions,
  seriesConfig: seriesConfig5,
  formattedSeries,
  direction
}) {
  return (axis, axisIndex) => {
    var _a;
    const zoomOption = zoomOptions[axis.id];
    if (!zoomOption || zoomOption.filterMode !== "discard") {
      return null;
    }
    const zoom = zoomMap == null ? void 0 : zoomMap.get(axis.id);
    if (zoom === void 0 || zoom.start <= 0 && zoom.end >= 100) {
      return null;
    }
    let extremums = [];
    const scaleType = axis.scaleType;
    if (scaleType === "point" || scaleType === "band") {
      extremums = [0, (((_a = axis.data) == null ? void 0 : _a.length) ?? 1) - 1];
    } else {
      extremums = getAxisExtremum(axis, direction, seriesConfig5, axisIndex, formattedSeries);
    }
    let min4;
    let max4;
    const continuousScaleType = !scaleType || scaleType === "band" || scaleType === "point" ? "linear" : scaleType;
    [min4, max4] = getScale(continuousScaleType, extremums, [0, 100]).nice().domain();
    min4 = min4 instanceof Date ? min4.getTime() : min4;
    max4 = max4 instanceof Date ? max4.getTime() : max4;
    const minVal = min4 + zoom.start * (max4 - min4) / 100;
    const maxVal = min4 + zoom.end * (max4 - min4) / 100;
    return (value, dataIndex) => {
      var _a2;
      const val = value[direction] ?? ((_a2 = axis.data) == null ? void 0 : _a2[dataIndex]);
      if (val == null) {
        return true;
      }
      if (axis.scaleType === "point" || axis.scaleType === "band" || typeof val === "string") {
        return dataIndex >= minVal && dataIndex <= maxVal;
      }
      return val >= minVal && val <= maxVal;
    };
  };
}
var createGetAxisFilters = (filters) => ({
  currentAxisId,
  seriesXAxisId,
  seriesYAxisId,
  isDefaultAxis
}) => {
  return (value, dataIndex) => {
    var _a, _b;
    const axisId = currentAxisId === seriesXAxisId ? seriesYAxisId : seriesXAxisId;
    if (!axisId || isDefaultAxis) {
      return ((_b = (_a = Object.values(filters ?? {}))[0]) == null ? void 0 : _b.call(_a, value, dataIndex)) ?? true;
    }
    const data = [seriesYAxisId, seriesXAxisId].filter((id) => id !== currentAxisId).map((id) => filters[id ?? ""]).filter(isDefined);
    return data.every((f2) => f2(value, dataIndex));
  };
};

// node_modules/@mui/x-charts/esm/internals/plugins/featurePlugins/useChartCartesianAxis/createZoomLookup.js
var createZoomLookup = (axisDirection) => (axes = []) => axes.reduce((acc, v3) => {
  const {
    zoom,
    id: axisId
  } = v3;
  const defaultizedZoom = defaultizeZoom(zoom, axisId, axisDirection);
  if (defaultizedZoom) {
    acc[axisId] = defaultizedZoom;
  }
  return acc;
}, {});

// node_modules/@mui/x-charts/esm/internals/plugins/featurePlugins/useChartCartesianAxis/useChartCartesianAxisRendering.selectors.js
var createZoomMap = (zoom) => {
  const zoomItemMap = /* @__PURE__ */ new Map();
  zoom.forEach((zoomItem) => {
    zoomItemMap.set(zoomItem.axisId, zoomItem);
  });
  return zoomItemMap;
};
var selectorChartZoomState = (state) => state.zoom;
var selectorChartZoomIsInteracting = createSelector2(selectorChartZoomState, (zoom) => zoom == null ? void 0 : zoom.isInteracting);
var selectorChartZoomMap = createSelector2(selectorChartZoomState, (zoom) => (zoom == null ? void 0 : zoom.zoomData) && createZoomMap(zoom == null ? void 0 : zoom.zoomData));
var selectorChartXZoomOptionsLookup = createSelector2(selectorChartRawXAxis, createZoomLookup("x"));
var selectorChartYZoomOptionsLookup = createSelector2(selectorChartRawYAxis, createZoomLookup("y"));
var selectorChartZoomOptionsLookup = createSelector2([selectorChartXZoomOptionsLookup, selectorChartYZoomOptionsLookup], (xLookup, yLookup) => _extends({}, xLookup, yLookup));
var selectorChartAxisZoomOptionsLookup = createSelector2([selectorChartXZoomOptionsLookup, selectorChartYZoomOptionsLookup, (state, axisId) => axisId], (xLookup, yLookup, axisId) => xLookup[axisId] ?? yLookup[axisId]);
var selectorChartXFilter = createSelector2([selectorChartZoomMap, selectorChartZoomOptionsLookup, selectorChartSeriesConfig, selectorChartSeriesProcessed], (zoomMap, zoomOptions, seriesConfig5, formattedSeries) => zoomMap && zoomOptions && createAxisFilterMapper({
  zoomMap,
  zoomOptions,
  seriesConfig: seriesConfig5,
  formattedSeries,
  direction: "x"
}));
var selectorChartYFilter = createSelector2([selectorChartZoomMap, selectorChartZoomOptionsLookup, selectorChartSeriesConfig, selectorChartSeriesProcessed], (zoomMap, zoomOptions, seriesConfig5, formattedSeries) => zoomMap && zoomOptions && createAxisFilterMapper({
  zoomMap,
  zoomOptions,
  seriesConfig: seriesConfig5,
  formattedSeries,
  direction: "y"
}));
var selectorChartZoomAxisFilters = createSelector2([selectorChartXFilter, selectorChartYFilter, selectorChartRawXAxis, selectorChartRawYAxis], (xMapper, yMapper, xAxis, yAxis) => {
  if (xMapper === void 0 || yMapper === void 0) {
    return void 0;
  }
  const xFilters = xAxis == null ? void 0 : xAxis.reduce((acc, axis, index2) => {
    const filter3 = xMapper(axis, index2);
    if (filter3 !== null) {
      acc[axis.id] = filter3;
    }
    return acc;
  }, {});
  const yFilters = yAxis == null ? void 0 : yAxis.reduce((acc, axis, index2) => {
    const filter3 = yMapper(axis, index2);
    if (filter3 !== null) {
      acc[axis.id] = filter3;
    }
    return acc;
  }, {});
  if (Object.keys(xFilters ?? {}).length === 0 && Object.keys(yFilters ?? {}).length === 0) {
    return void 0;
  }
  return createGetAxisFilters(_extends({}, xFilters, yFilters));
});
var selectorChartXAxis = createSelector2([selectorChartRawXAxis, selectorChartDrawingArea, selectorChartSeriesProcessed, selectorChartSeriesConfig, selectorChartZoomMap, selectorChartZoomOptionsLookup, selectorChartZoomAxisFilters], (axis, drawingArea, formattedSeries, seriesConfig5, zoomMap, zoomOptions, getFilters) => computeAxisValue({
  drawingArea,
  formattedSeries,
  axis,
  seriesConfig: seriesConfig5,
  axisDirection: "x",
  zoomMap,
  zoomOptions,
  getFilters
}));
var selectorChartYAxis = createSelector2([selectorChartRawYAxis, selectorChartDrawingArea, selectorChartSeriesProcessed, selectorChartSeriesConfig, selectorChartZoomMap, selectorChartZoomOptionsLookup, selectorChartZoomAxisFilters], (axis, drawingArea, formattedSeries, seriesConfig5, zoomMap, zoomOptions, getFilters) => computeAxisValue({
  drawingArea,
  formattedSeries,
  axis,
  seriesConfig: seriesConfig5,
  axisDirection: "y",
  zoomMap,
  zoomOptions,
  getFilters
}));

// node_modules/@mui/x-charts/esm/internals/plugins/featurePlugins/useChartCartesianAxis/getAxisValue.js
function getAsANumber(value) {
  return value instanceof Date ? value.getTime() : value;
}
function getAxisIndex(axisConfig, pointerValue) {
  const {
    scale: scale2,
    data: axisData,
    reverse: reverse2
  } = axisConfig;
  if (!isBandScale(scale2)) {
    const value = scale2.invert(pointerValue);
    if (axisData === void 0) {
      return -1;
    }
    const valueAsNumber = getAsANumber(value);
    const closestIndex = axisData == null ? void 0 : axisData.findIndex((pointValue, index2) => {
      const v3 = getAsANumber(pointValue);
      if (v3 > valueAsNumber) {
        if (index2 === 0 || Math.abs(valueAsNumber - v3) <= Math.abs(valueAsNumber - getAsANumber(axisData[index2 - 1]))) {
          return true;
        }
      }
      if (v3 <= valueAsNumber) {
        if (index2 === axisData.length - 1 || Math.abs(getAsANumber(value) - v3) < Math.abs(getAsANumber(value) - getAsANumber(axisData[index2 + 1]))) {
          return true;
        }
      }
      return false;
    });
    return closestIndex;
  }
  const dataIndex = scale2.bandwidth() === 0 ? Math.floor((pointerValue - Math.min(...scale2.range()) + scale2.step() / 2) / scale2.step()) : Math.floor((pointerValue - Math.min(...scale2.range())) / scale2.step());
  if (dataIndex < 0 || dataIndex >= axisData.length) {
    return -1;
  }
  return reverse2 ? axisData.length - 1 - dataIndex : dataIndex;
}
function getAxisValue(axisConfig, pointerValue, dataIndex) {
  const {
    scale: scale2,
    data: axisData
  } = axisConfig;
  if (!isBandScale(scale2)) {
    const value = scale2.invert(pointerValue);
    if (dataIndex < 0) {
      return value;
    }
    return axisData[dataIndex];
  }
  if (dataIndex < 0 || dataIndex >= axisData.length) {
    return null;
  }
  return axisData[dataIndex];
}

// node_modules/@mui/x-charts/esm/internals/getSVGPoint.js
function getSVGPoint(svg, event) {
  const pt2 = svg.createSVGPoint();
  pt2.x = event.clientX;
  pt2.y = event.clientY;
  return pt2.matrixTransform(svg.getScreenCTM().inverse());
}

// node_modules/@mui/utils/esm/useEventCallback/useEventCallback.js
var React10 = __toESM(require_react(), 1);
function useEventCallback(fn2) {
  const ref = React10.useRef(fn2);
  useEnhancedEffect_default(() => {
    ref.current = fn2;
  });
  return React10.useRef((...args) => (
    // @ts-expect-error hide `this`
    (0, ref.current)(...args)
  )).current;
}
var useEventCallback_default = useEventCallback;

// node_modules/@mui/x-charts/esm/internals/plugins/featurePlugins/useChartInteraction/useChartInteraction.js
var useChartInteraction = ({
  store
}) => {
  const cleanInteraction = useEventCallback_default(() => {
    store.update((prev2) => {
      return _extends({}, prev2, {
        interaction: {
          pointer: null,
          item: null
        }
      });
    });
  });
  const removeItemInteraction = useEventCallback_default((itemToRemove) => {
    store.update((prev2) => {
      const prevItem = prev2.interaction.item;
      if (!itemToRemove) {
        return prevItem === null ? prev2 : _extends({}, prev2, {
          interaction: _extends({}, prev2.interaction, {
            item: null
          })
        });
      }
      if (prevItem === null || Object.keys(itemToRemove).some((key) => itemToRemove[key] !== prevItem[key])) {
        return prev2;
      }
      return _extends({}, prev2, {
        interaction: _extends({}, prev2.interaction, {
          item: null
        })
      });
    });
  });
  const setItemInteraction = useEventCallback_default((newItem) => {
    store.update((prev2) => _extends({}, prev2, {
      interaction: _extends({}, prev2.interaction, {
        item: newItem
      })
    }));
  });
  const setPointerCoordinate = useEventCallback_default((coordinate) => {
    store.update((prev2) => _extends({}, prev2, {
      interaction: _extends({}, prev2.interaction, {
        pointer: coordinate
      })
    }));
  });
  return {
    instance: {
      cleanInteraction,
      setItemInteraction,
      removeItemInteraction,
      setPointerCoordinate
    }
  };
};
useChartInteraction.getInitialState = () => ({
  interaction: {
    item: null,
    pointer: null
  }
});
useChartInteraction.params = {};

// node_modules/@mui/x-charts/esm/internals/plugins/featurePlugins/useChartInteraction/useChartInteraction.selectors.js
var selectInteraction = (state) => state.interaction;
var selectorChartsInteractionIsInitialized = createSelector2(selectInteraction, (interaction) => interaction !== void 0);
var selectorChartsInteractionItem = createSelector2(selectInteraction, (interaction) => (interaction == null ? void 0 : interaction.item) ?? null);
var selectorChartsInteractionPointer = createSelector2(selectInteraction, (interaction) => (interaction == null ? void 0 : interaction.pointer) ?? null);
var selectorChartsInteractionPointerX = createSelector2(selectorChartsInteractionPointer, (pointer) => pointer && pointer.x);
var selectorChartsInteractionPointerY = createSelector2(selectorChartsInteractionPointer, (pointer) => pointer && pointer.y);
var selectorChartsInteractionItemIsDefined = createSelector2(selectorChartsInteractionItem, (item) => item !== null);

// node_modules/@mui/x-charts/esm/internals/plugins/featurePlugins/useChartCartesianAxis/useChartCartesianAxis.js
var useChartCartesianAxis = ({
  params,
  store,
  seriesConfig: seriesConfig5,
  svgRef,
  instance
}) => {
  const {
    xAxis,
    yAxis,
    dataset
  } = params;
  if (true) {
    const ids = [...xAxis ?? [], ...yAxis ?? []].filter((axis) => axis.id).map((axis) => axis.id);
    const duplicates = new Set(ids.filter((id, index2) => ids.indexOf(id) !== index2));
    if (duplicates.size > 0) {
      warnOnce([`MUI X Charts: The following axis ids are duplicated: ${Array.from(duplicates).join(", ")}.`, `Please make sure that each axis has a unique id.`].join("\n"), "error");
    }
  }
  const drawingArea = useSelector(store, selectorChartDrawingArea);
  const processedSeries = useSelector(store, selectorChartSeriesProcessed);
  const isInteractionEnabled = useSelector(store, selectorChartsInteractionIsInitialized);
  const {
    axis: xAxisWithScale,
    axisIds: xAxisIds
  } = useSelector(store, selectorChartXAxis);
  const {
    axis: yAxisWithScale,
    axisIds: yAxisIds
  } = useSelector(store, selectorChartYAxis);
  const isFirstRender = React11.useRef(true);
  React11.useEffect(() => {
    if (isFirstRender.current) {
      isFirstRender.current = false;
      return;
    }
    store.update((prev2) => _extends({}, prev2, {
      cartesianAxis: _extends({}, prev2.cartesianAxis, {
        x: defaultizeXAxis(xAxis, dataset),
        y: defaultizeYAxis(yAxis, dataset)
      })
    }));
  }, [seriesConfig5, drawingArea, xAxis, yAxis, dataset, store]);
  const usedXAxis = xAxisIds[0];
  const usedYAxis = yAxisIds[0];
  React11.useEffect(() => {
    const element = svgRef.current;
    if (!isInteractionEnabled || element === null || params.disableAxisListener) {
      return () => {
      };
    }
    const handleOut = () => {
      var _a;
      (_a = instance.cleanInteraction) == null ? void 0 : _a.call(instance);
    };
    const handleMove = (event) => {
      var _a, _b;
      const target = "targetTouches" in event ? event.targetTouches[0] : event;
      const svgPoint = getSVGPoint(element, target);
      if (!instance.isPointInside(svgPoint, {
        targetElement: event.target
      })) {
        (_a = instance.cleanInteraction) == null ? void 0 : _a.call(instance);
        return;
      }
      (_b = instance.setPointerCoordinate) == null ? void 0 : _b.call(instance, svgPoint);
    };
    const handleDown = (event) => {
      const target = event.currentTarget;
      if (!target) {
        return;
      }
      if ("hasPointerCapture" in target && target.hasPointerCapture(event.pointerId)) {
        target.releasePointerCapture(event.pointerId);
      }
    };
    element.addEventListener("pointerdown", handleDown);
    element.addEventListener("pointermove", handleMove);
    element.addEventListener("pointercancel", handleOut);
    element.addEventListener("pointerleave", handleOut);
    return () => {
      element.removeEventListener("pointerdown", handleDown);
      element.removeEventListener("pointermove", handleMove);
      element.removeEventListener("pointercancel", handleOut);
      element.removeEventListener("pointerleave", handleOut);
    };
  }, [svgRef, store, xAxisWithScale, usedXAxis, yAxisWithScale, usedYAxis, instance, params.disableAxisListener, isInteractionEnabled]);
  React11.useEffect(() => {
    const element = svgRef.current;
    const onAxisClick = params.onAxisClick;
    if (element === null || !onAxisClick) {
      return () => {
      };
    }
    const handleMouseClick = (event) => {
      event.preventDefault();
      let dataIndex = null;
      let isXAxis = false;
      const svgPoint = getSVGPoint(element, event);
      const xIndex = getAxisIndex(xAxisWithScale[usedXAxis], svgPoint.x);
      isXAxis = xIndex !== -1;
      dataIndex = isXAxis ? xIndex : getAxisIndex(yAxisWithScale[usedYAxis], svgPoint.y);
      const USED_AXIS_ID = isXAxis ? xAxisIds[0] : yAxisIds[0];
      if (dataIndex == null || dataIndex === -1) {
        return;
      }
      const axisValue = (isXAxis ? xAxisWithScale : yAxisWithScale)[USED_AXIS_ID].data[dataIndex];
      const seriesValues = {};
      Object.keys(processedSeries).filter((seriesType) => ["bar", "line"].includes(seriesType)).forEach((seriesType) => {
        var _a;
        (_a = processedSeries[seriesType]) == null ? void 0 : _a.seriesOrder.forEach((seriesId) => {
          const seriesItem = processedSeries[seriesType].series[seriesId];
          const providedXAxisId = seriesItem.xAxisId;
          const providedYAxisId = seriesItem.yAxisId;
          const axisKey = isXAxis ? providedXAxisId : providedYAxisId;
          if (axisKey === void 0 || axisKey === USED_AXIS_ID) {
            seriesValues[seriesId] = seriesItem.data[dataIndex];
          }
        });
      });
      onAxisClick(event, {
        dataIndex,
        axisValue,
        seriesValues
      });
    };
    element.addEventListener("click", handleMouseClick);
    return () => {
      element.removeEventListener("click", handleMouseClick);
    };
  }, [params.onAxisClick, processedSeries, svgRef, xAxisWithScale, xAxisIds, yAxisWithScale, yAxisIds, usedXAxis, usedYAxis]);
  return {};
};
useChartCartesianAxis.params = {
  xAxis: true,
  yAxis: true,
  dataset: true,
  onAxisClick: true,
  disableAxisListener: true
};
useChartCartesianAxis.getDefaultizedParams = ({
  params
}) => {
  return _extends({}, params, {
    colors: params.colors ?? rainbowSurgePalette,
    theme: params.theme ?? "light",
    defaultizedXAxis: defaultizeXAxis(params.xAxis, params.dataset),
    defaultizedYAxis: defaultizeYAxis(params.yAxis, params.dataset)
  });
};
useChartCartesianAxis.getInitialState = (params) => ({
  cartesianAxis: {
    x: params.defaultizedXAxis,
    y: params.defaultizedYAxis
  }
});

// node_modules/@mui/x-internals/esm/isDeepEqual/isDeepEqual.js
function isDeepEqual(a3, b2) {
  if (a3 === b2) {
    return true;
  }
  if (a3 && b2 && typeof a3 === "object" && typeof b2 === "object") {
    if (a3.constructor !== b2.constructor) {
      return false;
    }
    if (Array.isArray(a3)) {
      const length3 = a3.length;
      if (length3 !== b2.length) {
        return false;
      }
      for (let i2 = 0; i2 < length3; i2 += 1) {
        if (!isDeepEqual(a3[i2], b2[i2])) {
          return false;
        }
      }
      return true;
    }
    if (a3 instanceof Map && b2 instanceof Map) {
      if (a3.size !== b2.size) {
        return false;
      }
      const entriesA = Array.from(a3.entries());
      for (let i2 = 0; i2 < entriesA.length; i2 += 1) {
        if (!b2.has(entriesA[i2][0])) {
          return false;
        }
      }
      for (let i2 = 0; i2 < entriesA.length; i2 += 1) {
        const entryA = entriesA[i2];
        if (!isDeepEqual(entryA[1], b2.get(entryA[0]))) {
          return false;
        }
      }
      return true;
    }
    if (a3 instanceof Set && b2 instanceof Set) {
      if (a3.size !== b2.size) {
        return false;
      }
      const entries = Array.from(a3.entries());
      for (let i2 = 0; i2 < entries.length; i2 += 1) {
        if (!b2.has(entries[i2][0])) {
          return false;
        }
      }
      return true;
    }
    if (ArrayBuffer.isView(a3) && ArrayBuffer.isView(b2)) {
      const length3 = a3.length;
      if (length3 !== b2.length) {
        return false;
      }
      for (let i2 = 0; i2 < length3; i2 += 1) {
        if (a3[i2] !== b2[i2]) {
          return false;
        }
      }
      return true;
    }
    if (a3.constructor === RegExp) {
      return a3.source === b2.source && a3.flags === b2.flags;
    }
    if (a3.valueOf !== Object.prototype.valueOf) {
      return a3.valueOf() === b2.valueOf();
    }
    if (a3.toString !== Object.prototype.toString) {
      return a3.toString() === b2.toString();
    }
    const keys = Object.keys(a3);
    const length2 = keys.length;
    if (length2 !== Object.keys(b2).length) {
      return false;
    }
    for (let i2 = 0; i2 < length2; i2 += 1) {
      if (!Object.prototype.hasOwnProperty.call(b2, keys[i2])) {
        return false;
      }
    }
    for (let i2 = 0; i2 < length2; i2 += 1) {
      const key = keys[i2];
      if (!isDeepEqual(a3[key], b2[key])) {
        return false;
      }
    }
    return true;
  }
  return a3 !== a3 && b2 !== b2;
}

// node_modules/@mui/x-charts/esm/internals/plugins/featurePlugins/useChartCartesianAxis/useChartCartesianInteraction.selectors.js
var optionalGetAxisId = (_2, id) => id;
function indexGetter(value, axes, ids = axes.axisIds[0]) {
  return Array.isArray(ids) ? ids.map((id) => getAxisIndex(axes.axis[id], value)) : getAxisIndex(axes.axis[ids], value);
}
var selectorChartsInteractionXAxisIndex = createSelector2([selectorChartsInteractionPointerX, selectorChartXAxis, optionalGetAxisId], (value, axes, id) => value === null ? null : indexGetter(value, axes, id));
var selectorChartsInteractionYAxisIndex = createSelector2([selectorChartsInteractionPointerY, selectorChartYAxis, optionalGetAxisId], (value, axes, id) => value === null ? null : indexGetter(value, axes, id));
function valueGetter(value, axes, indexes2, ids = axes.axisIds[0]) {
  return Array.isArray(ids) ? ids.map((id, axisIndex) => getAxisValue(axes.axis[id], value, indexes2[axisIndex])) : getAxisValue(axes.axis[ids], value, indexes2);
}
var selectorChartsInteractionXAxisValue = createSelector2([selectorChartsInteractionPointerX, selectorChartXAxis, selectorChartsInteractionXAxisIndex, optionalGetAxisId], (x3, xAxes, xIndex, id) => {
  if (x3 === null || xIndex === null || xAxes.axisIds.length === 0) {
    return null;
  }
  return valueGetter(x3, xAxes, xIndex, id);
});
var selectorChartsInteractionYAxisValue = createSelector2([selectorChartsInteractionPointerY, selectorChartYAxis, selectorChartsInteractionYAxisIndex, optionalGetAxisId], (y3, yAxes, yIndex, id) => {
  if (y3 === null || yIndex === null || yAxes.axisIds.length === 0) {
    return null;
  }
  return valueGetter(y3, yAxes, yIndex, id);
});
var selectorChartsInteractionTooltipXAxes = createSelector2([selectorChartsInteractionPointerX, selectorChartXAxis], (value, axes) => {
  if (value === null) {
    return [];
  }
  return axes.axisIds.filter((id) => axes.axis[id].triggerTooltip).map((axisId) => ({
    axisId,
    dataIndex: getAxisIndex(axes.axis[axisId], value)
  })).filter(({
    dataIndex
  }) => dataIndex >= 0);
}, {
  memoizeOptions: {
    // Keep the same reference if array content is the same.
    // If possible, avoid this pattern by creating selectors that
    // uses string/number as arguments.
    resultEqualityCheck: isDeepEqual
  }
});
var selectorChartsInteractionTooltipYAxes = createSelector2([selectorChartsInteractionPointerY, selectorChartYAxis], (value, axes) => {
  if (value === null) {
    return [];
  }
  return axes.axisIds.filter((id) => axes.axis[id].triggerTooltip).map((axisId) => ({
    axisId,
    dataIndex: getAxisIndex(axes.axis[axisId], value)
  })).filter(({
    dataIndex
  }) => dataIndex >= 0);
}, {
  memoizeOptions: {
    // Keep the same reference if array content is the same.
    // If possible, avoid this pattern by creating selectors that
    // uses string/number as arguments.
    resultEqualityCheck: isDeepEqual
  }
});
var selectorChartsInteractionAxisTooltip = createSelector2([selectorChartsInteractionTooltipXAxes, selectorChartsInteractionTooltipYAxes], (xTooltip, yTooltip) => xTooltip.length > 0 || yTooltip.length > 0);

// node_modules/@mui/x-charts/esm/internals/plugins/featurePlugins/useChartZAxis/useChartZAxis.js
var React12 = __toESM(require_react(), 1);
function addDefaultId(axisConfig, defaultId) {
  if (axisConfig.id !== void 0) {
    return axisConfig;
  }
  return _extends({
    id: defaultId
  }, axisConfig);
}
function processColorMap(axisConfig) {
  if (!axisConfig.colorMap) {
    return axisConfig;
  }
  return _extends({}, axisConfig, {
    colorScale: axisConfig.colorMap.type === "ordinal" && axisConfig.data ? getOrdinalColorScale(_extends({
      values: axisConfig.data
    }, axisConfig.colorMap)) : getColorScale(axisConfig.colorMap.type === "continuous" ? _extends({
      min: axisConfig.min,
      max: axisConfig.max
    }, axisConfig.colorMap) : axisConfig.colorMap)
  });
}
function getZAxisState(zAxis, dataset) {
  if (!zAxis || zAxis.length === 0) {
    return {
      axis: {},
      axisIds: []
    };
  }
  const zAxisLookup = {};
  const axisIds = [];
  zAxis.forEach((axisConfig, index2) => {
    const dataKey = axisConfig.dataKey;
    const defaultizedId = axisConfig.id ?? `defaultized-z-axis-${index2}`;
    if (dataKey === void 0 || axisConfig.data !== void 0) {
      zAxisLookup[defaultizedId] = processColorMap(addDefaultId(axisConfig, defaultizedId));
      axisIds.push(defaultizedId);
      return;
    }
    if (dataset === void 0) {
      throw new Error("MUI X Charts: z-axis uses `dataKey` but no `dataset` is provided.");
    }
    zAxisLookup[defaultizedId] = processColorMap(addDefaultId(_extends({}, axisConfig, {
      data: dataset.map((d) => d[dataKey])
    }), defaultizedId));
    axisIds.push(defaultizedId);
  });
  return {
    axis: zAxisLookup,
    axisIds
  };
}
var useChartZAxis = ({
  params,
  store
}) => {
  const {
    zAxis,
    dataset
  } = params;
  const isFirstRender = React12.useRef(true);
  React12.useEffect(() => {
    if (isFirstRender.current) {
      isFirstRender.current = false;
      return;
    }
    store.update((prev2) => _extends({}, prev2, {
      zAxis: getZAxisState(zAxis, dataset)
    }));
  }, [zAxis, dataset, store]);
  return {};
};
useChartZAxis.params = {
  zAxis: true,
  dataset: true
};
useChartZAxis.getInitialState = (params) => ({
  zAxis: getZAxisState(params.zAxis, params.dataset)
});

// node_modules/@mui/x-charts/esm/internals/plugins/featurePlugins/useChartZAxis/useChartZAxis.selectors.js
var selectRootState = (state) => state;
var selectorChartZAxis = createSelector2([selectRootState], (state) => state.zAxis);

// node_modules/@mui/x-internals/esm/useAssertModelConsistency/useAssertModelConsistency.js
var React13 = __toESM(require_react(), 1);
function useAssertModelConsistencyOutsideOfProduction(parameters) {
  const {
    componentName,
    propName,
    controlled,
    defaultValue,
    warningPrefix = "MUI X"
  } = parameters;
  const [{
    initialDefaultValue,
    isControlled
  }] = React13.useState({
    initialDefaultValue: defaultValue,
    isControlled: controlled !== void 0
  });
  if (isControlled !== (controlled !== void 0)) {
    warnOnce([`${warningPrefix}: A component is changing the ${isControlled ? "" : "un"}controlled ${propName} state of ${componentName} to be ${isControlled ? "un" : ""}controlled.`, "Elements should not switch from uncontrolled to controlled (or vice versa).", `Decide between using a controlled or uncontrolled ${propName} element for the lifetime of the component.`, "The nature of the state is determined during the first render. It's considered controlled if the value is not `undefined`.", "More info: https://fb.me/react-controlled-components"], "error");
  }
  if (JSON.stringify(initialDefaultValue) !== JSON.stringify(defaultValue)) {
    warnOnce([`${warningPrefix}: A component is changing the default ${propName} state of an uncontrolled ${componentName} after being initialized. To suppress this warning opt to use a controlled ${componentName}.`], "error");
  }
}
var useAssertModelConsistency = false ? () => {
} : useAssertModelConsistencyOutsideOfProduction;

// node_modules/@mui/x-charts/esm/internals/plugins/featurePlugins/useChartHighlight/useChartHighlight.js
var useChartHighlight = ({
  store,
  params
}) => {
  useAssertModelConsistency({
    warningPrefix: "MUI X Charts",
    componentName: "Chart",
    propName: "highlightedItem",
    controlled: params.highlightedItem,
    defaultValue: null
  });
  useEnhancedEffect_default(() => {
    store.update((prevState) => prevState.highlight.item === params.highlightedItem ? prevState : _extends({}, prevState, {
      highlight: _extends({}, prevState.highlight, {
        item: params.highlightedItem
      })
    }));
  }, [store, params.highlightedItem]);
  const clearHighlight = useEventCallback_default(() => {
    var _a;
    (_a = params.onHighlightChange) == null ? void 0 : _a.call(params, null);
    store.update((prev2) => _extends({}, prev2, {
      highlight: {
        item: null
      }
    }));
  });
  const setHighlight = useEventCallback_default((newItem) => {
    var _a;
    (_a = params.onHighlightChange) == null ? void 0 : _a.call(params, newItem);
    store.update((prev2) => _extends({}, prev2, {
      highlight: {
        item: newItem
      }
    }));
  });
  return {
    instance: {
      clearHighlight,
      setHighlight
    }
  };
};
useChartHighlight.getDefaultizedParams = ({
  params
}) => _extends({}, params, {
  highlightedItem: params.highlightedItem ?? null
});
useChartHighlight.getInitialState = (params) => ({
  highlight: {
    item: params.highlightedItem
  }
});
useChartHighlight.params = {
  highlightedItem: true,
  onHighlightChange: true
};

// node_modules/@mui/x-charts/esm/BarChart/seriesConfig/extremums.js
var createResult = (data, direction) => {
  if (direction === "x") {
    return {
      x: data,
      y: null
    };
  }
  return {
    x: null,
    y: data
  };
};
var getBaseExtremum = (params) => {
  var _a;
  const {
    axis,
    getFilters,
    isDefaultAxis
  } = params;
  const filter3 = getFilters == null ? void 0 : getFilters({
    currentAxisId: axis.id,
    isDefaultAxis
  });
  const data = filter3 ? (_a = axis.data) == null ? void 0 : _a.filter((_2, i2) => filter3({
    x: null,
    y: null
  }, i2)) : axis.data;
  const minX = Math.min(...data ?? []);
  const maxX = Math.max(...data ?? []);
  return [minX, maxX];
};
var getValueExtremum = (direction) => (params) => {
  const {
    series,
    axis,
    getFilters,
    isDefaultAxis
  } = params;
  return Object.keys(series).filter((seriesId) => {
    const axisId = direction === "x" ? series[seriesId].xAxisId : series[seriesId].yAxisId;
    return axisId === axis.id || isDefaultAxis && axisId === void 0;
  }).reduce((acc, seriesId) => {
    const {
      stackedData
    } = series[seriesId];
    const filter3 = getFilters == null ? void 0 : getFilters({
      currentAxisId: axis.id,
      isDefaultAxis,
      seriesXAxisId: series[seriesId].xAxisId,
      seriesYAxisId: series[seriesId].yAxisId
    });
    const [seriesMin, seriesMax] = (stackedData == null ? void 0 : stackedData.reduce((seriesAcc, values3, index2) => {
      if (filter3 && (!filter3(createResult(values3[0], direction), index2) || !filter3(createResult(values3[1], direction), index2))) {
        return seriesAcc;
      }
      return [Math.min(...values3, seriesAcc[0]), Math.max(...values3, seriesAcc[1])];
    }, [Infinity, -Infinity])) ?? [Infinity, -Infinity];
    return [Math.min(seriesMin, acc[0]), Math.max(seriesMax, acc[1])];
  }, [Infinity, -Infinity]);
};
var getExtremumX = (params) => {
  const isHorizontal = Object.keys(params.series).some((seriesId) => params.series[seriesId].layout === "horizontal");
  if (isHorizontal) {
    return getValueExtremum("x")(params);
  }
  return getBaseExtremum(params);
};
var getExtremumY = (params) => {
  const isHorizontal = Object.keys(params.series).some((seriesId) => params.series[seriesId].layout === "horizontal");
  if (isHorizontal) {
    return getBaseExtremum(params);
  }
  return getValueExtremum("y")(params);
};

// node_modules/d3-shape/src/constant.js
function constant_default2(x3) {
  return function constant2() {
    return x3;
  };
}

// node_modules/d3-shape/src/math.js
var abs = Math.abs;
var atan2 = Math.atan2;
var cos = Math.cos;
var max2 = Math.max;
var min2 = Math.min;
var sin = Math.sin;
var sqrt2 = Math.sqrt;
var epsilon = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var tau = 2 * pi;
function acos(x3) {
  return x3 > 1 ? 0 : x3 < -1 ? pi : Math.acos(x3);
}
function asin(x3) {
  return x3 >= 1 ? halfPi : x3 <= -1 ? -halfPi : Math.asin(x3);
}

// node_modules/d3-path/src/path.js
var pi2 = Math.PI;
var tau2 = 2 * pi2;
var epsilon3 = 1e-6;
var tauEpsilon = tau2 - epsilon3;
function append(strings) {
  this._ += strings[0];
  for (let i2 = 1, n = strings.length; i2 < n; ++i2) {
    this._ += arguments[i2] + strings[i2];
  }
}
function appendRound(digits) {
  let d = Math.floor(digits);
  if (!(d >= 0)) throw new Error(`invalid digits: ${digits}`);
  if (d > 15) return append;
  const k3 = 10 ** d;
  return function(strings) {
    this._ += strings[0];
    for (let i2 = 1, n = strings.length; i2 < n; ++i2) {
      this._ += Math.round(arguments[i2] * k3) / k3 + strings[i2];
    }
  };
}
var Path = class {
  constructor(digits) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null;
    this._ = "";
    this._append = digits == null ? append : appendRound(digits);
  }
  moveTo(x3, y3) {
    this._append`M${this._x0 = this._x1 = +x3},${this._y0 = this._y1 = +y3}`;
  }
  closePath() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._append`Z`;
    }
  }
  lineTo(x3, y3) {
    this._append`L${this._x1 = +x3},${this._y1 = +y3}`;
  }
  quadraticCurveTo(x1, y1, x3, y3) {
    this._append`Q${+x1},${+y1},${this._x1 = +x3},${this._y1 = +y3}`;
  }
  bezierCurveTo(x1, y1, x22, y22, x3, y3) {
    this._append`C${+x1},${+y1},${+x22},${+y22},${this._x1 = +x3},${this._y1 = +y3}`;
  }
  arcTo(x1, y1, x22, y22, r3) {
    x1 = +x1, y1 = +y1, x22 = +x22, y22 = +y22, r3 = +r3;
    if (r3 < 0) throw new Error(`negative radius: ${r3}`);
    let x0 = this._x1, y0 = this._y1, x21 = x22 - x1, y21 = y22 - y1, x01 = x0 - x1, y01 = y0 - y1, l01_2 = x01 * x01 + y01 * y01;
    if (this._x1 === null) {
      this._append`M${this._x1 = x1},${this._y1 = y1}`;
    } else if (!(l01_2 > epsilon3)) ;
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon3) || !r3) {
      this._append`L${this._x1 = x1},${this._y1 = y1}`;
    } else {
      let x20 = x22 - x0, y20 = y22 - y0, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l2 = r3 * Math.tan((pi2 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l2 / l01, t21 = l2 / l21;
      if (Math.abs(t01 - 1) > epsilon3) {
        this._append`L${x1 + t01 * x01},${y1 + t01 * y01}`;
      }
      this._append`A${r3},${r3},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x1 + t21 * x21},${this._y1 = y1 + t21 * y21}`;
    }
  }
  arc(x3, y3, r3, a0, a1, ccw) {
    x3 = +x3, y3 = +y3, r3 = +r3, ccw = !!ccw;
    if (r3 < 0) throw new Error(`negative radius: ${r3}`);
    let dx = r3 * Math.cos(a0), dy = r3 * Math.sin(a0), x0 = x3 + dx, y0 = y3 + dy, cw = 1 ^ ccw, da2 = ccw ? a0 - a1 : a1 - a0;
    if (this._x1 === null) {
      this._append`M${x0},${y0}`;
    } else if (Math.abs(this._x1 - x0) > epsilon3 || Math.abs(this._y1 - y0) > epsilon3) {
      this._append`L${x0},${y0}`;
    }
    if (!r3) return;
    if (da2 < 0) da2 = da2 % tau2 + tau2;
    if (da2 > tauEpsilon) {
      this._append`A${r3},${r3},0,1,${cw},${x3 - dx},${y3 - dy}A${r3},${r3},0,1,${cw},${this._x1 = x0},${this._y1 = y0}`;
    } else if (da2 > epsilon3) {
      this._append`A${r3},${r3},0,${+(da2 >= pi2)},${cw},${this._x1 = x3 + r3 * Math.cos(a1)},${this._y1 = y3 + r3 * Math.sin(a1)}`;
    }
  }
  rect(x3, y3, w2, h) {
    this._append`M${this._x0 = this._x1 = +x3},${this._y0 = this._y1 = +y3}h${w2 = +w2}v${+h}h${-w2}Z`;
  }
  toString() {
    return this._;
  }
};
function path() {
  return new Path();
}
path.prototype = Path.prototype;

// node_modules/d3-shape/src/path.js
function withPath(shape2) {
  let digits = 3;
  shape2.digits = function(_2) {
    if (!arguments.length) return digits;
    if (_2 == null) {
      digits = null;
    } else {
      const d = Math.floor(_2);
      if (!(d >= 0)) throw new RangeError(`invalid digits: ${_2}`);
      digits = d;
    }
    return shape2;
  };
  return () => new Path(digits);
}

// node_modules/d3-shape/src/arc.js
function arcInnerRadius(d) {
  return d.innerRadius;
}
function arcOuterRadius(d) {
  return d.outerRadius;
}
function arcStartAngle(d) {
  return d.startAngle;
}
function arcEndAngle(d) {
  return d.endAngle;
}
function arcPadAngle(d) {
  return d && d.padAngle;
}
function intersect(x0, y0, x1, y1, x22, y22, x3, y3) {
  var x10 = x1 - x0, y10 = y1 - y0, x32 = x3 - x22, y32 = y3 - y22, t = y32 * x10 - x32 * y10;
  if (t * t < epsilon) return;
  t = (x32 * (y0 - y22) - y32 * (x0 - x22)) / t;
  return [x0 + t * x10, y0 + t * y10];
}
function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
  var x01 = x0 - x1, y01 = y0 - y1, lo = (cw ? rc : -rc) / sqrt2(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x11 = x0 + ox, y11 = y0 + oy, x10 = x1 + ox, y10 = y1 + oy, x00 = (x11 + x10) / 2, y00 = (y11 + y10) / 2, dx = x10 - x11, dy = y10 - y11, d2 = dx * dx + dy * dy, r3 = r1 - rc, D4 = x11 * y10 - x10 * y11, d = (dy < 0 ? -1 : 1) * sqrt2(max2(0, r3 * r3 * d2 - D4 * D4)), cx0 = (D4 * dy - dx * d) / d2, cy0 = (-D4 * dx - dy * d) / d2, cx1 = (D4 * dy + dx * d) / d2, cy1 = (-D4 * dx + dy * d) / d2, dx0 = cx0 - x00, dy0 = cy0 - y00, dx1 = cx1 - x00, dy1 = cy1 - y00;
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;
  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r3 - 1),
    y11: cy0 * (r1 / r3 - 1)
  };
}
function arc_default() {
  var innerRadius = arcInnerRadius, outerRadius = arcOuterRadius, cornerRadius = constant_default2(0), padRadius = null, startAngle = arcStartAngle, endAngle = arcEndAngle, padAngle = arcPadAngle, context = null, path2 = withPath(arc);
  function arc() {
    var buffer, r3, r0 = +innerRadius.apply(this, arguments), r1 = +outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) - halfPi, a1 = endAngle.apply(this, arguments) - halfPi, da2 = abs(a1 - a0), cw = a1 > a0;
    if (!context) context = buffer = path2();
    if (r1 < r0) r3 = r1, r1 = r0, r0 = r3;
    if (!(r1 > epsilon)) context.moveTo(0, 0);
    else if (da2 > tau - epsilon) {
      context.moveTo(r1 * cos(a0), r1 * sin(a0));
      context.arc(0, 0, r1, a0, a1, !cw);
      if (r0 > epsilon) {
        context.moveTo(r0 * cos(a1), r0 * sin(a1));
        context.arc(0, 0, r0, a1, a0, cw);
      }
    } else {
      var a01 = a0, a11 = a1, a00 = a0, a10 = a1, da0 = da2, da1 = da2, ap = padAngle.apply(this, arguments) / 2, rp = ap > epsilon && (padRadius ? +padRadius.apply(this, arguments) : sqrt2(r0 * r0 + r1 * r1)), rc = min2(abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)), rc0 = rc, rc1 = rc, t03, t13;
      if (rp > epsilon) {
        var p0 = asin(rp / r0 * sin(ap)), p1 = asin(rp / r1 * sin(ap));
        if ((da0 -= p0 * 2) > epsilon) p0 *= cw ? 1 : -1, a00 += p0, a10 -= p0;
        else da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > epsilon) p1 *= cw ? 1 : -1, a01 += p1, a11 -= p1;
        else da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }
      var x01 = r1 * cos(a01), y01 = r1 * sin(a01), x10 = r0 * cos(a10), y10 = r0 * sin(a10);
      if (rc > epsilon) {
        var x11 = r1 * cos(a11), y11 = r1 * sin(a11), x00 = r0 * cos(a00), y00 = r0 * sin(a00), oc;
        if (da2 < pi) {
          if (oc = intersect(x01, y01, x00, y00, x11, y11, x10, y10)) {
            var ax = x01 - oc[0], ay = y01 - oc[1], bx = x11 - oc[0], by = y11 - oc[1], kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt2(ax * ax + ay * ay) * sqrt2(bx * bx + by * by))) / 2), lc = sqrt2(oc[0] * oc[0] + oc[1] * oc[1]);
            rc0 = min2(rc, (r0 - lc) / (kc - 1));
            rc1 = min2(rc, (r1 - lc) / (kc + 1));
          } else {
            rc0 = rc1 = 0;
          }
        }
      }
      if (!(da1 > epsilon)) context.moveTo(x01, y01);
      else if (rc1 > epsilon) {
        t03 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
        t13 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);
        context.moveTo(t03.cx + t03.x01, t03.cy + t03.y01);
        if (rc1 < rc) context.arc(t03.cx, t03.cy, rc1, atan2(t03.y01, t03.x01), atan2(t13.y01, t13.x01), !cw);
        else {
          context.arc(t03.cx, t03.cy, rc1, atan2(t03.y01, t03.x01), atan2(t03.y11, t03.x11), !cw);
          context.arc(0, 0, r1, atan2(t03.cy + t03.y11, t03.cx + t03.x11), atan2(t13.cy + t13.y11, t13.cx + t13.x11), !cw);
          context.arc(t13.cx, t13.cy, rc1, atan2(t13.y11, t13.x11), atan2(t13.y01, t13.x01), !cw);
        }
      } else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);
      if (!(r0 > epsilon) || !(da0 > epsilon)) context.lineTo(x10, y10);
      else if (rc0 > epsilon) {
        t03 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
        t13 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);
        context.lineTo(t03.cx + t03.x01, t03.cy + t03.y01);
        if (rc0 < rc) context.arc(t03.cx, t03.cy, rc0, atan2(t03.y01, t03.x01), atan2(t13.y01, t13.x01), !cw);
        else {
          context.arc(t03.cx, t03.cy, rc0, atan2(t03.y01, t03.x01), atan2(t03.y11, t03.x11), !cw);
          context.arc(0, 0, r0, atan2(t03.cy + t03.y11, t03.cx + t03.x11), atan2(t13.cy + t13.y11, t13.cx + t13.x11), cw);
          context.arc(t13.cx, t13.cy, rc0, atan2(t13.y11, t13.x11), atan2(t13.y01, t13.x01), !cw);
        }
      } else context.arc(0, 0, r0, a10, a00, cw);
    }
    context.closePath();
    if (buffer) return context = null, buffer + "" || null;
  }
  arc.centroid = function() {
    var r3 = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a3 = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi / 2;
    return [cos(a3) * r3, sin(a3) * r3];
  };
  arc.innerRadius = function(_2) {
    return arguments.length ? (innerRadius = typeof _2 === "function" ? _2 : constant_default2(+_2), arc) : innerRadius;
  };
  arc.outerRadius = function(_2) {
    return arguments.length ? (outerRadius = typeof _2 === "function" ? _2 : constant_default2(+_2), arc) : outerRadius;
  };
  arc.cornerRadius = function(_2) {
    return arguments.length ? (cornerRadius = typeof _2 === "function" ? _2 : constant_default2(+_2), arc) : cornerRadius;
  };
  arc.padRadius = function(_2) {
    return arguments.length ? (padRadius = _2 == null ? null : typeof _2 === "function" ? _2 : constant_default2(+_2), arc) : padRadius;
  };
  arc.startAngle = function(_2) {
    return arguments.length ? (startAngle = typeof _2 === "function" ? _2 : constant_default2(+_2), arc) : startAngle;
  };
  arc.endAngle = function(_2) {
    return arguments.length ? (endAngle = typeof _2 === "function" ? _2 : constant_default2(+_2), arc) : endAngle;
  };
  arc.padAngle = function(_2) {
    return arguments.length ? (padAngle = typeof _2 === "function" ? _2 : constant_default2(+_2), arc) : padAngle;
  };
  arc.context = function(_2) {
    return arguments.length ? (context = _2 == null ? null : _2, arc) : context;
  };
  return arc;
}

// node_modules/d3-shape/src/array.js
var slice2 = Array.prototype.slice;
function array_default2(x3) {
  return typeof x3 === "object" && "length" in x3 ? x3 : Array.from(x3);
}

// node_modules/d3-shape/src/curve/linear.js
function Linear(context) {
  this._context = context;
}
Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x3, y3) {
    x3 = +x3, y3 = +y3;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x3, y3) : this._context.moveTo(x3, y3);
        break;
      case 1:
        this._point = 2;
      // falls through
      default:
        this._context.lineTo(x3, y3);
        break;
    }
  }
};
function linear_default(context) {
  return new Linear(context);
}

// node_modules/d3-shape/src/point.js
function x(p2) {
  return p2[0];
}
function y(p2) {
  return p2[1];
}

// node_modules/d3-shape/src/line.js
function line_default(x3, y3) {
  var defined = constant_default2(true), context = null, curve = linear_default, output = null, path2 = withPath(line2);
  x3 = typeof x3 === "function" ? x3 : x3 === void 0 ? x : constant_default2(x3);
  y3 = typeof y3 === "function" ? y3 : y3 === void 0 ? y : constant_default2(y3);
  function line2(data) {
    var i2, n = (data = array_default2(data)).length, d, defined0 = false, buffer;
    if (context == null) output = curve(buffer = path2());
    for (i2 = 0; i2 <= n; ++i2) {
      if (!(i2 < n && defined(d = data[i2], i2, data)) === defined0) {
        if (defined0 = !defined0) output.lineStart();
        else output.lineEnd();
      }
      if (defined0) output.point(+x3(d, i2, data), +y3(d, i2, data));
    }
    if (buffer) return output = null, buffer + "" || null;
  }
  line2.x = function(_2) {
    return arguments.length ? (x3 = typeof _2 === "function" ? _2 : constant_default2(+_2), line2) : x3;
  };
  line2.y = function(_2) {
    return arguments.length ? (y3 = typeof _2 === "function" ? _2 : constant_default2(+_2), line2) : y3;
  };
  line2.defined = function(_2) {
    return arguments.length ? (defined = typeof _2 === "function" ? _2 : constant_default2(!!_2), line2) : defined;
  };
  line2.curve = function(_2) {
    return arguments.length ? (curve = _2, context != null && (output = curve(context)), line2) : curve;
  };
  line2.context = function(_2) {
    return arguments.length ? (_2 == null ? context = output = null : output = curve(context = _2), line2) : context;
  };
  return line2;
}

// node_modules/d3-shape/src/area.js
function area_default(x0, y0, y1) {
  var x1 = null, defined = constant_default2(true), context = null, curve = linear_default, output = null, path2 = withPath(area);
  x0 = typeof x0 === "function" ? x0 : x0 === void 0 ? x : constant_default2(+x0);
  y0 = typeof y0 === "function" ? y0 : y0 === void 0 ? constant_default2(0) : constant_default2(+y0);
  y1 = typeof y1 === "function" ? y1 : y1 === void 0 ? y : constant_default2(+y1);
  function area(data) {
    var i2, j2, k3, n = (data = array_default2(data)).length, d, defined0 = false, buffer, x0z = new Array(n), y0z = new Array(n);
    if (context == null) output = curve(buffer = path2());
    for (i2 = 0; i2 <= n; ++i2) {
      if (!(i2 < n && defined(d = data[i2], i2, data)) === defined0) {
        if (defined0 = !defined0) {
          j2 = i2;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k3 = i2 - 1; k3 >= j2; --k3) {
            output.point(x0z[k3], y0z[k3]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i2] = +x0(d, i2, data), y0z[i2] = +y0(d, i2, data);
        output.point(x1 ? +x1(d, i2, data) : x0z[i2], y1 ? +y1(d, i2, data) : y0z[i2]);
      }
    }
    if (buffer) return output = null, buffer + "" || null;
  }
  function arealine() {
    return line_default().defined(defined).curve(curve).context(context);
  }
  area.x = function(_2) {
    return arguments.length ? (x0 = typeof _2 === "function" ? _2 : constant_default2(+_2), x1 = null, area) : x0;
  };
  area.x0 = function(_2) {
    return arguments.length ? (x0 = typeof _2 === "function" ? _2 : constant_default2(+_2), area) : x0;
  };
  area.x1 = function(_2) {
    return arguments.length ? (x1 = _2 == null ? null : typeof _2 === "function" ? _2 : constant_default2(+_2), area) : x1;
  };
  area.y = function(_2) {
    return arguments.length ? (y0 = typeof _2 === "function" ? _2 : constant_default2(+_2), y1 = null, area) : y0;
  };
  area.y0 = function(_2) {
    return arguments.length ? (y0 = typeof _2 === "function" ? _2 : constant_default2(+_2), area) : y0;
  };
  area.y1 = function(_2) {
    return arguments.length ? (y1 = _2 == null ? null : typeof _2 === "function" ? _2 : constant_default2(+_2), area) : y1;
  };
  area.lineX0 = area.lineY0 = function() {
    return arealine().x(x0).y(y0);
  };
  area.lineY1 = function() {
    return arealine().x(x0).y(y1);
  };
  area.lineX1 = function() {
    return arealine().x(x1).y(y0);
  };
  area.defined = function(_2) {
    return arguments.length ? (defined = typeof _2 === "function" ? _2 : constant_default2(!!_2), area) : defined;
  };
  area.curve = function(_2) {
    return arguments.length ? (curve = _2, context != null && (output = curve(context)), area) : curve;
  };
  area.context = function(_2) {
    return arguments.length ? (_2 == null ? context = output = null : output = curve(context = _2), area) : context;
  };
  return area;
}

// node_modules/d3-shape/src/descending.js
function descending_default(a3, b2) {
  return b2 < a3 ? -1 : b2 > a3 ? 1 : b2 >= a3 ? 0 : NaN;
}

// node_modules/d3-shape/src/identity.js
function identity_default2(d) {
  return d;
}

// node_modules/d3-shape/src/pie.js
function pie_default() {
  var value = identity_default2, sortValues = descending_default, sort2 = null, startAngle = constant_default2(0), endAngle = constant_default2(tau), padAngle = constant_default2(0);
  function pie(data) {
    var i2, n = (data = array_default2(data)).length, j2, k3, sum4 = 0, index2 = new Array(n), arcs = new Array(n), a0 = +startAngle.apply(this, arguments), da2 = Math.min(tau, Math.max(-tau, endAngle.apply(this, arguments) - a0)), a1, p2 = Math.min(Math.abs(da2) / n, padAngle.apply(this, arguments)), pa = p2 * (da2 < 0 ? -1 : 1), v3;
    for (i2 = 0; i2 < n; ++i2) {
      if ((v3 = arcs[index2[i2] = i2] = +value(data[i2], i2, data)) > 0) {
        sum4 += v3;
      }
    }
    if (sortValues != null) index2.sort(function(i3, j3) {
      return sortValues(arcs[i3], arcs[j3]);
    });
    else if (sort2 != null) index2.sort(function(i3, j3) {
      return sort2(data[i3], data[j3]);
    });
    for (i2 = 0, k3 = sum4 ? (da2 - n * pa) / sum4 : 0; i2 < n; ++i2, a0 = a1) {
      j2 = index2[i2], v3 = arcs[j2], a1 = a0 + (v3 > 0 ? v3 * k3 : 0) + pa, arcs[j2] = {
        data: data[j2],
        index: i2,
        value: v3,
        startAngle: a0,
        endAngle: a1,
        padAngle: p2
      };
    }
    return arcs;
  }
  pie.value = function(_2) {
    return arguments.length ? (value = typeof _2 === "function" ? _2 : constant_default2(+_2), pie) : value;
  };
  pie.sortValues = function(_2) {
    return arguments.length ? (sortValues = _2, sort2 = null, pie) : sortValues;
  };
  pie.sort = function(_2) {
    return arguments.length ? (sort2 = _2, sortValues = null, pie) : sort2;
  };
  pie.startAngle = function(_2) {
    return arguments.length ? (startAngle = typeof _2 === "function" ? _2 : constant_default2(+_2), pie) : startAngle;
  };
  pie.endAngle = function(_2) {
    return arguments.length ? (endAngle = typeof _2 === "function" ? _2 : constant_default2(+_2), pie) : endAngle;
  };
  pie.padAngle = function(_2) {
    return arguments.length ? (padAngle = typeof _2 === "function" ? _2 : constant_default2(+_2), pie) : padAngle;
  };
  return pie;
}

// node_modules/d3-shape/src/curve/radial.js
var curveRadialLinear = curveRadial(linear_default);
function Radial(curve) {
  this._curve = curve;
}
Radial.prototype = {
  areaStart: function() {
    this._curve.areaStart();
  },
  areaEnd: function() {
    this._curve.areaEnd();
  },
  lineStart: function() {
    this._curve.lineStart();
  },
  lineEnd: function() {
    this._curve.lineEnd();
  },
  point: function(a3, r3) {
    this._curve.point(r3 * Math.sin(a3), r3 * -Math.cos(a3));
  }
};
function curveRadial(curve) {
  function radial2(context) {
    return new Radial(curve(context));
  }
  radial2._curve = curve;
  return radial2;
}

// node_modules/d3-shape/src/curve/bump.js
var Bump = class {
  constructor(context, x3) {
    this._context = context;
    this._x = x3;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  }
  point(x3, y3) {
    x3 = +x3, y3 = +y3;
    switch (this._point) {
      case 0: {
        this._point = 1;
        if (this._line) this._context.lineTo(x3, y3);
        else this._context.moveTo(x3, y3);
        break;
      }
      case 1:
        this._point = 2;
      // falls through
      default: {
        if (this._x) this._context.bezierCurveTo(this._x0 = (this._x0 + x3) / 2, this._y0, this._x0, y3, x3, y3);
        else this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + y3) / 2, x3, this._y0, x3, y3);
        break;
      }
    }
    this._x0 = x3, this._y0 = y3;
  }
};
function bumpX(context) {
  return new Bump(context, true);
}
function bumpY(context) {
  return new Bump(context, false);
}

// node_modules/d3-shape/src/symbol/asterisk.js
var sqrt3 = sqrt2(3);

// node_modules/d3-shape/src/symbol/circle.js
var circle_default = {
  draw(context, size) {
    const r3 = sqrt2(size / pi);
    context.moveTo(r3, 0);
    context.arc(0, 0, r3, 0, tau);
  }
};

// node_modules/d3-shape/src/symbol/cross.js
var cross_default = {
  draw(context, size) {
    const r3 = sqrt2(size / 5) / 2;
    context.moveTo(-3 * r3, -r3);
    context.lineTo(-r3, -r3);
    context.lineTo(-r3, -3 * r3);
    context.lineTo(r3, -3 * r3);
    context.lineTo(r3, -r3);
    context.lineTo(3 * r3, -r3);
    context.lineTo(3 * r3, r3);
    context.lineTo(r3, r3);
    context.lineTo(r3, 3 * r3);
    context.lineTo(-r3, 3 * r3);
    context.lineTo(-r3, r3);
    context.lineTo(-3 * r3, r3);
    context.closePath();
  }
};

// node_modules/d3-shape/src/symbol/diamond.js
var tan30 = sqrt2(1 / 3);
var tan30_2 = tan30 * 2;
var diamond_default = {
  draw(context, size) {
    const y3 = sqrt2(size / tan30_2);
    const x3 = y3 * tan30;
    context.moveTo(0, -y3);
    context.lineTo(x3, 0);
    context.lineTo(0, y3);
    context.lineTo(-x3, 0);
    context.closePath();
  }
};

// node_modules/d3-shape/src/symbol/square.js
var square_default = {
  draw(context, size) {
    const w2 = sqrt2(size);
    const x3 = -w2 / 2;
    context.rect(x3, x3, w2, w2);
  }
};

// node_modules/d3-shape/src/symbol/star.js
var ka = 0.8908130915292852;
var kr = sin(pi / 10) / sin(7 * pi / 10);
var kx = sin(tau / 10) * kr;
var ky = -cos(tau / 10) * kr;
var star_default = {
  draw(context, size) {
    const r3 = sqrt2(size * ka);
    const x3 = kx * r3;
    const y3 = ky * r3;
    context.moveTo(0, -r3);
    context.lineTo(x3, y3);
    for (let i2 = 1; i2 < 5; ++i2) {
      const a3 = tau * i2 / 5;
      const c3 = cos(a3);
      const s3 = sin(a3);
      context.lineTo(s3 * r3, -c3 * r3);
      context.lineTo(c3 * x3 - s3 * y3, s3 * x3 + c3 * y3);
    }
    context.closePath();
  }
};

// node_modules/d3-shape/src/symbol/triangle.js
var sqrt32 = sqrt2(3);
var triangle_default = {
  draw(context, size) {
    const y3 = -sqrt2(size / (sqrt32 * 3));
    context.moveTo(0, y3 * 2);
    context.lineTo(-sqrt32 * y3, -y3);
    context.lineTo(sqrt32 * y3, -y3);
    context.closePath();
  }
};

// node_modules/d3-shape/src/symbol/triangle2.js
var sqrt33 = sqrt2(3);

// node_modules/d3-shape/src/symbol/wye.js
var c = -0.5;
var s = sqrt2(3) / 2;
var k = 1 / sqrt2(12);
var a = (k / 2 + 1) * 3;
var wye_default = {
  draw(context, size) {
    const r3 = sqrt2(size / a);
    const x0 = r3 / 2, y0 = r3 * k;
    const x1 = x0, y1 = r3 * k + r3;
    const x22 = -x1, y22 = y1;
    context.moveTo(x0, y0);
    context.lineTo(x1, y1);
    context.lineTo(x22, y22);
    context.lineTo(c * x0 - s * y0, s * x0 + c * y0);
    context.lineTo(c * x1 - s * y1, s * x1 + c * y1);
    context.lineTo(c * x22 - s * y22, s * x22 + c * y22);
    context.lineTo(c * x0 + s * y0, c * y0 - s * x0);
    context.lineTo(c * x1 + s * y1, c * y1 - s * x1);
    context.lineTo(c * x22 + s * y22, c * y22 - s * x22);
    context.closePath();
  }
};

// node_modules/d3-shape/src/symbol.js
var symbolsFill = [
  circle_default,
  cross_default,
  diamond_default,
  square_default,
  star_default,
  triangle_default,
  wye_default
];
function Symbol2(type, size) {
  let context = null, path2 = withPath(symbol);
  type = typeof type === "function" ? type : constant_default2(type || circle_default);
  size = typeof size === "function" ? size : constant_default2(size === void 0 ? 64 : +size);
  function symbol() {
    let buffer;
    if (!context) context = buffer = path2();
    type.apply(this, arguments).draw(context, +size.apply(this, arguments));
    if (buffer) return context = null, buffer + "" || null;
  }
  symbol.type = function(_2) {
    return arguments.length ? (type = typeof _2 === "function" ? _2 : constant_default2(_2), symbol) : type;
  };
  symbol.size = function(_2) {
    return arguments.length ? (size = typeof _2 === "function" ? _2 : constant_default2(+_2), symbol) : size;
  };
  symbol.context = function(_2) {
    return arguments.length ? (context = _2 == null ? null : _2, symbol) : context;
  };
  return symbol;
}

// node_modules/d3-shape/src/noop.js
function noop_default() {
}

// node_modules/d3-shape/src/curve/basis.js
function point2(that, x3, y3) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x3) / 6,
    (that._y0 + 4 * that._y1 + y3) / 6
  );
}
function Basis(context) {
  this._context = context;
}
Basis.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        point2(this, this._x1, this._y1);
      // falls through
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x3, y3) {
    x3 = +x3, y3 = +y3;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x3, y3) : this._context.moveTo(x3, y3);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      // falls through
      default:
        point2(this, x3, y3);
        break;
    }
    this._x0 = this._x1, this._x1 = x3;
    this._y0 = this._y1, this._y1 = y3;
  }
};

// node_modules/d3-shape/src/curve/basisClosed.js
function BasisClosed(context) {
  this._context = context;
}
BasisClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2);
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(x3, y3) {
    x3 = +x3, y3 = +y3;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x2 = x3, this._y2 = y3;
        break;
      case 1:
        this._point = 2;
        this._x3 = x3, this._y3 = y3;
        break;
      case 2:
        this._point = 3;
        this._x4 = x3, this._y4 = y3;
        this._context.moveTo((this._x0 + 4 * this._x1 + x3) / 6, (this._y0 + 4 * this._y1 + y3) / 6);
        break;
      default:
        point2(this, x3, y3);
        break;
    }
    this._x0 = this._x1, this._x1 = x3;
    this._y0 = this._y1, this._y1 = y3;
  }
};

// node_modules/d3-shape/src/curve/basisOpen.js
function BasisOpen(context) {
  this._context = context;
}
BasisOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x3, y3) {
    x3 = +x3, y3 = +y3;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var x0 = (this._x0 + 4 * this._x1 + x3) / 6, y0 = (this._y0 + 4 * this._y1 + y3) / 6;
        this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0);
        break;
      case 3:
        this._point = 4;
      // falls through
      default:
        point2(this, x3, y3);
        break;
    }
    this._x0 = this._x1, this._x1 = x3;
    this._y0 = this._y1, this._y1 = y3;
  }
};

// node_modules/d3-shape/src/curve/bundle.js
function Bundle(context, beta) {
  this._basis = new Basis(context);
  this._beta = beta;
}
Bundle.prototype = {
  lineStart: function() {
    this._x = [];
    this._y = [];
    this._basis.lineStart();
  },
  lineEnd: function() {
    var x3 = this._x, y3 = this._y, j2 = x3.length - 1;
    if (j2 > 0) {
      var x0 = x3[0], y0 = y3[0], dx = x3[j2] - x0, dy = y3[j2] - y0, i2 = -1, t;
      while (++i2 <= j2) {
        t = i2 / j2;
        this._basis.point(
          this._beta * x3[i2] + (1 - this._beta) * (x0 + t * dx),
          this._beta * y3[i2] + (1 - this._beta) * (y0 + t * dy)
        );
      }
    }
    this._x = this._y = null;
    this._basis.lineEnd();
  },
  point: function(x3, y3) {
    this._x.push(+x3);
    this._y.push(+y3);
  }
};
var bundle_default = function custom(beta) {
  function bundle(context) {
    return beta === 1 ? new Basis(context) : new Bundle(context, beta);
  }
  bundle.beta = function(beta2) {
    return custom(+beta2);
  };
  return bundle;
}(0.85);

// node_modules/d3-shape/src/curve/cardinal.js
function point3(that, x3, y3) {
  that._context.bezierCurveTo(
    that._x1 + that._k * (that._x2 - that._x0),
    that._y1 + that._k * (that._y2 - that._y0),
    that._x2 + that._k * (that._x1 - x3),
    that._y2 + that._k * (that._y1 - y3),
    that._x2,
    that._y2
  );
}
function Cardinal(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
Cardinal.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        point3(this, this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x3, y3) {
    x3 = +x3, y3 = +y3;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x3, y3) : this._context.moveTo(x3, y3);
        break;
      case 1:
        this._point = 2;
        this._x1 = x3, this._y1 = y3;
        break;
      case 2:
        this._point = 3;
      // falls through
      default:
        point3(this, x3, y3);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x3;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y3;
  }
};
var cardinal_default = function custom2(tension) {
  function cardinal(context) {
    return new Cardinal(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom2(+tension2);
  };
  return cardinal;
}(0);

// node_modules/d3-shape/src/curve/cardinalClosed.js
function CardinalClosed(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
CardinalClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x3, y3) {
    x3 = +x3, y3 = +y3;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x3, this._y3 = y3;
        break;
      case 1:
        this._point = 2;
        this._context.moveTo(this._x4 = x3, this._y4 = y3);
        break;
      case 2:
        this._point = 3;
        this._x5 = x3, this._y5 = y3;
        break;
      default:
        point3(this, x3, y3);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x3;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y3;
  }
};
var cardinalClosed_default = function custom3(tension) {
  function cardinal(context) {
    return new CardinalClosed(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom3(+tension2);
  };
  return cardinal;
}(0);

// node_modules/d3-shape/src/curve/cardinalOpen.js
function CardinalOpen(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
CardinalOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x3, y3) {
    x3 = +x3, y3 = +y3;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      // falls through
      default:
        point3(this, x3, y3);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x3;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y3;
  }
};
var cardinalOpen_default = function custom4(tension) {
  function cardinal(context) {
    return new CardinalOpen(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom4(+tension2);
  };
  return cardinal;
}(0);

// node_modules/d3-shape/src/curve/catmullRom.js
function point4(that, x3, y3) {
  var x1 = that._x1, y1 = that._y1, x22 = that._x2, y22 = that._y2;
  if (that._l01_a > epsilon) {
    var a3 = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a, n = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x1 = (x1 * a3 - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
    y1 = (y1 * a3 - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
  }
  if (that._l23_a > epsilon) {
    var b2 = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a, m2 = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x22 = (x22 * b2 + that._x1 * that._l23_2a - x3 * that._l12_2a) / m2;
    y22 = (y22 * b2 + that._y1 * that._l23_2a - y3 * that._l12_2a) / m2;
  }
  that._context.bezierCurveTo(x1, y1, x22, y22, that._x2, that._y2);
}
function CatmullRom(context, alpha2) {
  this._context = context;
  this._alpha = alpha2;
}
CatmullRom.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x3, y3) {
    x3 = +x3, y3 = +y3;
    if (this._point) {
      var x23 = this._x2 - x3, y23 = this._y2 - y3;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x3, y3) : this._context.moveTo(x3, y3);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      // falls through
      default:
        point4(this, x3, y3);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x3;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y3;
  }
};
var catmullRom_default = function custom5(alpha2) {
  function catmullRom(context) {
    return alpha2 ? new CatmullRom(context, alpha2) : new Cardinal(context, 0);
  }
  catmullRom.alpha = function(alpha3) {
    return custom5(+alpha3);
  };
  return catmullRom;
}(0.5);

// node_modules/d3-shape/src/curve/catmullRomClosed.js
function CatmullRomClosed(context, alpha2) {
  this._context = context;
  this._alpha = alpha2;
}
CatmullRomClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x3, y3) {
    x3 = +x3, y3 = +y3;
    if (this._point) {
      var x23 = this._x2 - x3, y23 = this._y2 - y3;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x3, this._y3 = y3;
        break;
      case 1:
        this._point = 2;
        this._context.moveTo(this._x4 = x3, this._y4 = y3);
        break;
      case 2:
        this._point = 3;
        this._x5 = x3, this._y5 = y3;
        break;
      default:
        point4(this, x3, y3);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x3;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y3;
  }
};
var catmullRomClosed_default = function custom6(alpha2) {
  function catmullRom(context) {
    return alpha2 ? new CatmullRomClosed(context, alpha2) : new CardinalClosed(context, 0);
  }
  catmullRom.alpha = function(alpha3) {
    return custom6(+alpha3);
  };
  return catmullRom;
}(0.5);

// node_modules/d3-shape/src/curve/catmullRomOpen.js
function CatmullRomOpen(context, alpha2) {
  this._context = context;
  this._alpha = alpha2;
}
CatmullRomOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x3, y3) {
    x3 = +x3, y3 = +y3;
    if (this._point) {
      var x23 = this._x2 - x3, y23 = this._y2 - y3;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      // falls through
      default:
        point4(this, x3, y3);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x3;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y3;
  }
};
var catmullRomOpen_default = function custom7(alpha2) {
  function catmullRom(context) {
    return alpha2 ? new CatmullRomOpen(context, alpha2) : new CardinalOpen(context, 0);
  }
  catmullRom.alpha = function(alpha3) {
    return custom7(+alpha3);
  };
  return catmullRom;
}(0.5);

// node_modules/d3-shape/src/curve/linearClosed.js
function LinearClosed(context) {
  this._context = context;
}
LinearClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._point) this._context.closePath();
  },
  point: function(x3, y3) {
    x3 = +x3, y3 = +y3;
    if (this._point) this._context.lineTo(x3, y3);
    else this._point = 1, this._context.moveTo(x3, y3);
  }
};

// node_modules/d3-shape/src/curve/monotone.js
function sign(x3) {
  return x3 < 0 ? -1 : 1;
}
function slope3(that, x22, y22) {
  var h0 = that._x1 - that._x0, h1 = x22 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y22 - that._y1) / (h1 || h0 < 0 && -0), p2 = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p2)) || 0;
}
function slope2(that, t) {
  var h = that._x1 - that._x0;
  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
}
function point5(that, t03, t13) {
  var x0 = that._x0, y0 = that._y0, x1 = that._x1, y1 = that._y1, dx = (x1 - x0) / 3;
  that._context.bezierCurveTo(x0 + dx, y0 + dx * t03, x1 - dx, y1 - dx * t13, x1, y1);
}
function MonotoneX(context) {
  this._context = context;
}
MonotoneX.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        point5(this, this._t0, slope2(this, this._t0));
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x3, y3) {
    var t13 = NaN;
    x3 = +x3, y3 = +y3;
    if (x3 === this._x1 && y3 === this._y1) return;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x3, y3) : this._context.moveTo(x3, y3);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        point5(this, slope2(this, t13 = slope3(this, x3, y3)), t13);
        break;
      default:
        point5(this, this._t0, t13 = slope3(this, x3, y3));
        break;
    }
    this._x0 = this._x1, this._x1 = x3;
    this._y0 = this._y1, this._y1 = y3;
    this._t0 = t13;
  }
};
function MonotoneY(context) {
  this._context = new ReflectContext(context);
}
(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x3, y3) {
  MonotoneX.prototype.point.call(this, y3, x3);
};
function ReflectContext(context) {
  this._context = context;
}
ReflectContext.prototype = {
  moveTo: function(x3, y3) {
    this._context.moveTo(y3, x3);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(x3, y3) {
    this._context.lineTo(y3, x3);
  },
  bezierCurveTo: function(x1, y1, x22, y22, x3, y3) {
    this._context.bezierCurveTo(y1, x1, y22, x22, y3, x3);
  }
};
function monotoneX(context) {
  return new MonotoneX(context);
}
function monotoneY(context) {
  return new MonotoneY(context);
}

// node_modules/d3-shape/src/curve/natural.js
function Natural(context) {
  this._context = context;
}
Natural.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function() {
    var x3 = this._x, y3 = this._y, n = x3.length;
    if (n) {
      this._line ? this._context.lineTo(x3[0], y3[0]) : this._context.moveTo(x3[0], y3[0]);
      if (n === 2) {
        this._context.lineTo(x3[1], y3[1]);
      } else {
        var px = controlPoints(x3), py = controlPoints(y3);
        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x3[i1], y3[i1]);
        }
      }
    }
    if (this._line || this._line !== 0 && n === 1) this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function(x3, y3) {
    this._x.push(+x3);
    this._y.push(+y3);
  }
};
function controlPoints(x3) {
  var i2, n = x3.length - 1, m2, a3 = new Array(n), b2 = new Array(n), r3 = new Array(n);
  a3[0] = 0, b2[0] = 2, r3[0] = x3[0] + 2 * x3[1];
  for (i2 = 1; i2 < n - 1; ++i2) a3[i2] = 1, b2[i2] = 4, r3[i2] = 4 * x3[i2] + 2 * x3[i2 + 1];
  a3[n - 1] = 2, b2[n - 1] = 7, r3[n - 1] = 8 * x3[n - 1] + x3[n];
  for (i2 = 1; i2 < n; ++i2) m2 = a3[i2] / b2[i2 - 1], b2[i2] -= m2, r3[i2] -= m2 * r3[i2 - 1];
  a3[n - 1] = r3[n - 1] / b2[n - 1];
  for (i2 = n - 2; i2 >= 0; --i2) a3[i2] = (r3[i2] - a3[i2 + 1]) / b2[i2];
  b2[n - 1] = (x3[n] + a3[n - 1]) / 2;
  for (i2 = 0; i2 < n - 1; ++i2) b2[i2] = 2 * x3[i2 + 1] - a3[i2 + 1];
  return [a3, b2];
}
function natural_default(context) {
  return new Natural(context);
}

// node_modules/d3-shape/src/curve/step.js
function Step(context, t) {
  this._context = context;
  this._t = t;
}
Step.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function(x3, y3) {
    x3 = +x3, y3 = +y3;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x3, y3) : this._context.moveTo(x3, y3);
        break;
      case 1:
        this._point = 2;
      // falls through
      default: {
        if (this._t <= 0) {
          this._context.lineTo(this._x, y3);
          this._context.lineTo(x3, y3);
        } else {
          var x1 = this._x * (1 - this._t) + x3 * this._t;
          this._context.lineTo(x1, this._y);
          this._context.lineTo(x1, y3);
        }
        break;
      }
    }
    this._x = x3, this._y = y3;
  }
};
function step_default(context) {
  return new Step(context, 0.5);
}
function stepBefore(context) {
  return new Step(context, 0);
}
function stepAfter(context) {
  return new Step(context, 1);
}

// node_modules/d3-shape/src/offset/none.js
function none_default(series, order3) {
  if (!((n = series.length) > 1)) return;
  for (var i2 = 1, j2, s0, s1 = series[order3[0]], n, m2 = s1.length; i2 < n; ++i2) {
    s0 = s1, s1 = series[order3[i2]];
    for (j2 = 0; j2 < m2; ++j2) {
      s1[j2][1] += s1[j2][0] = isNaN(s0[j2][1]) ? s0[j2][0] : s0[j2][1];
    }
  }
}

// node_modules/d3-shape/src/order/none.js
function none_default2(series) {
  var n = series.length, o2 = new Array(n);
  while (--n >= 0) o2[n] = n;
  return o2;
}

// node_modules/d3-shape/src/stack.js
function stackValue(d, key) {
  return d[key];
}
function stackSeries(key) {
  const series = [];
  series.key = key;
  return series;
}
function stack_default() {
  var keys = constant_default2([]), order3 = none_default2, offset2 = none_default, value = stackValue;
  function stack(data) {
    var sz = Array.from(keys.apply(this, arguments), stackSeries), i2, n = sz.length, j2 = -1, oz;
    for (const d of data) {
      for (i2 = 0, ++j2; i2 < n; ++i2) {
        (sz[i2][j2] = [0, +value(d, sz[i2].key, j2, data)]).data = d;
      }
    }
    for (i2 = 0, oz = array_default2(order3(sz)); i2 < n; ++i2) {
      sz[oz[i2]].index = i2;
    }
    offset2(sz, oz);
    return sz;
  }
  stack.keys = function(_2) {
    return arguments.length ? (keys = typeof _2 === "function" ? _2 : constant_default2(Array.from(_2)), stack) : keys;
  };
  stack.value = function(_2) {
    return arguments.length ? (value = typeof _2 === "function" ? _2 : constant_default2(+_2), stack) : value;
  };
  stack.order = function(_2) {
    return arguments.length ? (order3 = _2 == null ? none_default2 : typeof _2 === "function" ? _2 : constant_default2(Array.from(_2)), stack) : order3;
  };
  stack.offset = function(_2) {
    return arguments.length ? (offset2 = _2 == null ? none_default : _2, stack) : offset2;
  };
  return stack;
}

// node_modules/d3-shape/src/offset/expand.js
function expand_default(series, order3) {
  if (!((n = series.length) > 0)) return;
  for (var i2, n, j2 = 0, m2 = series[0].length, y3; j2 < m2; ++j2) {
    for (y3 = i2 = 0; i2 < n; ++i2) y3 += series[i2][j2][1] || 0;
    if (y3) for (i2 = 0; i2 < n; ++i2) series[i2][j2][1] /= y3;
  }
  none_default(series, order3);
}

// node_modules/d3-shape/src/offset/diverging.js
function diverging_default(series, order3) {
  if (!((n = series.length) > 0)) return;
  for (var i2, j2 = 0, d, dy, yp, yn, n, m2 = series[order3[0]].length; j2 < m2; ++j2) {
    for (yp = yn = 0, i2 = 0; i2 < n; ++i2) {
      if ((dy = (d = series[order3[i2]][j2])[1] - d[0]) > 0) {
        d[0] = yp, d[1] = yp += dy;
      } else if (dy < 0) {
        d[1] = yn, d[0] = yn += dy;
      } else {
        d[0] = 0, d[1] = dy;
      }
    }
  }
}

// node_modules/d3-shape/src/offset/silhouette.js
function silhouette_default(series, order3) {
  if (!((n = series.length) > 0)) return;
  for (var j2 = 0, s0 = series[order3[0]], n, m2 = s0.length; j2 < m2; ++j2) {
    for (var i2 = 0, y3 = 0; i2 < n; ++i2) y3 += series[i2][j2][1] || 0;
    s0[j2][1] += s0[j2][0] = -y3 / 2;
  }
  none_default(series, order3);
}

// node_modules/d3-shape/src/offset/wiggle.js
function wiggle_default(series, order3) {
  if (!((n = series.length) > 0) || !((m2 = (s0 = series[order3[0]]).length) > 0)) return;
  for (var y3 = 0, j2 = 1, s0, m2, n; j2 < m2; ++j2) {
    for (var i2 = 0, s1 = 0, s22 = 0; i2 < n; ++i2) {
      var si = series[order3[i2]], sij0 = si[j2][1] || 0, sij1 = si[j2 - 1][1] || 0, s3 = (sij0 - sij1) / 2;
      for (var k3 = 0; k3 < i2; ++k3) {
        var sk = series[order3[k3]], skj0 = sk[j2][1] || 0, skj1 = sk[j2 - 1][1] || 0;
        s3 += skj0 - skj1;
      }
      s1 += sij0, s22 += s3 * sij0;
    }
    s0[j2 - 1][1] += s0[j2 - 1][0] = y3;
    if (s1) y3 -= s22 / s1;
  }
  s0[j2 - 1][1] += s0[j2 - 1][0] = y3;
  none_default(series, order3);
}

// node_modules/d3-shape/src/order/appearance.js
function appearance_default(series) {
  var peaks = series.map(peak);
  return none_default2(series).sort(function(a3, b2) {
    return peaks[a3] - peaks[b2];
  });
}
function peak(series) {
  var i2 = -1, j2 = 0, n = series.length, vi, vj = -Infinity;
  while (++i2 < n) if ((vi = +series[i2][1]) > vj) vj = vi, j2 = i2;
  return j2;
}

// node_modules/d3-shape/src/order/ascending.js
function ascending_default(series) {
  var sums = series.map(sum2);
  return none_default2(series).sort(function(a3, b2) {
    return sums[a3] - sums[b2];
  });
}
function sum2(series) {
  var s3 = 0, i2 = -1, n = series.length, v3;
  while (++i2 < n) if (v3 = +series[i2][1]) s3 += v3;
  return s3;
}

// node_modules/d3-shape/src/order/descending.js
function descending_default2(series) {
  return ascending_default(series).reverse();
}

// node_modules/d3-shape/src/order/insideOut.js
function insideOut_default(series) {
  var n = series.length, i2, j2, sums = series.map(sum2), order3 = appearance_default(series), top3 = 0, bottom3 = 0, tops = [], bottoms = [];
  for (i2 = 0; i2 < n; ++i2) {
    j2 = order3[i2];
    if (top3 < bottom3) {
      top3 += sums[j2];
      tops.push(j2);
    } else {
      bottom3 += sums[j2];
      bottoms.push(j2);
    }
  }
  return bottoms.reverse().concat(tops);
}

// node_modules/d3-shape/src/order/reverse.js
function reverse_default(series) {
  return none_default2(series).reverse();
}

// node_modules/@mui/x-charts/esm/internals/stackSeries.js
var StackOrder = {
  /**
   * Series order such that the earliest series (according to the maximum value) is at the bottom.
   * */
  appearance: appearance_default,
  /**
   *  Series order such that the smallest series (according to the sum of values) is at the bottom.
   * */
  ascending: ascending_default,
  /**
   * Series order such that the largest series (according to the sum of values) is at the bottom.
   */
  descending: descending_default2,
  /**
   * Series order such that the earliest series (according to the maximum value) are on the inside and the later series are on the outside. This order is recommended for streamgraphs in conjunction with the wiggle offset. See Stacked GraphsGeometry & Aesthetics by Byron & Wattenberg for more information.
   */
  insideOut: insideOut_default,
  /**
   * Given series order [0, 1,  n - 1] where n is the number of elements in series. Thus, the stack order is given by the key accessor.
   */
  none: none_default2,
  /**
   * Reverse of the given series order [n - 1, n - 2,  0] where n is the number of elements in series. Thus, the stack order is given by the reverse of the key accessor.
   */
  reverse: reverse_default
};
var StackOffset = {
  /**
   * Applies a zero baseline and normalizes the values for each point such that the topline is always one.
   * */
  expand: expand_default,
  /**
   * Positive values are stacked above zero, negative values are stacked below zero, and zero values are stacked at zero.
   * */
  diverging: diverging_default,
  /**
   * Applies a zero baseline.
   * */
  none: none_default,
  /**
   * Shifts the baseline down such that the center of the streamgraph is always at zero.
   * */
  silhouette: silhouette_default,
  /**
   * Shifts the baseline so as to minimize the weighted wiggle of layers. This offset is recommended for streamgraphs in conjunction with the inside-out order. See Stacked GraphsGeometry & Aesthetics by Bryon & Wattenberg for more information.
   * */
  wiggle: wiggle_default
};
var getStackingGroups = (params) => {
  const {
    series,
    seriesOrder,
    defaultStrategy
  } = params;
  const stackingGroups = [];
  const stackIndex = {};
  seriesOrder.forEach((id) => {
    const {
      stack,
      stackOrder,
      stackOffset
    } = series[id];
    if (stack === void 0) {
      stackingGroups.push({
        ids: [id],
        stackingOrder: StackOrder.none,
        stackingOffset: StackOffset.none
      });
    } else if (stackIndex[stack] === void 0) {
      stackIndex[stack] = stackingGroups.length;
      stackingGroups.push({
        ids: [id],
        stackingOrder: StackOrder[stackOrder ?? (defaultStrategy == null ? void 0 : defaultStrategy.stackOrder) ?? "none"],
        stackingOffset: StackOffset[stackOffset ?? (defaultStrategy == null ? void 0 : defaultStrategy.stackOffset) ?? "diverging"]
      });
    } else {
      stackingGroups[stackIndex[stack]].ids.push(id);
      if (stackOrder !== void 0) {
        stackingGroups[stackIndex[stack]].stackingOrder = StackOrder[stackOrder];
      }
      if (stackOffset !== void 0) {
        stackingGroups[stackIndex[stack]].stackingOffset = StackOffset[stackOffset];
      }
    }
  });
  return stackingGroups;
};

// node_modules/@mui/x-charts/esm/internals/defaultizeValueFormatter.js
function defaultizeValueFormatter(series, defaultValueFormatter) {
  const defaultizedSeries = {};
  Object.keys(series).forEach((seriesId) => {
    defaultizedSeries[seriesId] = _extends({}, series[seriesId], {
      valueFormatter: series[seriesId].valueFormatter ?? defaultValueFormatter
    });
  });
  return defaultizedSeries;
}

// node_modules/@mui/x-charts/esm/BarChart/seriesConfig/seriesProcessor.js
var seriesProcessor = (params, dataset) => {
  const {
    seriesOrder,
    series
  } = params;
  const stackingGroups = getStackingGroups(params);
  const d3Dataset = dataset ?? [];
  seriesOrder.forEach((id) => {
    const data = series[id].data;
    if (data !== void 0) {
      data.forEach((value, index2) => {
        if (d3Dataset.length <= index2) {
          d3Dataset.push({
            [id]: value
          });
        } else {
          d3Dataset[index2][id] = value;
        }
      });
    } else if (dataset === void 0) {
      throw new Error([`MUI X Charts: bar series with id='${id}' has no data.`, "Either provide a data property to the series or use the dataset prop."].join("\n"));
    }
  });
  const completedSeries = {};
  stackingGroups.forEach((stackingGroup) => {
    const {
      ids,
      stackingOffset,
      stackingOrder
    } = stackingGroup;
    const stackedSeries = stack_default().keys(ids.map((id) => {
      const dataKey = series[id].dataKey;
      return series[id].data === void 0 && dataKey !== void 0 ? dataKey : id;
    })).value((d, key) => d[key] ?? 0).order(stackingOrder).offset(stackingOffset)(d3Dataset);
    ids.forEach((id, index2) => {
      const dataKey = series[id].dataKey;
      completedSeries[id] = _extends({
        layout: "vertical",
        labelMarkType: "square"
      }, series[id], {
        data: dataKey ? dataset.map((data) => {
          const value = data[dataKey];
          if (typeof value !== "number") {
            if (true) {
              if (value !== null) {
                warnOnce([`MUI X Charts: your dataset key "${dataKey}" is used for plotting bars, but contains nonnumerical elements.`, "Bar plots only support numbers and null values."]);
              }
            }
            return 0;
          }
          return value;
        }) : series[id].data,
        stackedData: stackedSeries[index2].map(([a3, b2]) => [a3, b2])
      });
    });
  });
  return {
    seriesOrder,
    stackingGroups,
    series: defaultizeValueFormatter(completedSeries, (v3) => v3 == null ? "" : v3.toLocaleString())
  };
};
var seriesProcessor_default = seriesProcessor;

// node_modules/@mui/x-charts/esm/internals/getLabel.js
function getLabel(value, location) {
  return typeof value === "function" ? value(location) : value;
}

// node_modules/@mui/x-charts/esm/BarChart/seriesConfig/legend.js
var legendGetter = (params) => {
  const {
    seriesOrder,
    series
  } = params;
  return seriesOrder.reduce((acc, seriesId) => {
    const formattedLabel = getLabel(series[seriesId].label, "legend");
    if (formattedLabel === void 0) {
      return acc;
    }
    acc.push({
      markType: series[seriesId].labelMarkType,
      id: seriesId,
      seriesId,
      color: series[seriesId].color,
      label: formattedLabel
    });
    return acc;
  }, []);
};
var legend_default = legendGetter;

// node_modules/@mui/x-charts/esm/BarChart/seriesConfig/getColor.js
var getColor = (series, xAxis, yAxis) => {
  const verticalLayout = series.layout === "vertical";
  const bandColorScale = verticalLayout ? xAxis == null ? void 0 : xAxis.colorScale : yAxis == null ? void 0 : yAxis.colorScale;
  const valueColorScale = verticalLayout ? yAxis == null ? void 0 : yAxis.colorScale : xAxis == null ? void 0 : xAxis.colorScale;
  const bandValues = verticalLayout ? xAxis == null ? void 0 : xAxis.data : yAxis == null ? void 0 : yAxis.data;
  if (valueColorScale) {
    return (dataIndex) => {
      if (dataIndex === void 0) {
        return series.color;
      }
      const value = series.data[dataIndex];
      const color3 = value === null ? series.color : valueColorScale(value);
      if (color3 === null) {
        return series.color;
      }
      return color3;
    };
  }
  if (bandColorScale && bandValues) {
    return (dataIndex) => {
      if (dataIndex === void 0) {
        return series.color;
      }
      const value = bandValues[dataIndex];
      const color3 = value === null ? series.color : bandColorScale(value);
      if (color3 === null) {
        return series.color;
      }
      return color3;
    };
  }
  return () => series.color;
};
var getColor_default = getColor;

// node_modules/@mui/x-charts/esm/BarChart/seriesConfig/tooltip.js
var tooltipGetter = (params) => {
  const {
    series,
    getColor: getColor6,
    identifier: identifier2
  } = params;
  if (!identifier2 || identifier2.dataIndex === void 0) {
    return null;
  }
  const label = getLabel(series.label, "tooltip");
  const value = series.data[identifier2.dataIndex];
  if (value == null) {
    return null;
  }
  const formattedValue = series.valueFormatter(value, {
    dataIndex: identifier2.dataIndex
  });
  return {
    identifier: identifier2,
    color: getColor6(identifier2.dataIndex),
    label,
    value,
    formattedValue,
    markType: series.labelMarkType
  };
};
var axisTooltipGetter = (series) => {
  return Object.values(series).map((s3) => s3.layout === "horizontal" ? {
    direction: "y",
    axisId: s3.yAxisId
  } : {
    direction: "x",
    axisId: s3.xAxisId
  });
};
var tooltip_default = tooltipGetter;

// node_modules/@mui/x-charts/esm/BarChart/seriesConfig/getSeriesWithDefaultValues.js
var getSeriesWithDefaultValues = (seriesData, seriesIndex, colors) => {
  return _extends({
    id: seriesData.id ?? `auto-generated-id-${seriesIndex}`,
    color: colors[seriesIndex % colors.length]
  }, seriesData);
};
var getSeriesWithDefaultValues_default = getSeriesWithDefaultValues;

// node_modules/@mui/x-charts/esm/BarChart/seriesConfig/index.js
var seriesConfig = {
  seriesProcessor: seriesProcessor_default,
  colorProcessor: getColor_default,
  legendGetter: legend_default,
  tooltipGetter: tooltip_default,
  axisTooltipGetter,
  xExtremumGetter: getExtremumX,
  yExtremumGetter: getExtremumY,
  getSeriesWithDefaultValues: getSeriesWithDefaultValues_default
};

// node_modules/@mui/x-charts/esm/ScatterChart/seriesConfig/extremums.js
var mergeMinMax = (acc, val) => {
  return [val[0] === null ? acc[0] : Math.min(acc[0], val[0]), val[1] === null ? acc[1] : Math.max(acc[1], val[1])];
};
var getExtremumX2 = (params) => {
  const {
    series,
    axis,
    isDefaultAxis,
    getFilters
  } = params;
  return Object.keys(series).filter((seriesId) => {
    const axisId = series[seriesId].xAxisId;
    return axisId === axis.id || axisId === void 0 && isDefaultAxis;
  }).reduce((acc, seriesId) => {
    var _a;
    const filter3 = getFilters == null ? void 0 : getFilters({
      currentAxisId: axis.id,
      isDefaultAxis,
      seriesXAxisId: series[seriesId].xAxisId,
      seriesYAxisId: series[seriesId].yAxisId
    });
    const seriesMinMax = (_a = series[seriesId].data) == null ? void 0 : _a.reduce((accSeries, d, dataIndex) => {
      if (filter3 && !filter3(d, dataIndex)) {
        return accSeries;
      }
      return mergeMinMax(accSeries, [d.x, d.x]);
    }, [Infinity, -Infinity]);
    return mergeMinMax(acc, seriesMinMax ?? [Infinity, -Infinity]);
  }, [Infinity, -Infinity]);
};
var getExtremumY2 = (params) => {
  const {
    series,
    axis,
    isDefaultAxis,
    getFilters
  } = params;
  return Object.keys(series).filter((seriesId) => {
    const axisId = series[seriesId].yAxisId;
    return axisId === axis.id || axisId === void 0 && isDefaultAxis;
  }).reduce((acc, seriesId) => {
    var _a;
    const filter3 = getFilters == null ? void 0 : getFilters({
      currentAxisId: axis.id,
      isDefaultAxis,
      seriesXAxisId: series[seriesId].xAxisId,
      seriesYAxisId: series[seriesId].yAxisId
    });
    const seriesMinMax = (_a = series[seriesId].data) == null ? void 0 : _a.reduce((accSeries, d, dataIndex) => {
      if (filter3 && !filter3(d, dataIndex)) {
        return accSeries;
      }
      return mergeMinMax(accSeries, [d.y, d.y]);
    }, [Infinity, -Infinity]);
    return mergeMinMax(acc, seriesMinMax ?? [Infinity, -Infinity]);
  }, [Infinity, -Infinity]);
};

// node_modules/@mui/x-charts/esm/ScatterChart/seriesConfig/seriesProcessor.js
var seriesProcessor2 = ({
  series,
  seriesOrder
}, dataset) => {
  const completeSeries = Object.fromEntries(Object.entries(series).map(([seriesId, seriesData]) => {
    const datasetKeys = seriesData == null ? void 0 : seriesData.datasetKeys;
    const missingKeys = ["x", "y", "id"].filter((key) => typeof (datasetKeys == null ? void 0 : datasetKeys[key]) !== "string");
    if ((seriesData == null ? void 0 : seriesData.datasetKeys) && missingKeys.length > 0) {
      throw new Error([`MUI X Charts: scatter series with id='${seriesId}' has incomplete datasetKeys.`, `Properties ${missingKeys.map((key) => `"${key}"`).join(", ")} are missing.`].join("\n"));
    }
    const data = !datasetKeys ? seriesData.data ?? [] : (dataset == null ? void 0 : dataset.map((d) => {
      return {
        x: d[datasetKeys.x] ?? null,
        y: d[datasetKeys.y] ?? null,
        z: datasetKeys.z && d[datasetKeys.z],
        id: datasetKeys.id && d[datasetKeys.id]
      };
    })) ?? [];
    return [seriesId, _extends({
      labelMarkType: "circle",
      markerSize: 4
    }, seriesData, {
      data,
      valueFormatter: seriesData.valueFormatter ?? ((v3) => v3 && `(${v3.x}, ${v3.y})`)
    })];
  }));
  return {
    series: completeSeries,
    seriesOrder
  };
};
var seriesProcessor_default2 = seriesProcessor2;

// node_modules/@mui/x-charts/esm/ScatterChart/seriesConfig/getColor.js
var getColor2 = (series, xAxis, yAxis, zAxis) => {
  const zColorScale = zAxis == null ? void 0 : zAxis.colorScale;
  const yColorScale = yAxis == null ? void 0 : yAxis.colorScale;
  const xColorScale = xAxis == null ? void 0 : xAxis.colorScale;
  if (zColorScale) {
    return (dataIndex) => {
      var _a, _b;
      if (dataIndex === void 0) {
        return series.color;
      }
      if (((_a = zAxis == null ? void 0 : zAxis.data) == null ? void 0 : _a[dataIndex]) !== void 0) {
        const color4 = zColorScale((_b = zAxis == null ? void 0 : zAxis.data) == null ? void 0 : _b[dataIndex]);
        if (color4 !== null) {
          return color4;
        }
      }
      const value = series.data[dataIndex];
      const color3 = value === null ? series.color : zColorScale(value.z);
      if (color3 === null) {
        return series.color;
      }
      return color3;
    };
  }
  if (yColorScale) {
    return (dataIndex) => {
      if (dataIndex === void 0) {
        return series.color;
      }
      const value = series.data[dataIndex];
      const color3 = value === null ? series.color : yColorScale(value.y);
      if (color3 === null) {
        return series.color;
      }
      return color3;
    };
  }
  if (xColorScale) {
    return (dataIndex) => {
      if (dataIndex === void 0) {
        return series.color;
      }
      const value = series.data[dataIndex];
      const color3 = value === null ? series.color : xColorScale(value.x);
      if (color3 === null) {
        return series.color;
      }
      return color3;
    };
  }
  return () => series.color;
};
var getColor_default2 = getColor2;

// node_modules/@mui/x-charts/esm/ScatterChart/seriesConfig/legend.js
var legendGetter2 = (params) => {
  const {
    seriesOrder,
    series
  } = params;
  return seriesOrder.reduce((acc, seriesId) => {
    const formattedLabel = getLabel(series[seriesId].label, "legend");
    if (formattedLabel === void 0) {
      return acc;
    }
    acc.push({
      markType: series[seriesId].labelMarkType,
      id: seriesId,
      seriesId,
      color: series[seriesId].color,
      label: formattedLabel
    });
    return acc;
  }, []);
};
var legend_default2 = legendGetter2;

// node_modules/@mui/x-charts/esm/ScatterChart/seriesConfig/tooltip.js
var tooltipGetter2 = (params) => {
  const {
    series,
    getColor: getColor6,
    identifier: identifier2
  } = params;
  if (!identifier2 || identifier2.dataIndex === void 0) {
    return null;
  }
  const label = getLabel(series.label, "tooltip");
  const value = series.data[identifier2.dataIndex];
  const formattedValue = series.valueFormatter(value, {
    dataIndex: identifier2.dataIndex
  });
  return {
    identifier: identifier2,
    color: getColor6(identifier2.dataIndex),
    label,
    value,
    formattedValue,
    markType: series.labelMarkType
  };
};
var tooltip_default2 = tooltipGetter2;

// node_modules/@mui/x-charts/esm/ScatterChart/seriesConfig/getSeriesWithDefaultValues.js
var getSeriesWithDefaultValues2 = (seriesData, seriesIndex, colors) => {
  return _extends({
    id: seriesData.id ?? `auto-generated-id-${seriesIndex}`,
    color: colors[seriesIndex % colors.length]
  }, seriesData);
};
var getSeriesWithDefaultValues_default2 = getSeriesWithDefaultValues2;

// node_modules/@mui/x-charts/esm/ScatterChart/seriesConfig/index.js
var seriesConfig2 = {
  seriesProcessor: seriesProcessor_default2,
  colorProcessor: getColor_default2,
  legendGetter: legend_default2,
  tooltipGetter: tooltip_default2,
  xExtremumGetter: getExtremumX2,
  yExtremumGetter: getExtremumY2,
  getSeriesWithDefaultValues: getSeriesWithDefaultValues_default2
};

// node_modules/@mui/x-charts/esm/LineChart/seriesConfig/extremums.js
var getExtremumX3 = (params) => {
  const {
    axis
  } = params;
  const minX = Math.min(...axis.data ?? []);
  const maxX = Math.max(...axis.data ?? []);
  return [minX, maxX];
};
function getSeriesExtremums(getValues, data, stackedData, filter3) {
  return stackedData.reduce((seriesAcc, stackedValue, index2) => {
    if (data[index2] === null) {
      return seriesAcc;
    }
    const [base, value] = getValues(stackedValue);
    if (filter3 && (!filter3({
      y: base,
      x: null
    }, index2) || !filter3({
      y: value,
      x: null
    }, index2))) {
      return seriesAcc;
    }
    return [Math.min(base, value, seriesAcc[0]), Math.max(base, value, seriesAcc[1])];
  }, [Infinity, -Infinity]);
}
var getExtremumY3 = (params) => {
  const {
    series,
    axis,
    isDefaultAxis,
    getFilters
  } = params;
  return Object.keys(series).filter((seriesId) => {
    const yAxisId = series[seriesId].yAxisId;
    return yAxisId === axis.id || isDefaultAxis && yAxisId === void 0;
  }).reduce((acc, seriesId) => {
    const {
      area,
      stackedData,
      data
    } = series[seriesId];
    const isArea = area !== void 0;
    const filter3 = getFilters == null ? void 0 : getFilters({
      currentAxisId: axis.id,
      isDefaultAxis,
      seriesXAxisId: series[seriesId].xAxisId,
      seriesYAxisId: series[seriesId].yAxisId
    });
    const getValues = isArea && axis.scaleType !== "log" && typeof series[seriesId].baseline !== "string" ? (d) => d : (d) => [d[1], d[1]];
    const seriesExtremums = getSeriesExtremums(getValues, data, stackedData, filter3);
    const [seriesMin, seriesMax] = seriesExtremums;
    return [Math.min(seriesMin, acc[0]), Math.max(seriesMax, acc[1])];
  }, [Infinity, -Infinity]);
};

// node_modules/@mui/x-charts/esm/LineChart/seriesConfig/seriesProcessor.js
var seriesProcessor3 = (params, dataset) => {
  const {
    seriesOrder,
    series
  } = params;
  const stackingGroups = getStackingGroups(_extends({}, params, {
    defaultStrategy: {
      stackOffset: "none"
    }
  }));
  const d3Dataset = dataset ?? [];
  seriesOrder.forEach((id) => {
    const data = series[id].data;
    if (data !== void 0) {
      data.forEach((value, index2) => {
        if (d3Dataset.length <= index2) {
          d3Dataset.push({
            [id]: value
          });
        } else {
          d3Dataset[index2][id] = value;
        }
      });
    } else if (dataset === void 0 && true) {
      throw new Error([`MUI X Charts: line series with id='${id}' has no data.`, "Either provide a data property to the series or use the dataset prop."].join("\n"));
    }
  });
  const completedSeries = {};
  stackingGroups.forEach((stackingGroup) => {
    const {
      ids,
      stackingOrder,
      stackingOffset
    } = stackingGroup;
    const stackedSeries = stack_default().keys(ids.map((id) => {
      const dataKey = series[id].dataKey;
      return series[id].data === void 0 && dataKey !== void 0 ? dataKey : id;
    })).value((d, key) => d[key] ?? 0).order(stackingOrder).offset(stackingOffset)(d3Dataset);
    ids.forEach((id, index2) => {
      const dataKey = series[id].dataKey;
      completedSeries[id] = _extends({
        labelMarkType: "line"
      }, series[id], {
        data: dataKey ? dataset.map((data) => {
          const value = data[dataKey];
          if (typeof value !== "number") {
            if (true) {
              if (value !== null) {
                warnOnce([`MUI X Charts: Your dataset key "${dataKey}" is used for plotting line, but contains nonnumerical elements.`, "Line plots only support numbers and null values."]);
              }
            }
            return null;
          }
          return value;
        }) : series[id].data,
        stackedData: stackedSeries[index2].map(([a3, b2]) => [a3, b2])
      });
    });
  });
  return {
    seriesOrder,
    stackingGroups,
    series: defaultizeValueFormatter(completedSeries, (v3) => v3 == null ? "" : v3.toLocaleString())
  };
};
var seriesProcessor_default3 = seriesProcessor3;

// node_modules/@mui/x-charts/esm/LineChart/seriesConfig/getColor.js
var getColor3 = (series, xAxis, yAxis) => {
  const yColorScale = yAxis == null ? void 0 : yAxis.colorScale;
  const xColorScale = xAxis == null ? void 0 : xAxis.colorScale;
  if (yColorScale) {
    return (dataIndex) => {
      if (dataIndex === void 0) {
        return series.color;
      }
      const value = series.data[dataIndex];
      const color3 = value === null ? series.color : yColorScale(value);
      if (color3 === null) {
        return series.color;
      }
      return color3;
    };
  }
  if (xColorScale) {
    return (dataIndex) => {
      var _a;
      if (dataIndex === void 0) {
        return series.color;
      }
      const value = (_a = xAxis.data) == null ? void 0 : _a[dataIndex];
      const color3 = value === null ? series.color : xColorScale(value);
      if (color3 === null) {
        return series.color;
      }
      return color3;
    };
  }
  return () => series.color;
};
var getColor_default3 = getColor3;

// node_modules/@mui/x-charts/esm/LineChart/seriesConfig/legend.js
var legendGetter3 = (params) => {
  const {
    seriesOrder,
    series
  } = params;
  return seriesOrder.reduce((acc, seriesId) => {
    const formattedLabel = getLabel(series[seriesId].label, "legend");
    if (formattedLabel === void 0) {
      return acc;
    }
    acc.push({
      markType: series[seriesId].labelMarkType,
      id: seriesId,
      seriesId,
      color: series[seriesId].color,
      label: formattedLabel
    });
    return acc;
  }, []);
};
var legend_default3 = legendGetter3;

// node_modules/@mui/x-charts/esm/LineChart/seriesConfig/tooltip.js
var tooltipGetter3 = (params) => {
  const {
    series,
    getColor: getColor6,
    identifier: identifier2
  } = params;
  if (!identifier2 || identifier2.dataIndex === void 0) {
    return null;
  }
  const label = getLabel(series.label, "tooltip");
  const value = series.data[identifier2.dataIndex];
  const formattedValue = series.valueFormatter(value, {
    dataIndex: identifier2.dataIndex
  });
  return {
    identifier: identifier2,
    color: getColor6(identifier2.dataIndex),
    label,
    value,
    formattedValue,
    markType: series.labelMarkType
  };
};
var axisTooltipGetter2 = (series) => {
  return Object.values(series).map((s3) => ({
    direction: "x",
    axisId: s3.xAxisId
  }));
};
var tooltip_default3 = tooltipGetter3;

// node_modules/@mui/x-charts/esm/LineChart/seriesConfig/getSeriesWithDefaultValues.js
var getSeriesWithDefaultValues3 = (seriesData, seriesIndex, colors) => {
  return _extends({
    id: seriesData.id ?? `auto-generated-id-${seriesIndex}`,
    color: colors[seriesIndex % colors.length]
  }, seriesData);
};
var getSeriesWithDefaultValues_default3 = getSeriesWithDefaultValues3;

// node_modules/@mui/x-charts/esm/LineChart/seriesConfig/index.js
var seriesConfig3 = {
  colorProcessor: getColor_default3,
  seriesProcessor: seriesProcessor_default3,
  legendGetter: legend_default3,
  tooltipGetter: tooltip_default3,
  axisTooltipGetter: axisTooltipGetter2,
  xExtremumGetter: getExtremumX3,
  yExtremumGetter: getExtremumY3,
  getSeriesWithDefaultValues: getSeriesWithDefaultValues_default3
};

// node_modules/@mui/x-charts/esm/PieChart/seriesConfig/seriesProcessor.js
var getSortingComparator = (comparator = "none") => {
  if (typeof comparator === "function") {
    return comparator;
  }
  switch (comparator) {
    case "none":
      return null;
    case "desc":
      return (a3, b2) => b2 - a3;
    case "asc":
      return (a3, b2) => a3 - b2;
    default:
      return null;
  }
};
var seriesProcessor4 = (params) => {
  const {
    seriesOrder,
    series
  } = params;
  const defaultizedSeries = {};
  seriesOrder.forEach((seriesId) => {
    const arcs = pie_default().startAngle(2 * Math.PI * (series[seriesId].startAngle ?? 0) / 360).endAngle(2 * Math.PI * (series[seriesId].endAngle ?? 360) / 360).padAngle(2 * Math.PI * (series[seriesId].paddingAngle ?? 0) / 360).sortValues(getSortingComparator(series[seriesId].sortingValues ?? "none"))(series[seriesId].data.map((piePoint) => piePoint.value));
    defaultizedSeries[seriesId] = _extends({
      labelMarkType: "circle",
      valueFormatter: (item) => item.value.toLocaleString()
    }, series[seriesId], {
      data: series[seriesId].data.map((item, index2) => _extends({}, item, {
        id: item.id ?? `auto-generated-pie-id-${seriesId}-${index2}`
      }, arcs[index2])).map((item, index2) => {
        var _a, _b;
        return _extends({
          labelMarkType: "circle"
        }, item, {
          formattedValue: ((_b = (_a = series[seriesId]).valueFormatter) == null ? void 0 : _b.call(_a, _extends({}, item, {
            label: getLabel(item.label, "arc")
          }), {
            dataIndex: index2
          })) ?? item.value.toLocaleString()
        });
      })
    });
  });
  return {
    seriesOrder,
    series: defaultizedSeries
  };
};
var seriesProcessor_default4 = seriesProcessor4;

// node_modules/@mui/x-charts/esm/PieChart/seriesConfig/getColor.js
var getColor4 = (series) => {
  return (dataIndex) => {
    return series.data[dataIndex].color;
  };
};
var getColor_default4 = getColor4;

// node_modules/@mui/x-charts/esm/PieChart/seriesConfig/legend.js
var legendGetter4 = (params) => {
  const {
    seriesOrder,
    series
  } = params;
  return seriesOrder.reduce((acc, seriesId) => {
    series[seriesId].data.forEach((item, dataIndex) => {
      const formattedLabel = getLabel(item.label, "legend");
      if (formattedLabel === void 0) {
        return;
      }
      acc.push({
        markType: item.labelMarkType ?? series[seriesId].labelMarkType,
        id: item.id ?? dataIndex,
        seriesId,
        color: item.color,
        label: formattedLabel,
        itemId: item.id ?? dataIndex
      });
    });
    return acc;
  }, []);
};
var legend_default4 = legendGetter4;

// node_modules/@mui/x-charts/esm/PieChart/seriesConfig/tooltip.js
var tooltipGetter4 = (params) => {
  const {
    series,
    getColor: getColor6,
    identifier: identifier2
  } = params;
  if (!identifier2 || identifier2.dataIndex === void 0) {
    return null;
  }
  const point6 = series.data[identifier2.dataIndex];
  if (point6 == null) {
    return null;
  }
  const label = getLabel(point6.label, "tooltip");
  const value = _extends({}, point6, {
    label
  });
  const formattedValue = series.valueFormatter(value, {
    dataIndex: identifier2.dataIndex
  });
  return {
    identifier: identifier2,
    color: getColor6(identifier2.dataIndex),
    label,
    value,
    formattedValue,
    markType: point6.labelMarkType ?? series.labelMarkType
  };
};
var tooltip_default4 = tooltipGetter4;

// node_modules/@mui/x-charts/esm/PieChart/seriesConfig/getSeriesWithDefaultValues.js
var getSeriesWithDefaultValues4 = (seriesData, seriesIndex, colors) => {
  return _extends({
    id: seriesData.id ?? `auto-generated-id-${seriesIndex}`
  }, seriesData, {
    data: seriesData.data.map((d, index2) => _extends({
      color: colors[index2 % colors.length]
    }, d))
  });
};
var getSeriesWithDefaultValues_default4 = getSeriesWithDefaultValues4;

// node_modules/@mui/x-charts/esm/PieChart/seriesConfig/index.js
var seriesConfig4 = {
  colorProcessor: getColor_default4,
  seriesProcessor: seriesProcessor_default4,
  legendGetter: legend_default4,
  tooltipGetter: tooltip_default4,
  getSeriesWithDefaultValues: getSeriesWithDefaultValues_default4
};

// node_modules/@mui/x-charts/esm/context/ChartProvider/ChartProvider.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var defaultSeriesConfig = {
  bar: seriesConfig,
  scatter: seriesConfig2,
  line: seriesConfig3,
  pie: seriesConfig4
};
var defaultPlugins = [useChartZAxis, useChartCartesianAxis, useChartInteraction, useChartHighlight];
function ChartProvider(props) {
  const {
    children: children2,
    plugins = defaultPlugins,
    pluginParams = {},
    seriesConfig: seriesConfig5 = defaultSeriesConfig
  } = props;
  const {
    contextValue
  } = useCharts(plugins, pluginParams, seriesConfig5);
  return (0, import_jsx_runtime.jsx)(ChartContext.Provider, {
    value: contextValue,
    children: children2
  });
}

// node_modules/@mui/x-charts/esm/context/ChartProvider/useChartContext.js
var React15 = __toESM(require_react(), 1);
var useChartContext = () => {
  const context = React15.useContext(ChartContext);
  if (context == null) {
    throw new Error(["MUI X Charts: Could not find the Chart context.", "It looks like you rendered your component outside of a ChartDataProvider.", "This can also happen if you are bundling multiple versions of the library."].join("\n"));
  }
  return context;
};

// node_modules/@mui/x-charts/esm/internals/store/useStore.js
function useStore() {
  const context = useChartContext();
  if (!context) {
    throw new Error(["MUI X Charts: Could not find the charts context.", "It looks like you rendered your component outside of a ChartContainer parent component."].join("\n"));
  }
  return context.store;
}

// node_modules/@mui/x-charts/esm/hooks/useDrawingArea.js
function useDrawingArea() {
  const store = useStore();
  return useSelector(store, selectorChartDrawingArea);
}

// node_modules/@mui/x-charts/esm/hooks/useChartId.js
function useChartId2() {
  const store = useStore();
  return useSelector(store, selectorChartId);
}

// node_modules/@mui/x-charts/esm/internals/plugins/featurePlugins/useChartPolarAxis/useChartPolarAxis.js
var React16 = __toESM(require_react(), 1);

// node_modules/@mui/x-charts/esm/internals/plugins/featurePlugins/useChartPolarAxis/defaultizeAxis.js
function defaultizeAxis(inAxis, dataset, axisName) {
  const DEFAULT_AXIS_KEY = axisName === "rotation" ? DEFAULT_ROTATION_AXIS_KEY : DEFAULT_RADIUS_AXIS_KEY;
  const inputAxes = inAxis && inAxis.length > 0 ? inAxis : [{
    id: DEFAULT_AXIS_KEY
  }];
  return inputAxes.map((axisConfig, index2) => {
    const id = `defaultized-${axisName}-axis-${index2}`;
    const dataKey = axisConfig.dataKey;
    if (dataKey === void 0 || axisConfig.data !== void 0) {
      return _extends({
        id
      }, axisConfig);
    }
    if (dataset === void 0) {
      throw new Error(`MUI X Charts: ${axisName}-axis uses \`dataKey\` but no \`dataset\` is provided.`);
    }
    return _extends({
      id,
      data: dataset.map((d) => d[dataKey])
    }, axisConfig);
  });
}

// node_modules/@mui/x-charts/esm/internals/isPolar.js
function isPolarSeriesType(seriesType) {
  return polarSeriesTypes.getTypes().has(seriesType);
}

// node_modules/@mui/x-charts/esm/internals/plugins/featurePlugins/useChartPolarAxis/getAxisExtremum.js
var axisExtremumCallback2 = (acc, chartType, axis, axisDirection, seriesConfig5, axisIndex, formattedSeries) => {
  var _a;
  const getter = axisDirection === "rotation" ? seriesConfig5[chartType].rotationExtremumGetter : seriesConfig5[chartType].radiusExtremumGetter;
  const series = ((_a = formattedSeries[chartType]) == null ? void 0 : _a.series) ?? {};
  const [minChartTypeData, maxChartTypeData] = (getter == null ? void 0 : getter({
    series,
    axis,
    axisIndex,
    isDefaultAxis: axisIndex === 0
  })) ?? [Infinity, -Infinity];
  const [minData, maxData] = acc;
  return [Math.min(minChartTypeData, minData), Math.max(maxChartTypeData, maxData)];
};
var getAxisExtremum2 = (axis, axisDirection, seriesConfig5, axisIndex, formattedSeries) => {
  const polarSeriesTypes2 = Object.keys(seriesConfig5).filter(isPolarSeriesType);
  const extremums = polarSeriesTypes2.reduce((acc, charType) => axisExtremumCallback2(acc, charType, axis, axisDirection, seriesConfig5, axisIndex, formattedSeries), [Infinity, -Infinity]);
  if (Number.isNaN(extremums[0]) || Number.isNaN(extremums[1])) {
    return [Infinity, -Infinity];
  }
  return extremums;
};

// node_modules/@mui/x-charts/esm/internals/angleConversion.js
var deg2rad = (value, defaultRad) => {
  if (value === void 0) {
    return defaultRad;
  }
  return Math.PI * value / 180;
};
var rad2deg = (value, defaultDeg) => {
  if (value === void 0) {
    return defaultDeg;
  }
  return 180 * value / Math.PI;
};

// node_modules/@mui/x-charts/esm/internals/plugins/featurePlugins/useChartPolarAxis/getAxisTriggerTooltip.js
var getAxisTriggerTooltip2 = (axisDirection, seriesConfig5, formattedSeries, defaultAxisId) => {
  const tooltipAxesIds = /* @__PURE__ */ new Set();
  const chartTypes = Object.keys(seriesConfig5).filter(isPolarSeriesType);
  chartTypes.forEach((chartType) => {
    var _a, _b, _c;
    const series = ((_a = formattedSeries[chartType]) == null ? void 0 : _a.series) ?? {};
    const tooltipAxes = (_c = (_b = seriesConfig5[chartType]).axisTooltipGetter) == null ? void 0 : _c.call(_b, series);
    if (tooltipAxes === void 0) {
      return;
    }
    tooltipAxes.forEach(({
      axisId,
      direction
    }) => {
      if (direction === axisDirection) {
        tooltipAxesIds.add(axisId ?? defaultAxisId);
      }
    });
  });
  return tooltipAxesIds;
};

// node_modules/@mui/x-charts/esm/internals/plugins/featurePlugins/useChartPolarAxis/computeAxisValue.js
function getRange2(drawingArea, axisDirection, axis) {
  if (axisDirection === "rotation") {
    if (axis.scaleType === "point") {
      const angles = [deg2rad(axis.startAngle, 0), deg2rad(axis.endAngle, 2 * Math.PI)];
      const diff = angles[1] - angles[0];
      if (diff > Math.PI * 2 - 0.1) {
        angles[1] -= diff / axis.data.length;
      }
      return angles;
    }
    return [deg2rad(axis.startAngle, 0), deg2rad(axis.endAngle, 2 * Math.PI)];
  }
  return [0, Math.min(drawingArea.height, drawingArea.width) / 2];
}
var isDateData2 = (data) => (data == null ? void 0 : data[0]) instanceof Date;
function createDateFormatter2(axis, range2) {
  const timeScale = time(axis.data, range2);
  return (v3, {
    location
  }) => location === "tick" ? timeScale.tickFormat(axis.tickNumber)(v3) : `${v3.toLocaleString()}`;
}
var DEFAULT_CATEGORY_GAP_RATIO2 = 0.2;
var DEFAULT_BAR_GAP_RATIO2 = 0.1;
function computeAxisValue2({
  drawingArea,
  formattedSeries,
  axis: allAxis,
  seriesConfig: seriesConfig5,
  axisDirection
}) {
  if (allAxis === void 0) {
    return {
      axis: {},
      axisIds: []
    };
  }
  const axisIdsTriggeringTooltip = getAxisTriggerTooltip2(axisDirection, seriesConfig5, formattedSeries, allAxis[0].id);
  const completeAxis = {};
  allAxis.forEach((eachAxis, axisIndex) => {
    const axis = eachAxis;
    const range2 = getRange2(drawingArea, axisDirection, axis);
    const [minData, maxData] = getAxisExtremum2(axis, axisDirection, seriesConfig5, axisIndex, formattedSeries);
    const triggerTooltip = !axis.ignoreTooltip && axisIdsTriggeringTooltip.has(axis.id);
    const data = axis.data ?? [];
    if (isBandScaleConfig(axis)) {
      const categoryGapRatio = axis.categoryGapRatio ?? DEFAULT_CATEGORY_GAP_RATIO2;
      const barGapRatio = axis.barGapRatio ?? DEFAULT_BAR_GAP_RATIO2;
      completeAxis[axis.id] = _extends({
        offset: 0,
        categoryGapRatio,
        barGapRatio,
        triggerTooltip
      }, axis, {
        data,
        scale: band(axis.data, range2).paddingInner(categoryGapRatio).paddingOuter(categoryGapRatio / 2),
        tickNumber: axis.data.length,
        colorScale: axis.colorMap && (axis.colorMap.type === "ordinal" ? getOrdinalColorScale(_extends({
          values: axis.data
        }, axis.colorMap)) : getColorScale(axis.colorMap))
      });
      if (isDateData2(axis.data)) {
        const dateFormatter = createDateFormatter2(axis, range2);
        completeAxis[axis.id].valueFormatter = axis.valueFormatter ?? dateFormatter;
      }
    }
    if (isPointScaleConfig(axis)) {
      completeAxis[axis.id] = _extends({
        offset: 0,
        triggerTooltip
      }, axis, {
        data,
        scale: point(axis.data, range2),
        tickNumber: axis.data.length,
        colorScale: axis.colorMap && (axis.colorMap.type === "ordinal" ? getOrdinalColorScale(_extends({
          values: axis.data
        }, axis.colorMap)) : getColorScale(axis.colorMap))
      });
      if (isDateData2(axis.data)) {
        const dateFormatter = createDateFormatter2(axis, range2);
        completeAxis[axis.id].valueFormatter = axis.valueFormatter ?? dateFormatter;
      }
    }
    if (axis.scaleType === "band" || axis.scaleType === "point") {
      return;
    }
    const scaleType = axis.scaleType ?? "linear";
    const domainLimit = axis.domainLimit ?? "nice";
    const axisExtremums = [axis.min ?? minData, axis.max ?? maxData];
    if (typeof domainLimit === "function") {
      const {
        min: min4,
        max: max4
      } = domainLimit(minData, maxData);
      axisExtremums[0] = min4;
      axisExtremums[1] = max4;
    }
    const rawTickNumber = getTickNumber(_extends({}, axis, {
      range: range2,
      domain: axisExtremums
    }));
    const tickNumber = rawTickNumber / ((range2[1] - range2[0]) / 100);
    const scale2 = getScale(scaleType, axisExtremums, range2);
    const finalScale = domainLimit === "nice" ? scale2.nice(rawTickNumber) : scale2;
    const [minDomain, maxDomain] = finalScale.domain();
    const domain = [axis.min ?? minDomain, axis.max ?? maxDomain];
    completeAxis[axis.id] = _extends({
      offset: 0,
      triggerTooltip
    }, axis, {
      data,
      scaleType,
      scale: finalScale.domain(domain),
      tickNumber,
      colorScale: axis.colorMap && getColorScale(axis.colorMap)
    });
  });
  return {
    axis: completeAxis,
    axisIds: allAxis.map(({
      id
    }) => id)
  };
}

// node_modules/@mui/x-charts/esm/internals/plugins/featurePlugins/useChartPolarAxis/useChartPolarAxis.selectors.js
var selectorChartPolarAxisState = (state) => state.polarAxis;
var selectorChartRawRotationAxis = createSelector2(selectorChartPolarAxisState, (axis) => axis == null ? void 0 : axis.rotation);
var selectorChartRawRadiusAxis = createSelector2(selectorChartPolarAxisState, (axis) => axis == null ? void 0 : axis.radius);
var selectorChartRotationAxis = createSelector2([selectorChartRawRotationAxis, selectorChartDrawingArea, selectorChartSeriesProcessed, selectorChartSeriesConfig], (axis, drawingArea, formattedSeries, seriesConfig5) => computeAxisValue2({
  drawingArea,
  formattedSeries,
  axis,
  seriesConfig: seriesConfig5,
  axisDirection: "rotation"
}));
var selectorChartRadiusAxis = createSelector2([selectorChartRawRadiusAxis, selectorChartDrawingArea, selectorChartSeriesProcessed, selectorChartSeriesConfig], (axis, drawingArea, formattedSeries, seriesConfig5) => computeAxisValue2({
  drawingArea,
  formattedSeries,
  axis,
  seriesConfig: seriesConfig5,
  axisDirection: "radius"
}));
var selectorChartPolarCenter = createSelector2([selectorChartDrawingArea], (drawingArea) => ({
  cx: drawingArea.left + drawingArea.width / 2,
  cy: drawingArea.top + drawingArea.height / 2
}));

// node_modules/@mui/x-charts/esm/internals/plugins/featurePlugins/useChartPolarAxis/coordinateTransformation.js
var generateSvg2rotation = (center) => (x3, y3) => Math.atan2(x3 - center.cx, center.cy - y3);
var generateSvg2polar = (center) => (x3, y3) => {
  const angle = Math.atan2(x3 - center.cx, center.cy - y3);
  return [Math.sqrt((x3 - center.cx) ** 2 + (center.cy - y3) ** 2), angle];
};
var generatePolar2svg = (center) => (radius, rotation) => {
  return [center.cx + radius * Math.sin(rotation), center.cy - radius * Math.cos(rotation)];
};

// node_modules/@mui/x-charts/esm/internals/plugins/featurePlugins/useChartPolarAxis/useChartPolarAxis.js
var useChartPolarAxis = ({
  params,
  store,
  seriesConfig: seriesConfig5,
  svgRef,
  instance
}) => {
  const {
    rotationAxis,
    radiusAxis,
    dataset
  } = params;
  if (true) {
    const ids = [...rotationAxis ?? [], ...radiusAxis ?? []].filter((axis) => axis.id).map((axis) => axis.id);
    const duplicates = new Set(ids.filter((id, index2) => ids.indexOf(id) !== index2));
    if (duplicates.size > 0) {
      warnOnce([`MUI X Charts: The following axis ids are duplicated: ${Array.from(duplicates).join(", ")}.`, `Please make sure that each axis has a unique id.`].join("\n"), "error");
    }
  }
  const drawingArea = useSelector(store, selectorChartDrawingArea);
  const center = useSelector(store, selectorChartPolarCenter);
  const isInteractionEnabled = useSelector(store, selectorChartsInteractionIsInitialized);
  const {
    axis: rotationAxisWithScale,
    axisIds: rotationAxisIds
  } = useSelector(store, selectorChartRotationAxis);
  const {
    axis: radiusAxisWithScale,
    axisIds: radiusAxisIds
  } = useSelector(store, selectorChartRadiusAxis);
  const isFirstRender = React16.useRef(true);
  React16.useEffect(() => {
    if (isFirstRender.current) {
      isFirstRender.current = false;
      return;
    }
    store.update((prev2) => _extends({}, prev2, {
      polarAxis: _extends({}, prev2.polarAxis, {
        rotation: defaultizeAxis(rotationAxis, dataset, "rotation"),
        radius: defaultizeAxis(radiusAxis, dataset, "radius")
      })
    }));
  }, [seriesConfig5, drawingArea, rotationAxis, radiusAxis, dataset, store]);
  const svg2rotation = React16.useMemo(() => generateSvg2rotation({
    cx: center.cx,
    cy: center.cy
  }), [center.cx, center.cy]);
  const svg2polar = React16.useMemo(() => generateSvg2polar({
    cx: center.cx,
    cy: center.cy
  }), [center.cx, center.cy]);
  const polar2svg = React16.useMemo(() => generatePolar2svg({
    cx: center.cx,
    cy: center.cy
  }), [center.cx, center.cy]);
  const usedRotationAxisId = rotationAxisIds[0];
  const usedRadiusAxisId = radiusAxisIds[0];
  const mousePosition = React16.useRef({
    isInChart: false,
    x: -1,
    y: -1
  });
  React16.useEffect(() => {
    const element = svgRef.current;
    if (!isInteractionEnabled || element === null || params.disableAxisListener) {
      return () => {
      };
    }
    const handleOut = () => {
      var _a;
      mousePosition.current = {
        isInChart: false,
        x: -1,
        y: -1
      };
      (_a = instance.cleanInteraction) == null ? void 0 : _a.call(instance);
    };
    const handleMove = (event) => {
      var _a;
      const target = "targetTouches" in event ? event.targetTouches[0] : event;
      const svgPoint = getSVGPoint(element, target);
      mousePosition.current.x = svgPoint.x;
      mousePosition.current.y = svgPoint.y;
      if (!instance.isPointInside(svgPoint, {
        targetElement: event.target
      })) {
        if (mousePosition.current.isInChart) {
          instance == null ? void 0 : instance.cleanInteraction();
          mousePosition.current.isInChart = false;
        }
        return;
      }
      const radiusSquare = (center.cx - svgPoint.x) ** 2 + (center.cy - svgPoint.y) ** 2;
      const maxRadius = radiusAxisWithScale[usedRadiusAxisId].scale.range()[1];
      if (radiusSquare > maxRadius ** 2) {
        if (mousePosition.current.isInChart) {
          instance == null ? void 0 : instance.cleanInteraction();
          mousePosition.current.isInChart = false;
        }
        return;
      }
      mousePosition.current.isInChart = true;
      (_a = instance.setPointerCoordinate) == null ? void 0 : _a.call(instance, svgPoint);
    };
    const handleDown = (event) => {
      const target = event.currentTarget;
      if (!target) {
        return;
      }
      if ("hasPointerCapture" in target && target.hasPointerCapture(event.pointerId)) {
        target.releasePointerCapture(event.pointerId);
      }
    };
    element.addEventListener("pointerdown", handleDown);
    element.addEventListener("pointermove", handleMove);
    element.addEventListener("pointerout", handleOut);
    element.addEventListener("pointercancel", handleOut);
    element.addEventListener("pointerleave", handleOut);
    return () => {
      element.removeEventListener("pointerdown", handleDown);
      element.removeEventListener("pointermove", handleMove);
      element.removeEventListener("pointerout", handleOut);
      element.removeEventListener("pointercancel", handleOut);
      element.removeEventListener("pointerleave", handleOut);
    };
  }, [svgRef, store, center, radiusAxisWithScale, usedRadiusAxisId, rotationAxisWithScale, usedRotationAxisId, instance, params.disableAxisListener, isInteractionEnabled, svg2rotation]);
  return {
    instance: {
      svg2polar,
      svg2rotation,
      polar2svg
    }
  };
};
useChartPolarAxis.params = {
  rotationAxis: true,
  radiusAxis: true,
  dataset: true,
  disableAxisListener: true
};
useChartPolarAxis.getInitialState = (params) => ({
  polarAxis: {
    rotation: defaultizeAxis(params.rotationAxis, params.dataset, "rotation"),
    radius: defaultizeAxis(params.radiusAxis, params.dataset, "radius")
  }
});

// node_modules/@mui/x-charts/esm/hooks/useAxis.js
function useXAxes() {
  const store = useStore();
  const {
    axis: xAxis,
    axisIds: xAxisIds
  } = useSelector(store, selectorChartXAxis);
  return {
    xAxis,
    xAxisIds
  };
}
function useYAxes() {
  const store = useStore();
  const {
    axis: yAxis,
    axisIds: yAxisIds
  } = useSelector(store, selectorChartYAxis);
  return {
    yAxis,
    yAxisIds
  };
}
function useXAxis(axisId) {
  const store = useStore();
  const {
    axis: xAxis,
    axisIds: xAxisIds
  } = useSelector(store, selectorChartXAxis);
  const id = axisId ?? xAxisIds[0];
  return xAxis[id];
}
function useYAxis(axisId) {
  const store = useStore();
  const {
    axis: yAxis,
    axisIds: yAxisIds
  } = useSelector(store, selectorChartYAxis);
  const id = axisId ?? yAxisIds[0];
  return yAxis[id];
}
function useRotationAxes() {
  const store = useStore();
  const {
    axis: rotationAxis,
    axisIds: rotationAxisIds
  } = useSelector(store, selectorChartRotationAxis);
  return {
    rotationAxis,
    rotationAxisIds
  };
}
function useRadiusAxes() {
  const store = useStore();
  const {
    axis: radiusAxis,
    axisIds: radiusAxisIds
  } = useSelector(store, selectorChartRadiusAxis);
  return {
    radiusAxis,
    radiusAxisIds
  };
}
function useRotationAxis(identifier2) {
  const store = useStore();
  const {
    axis: rotationAxis,
    axisIds: rotationAxisIds
  } = useSelector(store, selectorChartRotationAxis);
  const id = typeof identifier2 === "string" ? identifier2 : rotationAxisIds[identifier2 ?? 0];
  return rotationAxis[id];
}
function useRadiusAxis(identifier2) {
  const store = useStore();
  const {
    axis: radiusAxis,
    axisIds: radiusAxisIds
  } = useSelector(store, selectorChartRadiusAxis);
  const id = typeof identifier2 === "string" ? identifier2 : radiusAxisIds[identifier2 ?? 0];
  return radiusAxis[id];
}

// node_modules/@mui/x-charts/esm/hooks/useScale.js
function getValueToPositionMapper(scale2) {
  if (isBandScale(scale2)) {
    return (value) => (scale2(value) ?? 0) + scale2.bandwidth() / 2;
  }
  return (value) => scale2(value);
}
function useXScale(axisId) {
  const axis = useXAxis(axisId);
  return axis.scale;
}
function useYScale(axisId) {
  const axis = useYAxis(axisId);
  return axis.scale;
}
function useRotationScale(identifier2) {
  const axis = useRotationAxis(identifier2);
  return axis == null ? void 0 : axis.scale;
}
function useRadiusScale(identifier2) {
  const axis = useRadiusAxis(identifier2);
  return axis == null ? void 0 : axis.scale;
}

// node_modules/@mui/x-charts/esm/hooks/useZAxis.js
function useZAxes() {
  const store = useStore();
  const {
    axis: zAxis,
    axisIds: zAxisIds
  } = useSelector(store, selectorChartZAxis) ?? {
    axis: {},
    axisIds: []
  };
  return {
    zAxis,
    zAxisIds
  };
}
function useZAxis(identifier2) {
  const {
    zAxis,
    zAxisIds
  } = useZAxes();
  const id = typeof identifier2 === "string" ? identifier2 : zAxisIds[identifier2 ?? 0];
  return zAxis[id];
}

// node_modules/@mui/x-charts/esm/hooks/useColorScale.js
function useXColorScale(axisId) {
  const axis = useXAxis(axisId);
  return axis.colorScale;
}
function useYColorScale(axisId) {
  const axis = useYAxis(axisId);
  return axis.colorScale;
}
function useZColorScale(axisId) {
  const axis = useZAxis(axisId);
  return axis.colorScale;
}

// node_modules/@mui/x-charts/esm/hooks/useSvgRef.js
function useSvgRef() {
  const context = useChartContext();
  if (!context) {
    throw new Error(["MUI X Charts: Could not find the svg ref context.", "It looks like you rendered your component outside of a ChartContainer parent component."].join("\n"));
  }
  return context.svgRef;
}

// node_modules/@mui/x-charts/esm/hooks/useSeries.js
function useSeries() {
  const store = useStore();
  return useSelector(store, selectorChartSeriesProcessed);
}

// node_modules/@mui/x-internals/esm/fastArrayCompare/fastArrayCompare.js
function fastArrayCompare(a3, b2) {
  if (a3 === b2) {
    return true;
  }
  if (!Array.isArray(a3) || !Array.isArray(b2)) {
    return false;
  }
  let i2 = a3.length;
  if (i2 !== b2.length) {
    return false;
  }
  while (i2--) {
    if (a3[i2] !== b2[i2]) {
      return false;
    }
  }
  return true;
}

// node_modules/@mui/x-charts/esm/internals/createSeriesSelectorOfType.js
function createSeriesSelectorsOfType(seriesType) {
  const selectorSeriesWithIds = createSelector2([selectorChartSeriesProcessed, (_2, ids) => ids], (processedSeries, ids) => {
    var _a, _b, _c, _d, _e2, _f;
    if (!ids || Array.isArray(ids) && ids.length === 0) {
      return ((_b = (_a = processedSeries[seriesType]) == null ? void 0 : _a.seriesOrder) == null ? void 0 : _b.map((seriesId) => {
        var _a2;
        return (_a2 = processedSeries[seriesType]) == null ? void 0 : _a2.series[seriesId];
      })) ?? [];
    }
    if (!Array.isArray(ids)) {
      return (_d = (_c = processedSeries[seriesType]) == null ? void 0 : _c.series) == null ? void 0 : _d[ids];
    }
    const result = [];
    const failedIds = [];
    for (const id of ids) {
      const series = (_f = (_e2 = processedSeries[seriesType]) == null ? void 0 : _e2.series) == null ? void 0 : _f[id];
      if (series) {
        result.push(series);
      } else {
        failedIds.push(id);
      }
    }
    if (failedIds.length > 0) {
      const formattedIds = failedIds.map((v3) => JSON.stringify(v3)).join(", ");
      const fnName = `use${seriesType.charAt(0).toUpperCase()}${seriesType.slice(1)}Series`;
      warnOnce([`MUI X Charts: The following ids provided to "${fnName}" could not be found: ${formattedIds}.`, `Make sure that they exist and their series are using the "${seriesType}" series type.`]);
    }
    return result;
  });
  return (ids) => {
    const store = useStore();
    return useSelector(store, selectorSeriesWithIds, ids, fastArrayCompare);
  };
}
function createAllSeriesSelectorOfType(seriesType) {
  const selectorSeries = createSelector2(selectorChartSeriesProcessed, (processedSeries) => processedSeries[seriesType]);
  return () => {
    const store = useStore();
    return useSelector(store, selectorSeries);
  };
}

// node_modules/@mui/x-charts/esm/hooks/useScatterSeries.js
var useSelectorSeries = createSeriesSelectorsOfType("scatter");
var useSelectorSeriesContext = createAllSeriesSelectorOfType("scatter");
function useScatterSeries(seriesIds) {
  return useSelectorSeries(seriesIds);
}
function useScatterSeriesContext() {
  return useSelectorSeriesContext();
}

// node_modules/@mui/x-charts/esm/hooks/usePieSeries.js
var useSelectorSeries2 = createSeriesSelectorsOfType("pie");
var useSelectorSeriesContext2 = createAllSeriesSelectorOfType("pie");
function usePieSeries(seriesIds) {
  return useSelectorSeries2(seriesIds);
}
function usePieSeriesContext() {
  return useSelectorSeriesContext2();
}

// node_modules/@mui/x-charts/esm/hooks/useBarSeries.js
var useSelectorSeries3 = createSeriesSelectorsOfType("bar");
var useSelectorSeriesContext3 = createAllSeriesSelectorOfType("bar");
function useBarSeries(seriesIds) {
  return useSelectorSeries3(seriesIds);
}
function useBarSeriesContext() {
  return useSelectorSeriesContext3();
}

// node_modules/@mui/x-charts/esm/hooks/useLineSeries.js
var useSelectorSeries4 = createSeriesSelectorsOfType("line");
var useSelectorSeriesContext4 = createAllSeriesSelectorOfType("line");
function useLineSeries(seriesIds) {
  return useSelectorSeries4(seriesIds);
}
function useLineSeriesContext() {
  return useSelectorSeriesContext4();
}

// node_modules/@mui/x-charts/esm/internals/plugins/featurePlugins/useChartHighlight/createIsHighlighted.js
var createIsHighlighted = (highlightScope, highlightedItem) => (item) => {
  if (!highlightScope || !highlightedItem || !item) {
    return false;
  }
  if (highlightScope.highlight === "series") {
    return item.seriesId === highlightedItem.seriesId;
  }
  if (highlightScope.highlight === "item") {
    return item.dataIndex === highlightedItem.dataIndex && item.seriesId === highlightedItem.seriesId;
  }
  return false;
};

// node_modules/@mui/x-charts/esm/internals/plugins/featurePlugins/useChartHighlight/createIsFaded.js
var createIsFaded = (highlightScope, highlightedItem) => (item) => {
  if (!highlightScope || !highlightedItem || !item) {
    return false;
  }
  if (highlightScope.fade === "series") {
    return item.seriesId === highlightedItem.seriesId && item.dataIndex !== highlightedItem.dataIndex;
  }
  if (highlightScope.fade === "global") {
    return item.seriesId !== highlightedItem.seriesId || item.dataIndex !== highlightedItem.dataIndex;
  }
  return false;
};

// node_modules/@mui/x-charts/esm/internals/plugins/featurePlugins/useChartHighlight/useChartHighlight.selectors.js
var selectHighlight = (state) => state.highlight;
var selectSeries = (state) => state.series;
var selectorChartsHighlightScopePerSeriesId = createSelector2(selectSeries, (series) => {
  const map4 = /* @__PURE__ */ new Map();
  Object.keys(series.processedSeries).forEach((seriesType) => {
    const seriesData = series.processedSeries[seriesType];
    Object.keys((seriesData == null ? void 0 : seriesData.series) ?? {}).forEach((seriesId) => {
      const seriesItem = seriesData == null ? void 0 : seriesData.series[seriesId];
      map4.set(seriesId, seriesItem == null ? void 0 : seriesItem.highlightScope);
    });
  });
  return map4;
});
var selectorChartsHighlightedItem = createSelector2(selectHighlight, (highlight) => highlight.item);
var selectorChartsHighlightScope = createSelector2([selectorChartsHighlightScopePerSeriesId, selectorChartsHighlightedItem], (seriesIdToHighlightScope, highlightedItem) => {
  if (!highlightedItem) {
    return null;
  }
  const highlightScope = seriesIdToHighlightScope.get(highlightedItem.seriesId);
  if (highlightScope === void 0) {
    return null;
  }
  return highlightScope;
});
var selectorChartsIsHighlightedCallback = createSelector2([selectorChartsHighlightScope, selectorChartsHighlightedItem], createIsHighlighted);
var selectorChartsIsFadedCallback = createSelector2([selectorChartsHighlightScope, selectorChartsHighlightedItem], createIsFaded);
var selectorChartsIsHighlighted = createSelector2([selectorChartsHighlightScope, selectorChartsHighlightedItem, (_2, item) => item], (highlightScope, highlightedItem, item) => createIsHighlighted(highlightScope, highlightedItem)(item));
var selectorChartsIsFaded = createSelector2([selectorChartsHighlightScope, selectorChartsHighlightedItem, (_2, item) => item], (highlightScope, highlightedItem, item) => createIsFaded(highlightScope, highlightedItem)(item));

// node_modules/@mui/x-charts/esm/hooks/useItemHighlighted.js
function useItemHighlighted(item) {
  const store = useStore();
  const isHighlighted = useSelector(store, selectorChartsIsHighlighted, item);
  const isFaded = useSelector(store, selectorChartsIsFaded, item);
  return {
    isHighlighted,
    isFaded: !isHighlighted && isFaded
  };
}

// node_modules/@mui/x-charts/esm/hooks/useItemHighlightedGetter.js
function useItemHighlightedGetter() {
  const store = useStore();
  const isHighlighted = useSelector(store, selectorChartsIsHighlightedCallback);
  const isFaded = useSelector(store, selectorChartsIsFadedCallback);
  return {
    isHighlighted,
    isFaded
  };
}

// node_modules/@mui/x-charts/esm/hooks/useLegend.js
function getSeriesToDisplay(series, seriesConfig5) {
  return Object.keys(series).flatMap((seriesType) => {
    const getter = seriesConfig5[seriesType].legendGetter;
    return getter === void 0 ? [] : getter(series[seriesType]);
  });
}
function useLegend() {
  const series = useSeries();
  const store = useStore();
  const seriesConfig5 = useSelector(store, selectorChartSeriesConfig);
  return {
    items: getSeriesToDisplay(series, seriesConfig5)
  };
}

// node_modules/@mui/x-charts/esm/hooks/useChartGradientId.js
var React17 = __toESM(require_react(), 1);
function useChartGradientIdBuilder() {
  const chartId = useChartId2();
  return React17.useCallback((axisId) => `${chartId}-gradient-${axisId}`, [chartId]);
}
function useChartGradientIdObjectBoundBuilder() {
  const chartId = useChartId2();
  return React17.useCallback((axisId) => `${chartId}-gradient-${axisId}-object-bound`, [chartId]);
}
function useChartGradientId(axisId) {
  return useChartGradientIdBuilder()(axisId);
}
function useChartGradientIdObjectBound(axisId) {
  return useChartGradientIdObjectBoundBuilder()(axisId);
}

// node_modules/@mui/utils/esm/useForkRef/useForkRef.js
var React18 = __toESM(require_react(), 1);
function useForkRef(...refs) {
  const cleanupRef = React18.useRef(void 0);
  const refEffect = React18.useCallback((instance) => {
    const cleanups = refs.map((ref) => {
      if (ref == null) {
        return null;
      }
      if (typeof ref === "function") {
        const refCallback = ref;
        const refCleanup = refCallback(instance);
        return typeof refCleanup === "function" ? refCleanup : () => {
          refCallback(null);
        };
      }
      ref.current = instance;
      return () => {
        ref.current = null;
      };
    });
    return () => {
      cleanups.forEach((refCleanup) => refCleanup == null ? void 0 : refCleanup());
    };
  }, refs);
  return React18.useMemo(() => {
    if (refs.every((ref) => ref == null)) {
      return null;
    }
    return (value) => {
      if (cleanupRef.current) {
        cleanupRef.current();
        cleanupRef.current = void 0;
      }
      if (value != null) {
        cleanupRef.current = refEffect(value);
      }
    };
  }, refs);
}

// node_modules/@mui/x-charts/esm/internals/animation/useAnimateInternal.js
var React19 = __toESM(require_react(), 1);

// node_modules/@mui/x-charts/esm/internals/animation/animation.js
var import_bezier_easing = __toESM(require_src(), 1);
var ANIMATION_DURATION_MS = 300;
var ANIMATION_TIMING_FUNCTION = "cubic-bezier(0.66, 0, 0.34, 1)";
var ANIMATION_TIMING_FUNCTION_JS = (0, import_bezier_easing.default)(0.66, 0, 0.34, 1);

// node_modules/d3-timer/src/timer.js
var frame = 0;
var timeout = 0;
var interval = 0;
var pokeDelay = 1e3;
var taskHead;
var taskTail;
var clockLast = 0;
var clockNow = 0;
var clockSkew = 0;
var clock = typeof performance === "object" && performance.now ? performance : Date;
var setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f2) {
  setTimeout(f2, 17);
};
function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer() {
  this._call = this._time = this._next = null;
}
Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time2) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time2 = (time2 == null ? now() : +time2) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;
      else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time2;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};
function timer(callback, delay, time2) {
  var t = new Timer();
  t.restart(callback, delay, time2);
  return t;
}
function timerFlush() {
  now();
  ++frame;
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0) t._call.call(void 0, e);
    t = t._next;
  }
  --frame;
}
function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}
function poke() {
  var now2 = clock.now(), delay = now2 - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now2;
}
function nap() {
  var t03, t13 = taskHead, t22, time2 = Infinity;
  while (t13) {
    if (t13._call) {
      if (time2 > t13._time) time2 = t13._time;
      t03 = t13, t13 = t13._next;
    } else {
      t22 = t13._next, t13._next = null;
      t13 = t03 ? t03._next = t22 : taskHead = t22;
    }
  }
  taskTail = t03;
  sleep(time2);
}
function sleep(time2) {
  if (frame) return;
  if (timeout) timeout = clearTimeout(timeout);
  var delay = time2 - clockNow;
  if (delay > 24) {
    if (time2 < Infinity) timeout = setTimeout(wake, time2 - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}

// node_modules/d3-timer/src/timeout.js
function timeout_default(callback, delay, time2) {
  var t = new Timer();
  delay = delay == null ? 0 : +delay;
  t.restart((elapsed) => {
    t.stop();
    callback(elapsed + delay);
  }, delay, time2);
  return t;
}

// node_modules/@mui/x-charts/esm/internals/animation/Transition.js
var Transition = class {
  /**
   * Create a new ResumableTransition.
   * @param duration Duration in milliseconds
   * @param easingFn The easing function
   * @param onTick Callback function called on each animation frame with the eased time in range [0, 1].
   */
  constructor(duration2, easingFn, onTick) {
    this.duration = void 0;
    this.elapsed = 0;
    this.easingFn = void 0;
    this.timer = null;
    this.onTickCallback = void 0;
    this.duration = duration2;
    this.easingFn = easingFn;
    this.onTickCallback = onTick;
    this.resume();
  }
  get running() {
    return this.timer !== null;
  }
  timerCallback(elapsed) {
    this.elapsed = Math.min(elapsed, this.duration);
    const t = this.duration === 0 ? 1 : this.elapsed / this.duration;
    const easedT = this.easingFn(t);
    this.onTickCallback(easedT);
    if (this.elapsed >= this.duration) {
      this.stop();
    }
  }
  /**
   * Resume the transition
   */
  resume() {
    if (this.running || this.elapsed >= this.duration) {
      return this;
    }
    const time2 = now() - this.elapsed;
    this.timer = timer((elapsed) => this.timerCallback(elapsed), 0, time2);
    timerFlush();
    return this;
  }
  /**
   * Stops the transition.
   */
  stop() {
    if (!this.running) {
      return this;
    }
    if (this.timer) {
      this.timer.stop();
      this.timer = null;
    }
    return this;
  }
  /**
   * Immediately finishes the transition and calls the tick callback with the final value.
   */
  finish() {
    this.stop();
    timeout_default(() => this.timerCallback(this.duration));
    timerFlush();
    return this;
  }
};

// node_modules/@mui/x-charts/esm/internals/shallowEqual.js
function shallowEqual(objA, objB) {
  if (Object.is(objA, objB)) {
    return true;
  }
  if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
    return false;
  }
  const keysA = Object.keys(objA);
  const keysB = Object.keys(objB);
  if (keysA.length !== keysB.length) {
    return false;
  }
  for (let i2 = 0; i2 < keysA.length; i2 += 1) {
    const currentKey = keysA[i2];
    if (!Object.prototype.hasOwnProperty.call(objB, currentKey) || // @ts-ignore
    !Object.is(objA[currentKey], objB[currentKey])) {
      return false;
    }
  }
  return true;
}

// node_modules/@mui/x-charts/esm/internals/animation/useAnimateInternal.js
function useAnimateInternal(props, {
  createInterpolator,
  applyProps,
  skip,
  initialProps = props
}) {
  const lastInterpolatedPropsRef = React19.useRef(initialProps);
  const transitionRef = React19.useRef(null);
  const elementRef = React19.useRef(null);
  const lastPropsRef = React19.useRef(props);
  useEnhancedEffect_default(() => {
    lastPropsRef.current = props;
  }, [props]);
  useEnhancedEffect_default(() => {
    var _a;
    if (skip) {
      (_a = transitionRef.current) == null ? void 0 : _a.finish();
      transitionRef.current = null;
      elementRef.current = null;
      lastInterpolatedPropsRef.current = props;
    }
  }, [props, skip]);
  const animate = React19.useCallback((element) => {
    const lastInterpolatedProps = lastInterpolatedPropsRef.current;
    const interpolate = createInterpolator(lastInterpolatedProps, props);
    transitionRef.current = new Transition(ANIMATION_DURATION_MS, ANIMATION_TIMING_FUNCTION_JS, (t) => {
      const interpolatedProps = interpolate(t);
      lastInterpolatedPropsRef.current = interpolatedProps;
      applyProps(element, interpolatedProps);
    });
  }, [applyProps, createInterpolator, props]);
  const setRef2 = React19.useCallback((element) => {
    var _a, _b, _c, _d;
    if (element === null) {
      (_a = transitionRef.current) == null ? void 0 : _a.stop();
      return;
    }
    const lastElement = elementRef.current;
    if (lastElement === element) {
      if (shallowEqual(lastPropsRef.current, props)) {
        (_b = transitionRef.current) == null ? void 0 : _b.resume();
        return;
      }
      (_c = transitionRef.current) == null ? void 0 : _c.stop();
    }
    if (lastElement) {
      (_d = transitionRef.current) == null ? void 0 : _d.stop();
    }
    elementRef.current = element;
    if (transitionRef.current || !skip) {
      animate(element);
    }
  }, [animate, props, skip]);
  return setRef2;
}

// node_modules/@mui/x-charts/esm/hooks/animation/useAnimate.js
function useAnimate(props, {
  createInterpolator,
  transformProps,
  applyProps,
  skip,
  initialProps = props,
  ref
}) {
  const transform = transformProps ?? ((p2) => p2);
  const animateRef = useAnimateInternal(props, {
    initialProps,
    createInterpolator,
    applyProps: (element, animatedProps) => applyProps(element, transform(animatedProps)),
    skip
  });
  const usedProps = skip ? props : initialProps;
  return _extends({}, transformProps(usedProps), {
    ref: useForkRef(animateRef, ref)
  });
}

// node_modules/@mui/x-charts/esm/hooks/animation/useAnimateArea.js
function useAnimateArea(props) {
  return useAnimate({
    d: props.d
  }, {
    createInterpolator: (lastProps, newProps) => {
      const interpolate = string_default(lastProps.d, newProps.d);
      return (t) => ({
        d: interpolate(t)
      });
    },
    applyProps: (element, {
      d
    }) => element.setAttribute("d", d),
    transformProps: (p2) => p2,
    skip: props.skipAnimation,
    ref: props.ref
  });
}

// node_modules/@mui/x-charts/esm/hooks/animation/useAnimateBar.js
function barPropsInterpolator(from2, to) {
  const interpolateX = number_default(from2.x, to.x);
  const interpolateY = number_default(from2.y, to.y);
  const interpolateWidth = number_default(from2.width, to.width);
  const interpolateHeight = number_default(from2.height, to.height);
  return (t) => {
    return {
      x: interpolateX(t),
      y: interpolateY(t),
      width: interpolateWidth(t),
      height: interpolateHeight(t)
    };
  };
}
function useAnimateBar(props) {
  const initialProps = {
    x: props.layout === "vertical" ? props.x : props.xOrigin,
    y: props.layout === "vertical" ? props.yOrigin : props.y,
    width: props.layout === "vertical" ? props.width : 0,
    height: props.layout === "vertical" ? 0 : props.height
  };
  return useAnimate({
    x: props.x,
    y: props.y,
    width: props.width,
    height: props.height
  }, {
    createInterpolator: barPropsInterpolator,
    applyProps(element, animatedProps) {
      element.setAttribute("x", animatedProps.x.toString());
      element.setAttribute("y", animatedProps.y.toString());
      element.setAttribute("width", animatedProps.width.toString());
      element.setAttribute("height", animatedProps.height.toString());
    },
    transformProps: (p2) => p2,
    initialProps,
    skip: props.skipAnimation,
    ref: props.ref
  });
}

// node_modules/@mui/x-charts/esm/hooks/animation/useAnimateBarLabel.js
function barLabelPropsInterpolator(from2, to) {
  const interpolateX = number_default(from2.x, to.x);
  const interpolateY = number_default(from2.y, to.y);
  const interpolateWidth = number_default(from2.width, to.width);
  const interpolateHeight = number_default(from2.height, to.height);
  return (t) => {
    return {
      x: interpolateX(t),
      y: interpolateY(t),
      width: interpolateWidth(t),
      height: interpolateHeight(t)
    };
  };
}
function useAnimateBarLabel(props) {
  const initialProps = {
    x: props.layout === "vertical" ? props.x + props.width / 2 : props.xOrigin,
    y: props.layout === "vertical" ? props.yOrigin : props.y + props.height / 2,
    width: props.width,
    height: props.height
  };
  const currentProps = {
    x: props.x + props.width / 2,
    y: props.y + props.height / 2,
    width: props.width,
    height: props.height
  };
  return useAnimate(currentProps, {
    createInterpolator: barLabelPropsInterpolator,
    transformProps: (p2) => p2,
    applyProps(element, animatedProps) {
      element.setAttribute("x", animatedProps.x.toString());
      element.setAttribute("y", animatedProps.y.toString());
      element.setAttribute("width", animatedProps.width.toString());
      element.setAttribute("height", animatedProps.height.toString());
    },
    initialProps,
    skip: props.skipAnimation,
    ref: props.ref
  });
}

// node_modules/@mui/x-charts/esm/hooks/animation/useAnimateLine.js
function useAnimateLine(props) {
  return useAnimate({
    d: props.d
  }, {
    createInterpolator: (lastProps, newProps) => {
      const interpolate = string_default(lastProps.d, newProps.d);
      return (t) => ({
        d: interpolate(t)
      });
    },
    applyProps: (element, {
      d
    }) => element.setAttribute("d", d),
    skip: props.skipAnimation,
    transformProps: (p2) => p2,
    ref: props.ref
  });
}

// node_modules/@mui/x-charts/esm/hooks/animation/useAnimatePieArc.js
function pieArcPropsInterpolator(from2, to) {
  const interpolateStartAngle = number_default(from2.startAngle, to.startAngle);
  const interpolateEndAngle = number_default(from2.endAngle, to.endAngle);
  const interpolateInnerRadius = number_default(from2.innerRadius, to.innerRadius);
  const interpolateOuterRadius = number_default(from2.outerRadius, to.outerRadius);
  const interpolatePaddingAngle = number_default(from2.paddingAngle, to.paddingAngle);
  const interpolateCornerRadius = number_default(from2.cornerRadius, to.cornerRadius);
  return (t) => {
    return {
      startAngle: interpolateStartAngle(t),
      endAngle: interpolateEndAngle(t),
      innerRadius: interpolateInnerRadius(t),
      outerRadius: interpolateOuterRadius(t),
      paddingAngle: interpolatePaddingAngle(t),
      cornerRadius: interpolateCornerRadius(t)
    };
  };
}
function useAnimatePieArc(props) {
  const initialProps = {
    startAngle: (props.startAngle + props.endAngle) / 2,
    endAngle: (props.startAngle + props.endAngle) / 2,
    innerRadius: props.innerRadius,
    outerRadius: props.outerRadius,
    paddingAngle: props.paddingAngle,
    cornerRadius: props.cornerRadius
  };
  return useAnimate({
    startAngle: props.startAngle,
    endAngle: props.endAngle,
    innerRadius: props.innerRadius,
    outerRadius: props.outerRadius,
    paddingAngle: props.paddingAngle,
    cornerRadius: props.cornerRadius
  }, {
    createInterpolator: pieArcPropsInterpolator,
    transformProps: (p2) => ({
      d: arc_default().cornerRadius(p2.cornerRadius)({
        padAngle: p2.paddingAngle,
        innerRadius: p2.innerRadius,
        outerRadius: p2.outerRadius,
        startAngle: p2.startAngle,
        endAngle: p2.endAngle
      }),
      visibility: p2.startAngle === p2.endAngle ? "hidden" : "visible"
    }),
    applyProps(element, p2) {
      element.setAttribute("d", p2.d);
      element.setAttribute("visibility", p2.visibility);
    },
    initialProps,
    skip: props.skipAnimation,
    ref: props.ref
  });
}

// node_modules/@mui/x-charts/esm/hooks/animation/useAnimatePieArcLabel.js
function pieArcLabelPropsInterpolator(from2, to) {
  const interpolateStartAngle = number_default(from2.startAngle, to.startAngle);
  const interpolateEndAngle = number_default(from2.endAngle, to.endAngle);
  const interpolateInnerRadius = number_default(from2.innerRadius, to.innerRadius);
  const interpolateOuterRadius = number_default(from2.outerRadius, to.outerRadius);
  const interpolatePaddingAngle = number_default(from2.paddingAngle, to.paddingAngle);
  const interpolateCornerRadius = number_default(from2.cornerRadius, to.cornerRadius);
  return (t) => {
    return {
      startAngle: interpolateStartAngle(t),
      endAngle: interpolateEndAngle(t),
      innerRadius: interpolateInnerRadius(t),
      outerRadius: interpolateOuterRadius(t),
      paddingAngle: interpolatePaddingAngle(t),
      cornerRadius: interpolateCornerRadius(t)
    };
  };
}
function useAnimatePieArcLabel(props) {
  const initialProps = {
    startAngle: (props.startAngle + props.endAngle) / 2,
    endAngle: (props.startAngle + props.endAngle) / 2,
    innerRadius: props.arcLabelRadius ?? props.innerRadius,
    outerRadius: props.arcLabelRadius ?? props.outerRadius,
    paddingAngle: props.paddingAngle,
    cornerRadius: props.cornerRadius
  };
  return useAnimate({
    startAngle: props.startAngle,
    endAngle: props.endAngle,
    innerRadius: (props == null ? void 0 : props.arcLabelRadius) ?? props.innerRadius,
    outerRadius: (props == null ? void 0 : props.arcLabelRadius) ?? props.outerRadius,
    paddingAngle: props.paddingAngle,
    cornerRadius: props.cornerRadius
  }, {
    createInterpolator: pieArcLabelPropsInterpolator,
    transformProps: (animatedProps) => {
      const [x3, y3] = arc_default().cornerRadius(animatedProps.cornerRadius).centroid({
        padAngle: animatedProps.paddingAngle,
        startAngle: animatedProps.startAngle,
        endAngle: animatedProps.endAngle,
        innerRadius: animatedProps.innerRadius,
        outerRadius: animatedProps.outerRadius
      });
      return {
        x: x3,
        y: y3
      };
    },
    applyProps(element, {
      x: x3,
      y: y3
    }) {
      element.setAttribute("x", x3.toString());
      element.setAttribute("y", y3.toString());
    },
    initialProps,
    skip: props.skipAnimation,
    ref: props.ref
  });
}

// node_modules/@mui/x-charts/esm/hooks/useChartRootRef.js
function useChartRootRef() {
  const context = useChartContext();
  return context.chartRootRef;
}

// node_modules/@mui/x-charts/esm/hooks/useChartsLocalization.js
var React44 = __toESM(require_react(), 1);

// node_modules/@mui/x-charts/esm/ChartsLocalizationProvider/ChartsLocalizationProvider.js
var React43 = __toESM(require_react(), 1);
var import_prop_types19 = __toESM(require_prop_types(), 1);

// node_modules/@mui/material/esm/styles/identifier.js
var identifier_default = "$$material";

// node_modules/styled-components/node_modules/tslib/tslib.es6.mjs
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s3, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s3 = arguments[i2];
      for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2)) t[p2] = s3[p2];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __spreadArray(to, from2, pack) {
  if (pack || arguments.length === 2) for (var i2 = 0, l2 = from2.length, ar; i2 < l2; i2++) {
    if (ar || !(i2 in from2)) {
      if (!ar) ar = Array.prototype.slice.call(from2, 0, i2);
      ar[i2] = from2[i2];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from2));
}

// node_modules/styled-components/dist/styled-components.browser.esm.js
init_emotion_is_prop_valid_esm();
var import_react = __toESM(require_react());
var import_shallowequal = __toESM(require_shallowequal());

// node_modules/styled-components/node_modules/stylis/src/Enum.js
var MS = "-ms-";
var MOZ = "-moz-";
var WEBKIT = "-webkit-";
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var KEYFRAMES = "@keyframes";
var LAYER = "@layer";

// node_modules/styled-components/node_modules/stylis/src/Utility.js
var abs2 = Math.abs;
var from = String.fromCharCode;
var assign = Object.assign;
function hash(value, length2) {
  return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
}
function trim(value) {
  return value.trim();
}
function match(value, pattern) {
  return (value = pattern.exec(value)) ? value[0] : value;
}
function replace(value, pattern, replacement) {
  return value.replace(pattern, replacement);
}
function indexof(value, search, position3) {
  return value.indexOf(search, position3);
}
function charat(value, index2) {
  return value.charCodeAt(index2) | 0;
}
function substr(value, begin, end2) {
  return value.slice(begin, end2);
}
function strlen(value) {
  return value.length;
}
function sizeof(value) {
  return value.length;
}
function append2(value, array2) {
  return array2.push(value), value;
}
function combine(array2, callback) {
  return array2.map(callback).join("");
}
function filter2(array2, pattern) {
  return array2.filter(function(value) {
    return !match(value, pattern);
  });
}

// node_modules/styled-components/node_modules/stylis/src/Tokenizer.js
var line = 1;
var column = 1;
var length = 0;
var position = 0;
var character = 0;
var characters = "";
function node(value, root, parent, type, props, children2, length2, siblings) {
  return { value, root, parent, type, props, children: children2, line, column, length: length2, return: "", siblings };
}
function copy3(root, props) {
  return assign(node("", null, null, "", null, null, 0, root.siblings), root, { length: -root.length }, props);
}
function lift(root) {
  while (root.root)
    root = copy3(root.root, { children: [root] });
  append2(root, root.siblings);
}
function char() {
  return character;
}
function prev() {
  character = position > 0 ? charat(characters, --position) : 0;
  if (column--, character === 10)
    column = 1, line--;
  return character;
}
function next() {
  character = position < length ? charat(characters, position++) : 0;
  if (column++, character === 10)
    column = 1, line++;
  return character;
}
function peek() {
  return charat(characters, position);
}
function caret() {
  return position;
}
function slice3(begin, end2) {
  return substr(characters, begin, end2);
}
function token(type) {
  switch (type) {
    // \0 \t \n \r \s whitespace token
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    // ! + , / > @ ~ isolate token
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    // ; { } breakpoint token
    case 59:
    case 123:
    case 125:
      return 4;
    // : accompanied token
    case 58:
      return 3;
    // " ' ( [ opening delimit token
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    // ) ] closing delimit token
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(value) {
  return line = column = 1, length = strlen(characters = value), position = 0, [];
}
function dealloc(value) {
  return characters = "", value;
}
function delimit(type) {
  return trim(slice3(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
}
function whitespace(type) {
  while (character = peek())
    if (character < 33)
      next();
    else
      break;
  return token(type) > 2 || token(character) > 3 ? "" : " ";
}
function escaping(index2, count2) {
  while (--count2 && next())
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
      break;
  return slice3(index2, caret() + (count2 < 6 && peek() == 32 && next() == 32));
}
function delimiter(type) {
  while (next())
    switch (character) {
      // ] ) " '
      case type:
        return position;
      // " '
      case 34:
      case 39:
        if (type !== 34 && type !== 39)
          delimiter(character);
        break;
      // (
      case 40:
        if (type === 41)
          delimiter(type);
        break;
      // \
      case 92:
        next();
        break;
    }
  return position;
}
function commenter(type, index2) {
  while (next())
    if (type + character === 47 + 10)
      break;
    else if (type + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice3(index2, position - 1) + "*" + from(type === 47 ? type : next());
}
function identifier(index2) {
  while (!token(peek()))
    next();
  return slice3(index2, position);
}

// node_modules/styled-components/node_modules/stylis/src/Parser.js
function compile(value) {
  return dealloc(parse("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
function parse(value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
  var index2 = 0;
  var offset2 = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property = 0;
  var previous = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type = "";
  var props = rules;
  var children2 = rulesets;
  var reference2 = rule;
  var characters2 = type;
  while (scanning)
    switch (previous = character2, character2 = next()) {
      // (
      case 40:
        if (previous != 108 && charat(characters2, length2 - 1) == 58) {
          if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f", abs2(index2 ? points[index2 - 1] : 0)) != -1)
            ampersand = -1;
          break;
        }
      // " ' [
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      // \t \n \r \s
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace(previous);
        break;
      // \
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      // /
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append2(comment(commenter(next(), caret()), root, parent, declarations), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      // {
      case 123 * variable:
        points[index2++] = strlen(characters2) * ampersand;
      // } ; \0
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          // \0 }
          case 0:
          case 125:
            scanning = 0;
          // ;
          case 59 + offset2:
            if (ampersand == -1) characters2 = replace(characters2, /\f/g, "");
            if (property > 0 && strlen(characters2) - length2)
              append2(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1, declarations) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2, declarations), declarations);
            break;
          // @ ;
          case 59:
            characters2 += ";";
          // { rule/at-rule
          default:
            append2(reference2 = ruleset(characters2, root, parent, index2, offset2, rules, points, type, props = [], children2 = [], length2, rulesets), rulesets);
            if (character2 === 123)
              if (offset2 === 0)
                parse(characters2, root, reference2, reference2, props, rulesets, length2, points, children2);
              else
                switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                  // d l m s
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    parse(value, reference2, reference2, rule && append2(ruleset(value, reference2, reference2, 0, 0, rules, points, type, rules, props = [], length2, children2), children2), rules, children2, length2, points, rule ? props : children2);
                    break;
                  default:
                    parse(characters2, reference2, reference2, reference2, [""], children2, 0, points, children2);
                }
        }
        index2 = offset2 = property = 0, variable = ampersand = 1, type = characters2 = "", length2 = pseudo;
        break;
      // :
      case 58:
        length2 = 1 + strlen(characters2), property = previous;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev() == 125)
            continue;
        }
        switch (characters2 += from(character2), character2 * variable) {
          // &
          case 38:
            ampersand = offset2 > 0 ? 1 : (characters2 += "\f", -1);
            break;
          // ,
          case 44:
            points[index2++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          // @
          case 64:
            if (peek() === 45)
              characters2 += delimit(next());
            atrule = peek(), offset2 = length2 = strlen(type = characters2 += identifier(caret())), character2++;
            break;
          // -
          case 45:
            if (previous === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset(value, root, parent, index2, offset2, rules, points, type, props, children2, length2, siblings) {
  var post = offset2 - 1;
  var rule = offset2 === 0 ? rules : [""];
  var size = sizeof(rule);
  for (var i2 = 0, j2 = 0, k3 = 0; i2 < index2; ++i2)
    for (var x3 = 0, y3 = substr(value, post + 1, post = abs2(j2 = points[i2])), z2 = value; x3 < size; ++x3)
      if (z2 = trim(j2 > 0 ? rule[x3] + " " + y3 : replace(y3, /&\f/g, rule[x3])))
        props[k3++] = z2;
  return node(value, root, parent, offset2 === 0 ? RULESET : type, props, children2, length2, siblings);
}
function comment(value, root, parent, siblings) {
  return node(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0, siblings);
}
function declaration(value, root, parent, length2, siblings) {
  return node(value, root, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2, siblings);
}

// node_modules/styled-components/node_modules/stylis/src/Prefixer.js
function prefix(value, length2, children2) {
  switch (hash(value, length2)) {
    // color-adjust
    case 5103:
      return WEBKIT + "print-" + value + value;
    // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value + value;
    // tab-size
    case 4789:
      return MOZ + value + value;
    // appearance, user-select, transform, hyphens, text-size-adjust
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value + MOZ + value + MS + value + value;
    // writing-mode
    case 5936:
      switch (charat(value, length2 + 11)) {
        // vertical-l(r)
        case 114:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
        // vertical-r(l)
        case 108:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
        // horizontal(-)tb
        case 45:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
      }
    // flex, flex-direction, scroll-snap-type, writing-mode
    case 6828:
    case 4268:
    case 2903:
      return WEBKIT + value + MS + value + value;
    // order
    case 6165:
      return WEBKIT + value + MS + "flex-" + value + value;
    // align-items
    case 5187:
      return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
    // align-self
    case 5443:
      return WEBKIT + value + MS + "flex-item-" + replace(value, /flex-|-self/g, "") + (!match(value, /flex-|baseline/) ? MS + "grid-row-" + replace(value, /flex-|-self/g, "") : "") + value;
    // align-content
    case 4675:
      return WEBKIT + value + MS + "flex-line-pack" + replace(value, /align-content|flex-|-self/g, "") + value;
    // flex-shrink
    case 5548:
      return WEBKIT + value + MS + replace(value, "shrink", "negative") + value;
    // flex-basis
    case 5292:
      return WEBKIT + value + MS + replace(value, "basis", "preferred-size") + value;
    // flex-grow
    case 6060:
      return WEBKIT + "box-" + replace(value, "-grow", "") + WEBKIT + value + MS + replace(value, "grow", "positive") + value;
    // transition
    case 4554:
      return WEBKIT + replace(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
    // cursor
    case 6187:
      return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
    // background, background-image
    case 5495:
    case 3959:
      return replace(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    // justify-content
    case 4968:
      return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
    // justify-self
    case 4200:
      if (!match(value, /flex-|baseline/)) return MS + "grid-column-align" + substr(value, length2) + value;
      break;
    // grid-template-(columns|rows)
    case 2592:
    case 3360:
      return MS + replace(value, "template-", "") + value;
    // grid-(row|column)-start
    case 4384:
    case 3616:
      if (children2 && children2.some(function(element, index2) {
        return length2 = index2, match(element.props, /grid-\w+-end/);
      })) {
        return ~indexof(value + (children2 = children2[length2].value), "span", 0) ? value : MS + replace(value, "-start", "") + value + MS + "grid-row-span:" + (~indexof(children2, "span", 0) ? match(children2, /\d+/) : +match(children2, /\d+/) - +match(value, /\d+/)) + ";";
      }
      return MS + replace(value, "-start", "") + value;
    // grid-(row|column)-end
    case 4896:
    case 4128:
      return children2 && children2.some(function(element) {
        return match(element.props, /grid-\w+-start/);
      }) ? value : MS + replace(replace(value, "-end", "-span"), "span ", "") + value;
    // (margin|padding)-inline-(start|end)
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
    // (min|max)?(width|height|inline-size|block-size)
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(value) - 1 - length2 > 6)
        switch (charat(value, length2 + 1)) {
          // (m)ax-content, (m)in-content
          case 109:
            if (charat(value, length2 + 4) !== 45)
              break;
          // (f)ill-available, (f)it-content
          case 102:
            return replace(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
          // (s)tretch
          case 115:
            return ~indexof(value, "stretch", 0) ? prefix(replace(value, "stretch", "fill-available"), length2, children2) + value : value;
        }
      break;
    // grid-(column|row)
    case 5152:
    case 5920:
      return replace(value, /(.+?):(\d+)(\s*\/\s*(span)?\s*(\d+))?(.*)/, function(_2, a3, b2, c3, d, e, f2) {
        return MS + a3 + ":" + b2 + f2 + (c3 ? MS + a3 + "-span:" + (d ? e : +e - +b2) + f2 : "") + value;
      });
    // position: sticky
    case 4949:
      if (charat(value, length2 + 6) === 121)
        return replace(value, ":", ":" + WEBKIT) + value;
      break;
    // display: (flex|inline-flex|grid|inline-grid)
    case 6444:
      switch (charat(value, charat(value, 14) === 45 ? 18 : 11)) {
        // (inline-)?fle(x)
        case 120:
          return replace(value, /(.+:)([^;\s!]+)(;|(\s+)?!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
        // (inline-)?gri(d)
        case 100:
          return replace(value, ":", ":" + MS) + value;
      }
      break;
    // scroll-margin, scroll-margin-(top|right|bottom|left)
    case 5719:
    case 2647:
    case 2135:
    case 3927:
    case 2391:
      return replace(value, "scroll-", "scroll-snap-") + value;
  }
  return value;
}

// node_modules/styled-components/node_modules/stylis/src/Serializer.js
function serialize(children2, callback) {
  var output = "";
  for (var i2 = 0; i2 < children2.length; i2++)
    output += callback(children2[i2], i2, children2, callback) || "";
  return output;
}
function stringify(element, index2, children2, callback) {
  switch (element.type) {
    case LAYER:
      if (element.children.length) break;
    case IMPORT:
    case DECLARATION:
      return element.return = element.return || element.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element.return = element.value + "{" + serialize(element.children, callback) + "}";
    case RULESET:
      if (!strlen(element.value = element.props.join(","))) return "";
  }
  return strlen(children2 = serialize(element.children, callback)) ? element.return = element.value + "{" + children2 + "}" : "";
}

// node_modules/styled-components/node_modules/stylis/src/Middleware.js
function middleware(collection) {
  var length2 = sizeof(collection);
  return function(element, index2, children2, callback) {
    var output = "";
    for (var i2 = 0; i2 < length2; i2++)
      output += collection[i2](element, index2, children2, callback) || "";
    return output;
  };
}
function rulesheet(callback) {
  return function(element) {
    if (!element.root) {
      if (element = element.return)
        callback(element);
    }
  };
}
function prefixer(element, index2, children2, callback) {
  if (element.length > -1) {
    if (!element.return)
      switch (element.type) {
        case DECLARATION:
          element.return = prefix(element.value, element.length, children2);
          return;
        case KEYFRAMES:
          return serialize([copy3(element, { value: replace(element.value, "@", "@" + WEBKIT) })], callback);
        case RULESET:
          if (element.length)
            return combine(children2 = element.props, function(value) {
              switch (match(value, callback = /(::plac\w+|:read-\w+)/)) {
                // :read-(only|write)
                case ":read-only":
                case ":read-write":
                  lift(copy3(element, { props: [replace(value, /:(read-\w+)/, ":" + MOZ + "$1")] }));
                  lift(copy3(element, { props: [value] }));
                  assign(element, { props: filter2(children2, callback) });
                  break;
                // :placeholder
                case "::placeholder":
                  lift(copy3(element, { props: [replace(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")] }));
                  lift(copy3(element, { props: [replace(value, /:(plac\w+)/, ":" + MOZ + "$1")] }));
                  lift(copy3(element, { props: [replace(value, /:(plac\w+)/, MS + "input-$1")] }));
                  lift(copy3(element, { props: [value] }));
                  assign(element, { props: filter2(children2, callback) });
                  break;
              }
              return "";
            });
      }
  }
}

// node_modules/styled-components/node_modules/@emotion/unitless/dist/emotion-unitless.esm.js
var unitlessKeys = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};

// node_modules/styled-components/dist/styled-components.browser.esm.js
var f = "undefined" != typeof process && void 0 !== process.env && (process.env.REACT_APP_SC_ATTR || process.env.SC_ATTR) || "data-styled";
var m = "active";
var y2 = "data-styled-version";
var v = "6.1.18";
var g = "/*!sc*/\n";
var S = "undefined" != typeof window && "undefined" != typeof document;
var w = Boolean("boolean" == typeof SC_DISABLE_SPEEDY ? SC_DISABLE_SPEEDY : "undefined" != typeof process && void 0 !== process.env && void 0 !== process.env.REACT_APP_SC_DISABLE_SPEEDY && "" !== process.env.REACT_APP_SC_DISABLE_SPEEDY ? "false" !== process.env.REACT_APP_SC_DISABLE_SPEEDY && process.env.REACT_APP_SC_DISABLE_SPEEDY : "undefined" != typeof process && void 0 !== process.env && void 0 !== process.env.SC_DISABLE_SPEEDY && "" !== process.env.SC_DISABLE_SPEEDY ? "false" !== process.env.SC_DISABLE_SPEEDY && process.env.SC_DISABLE_SPEEDY : true);
var b = {};
var E2 = /invalid hook call/i;
var N = /* @__PURE__ */ new Set();
var P = function(t, n) {
  if (true) {
    var o2 = n ? ' with the id of "'.concat(n, '"') : "", s3 = "The component ".concat(t).concat(o2, " has been created dynamically.\n") + "You may see this warning because you've called styled inside another component.\nTo resolve this only create new StyledComponents outside of any render method and function component.\nSee https://styled-components.com/docs/basics#define-styled-components-outside-of-the-render-method for more info.\n", i2 = console.error;
    try {
      var a3 = true;
      console.error = function(t4) {
        for (var n2 = [], o3 = 1; o3 < arguments.length; o3++) n2[o3 - 1] = arguments[o3];
        E2.test(t4) ? (a3 = false, N.delete(s3)) : i2.apply(void 0, __spreadArray([t4], n2, false));
      }, (0, import_react.useRef)(), a3 && !N.has(s3) && (console.warn(s3), N.add(s3));
    } catch (e) {
      E2.test(e.message) && N.delete(s3);
    } finally {
      console.error = i2;
    }
  }
};
var _ = Object.freeze([]);
var C2 = Object.freeze({});
function I(e, t, n) {
  return void 0 === n && (n = C2), e.theme !== n.theme && e.theme || t || n.theme;
}
var A2 = /* @__PURE__ */ new Set(["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "u", "ul", "use", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "marker", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan"]);
var O = /[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g;
var D2 = /(^-|-$)/g;
function R(e) {
  return e.replace(O, "-").replace(D2, "");
}
var T = /(a)(d)/gi;
var k2 = 52;
var j = function(e) {
  return String.fromCharCode(e + (e > 25 ? 39 : 97));
};
function x2(e) {
  var t, n = "";
  for (t = Math.abs(e); t > k2; t = t / k2 | 0) n = j(t % k2) + n;
  return (j(t % k2) + n).replace(T, "$1-$2");
}
var V;
var F = 5381;
var M = function(e, t) {
  for (var n = t.length; n; ) e = 33 * e ^ t.charCodeAt(--n);
  return e;
};
var z = function(e) {
  return M(F, e);
};
function $(e) {
  return x2(z(e) >>> 0);
}
function B2(e) {
  return "string" == typeof e && e || e.displayName || e.name || "Component";
}
function L(e) {
  return "string" == typeof e && e.charAt(0) === e.charAt(0).toLowerCase();
}
var G = "function" == typeof Symbol && Symbol.for;
var Y = G ? Symbol.for("react.memo") : 60115;
var W = G ? Symbol.for("react.forward_ref") : 60112;
var q = { childContextTypes: true, contextType: true, contextTypes: true, defaultProps: true, displayName: true, getDefaultProps: true, getDerivedStateFromError: true, getDerivedStateFromProps: true, mixins: true, propTypes: true, type: true };
var H = { name: true, length: true, prototype: true, caller: true, callee: true, arguments: true, arity: true };
var U = { $$typeof: true, compare: true, defaultProps: true, displayName: true, propTypes: true, type: true };
var J = ((V = {})[W] = { $$typeof: true, render: true, defaultProps: true, displayName: true, propTypes: true }, V[Y] = U, V);
function X(e) {
  return ("type" in (t = e) && t.type.$$typeof) === Y ? U : "$$typeof" in e ? J[e.$$typeof] : q;
  var t;
}
var Z = Object.defineProperty;
var K2 = Object.getOwnPropertyNames;
var Q = Object.getOwnPropertySymbols;
var ee = Object.getOwnPropertyDescriptor;
var te = Object.getPrototypeOf;
var ne = Object.prototype;
function oe(e, t, n) {
  if ("string" != typeof t) {
    if (ne) {
      var o2 = te(t);
      o2 && o2 !== ne && oe(e, o2, n);
    }
    var r3 = K2(t);
    Q && (r3 = r3.concat(Q(t)));
    for (var s3 = X(e), i2 = X(t), a3 = 0; a3 < r3.length; ++a3) {
      var c3 = r3[a3];
      if (!(c3 in H || n && n[c3] || i2 && c3 in i2 || s3 && c3 in s3)) {
        var l2 = ee(t, c3);
        try {
          Z(e, c3, l2);
        } catch (e3) {
        }
      }
    }
  }
  return e;
}
function re2(e) {
  return "function" == typeof e;
}
function se(e) {
  return "object" == typeof e && "styledComponentId" in e;
}
function ie(e, t) {
  return e && t ? "".concat(e, " ").concat(t) : e || t || "";
}
function ae(e, t) {
  if (0 === e.length) return "";
  for (var n = e[0], o2 = 1; o2 < e.length; o2++) n += t ? t + e[o2] : e[o2];
  return n;
}
function ce(e) {
  return null !== e && "object" == typeof e && e.constructor.name === Object.name && !("props" in e && e.$$typeof);
}
function le(e, t, n) {
  if (void 0 === n && (n = false), !n && !ce(e) && !Array.isArray(e)) return t;
  if (Array.isArray(t)) for (var o2 = 0; o2 < t.length; o2++) e[o2] = le(e[o2], t[o2]);
  else if (ce(t)) for (var o2 in t) e[o2] = le(e[o2], t[o2]);
  return e;
}
function ue(e, t) {
  Object.defineProperty(e, "toString", { value: t });
}
var pe = true ? { 1: "Cannot create styled-component for component: %s.\n\n", 2: "Can't collect styles once you've consumed a `ServerStyleSheet`'s styles! `ServerStyleSheet` is a one off instance for each server-side render cycle.\n\n- Are you trying to reuse it across renders?\n- Are you accidentally calling collectStyles twice?\n\n", 3: "Streaming SSR is only supported in a Node.js environment; Please do not try to call this method in the browser.\n\n", 4: "The `StyleSheetManager` expects a valid target or sheet prop!\n\n- Does this error occur on the client and is your target falsy?\n- Does this error occur on the server and is the sheet falsy?\n\n", 5: "The clone method cannot be used on the client!\n\n- Are you running in a client-like environment on the server?\n- Are you trying to run SSR on the client?\n\n", 6: "Trying to insert a new style tag, but the given Node is unmounted!\n\n- Are you using a custom target that isn't mounted?\n- Does your document not have a valid head element?\n- Have you accidentally removed a style tag manually?\n\n", 7: 'ThemeProvider: Please return an object from your "theme" prop function, e.g.\n\n```js\ntheme={() => ({})}\n```\n\n', 8: 'ThemeProvider: Please make your "theme" prop an object.\n\n', 9: "Missing document `<head>`\n\n", 10: "Cannot find a StyleSheet instance. Usually this happens if there are multiple copies of styled-components loaded at once. Check out this issue for how to troubleshoot and fix the common cases where this situation can happen: https://github.com/styled-components/styled-components/issues/1941#issuecomment-417862021\n\n", 11: "_This error was replaced with a dev-time warning, it will be deleted for v4 final._ [createGlobalStyle] received children which will not be rendered. Please use the component without passing children elements.\n\n", 12: "It seems you are interpolating a keyframe declaration (%s) into an untagged string. This was supported in styled-components v3, but is not longer supported in v4 as keyframes are now injected on-demand. Please wrap your string in the css\\`\\` helper which ensures the styles are injected correctly. See https://www.styled-components.com/docs/api#css\n\n", 13: "%s is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details.\n\n", 14: 'ThemeProvider: "theme" prop is required.\n\n', 15: "A stylis plugin has been supplied that is not named. We need a name for each plugin to be able to prevent styling collisions between different stylis configurations within the same app. Before you pass your plugin to `<StyleSheetManager stylisPlugins={[]}>`, please make sure each plugin is uniquely-named, e.g.\n\n```js\nObject.defineProperty(importedPlugin, 'name', { value: 'some-unique-name' });\n```\n\n", 16: "Reached the limit of how many styled components may be created at group %s.\nYou may only create up to 1,073,741,824 components. If you're creating components dynamically,\nas for instance in your render method then you may be running into this limitation.\n\n", 17: "CSSStyleSheet could not be found on HTMLStyleElement.\nHas styled-components' style tag been unmounted or altered by another script?\n", 18: "ThemeProvider: Please make sure your useTheme hook is within a `<ThemeProvider>`" } : {};
function de() {
  for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
  for (var n = e[0], o2 = [], r3 = 1, s3 = e.length; r3 < s3; r3 += 1) o2.push(e[r3]);
  return o2.forEach(function(e3) {
    n = n.replace(/%[a-z]/, e3);
  }), n;
}
function he(t) {
  for (var n = [], o2 = 1; o2 < arguments.length; o2++) n[o2 - 1] = arguments[o2];
  return false ? new Error("An error occurred. See https://github.com/styled-components/styled-components/blob/main/packages/styled-components/src/utils/errors.md#".concat(t, " for more information.").concat(n.length > 0 ? " Args: ".concat(n.join(", ")) : "")) : new Error(de.apply(void 0, __spreadArray([pe[t]], n, false)).trim());
}
var fe = function() {
  function e(e3) {
    this.groupSizes = new Uint32Array(512), this.length = 512, this.tag = e3;
  }
  return e.prototype.indexOfGroup = function(e3) {
    for (var t = 0, n = 0; n < e3; n++) t += this.groupSizes[n];
    return t;
  }, e.prototype.insertRules = function(e3, t) {
    if (e3 >= this.groupSizes.length) {
      for (var n = this.groupSizes, o2 = n.length, r3 = o2; e3 >= r3; ) if ((r3 <<= 1) < 0) throw he(16, "".concat(e3));
      this.groupSizes = new Uint32Array(r3), this.groupSizes.set(n), this.length = r3;
      for (var s3 = o2; s3 < r3; s3++) this.groupSizes[s3] = 0;
    }
    for (var i2 = this.indexOfGroup(e3 + 1), a3 = (s3 = 0, t.length); s3 < a3; s3++) this.tag.insertRule(i2, t[s3]) && (this.groupSizes[e3]++, i2++);
  }, e.prototype.clearGroup = function(e3) {
    if (e3 < this.length) {
      var t = this.groupSizes[e3], n = this.indexOfGroup(e3), o2 = n + t;
      this.groupSizes[e3] = 0;
      for (var r3 = n; r3 < o2; r3++) this.tag.deleteRule(n);
    }
  }, e.prototype.getGroup = function(e3) {
    var t = "";
    if (e3 >= this.length || 0 === this.groupSizes[e3]) return t;
    for (var n = this.groupSizes[e3], o2 = this.indexOfGroup(e3), r3 = o2 + n, s3 = o2; s3 < r3; s3++) t += "".concat(this.tag.getRule(s3)).concat(g);
    return t;
  }, e;
}();
var me = 1 << 30;
var ye = /* @__PURE__ */ new Map();
var ve = /* @__PURE__ */ new Map();
var ge = 1;
var Se = function(e) {
  if (ye.has(e)) return ye.get(e);
  for (; ve.has(ge); ) ge++;
  var t = ge++;
  if ((0 | t) < 0 || t > me) throw he(16, "".concat(t));
  return ye.set(e, t), ve.set(t, e), t;
};
var we = function(e, t) {
  ge = t + 1, ye.set(e, t), ve.set(t, e);
};
var be = "style[".concat(f, "][").concat(y2, '="').concat(v, '"]');
var Ee = new RegExp("^".concat(f, '\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)'));
var Ne = function(e, t, n) {
  for (var o2, r3 = n.split(","), s3 = 0, i2 = r3.length; s3 < i2; s3++) (o2 = r3[s3]) && e.registerName(t, o2);
};
var Pe = function(e, t) {
  for (var n, o2 = (null !== (n = t.textContent) && void 0 !== n ? n : "").split(g), r3 = [], s3 = 0, i2 = o2.length; s3 < i2; s3++) {
    var a3 = o2[s3].trim();
    if (a3) {
      var c3 = a3.match(Ee);
      if (c3) {
        var l2 = 0 | parseInt(c3[1], 10), u5 = c3[2];
        0 !== l2 && (we(u5, l2), Ne(e, u5, c3[3]), e.getTag().insertRules(l2, r3)), r3.length = 0;
      } else r3.push(a3);
    }
  }
};
var _e = function(e) {
  for (var t = document.querySelectorAll(be), n = 0, o2 = t.length; n < o2; n++) {
    var r3 = t[n];
    r3 && r3.getAttribute(f) !== m && (Pe(e, r3), r3.parentNode && r3.parentNode.removeChild(r3));
  }
};
function Ce() {
  return "undefined" != typeof __webpack_nonce__ ? __webpack_nonce__ : null;
}
var Ie = function(e) {
  var t = document.head, n = e || t, o2 = document.createElement("style"), r3 = function(e3) {
    var t4 = Array.from(e3.querySelectorAll("style[".concat(f, "]")));
    return t4[t4.length - 1];
  }(n), s3 = void 0 !== r3 ? r3.nextSibling : null;
  o2.setAttribute(f, m), o2.setAttribute(y2, v);
  var i2 = Ce();
  return i2 && o2.setAttribute("nonce", i2), n.insertBefore(o2, s3), o2;
};
var Ae = function() {
  function e(e3) {
    this.element = Ie(e3), this.element.appendChild(document.createTextNode("")), this.sheet = function(e4) {
      if (e4.sheet) return e4.sheet;
      for (var t = document.styleSheets, n = 0, o2 = t.length; n < o2; n++) {
        var r3 = t[n];
        if (r3.ownerNode === e4) return r3;
      }
      throw he(17);
    }(this.element), this.length = 0;
  }
  return e.prototype.insertRule = function(e3, t) {
    try {
      return this.sheet.insertRule(t, e3), this.length++, true;
    } catch (e4) {
      return false;
    }
  }, e.prototype.deleteRule = function(e3) {
    this.sheet.deleteRule(e3), this.length--;
  }, e.prototype.getRule = function(e3) {
    var t = this.sheet.cssRules[e3];
    return t && t.cssText ? t.cssText : "";
  }, e;
}();
var Oe = function() {
  function e(e3) {
    this.element = Ie(e3), this.nodes = this.element.childNodes, this.length = 0;
  }
  return e.prototype.insertRule = function(e3, t) {
    if (e3 <= this.length && e3 >= 0) {
      var n = document.createTextNode(t);
      return this.element.insertBefore(n, this.nodes[e3] || null), this.length++, true;
    }
    return false;
  }, e.prototype.deleteRule = function(e3) {
    this.element.removeChild(this.nodes[e3]), this.length--;
  }, e.prototype.getRule = function(e3) {
    return e3 < this.length ? this.nodes[e3].textContent : "";
  }, e;
}();
var De = function() {
  function e(e3) {
    this.rules = [], this.length = 0;
  }
  return e.prototype.insertRule = function(e3, t) {
    return e3 <= this.length && (this.rules.splice(e3, 0, t), this.length++, true);
  }, e.prototype.deleteRule = function(e3) {
    this.rules.splice(e3, 1), this.length--;
  }, e.prototype.getRule = function(e3) {
    return e3 < this.length ? this.rules[e3] : "";
  }, e;
}();
var Re = S;
var Te = { isServer: !S, useCSSOMInjection: !w };
var ke = function() {
  function e(e3, n, o2) {
    void 0 === e3 && (e3 = C2), void 0 === n && (n = {});
    var r3 = this;
    this.options = __assign(__assign({}, Te), e3), this.gs = n, this.names = new Map(o2), this.server = !!e3.isServer, !this.server && S && Re && (Re = false, _e(this)), ue(this, function() {
      return function(e4) {
        for (var t = e4.getTag(), n2 = t.length, o3 = "", r4 = function(n3) {
          var r5 = function(e6) {
            return ve.get(e6);
          }(n3);
          if (void 0 === r5) return "continue";
          var s4 = e4.names.get(r5), i2 = t.getGroup(n3);
          if (void 0 === s4 || !s4.size || 0 === i2.length) return "continue";
          var a3 = "".concat(f, ".g").concat(n3, '[id="').concat(r5, '"]'), c3 = "";
          void 0 !== s4 && s4.forEach(function(e6) {
            e6.length > 0 && (c3 += "".concat(e6, ","));
          }), o3 += "".concat(i2).concat(a3, '{content:"').concat(c3, '"}').concat(g);
        }, s3 = 0; s3 < n2; s3++) r4(s3);
        return o3;
      }(r3);
    });
  }
  return e.registerId = function(e3) {
    return Se(e3);
  }, e.prototype.rehydrate = function() {
    !this.server && S && _e(this);
  }, e.prototype.reconstructWithOptions = function(n, o2) {
    return void 0 === o2 && (o2 = true), new e(__assign(__assign({}, this.options), n), this.gs, o2 && this.names || void 0);
  }, e.prototype.allocateGSInstance = function(e3) {
    return this.gs[e3] = (this.gs[e3] || 0) + 1;
  }, e.prototype.getTag = function() {
    return this.tag || (this.tag = (e3 = function(e4) {
      var t = e4.useCSSOMInjection, n = e4.target;
      return e4.isServer ? new De(n) : t ? new Ae(n) : new Oe(n);
    }(this.options), new fe(e3)));
    var e3;
  }, e.prototype.hasNameForId = function(e3, t) {
    return this.names.has(e3) && this.names.get(e3).has(t);
  }, e.prototype.registerName = function(e3, t) {
    if (Se(e3), this.names.has(e3)) this.names.get(e3).add(t);
    else {
      var n = /* @__PURE__ */ new Set();
      n.add(t), this.names.set(e3, n);
    }
  }, e.prototype.insertRules = function(e3, t, n) {
    this.registerName(e3, t), this.getTag().insertRules(Se(e3), n);
  }, e.prototype.clearNames = function(e3) {
    this.names.has(e3) && this.names.get(e3).clear();
  }, e.prototype.clearRules = function(e3) {
    this.getTag().clearGroup(Se(e3)), this.clearNames(e3);
  }, e.prototype.clearTag = function() {
    this.tag = void 0;
  }, e;
}();
var je = /&/g;
var xe = /^\s*\/\/.*$/gm;
function Ve(e, t) {
  return e.map(function(e3) {
    return "rule" === e3.type && (e3.value = "".concat(t, " ").concat(e3.value), e3.value = e3.value.replaceAll(",", ",".concat(t, " ")), e3.props = e3.props.map(function(e4) {
      return "".concat(t, " ").concat(e4);
    })), Array.isArray(e3.children) && "@keyframes" !== e3.type && (e3.children = Ve(e3.children, t)), e3;
  });
}
function Fe(e) {
  var t, n, o2, r3 = void 0 === e ? C2 : e, s3 = r3.options, i2 = void 0 === s3 ? C2 : s3, a3 = r3.plugins, c3 = void 0 === a3 ? _ : a3, l2 = function(e3, o3, r4) {
    return r4.startsWith(n) && r4.endsWith(n) && r4.replaceAll(n, "").length > 0 ? ".".concat(t) : e3;
  }, u5 = c3.slice();
  u5.push(function(e3) {
    e3.type === RULESET && e3.value.includes("&") && (e3.props[0] = e3.props[0].replace(je, n).replace(o2, l2));
  }), i2.prefix && u5.push(prefixer), u5.push(stringify);
  var p2 = function(e3, r4, s4, a4) {
    void 0 === r4 && (r4 = ""), void 0 === s4 && (s4 = ""), void 0 === a4 && (a4 = "&"), t = a4, n = r4, o2 = new RegExp("\\".concat(n, "\\b"), "g");
    var c4 = e3.replace(xe, ""), l3 = compile(s4 || r4 ? "".concat(s4, " ").concat(r4, " { ").concat(c4, " }") : c4);
    i2.namespace && (l3 = Ve(l3, i2.namespace));
    var p3 = [];
    return serialize(l3, middleware(u5.concat(rulesheet(function(e4) {
      return p3.push(e4);
    })))), p3;
  };
  return p2.hash = c3.length ? c3.reduce(function(e3, t4) {
    return t4.name || he(15), M(e3, t4.name);
  }, F).toString() : "", p2;
}
var Me = new ke();
var ze = Fe();
var $e = import_react.default.createContext({ shouldForwardProp: void 0, styleSheet: Me, stylis: ze });
var Be = $e.Consumer;
var Le = import_react.default.createContext(void 0);
function Ge() {
  return (0, import_react.useContext)($e);
}
function Ye(e) {
  var t = (0, import_react.useState)(e.stylisPlugins), n = t[0], r3 = t[1], c3 = Ge().styleSheet, l2 = (0, import_react.useMemo)(function() {
    var t4 = c3;
    return e.sheet ? t4 = e.sheet : e.target && (t4 = t4.reconstructWithOptions({ target: e.target }, false)), e.disableCSSOMInjection && (t4 = t4.reconstructWithOptions({ useCSSOMInjection: false })), t4;
  }, [e.disableCSSOMInjection, e.sheet, e.target, c3]), u5 = (0, import_react.useMemo)(function() {
    return Fe({ options: { namespace: e.namespace, prefix: e.enableVendorPrefixes }, plugins: n });
  }, [e.enableVendorPrefixes, e.namespace, n]);
  (0, import_react.useEffect)(function() {
    (0, import_shallowequal.default)(n, e.stylisPlugins) || r3(e.stylisPlugins);
  }, [e.stylisPlugins]);
  var d = (0, import_react.useMemo)(function() {
    return { shouldForwardProp: e.shouldForwardProp, styleSheet: l2, stylis: u5 };
  }, [e.shouldForwardProp, l2, u5]);
  return import_react.default.createElement($e.Provider, { value: d }, import_react.default.createElement(Le.Provider, { value: u5 }, e.children));
}
var We = function() {
  function e(e3, t) {
    var n = this;
    this.inject = function(e4, t4) {
      void 0 === t4 && (t4 = ze);
      var o2 = n.name + t4.hash;
      e4.hasNameForId(n.id, o2) || e4.insertRules(n.id, o2, t4(n.rules, o2, "@keyframes"));
    }, this.name = e3, this.id = "sc-keyframes-".concat(e3), this.rules = t, ue(this, function() {
      throw he(12, String(n.name));
    });
  }
  return e.prototype.getName = function(e3) {
    return void 0 === e3 && (e3 = ze), this.name + e3.hash;
  }, e;
}();
var qe = function(e) {
  return e >= "A" && e <= "Z";
};
function He(e) {
  for (var t = "", n = 0; n < e.length; n++) {
    var o2 = e[n];
    if (1 === n && "-" === o2 && "-" === e[0]) return e;
    qe(o2) ? t += "-" + o2.toLowerCase() : t += o2;
  }
  return t.startsWith("ms-") ? "-" + t : t;
}
var Ue = function(e) {
  return null == e || false === e || "" === e;
};
var Je = function(t) {
  var n, o2, r3 = [];
  for (var s3 in t) {
    var i2 = t[s3];
    t.hasOwnProperty(s3) && !Ue(i2) && (Array.isArray(i2) && i2.isCss || re2(i2) ? r3.push("".concat(He(s3), ":"), i2, ";") : ce(i2) ? r3.push.apply(r3, __spreadArray(__spreadArray(["".concat(s3, " {")], Je(i2), false), ["}"], false)) : r3.push("".concat(He(s3), ": ").concat((n = s3, null == (o2 = i2) || "boolean" == typeof o2 || "" === o2 ? "" : "number" != typeof o2 || 0 === o2 || n in unitlessKeys || n.startsWith("--") ? String(o2).trim() : "".concat(o2, "px")), ";")));
  }
  return r3;
};
function Xe(e, t, n, o2) {
  if (Ue(e)) return [];
  if (se(e)) return [".".concat(e.styledComponentId)];
  if (re2(e)) {
    if (!re2(s3 = e) || s3.prototype && s3.prototype.isReactComponent || !t) return [e];
    var r3 = e(t);
    return "object" != typeof r3 || Array.isArray(r3) || r3 instanceof We || ce(r3) || null === r3 || console.error("".concat(B2(e), " is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details.")), Xe(r3, t, n, o2);
  }
  var s3;
  return e instanceof We ? n ? (e.inject(n, o2), [e.getName(o2)]) : [e] : ce(e) ? Je(e) : Array.isArray(e) ? Array.prototype.concat.apply(_, e.map(function(e3) {
    return Xe(e3, t, n, o2);
  })) : [e.toString()];
}
function Ze(e) {
  for (var t = 0; t < e.length; t += 1) {
    var n = e[t];
    if (re2(n) && !se(n)) return false;
  }
  return true;
}
var Ke = z(v);
var Qe = function() {
  function e(e3, t, n) {
    this.rules = e3, this.staticRulesId = "", this.isStatic = false, this.componentId = t, this.baseHash = M(Ke, t), this.baseStyle = n, ke.registerId(t);
  }
  return e.prototype.generateAndInjectStyles = function(e3, t, n) {
    var o2 = this.baseStyle ? this.baseStyle.generateAndInjectStyles(e3, t, n) : "";
    if (this.isStatic && !n.hash) if (this.staticRulesId && t.hasNameForId(this.componentId, this.staticRulesId)) o2 = ie(o2, this.staticRulesId);
    else {
      var r3 = ae(Xe(this.rules, e3, t, n)), s3 = x2(M(this.baseHash, r3) >>> 0);
      if (!t.hasNameForId(this.componentId, s3)) {
        var i2 = n(r3, ".".concat(s3), void 0, this.componentId);
        t.insertRules(this.componentId, s3, i2);
      }
      o2 = ie(o2, s3), this.staticRulesId = s3;
    }
    else {
      for (var a3 = M(this.baseHash, n.hash), c3 = "", l2 = 0; l2 < this.rules.length; l2++) {
        var u5 = this.rules[l2];
        if ("string" == typeof u5) c3 += u5, a3 = M(a3, u5);
        else if (u5) {
          var p2 = ae(Xe(u5, e3, t, n));
          a3 = M(a3, p2 + l2), c3 += p2;
        }
      }
      if (c3) {
        var d = x2(a3 >>> 0);
        t.hasNameForId(this.componentId, d) || t.insertRules(this.componentId, d, n(c3, ".".concat(d), void 0, this.componentId)), o2 = ie(o2, d);
      }
    }
    return o2;
  }, e;
}();
var et = import_react.default.createContext(void 0);
var tt = et.Consumer;
var rt = {};
var st = /* @__PURE__ */ new Set();
function it(e, r3, s3) {
  var i2 = se(e), a3 = e, c3 = !L(e), p2 = r3.attrs, d = void 0 === p2 ? _ : p2, h = r3.componentId, f2 = void 0 === h ? function(e3, t) {
    var n = "string" != typeof e3 ? "sc" : R(e3);
    rt[n] = (rt[n] || 0) + 1;
    var o2 = "".concat(n, "-").concat($(v + n + rt[n]));
    return t ? "".concat(t, "-").concat(o2) : o2;
  }(r3.displayName, r3.parentComponentId) : h, m2 = r3.displayName, y3 = void 0 === m2 ? function(e3) {
    return L(e3) ? "styled.".concat(e3) : "Styled(".concat(B2(e3), ")");
  }(e) : m2, g2 = r3.displayName && r3.componentId ? "".concat(R(r3.displayName), "-").concat(r3.componentId) : r3.componentId || f2, S2 = i2 && a3.attrs ? a3.attrs.concat(d).filter(Boolean) : d, w2 = r3.shouldForwardProp;
  if (i2 && a3.shouldForwardProp) {
    var b2 = a3.shouldForwardProp;
    if (r3.shouldForwardProp) {
      var E3 = r3.shouldForwardProp;
      w2 = function(e3, t) {
        return b2(e3, t) && E3(e3, t);
      };
    } else w2 = b2;
  }
  var N2 = new Qe(s3, g2, i2 ? a3.componentStyle : void 0);
  function O2(e3, r4) {
    return function(e4, r5, s4) {
      var i3 = e4.attrs, a4 = e4.componentStyle, c4 = e4.defaultProps, p3 = e4.foldedComponentIds, d2 = e4.styledComponentId, h2 = e4.target, f3 = import_react.default.useContext(et), m3 = Ge(), y4 = e4.shouldForwardProp || m3.shouldForwardProp;
      (0, import_react.useDebugValue)(d2);
      var v3 = I(r5, f3, c4) || C2, g3 = function(e6, n, o2) {
        for (var r6, s5 = __assign(__assign({}, n), { className: void 0, theme: o2 }), i4 = 0; i4 < e6.length; i4 += 1) {
          var a5 = re2(r6 = e6[i4]) ? r6(s5) : r6;
          for (var c5 in a5) s5[c5] = "className" === c5 ? ie(s5[c5], a5[c5]) : "style" === c5 ? __assign(__assign({}, s5[c5]), a5[c5]) : a5[c5];
        }
        return n.className && (s5.className = ie(s5.className, n.className)), s5;
      }(i3, r5, v3), S3 = g3.as || h2, w3 = {};
      for (var b3 in g3) void 0 === g3[b3] || "$" === b3[0] || "as" === b3 || "theme" === b3 && g3.theme === v3 || ("forwardedAs" === b3 ? w3.as = g3.forwardedAs : y4 && !y4(b3, S3) || (w3[b3] = g3[b3], y4 || false || isPropValid(b3) || st.has(b3) || !A2.has(S3) || (st.add(b3), console.warn('styled-components: it looks like an unknown prop "'.concat(b3, '" is being sent through to the DOM, which will likely trigger a React console error. If you would like automatic filtering of unknown props, you can opt-into that behavior via `<StyleSheetManager shouldForwardProp={...}>` (connect an API like `@emotion/is-prop-valid`) or consider using transient props (`$` prefix for automatic filtering.)')))));
      var E4 = function(e6, t) {
        var n = Ge(), o2 = e6.generateAndInjectStyles(t, n.styleSheet, n.stylis);
        return (0, import_react.useDebugValue)(o2), o2;
      }(a4, g3);
      e4.warnTooManyClasses && e4.warnTooManyClasses(E4);
      var N3 = ie(p3, d2);
      return E4 && (N3 += " " + E4), g3.className && (N3 += " " + g3.className), w3[L(S3) && !A2.has(S3) ? "class" : "className"] = N3, s4 && (w3.ref = s4), (0, import_react.createElement)(S3, w3);
    }(D4, e3, r4);
  }
  O2.displayName = y3;
  var D4 = import_react.default.forwardRef(O2);
  return D4.attrs = S2, D4.componentStyle = N2, D4.displayName = y3, D4.shouldForwardProp = w2, D4.foldedComponentIds = i2 ? ie(a3.foldedComponentIds, a3.styledComponentId) : "", D4.styledComponentId = g2, D4.target = i2 ? a3.target : e, Object.defineProperty(D4, "defaultProps", { get: function() {
    return this._foldedDefaultProps;
  }, set: function(e3) {
    this._foldedDefaultProps = i2 ? function(e4) {
      for (var t = [], n = 1; n < arguments.length; n++) t[n - 1] = arguments[n];
      for (var o2 = 0, r4 = t; o2 < r4.length; o2++) le(e4, r4[o2], true);
      return e4;
    }({}, a3.defaultProps, e3) : e3;
  } }), P(y3, g2), D4.warnTooManyClasses = /* @__PURE__ */ function(e3, t) {
    var n = {}, o2 = false;
    return function(r4) {
      if (!o2 && (n[r4] = true, Object.keys(n).length >= 200)) {
        var s4 = t ? ' with the id of "'.concat(t, '"') : "";
        console.warn("Over ".concat(200, " classes were generated for component ").concat(e3).concat(s4, ".\n") + "Consider using the attrs method, together with a style object for frequently changed styles.\nExample:\n  const Component = styled.div.attrs(props => ({\n    style: {\n      background: props.background,\n    },\n  }))`width: 100%;`\n\n  <Component />"), o2 = true, n = {};
      }
    };
  }(y3, g2), ue(D4, function() {
    return ".".concat(D4.styledComponentId);
  }), c3 && oe(D4, e, { attrs: true, componentStyle: true, displayName: true, foldedComponentIds: true, shouldForwardProp: true, styledComponentId: true, target: true }), D4;
}
function at(e, t) {
  for (var n = [e[0]], o2 = 0, r3 = t.length; o2 < r3; o2 += 1) n.push(t[o2], e[o2 + 1]);
  return n;
}
var ct = function(e) {
  return Object.assign(e, { isCss: true });
};
function lt(t) {
  for (var n = [], o2 = 1; o2 < arguments.length; o2++) n[o2 - 1] = arguments[o2];
  if (re2(t) || ce(t)) return ct(Xe(at(_, __spreadArray([t], n, true))));
  var r3 = t;
  return 0 === n.length && 1 === r3.length && "string" == typeof r3[0] ? Xe(r3) : ct(Xe(at(r3, n)));
}
function ut(n, o2, r3) {
  if (void 0 === r3 && (r3 = C2), !o2) throw he(1, o2);
  var s3 = function(t) {
    for (var s4 = [], i2 = 1; i2 < arguments.length; i2++) s4[i2 - 1] = arguments[i2];
    return n(o2, r3, lt.apply(void 0, __spreadArray([t], s4, false)));
  };
  return s3.attrs = function(e) {
    return ut(n, o2, __assign(__assign({}, r3), { attrs: Array.prototype.concat(r3.attrs, e).filter(Boolean) }));
  }, s3.withConfig = function(e) {
    return ut(n, o2, __assign(__assign({}, r3), e));
  }, s3;
}
var pt = function(e) {
  return ut(it, e);
};
var dt = pt;
A2.forEach(function(e) {
  dt[e] = pt(e);
});
var ht = function() {
  function e(e3, t) {
    this.rules = e3, this.componentId = t, this.isStatic = Ze(e3), ke.registerId(this.componentId + 1);
  }
  return e.prototype.createStyles = function(e3, t, n, o2) {
    var r3 = o2(ae(Xe(this.rules, t, n, o2)), ""), s3 = this.componentId + e3;
    n.insertRules(s3, s3, r3);
  }, e.prototype.removeStyles = function(e3, t) {
    t.clearRules(this.componentId + e3);
  }, e.prototype.renderStyles = function(e3, t, n, o2) {
    e3 > 2 && ke.registerId(this.componentId + e3), this.removeStyles(e3, n), this.createStyles(e3, t, n, o2);
  }, e;
}();
function ft(n) {
  for (var r3 = [], s3 = 1; s3 < arguments.length; s3++) r3[s3 - 1] = arguments[s3];
  var i2 = lt.apply(void 0, __spreadArray([n], r3, false)), a3 = "sc-global-".concat($(JSON.stringify(i2))), c3 = new ht(i2, a3);
  P(a3);
  var l2 = function(e) {
    var t = Ge(), n2 = import_react.default.useContext(et), r4 = import_react.default.useRef(t.styleSheet.allocateGSInstance(a3)).current;
    return import_react.default.Children.count(e.children) && console.warn("The global style component ".concat(a3, " was given child JSX. createGlobalStyle does not render children.")), i2.some(function(e3) {
      return "string" == typeof e3 && -1 !== e3.indexOf("@import");
    }) && console.warn("Please do not use @import CSS syntax in createGlobalStyle at this time, as the CSSOM APIs we use in production do not handle it well. Instead, we recommend using a library such as react-helmet to inject a typical <link> meta tag to the stylesheet, or simply embedding it manually in your index.html <head> section for a simpler app."), t.styleSheet.server && u5(r4, e, t.styleSheet, n2, t.stylis), import_react.default.useLayoutEffect(function() {
      if (!t.styleSheet.server) return u5(r4, e, t.styleSheet, n2, t.stylis), function() {
        return c3.removeStyles(r4, t.styleSheet);
      };
    }, [r4, e, t.styleSheet, n2, t.stylis]), null;
  };
  function u5(e, n2, o2, r4, s4) {
    if (c3.isStatic) c3.renderStyles(e, b, o2, s4);
    else {
      var i3 = __assign(__assign({}, n2), { theme: I(n2, r4, l2.defaultProps) });
      c3.renderStyles(e, i3, o2, s4);
    }
  }
  return import_react.default.memo(l2);
}
function mt(t) {
  for (var n = [], o2 = 1; o2 < arguments.length; o2++) n[o2 - 1] = arguments[o2];
  "undefined" != typeof navigator && "ReactNative" === navigator.product && console.warn("`keyframes` cannot be used on ReactNative, only on the web. To do animation in ReactNative please use Animated.");
  var r3 = ae(lt.apply(void 0, __spreadArray([t], n, false))), s3 = $(r3);
  return new We(s3, r3);
}
var vt = function() {
  function e() {
    var e3 = this;
    this._emitSheetCSS = function() {
      var t = e3.instance.toString();
      if (!t) return "";
      var n = Ce(), o2 = ae([n && 'nonce="'.concat(n, '"'), "".concat(f, '="true"'), "".concat(y2, '="').concat(v, '"')].filter(Boolean), " ");
      return "<style ".concat(o2, ">").concat(t, "</style>");
    }, this.getStyleTags = function() {
      if (e3.sealed) throw he(2);
      return e3._emitSheetCSS();
    }, this.getStyleElement = function() {
      var n;
      if (e3.sealed) throw he(2);
      var r3 = e3.instance.toString();
      if (!r3) return [];
      var s3 = ((n = {})[f] = "", n[y2] = v, n.dangerouslySetInnerHTML = { __html: r3 }, n), i2 = Ce();
      return i2 && (s3.nonce = i2), [import_react.default.createElement("style", __assign({}, s3, { key: "sc-0-0" }))];
    }, this.seal = function() {
      e3.sealed = true;
    }, this.instance = new ke({ isServer: true }), this.sealed = false;
  }
  return e.prototype.collectStyles = function(e3) {
    if (this.sealed) throw he(2);
    return import_react.default.createElement(Ye, { sheet: this.instance }, e3);
  }, e.prototype.interleaveWithNodeStream = function(e3) {
    throw he(3);
  }, e;
}();
"undefined" != typeof navigator && "ReactNative" === navigator.product && console.warn("It looks like you've imported 'styled-components' on React Native.\nPerhaps you're looking to import 'styled-components/native'?\nRead more about this at https://www.styled-components.com/docs/basics#react-native");
var St = "__sc-".concat(f, "__");
"undefined" != typeof window && (window[St] || (window[St] = 0), 1 === window[St] && console.warn("It looks like there are several instances of 'styled-components' initialized in this application. This may cause dynamic styles to not render properly, errors during the rehydration process, a missing theme prop, and makes your application bigger without good reason.\n\nSee https://s-c.sh/2BAXzed for more info."), window[St] += 1);

// node_modules/@mui/styled-engine-sc/esm/StyledEngineProvider/StyledEngineProvider.js
var import_prop_types = __toESM(require_prop_types(), 1);
function StyledEngineProvider(props) {
  const {
    injectFirst,
    children: children2
  } = props;
  if (injectFirst && typeof window !== "undefined") {
    const head = document.head;
    if (!head.querySelector('[data-styled="active"]')) {
      const injectFirstNode = document.createElement("style");
      injectFirstNode.setAttribute("data-styled", "active");
      head.insertBefore(injectFirstNode, head.firstChild);
    }
  }
  return children2;
}
StyledEngineProvider.propTypes = {
  /**
   * Your component tree.
   */
  children: import_prop_types.default.node,
  /**
   * By default, the styles are injected last in the <head> element of the page.
   * As a result, they gain more specificity than any other style sheet.
   * If you want to override MUI's styles, set this prop.
   */
  injectFirst: import_prop_types.default.bool
};

// node_modules/@mui/styled-engine-sc/esm/GlobalStyles/GlobalStyles.js
var import_prop_types2 = __toESM(require_prop_types(), 1);
function isEmpty(obj) {
  return obj === void 0 || obj === null || Object.keys(obj).length === 0;
}
var GlobalStyles = ft((props) => {
  const {
    styles,
    defaultTheme: defaultTheme5 = {}
  } = props;
  if (typeof styles === "function") {
    return styles(isEmpty(props.theme) ? defaultTheme5 : props.theme);
  }
  return styles;
});
var GlobalStyles_default = GlobalStyles;
GlobalStyles.propTypes = {
  defaultTheme: import_prop_types2.default.object,
  styles: import_prop_types2.default.oneOfType([import_prop_types2.default.array, import_prop_types2.default.string, import_prop_types2.default.object, import_prop_types2.default.func])
};

// node_modules/@mui/styled-engine-sc/esm/index.js
function styled(tag, options) {
  let stylesFactory;
  if (options) {
    stylesFactory = dt(tag).withConfig({
      displayName: options.label,
      shouldForwardProp: options.shouldForwardProp
    });
  } else {
    stylesFactory = dt(tag);
  }
  if (true) {
    const fn2 = (...styles) => {
      const component = typeof tag === "string" ? `"${tag}"` : "component";
      if (styles.length === 0) {
        console.error([`MUI: Seems like you called \`styled(${component})()\` without a \`style\` argument.`, 'You must provide a `styles` argument: `styled("div")(styleYouForgotToPass)`.'].join("\n"));
      } else if (styles.some((style4) => style4 === void 0)) {
        console.error(`MUI: the styled(${component})(...args) API requires all its args to be defined.`);
      }
      return stylesFactory(...styles);
    };
    fn2.withConfig = stylesFactory.withConfig;
    return fn2;
  }
  return stylesFactory;
}
function internal_mutateStyles(tag, processor) {
  if (tag.componentStyle) {
    tag.componentStyle.rules = processor(tag.componentStyle.rules);
  }
}
function internal_serializeStyles(styles) {
  return styles;
}

// node_modules/@mui/system/esm/GlobalStyles/GlobalStyles.js
var React22 = __toESM(require_react(), 1);
var import_prop_types5 = __toESM(require_prop_types(), 1);

// node_modules/@mui/utils/esm/deepmerge/deepmerge.js
var React20 = __toESM(require_react(), 1);
var import_react_is = __toESM(require_react_is(), 1);
function isPlainObject(item) {
  if (typeof item !== "object" || item === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(item);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in item) && !(Symbol.iterator in item);
}
function deepClone(source) {
  if (React20.isValidElement(source) || (0, import_react_is.isValidElementType)(source) || !isPlainObject(source)) {
    return source;
  }
  const output = {};
  Object.keys(source).forEach((key) => {
    output[key] = deepClone(source[key]);
  });
  return output;
}
function deepmerge(target, source, options = {
  clone: true
}) {
  const output = options.clone ? {
    ...target
  } : target;
  if (isPlainObject(target) && isPlainObject(source)) {
    Object.keys(source).forEach((key) => {
      if (React20.isValidElement(source[key]) || (0, import_react_is.isValidElementType)(source[key])) {
        output[key] = source[key];
      } else if (isPlainObject(source[key]) && // Avoid prototype pollution
      Object.prototype.hasOwnProperty.call(target, key) && isPlainObject(target[key])) {
        output[key] = deepmerge(target[key], source[key], options);
      } else if (options.clone) {
        output[key] = isPlainObject(source[key]) ? deepClone(source[key]) : source[key];
      } else {
        output[key] = source[key];
      }
    });
  }
  return output;
}

// node_modules/@mui/system/esm/createBreakpoints/createBreakpoints.js
var sortBreakpointsValues = (values3) => {
  const breakpointsAsArray = Object.keys(values3).map((key) => ({
    key,
    val: values3[key]
  })) || [];
  breakpointsAsArray.sort((breakpoint1, breakpoint2) => breakpoint1.val - breakpoint2.val);
  return breakpointsAsArray.reduce((acc, obj) => {
    return {
      ...acc,
      [obj.key]: obj.val
    };
  }, {});
};
function createBreakpoints(breakpoints) {
  const {
    // The breakpoint **start** at this value.
    // For instance with the first breakpoint xs: [xs, sm).
    values: values3 = {
      xs: 0,
      // phone
      sm: 600,
      // tablet
      md: 900,
      // small laptop
      lg: 1200,
      // desktop
      xl: 1536
      // large screen
    },
    unit: unit2 = "px",
    step = 5,
    ...other
  } = breakpoints;
  const sortedValues = sortBreakpointsValues(values3);
  const keys = Object.keys(sortedValues);
  function up(key) {
    const value = typeof values3[key] === "number" ? values3[key] : key;
    return `@media (min-width:${value}${unit2})`;
  }
  function down(key) {
    const value = typeof values3[key] === "number" ? values3[key] : key;
    return `@media (max-width:${value - step / 100}${unit2})`;
  }
  function between(start2, end2) {
    const endIndex = keys.indexOf(end2);
    return `@media (min-width:${typeof values3[start2] === "number" ? values3[start2] : start2}${unit2}) and (max-width:${(endIndex !== -1 && typeof values3[keys[endIndex]] === "number" ? values3[keys[endIndex]] : end2) - step / 100}${unit2})`;
  }
  function only(key) {
    if (keys.indexOf(key) + 1 < keys.length) {
      return between(key, keys[keys.indexOf(key) + 1]);
    }
    return up(key);
  }
  function not(key) {
    const keyIndex = keys.indexOf(key);
    if (keyIndex === 0) {
      return up(keys[1]);
    }
    if (keyIndex === keys.length - 1) {
      return down(keys[keyIndex]);
    }
    return between(key, keys[keys.indexOf(key) + 1]).replace("@media", "@media not all and");
  }
  return {
    keys,
    values: sortedValues,
    up,
    down,
    between,
    only,
    not,
    unit: unit2,
    ...other
  };
}

// node_modules/@mui/system/esm/cssContainerQueries/cssContainerQueries.js
function sortContainerQueries(theme, css) {
  if (!theme.containerQueries) {
    return css;
  }
  const sorted = Object.keys(css).filter((key) => key.startsWith("@container")).sort((a3, b2) => {
    var _a, _b;
    const regex = /min-width:\s*([0-9.]+)/;
    return +(((_a = a3.match(regex)) == null ? void 0 : _a[1]) || 0) - +(((_b = b2.match(regex)) == null ? void 0 : _b[1]) || 0);
  });
  if (!sorted.length) {
    return css;
  }
  return sorted.reduce((acc, key) => {
    const value = css[key];
    delete acc[key];
    acc[key] = value;
    return acc;
  }, {
    ...css
  });
}
function isCqShorthand(breakpointKeys, value) {
  return value === "@" || value.startsWith("@") && (breakpointKeys.some((key) => value.startsWith(`@${key}`)) || !!value.match(/^@\d/));
}
function getContainerQuery(theme, shorthand) {
  const matches = shorthand.match(/^@([^/]+)?\/?(.+)?$/);
  if (!matches) {
    if (true) {
      throw new Error(true ? `MUI: The provided shorthand ${`(${shorthand})`} is invalid. The format should be \`@<breakpoint | number>\` or \`@<breakpoint | number>/<container>\`.
For example, \`@sm\` or \`@600\` or \`@40rem/sidebar\`.` : formatMuiErrorMessage(18, `(${shorthand})`));
    }
    return null;
  }
  const [, containerQuery, containerName] = matches;
  const value = Number.isNaN(+containerQuery) ? containerQuery || 0 : +containerQuery;
  return theme.containerQueries(containerName).up(value);
}
function cssContainerQueries(themeInput) {
  const toContainerQuery = (mediaQuery, name) => mediaQuery.replace("@media", name ? `@container ${name}` : "@container");
  function attachCq(node3, name) {
    node3.up = (...args) => toContainerQuery(themeInput.breakpoints.up(...args), name);
    node3.down = (...args) => toContainerQuery(themeInput.breakpoints.down(...args), name);
    node3.between = (...args) => toContainerQuery(themeInput.breakpoints.between(...args), name);
    node3.only = (...args) => toContainerQuery(themeInput.breakpoints.only(...args), name);
    node3.not = (...args) => {
      const result = toContainerQuery(themeInput.breakpoints.not(...args), name);
      if (result.includes("not all and")) {
        return result.replace("not all and ", "").replace("min-width:", "width<").replace("max-width:", "width>").replace("and", "or");
      }
      return result;
    };
  }
  const node2 = {};
  const containerQueries = (name) => {
    attachCq(node2, name);
    return node2;
  };
  attachCq(containerQueries);
  return {
    ...themeInput,
    containerQueries
  };
}

// node_modules/@mui/system/esm/createTheme/shape.js
var shape = {
  borderRadius: 4
};
var shape_default = shape;

// node_modules/@mui/system/esm/responsivePropType/responsivePropType.js
var import_prop_types3 = __toESM(require_prop_types(), 1);
var responsivePropType = true ? import_prop_types3.default.oneOfType([import_prop_types3.default.number, import_prop_types3.default.string, import_prop_types3.default.object, import_prop_types3.default.array]) : {};
var responsivePropType_default = responsivePropType;

// node_modules/@mui/system/esm/breakpoints/breakpoints.js
var import_prop_types4 = __toESM(require_prop_types(), 1);

// node_modules/@mui/system/esm/merge/merge.js
function merge2(acc, item) {
  if (!item) {
    return acc;
  }
  return deepmerge(acc, item, {
    clone: false
    // No need to clone deep, it's way faster.
  });
}
var merge_default = merge2;

// node_modules/@mui/system/esm/breakpoints/breakpoints.js
var values = {
  xs: 0,
  // phone
  sm: 600,
  // tablet
  md: 900,
  // small laptop
  lg: 1200,
  // desktop
  xl: 1536
  // large screen
};
var defaultBreakpoints = {
  // Sorted ASC by size. That's important.
  // It can't be configured as it's used statically for propTypes.
  keys: ["xs", "sm", "md", "lg", "xl"],
  up: (key) => `@media (min-width:${values[key]}px)`
};
var defaultContainerQueries = {
  containerQueries: (containerName) => ({
    up: (key) => {
      let result = typeof key === "number" ? key : values[key] || key;
      if (typeof result === "number") {
        result = `${result}px`;
      }
      return containerName ? `@container ${containerName} (min-width:${result})` : `@container (min-width:${result})`;
    }
  })
};
function handleBreakpoints(props, propValue, styleFromPropValue) {
  const theme = props.theme || {};
  if (Array.isArray(propValue)) {
    const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
    return propValue.reduce((acc, item, index2) => {
      acc[themeBreakpoints.up(themeBreakpoints.keys[index2])] = styleFromPropValue(propValue[index2]);
      return acc;
    }, {});
  }
  if (typeof propValue === "object") {
    const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
    return Object.keys(propValue).reduce((acc, breakpoint) => {
      if (isCqShorthand(themeBreakpoints.keys, breakpoint)) {
        const containerKey = getContainerQuery(theme.containerQueries ? theme : defaultContainerQueries, breakpoint);
        if (containerKey) {
          acc[containerKey] = styleFromPropValue(propValue[breakpoint], breakpoint);
        }
      } else if (Object.keys(themeBreakpoints.values || values).includes(breakpoint)) {
        const mediaKey = themeBreakpoints.up(breakpoint);
        acc[mediaKey] = styleFromPropValue(propValue[breakpoint], breakpoint);
      } else {
        const cssKey = breakpoint;
        acc[cssKey] = propValue[cssKey];
      }
      return acc;
    }, {});
  }
  const output = styleFromPropValue(propValue);
  return output;
}
function createEmptyBreakpointObject(breakpointsInput = {}) {
  var _a;
  const breakpointsInOrder = (_a = breakpointsInput.keys) == null ? void 0 : _a.reduce((acc, key) => {
    const breakpointStyleKey = breakpointsInput.up(key);
    acc[breakpointStyleKey] = {};
    return acc;
  }, {});
  return breakpointsInOrder || {};
}
function removeUnusedBreakpoints(breakpointKeys, style4) {
  return breakpointKeys.reduce((acc, key) => {
    const breakpointOutput = acc[key];
    const isBreakpointUnused = !breakpointOutput || Object.keys(breakpointOutput).length === 0;
    if (isBreakpointUnused) {
      delete acc[key];
    }
    return acc;
  }, style4);
}
function mergeBreakpointsInOrder(breakpointsInput, ...styles) {
  const emptyBreakpoints = createEmptyBreakpointObject(breakpointsInput);
  const mergedOutput = [emptyBreakpoints, ...styles].reduce((prev2, next2) => deepmerge(prev2, next2), {});
  return removeUnusedBreakpoints(Object.keys(emptyBreakpoints), mergedOutput);
}
function computeBreakpointsBase(breakpointValues, themeBreakpoints) {
  if (typeof breakpointValues !== "object") {
    return {};
  }
  const base = {};
  const breakpointsKeys = Object.keys(themeBreakpoints);
  if (Array.isArray(breakpointValues)) {
    breakpointsKeys.forEach((breakpoint, i2) => {
      if (i2 < breakpointValues.length) {
        base[breakpoint] = true;
      }
    });
  } else {
    breakpointsKeys.forEach((breakpoint) => {
      if (breakpointValues[breakpoint] != null) {
        base[breakpoint] = true;
      }
    });
  }
  return base;
}
function resolveBreakpointValues({
  values: breakpointValues,
  breakpoints: themeBreakpoints,
  base: customBase
}) {
  const base = customBase || computeBreakpointsBase(breakpointValues, themeBreakpoints);
  const keys = Object.keys(base);
  if (keys.length === 0) {
    return breakpointValues;
  }
  let previous;
  return keys.reduce((acc, breakpoint, i2) => {
    if (Array.isArray(breakpointValues)) {
      acc[breakpoint] = breakpointValues[i2] != null ? breakpointValues[i2] : breakpointValues[previous];
      previous = i2;
    } else if (typeof breakpointValues === "object") {
      acc[breakpoint] = breakpointValues[breakpoint] != null ? breakpointValues[breakpoint] : breakpointValues[previous];
      previous = breakpoint;
    } else {
      acc[breakpoint] = breakpointValues;
    }
    return acc;
  }, {});
}

// node_modules/@mui/utils/esm/capitalize/capitalize.js
function capitalize(string) {
  if (typeof string !== "string") {
    throw new Error(true ? "MUI: `capitalize(string)` expects a string argument." : formatMuiErrorMessage(7));
  }
  return string.charAt(0).toUpperCase() + string.slice(1);
}

// node_modules/@mui/system/esm/style/style.js
function getPath(obj, path2, checkVars = true) {
  if (!path2 || typeof path2 !== "string") {
    return null;
  }
  if (obj && obj.vars && checkVars) {
    const val = `vars.${path2}`.split(".").reduce((acc, item) => acc && acc[item] ? acc[item] : null, obj);
    if (val != null) {
      return val;
    }
  }
  return path2.split(".").reduce((acc, item) => {
    if (acc && acc[item] != null) {
      return acc[item];
    }
    return null;
  }, obj);
}
function getStyleValue(themeMapping, transform, propValueFinal, userValue = propValueFinal) {
  let value;
  if (typeof themeMapping === "function") {
    value = themeMapping(propValueFinal);
  } else if (Array.isArray(themeMapping)) {
    value = themeMapping[propValueFinal] || userValue;
  } else {
    value = getPath(themeMapping, propValueFinal) || userValue;
  }
  if (transform) {
    value = transform(value, userValue, themeMapping);
  }
  return value;
}
function style(options) {
  const {
    prop,
    cssProperty = options.prop,
    themeKey,
    transform
  } = options;
  const fn2 = (props) => {
    if (props[prop] == null) {
      return null;
    }
    const propValue = props[prop];
    const theme = props.theme;
    const themeMapping = getPath(theme, themeKey) || {};
    const styleFromPropValue = (propValueFinal) => {
      let value = getStyleValue(themeMapping, transform, propValueFinal);
      if (propValueFinal === value && typeof propValueFinal === "string") {
        value = getStyleValue(themeMapping, transform, `${prop}${propValueFinal === "default" ? "" : capitalize(propValueFinal)}`, propValueFinal);
      }
      if (cssProperty === false) {
        return value;
      }
      return {
        [cssProperty]: value
      };
    };
    return handleBreakpoints(props, propValue, styleFromPropValue);
  };
  fn2.propTypes = true ? {
    [prop]: responsivePropType_default
  } : {};
  fn2.filterProps = [prop];
  return fn2;
}
var style_default = style;

// node_modules/@mui/system/esm/memoize/memoize.js
function memoize(fn2) {
  const cache2 = {};
  return (arg2) => {
    if (cache2[arg2] === void 0) {
      cache2[arg2] = fn2(arg2);
    }
    return cache2[arg2];
  };
}

// node_modules/@mui/system/esm/spacing/spacing.js
var properties = {
  m: "margin",
  p: "padding"
};
var directions = {
  t: "Top",
  r: "Right",
  b: "Bottom",
  l: "Left",
  x: ["Left", "Right"],
  y: ["Top", "Bottom"]
};
var aliases = {
  marginX: "mx",
  marginY: "my",
  paddingX: "px",
  paddingY: "py"
};
var getCssProperties = memoize((prop) => {
  if (prop.length > 2) {
    if (aliases[prop]) {
      prop = aliases[prop];
    } else {
      return [prop];
    }
  }
  const [a3, b2] = prop.split("");
  const property = properties[a3];
  const direction = directions[b2] || "";
  return Array.isArray(direction) ? direction.map((dir) => property + dir) : [property + direction];
});
var marginKeys = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"];
var paddingKeys = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"];
var spacingKeys = [...marginKeys, ...paddingKeys];
function createUnaryUnit(theme, themeKey, defaultValue, propName) {
  const themeSpacing = getPath(theme, themeKey, true) ?? defaultValue;
  if (typeof themeSpacing === "number" || typeof themeSpacing === "string") {
    return (val) => {
      if (typeof val === "string") {
        return val;
      }
      if (true) {
        if (typeof val !== "number") {
          console.error(`MUI: Expected ${propName} argument to be a number or a string, got ${val}.`);
        }
      }
      if (typeof themeSpacing === "string") {
        if (themeSpacing.startsWith("var(") && val === 0) {
          return 0;
        }
        if (themeSpacing.startsWith("var(") && val === 1) {
          return themeSpacing;
        }
        return `calc(${val} * ${themeSpacing})`;
      }
      return themeSpacing * val;
    };
  }
  if (Array.isArray(themeSpacing)) {
    return (val) => {
      if (typeof val === "string") {
        return val;
      }
      const abs3 = Math.abs(val);
      if (true) {
        if (!Number.isInteger(abs3)) {
          console.error([`MUI: The \`theme.${themeKey}\` array type cannot be combined with non integer values.You should either use an integer value that can be used as index, or define the \`theme.${themeKey}\` as a number.`].join("\n"));
        } else if (abs3 > themeSpacing.length - 1) {
          console.error([`MUI: The value provided (${abs3}) overflows.`, `The supported values are: ${JSON.stringify(themeSpacing)}.`, `${abs3} > ${themeSpacing.length - 1}, you need to add the missing values.`].join("\n"));
        }
      }
      const transformed = themeSpacing[abs3];
      if (val >= 0) {
        return transformed;
      }
      if (typeof transformed === "number") {
        return -transformed;
      }
      if (typeof transformed === "string" && transformed.startsWith("var(")) {
        return `calc(-1 * ${transformed})`;
      }
      return `-${transformed}`;
    };
  }
  if (typeof themeSpacing === "function") {
    return themeSpacing;
  }
  if (true) {
    console.error([`MUI: The \`theme.${themeKey}\` value (${themeSpacing}) is invalid.`, "It should be a number, an array or a function."].join("\n"));
  }
  return () => void 0;
}
function createUnarySpacing(theme) {
  return createUnaryUnit(theme, "spacing", 8, "spacing");
}
function getValue(transformer3, propValue) {
  if (typeof propValue === "string" || propValue == null) {
    return propValue;
  }
  return transformer3(propValue);
}
function getStyleFromPropValue(cssProperties, transformer3) {
  return (propValue) => cssProperties.reduce((acc, cssProperty) => {
    acc[cssProperty] = getValue(transformer3, propValue);
    return acc;
  }, {});
}
function resolveCssProperty(props, keys, prop, transformer3) {
  if (!keys.includes(prop)) {
    return null;
  }
  const cssProperties = getCssProperties(prop);
  const styleFromPropValue = getStyleFromPropValue(cssProperties, transformer3);
  const propValue = props[prop];
  return handleBreakpoints(props, propValue, styleFromPropValue);
}
function style2(props, keys) {
  const transformer3 = createUnarySpacing(props.theme);
  return Object.keys(props).map((prop) => resolveCssProperty(props, keys, prop, transformer3)).reduce(merge_default, {});
}
function margin(props) {
  return style2(props, marginKeys);
}
margin.propTypes = true ? marginKeys.reduce((obj, key) => {
  obj[key] = responsivePropType_default;
  return obj;
}, {}) : {};
margin.filterProps = marginKeys;
function padding(props) {
  return style2(props, paddingKeys);
}
padding.propTypes = true ? paddingKeys.reduce((obj, key) => {
  obj[key] = responsivePropType_default;
  return obj;
}, {}) : {};
padding.filterProps = paddingKeys;
function spacing(props) {
  return style2(props, spacingKeys);
}
spacing.propTypes = true ? spacingKeys.reduce((obj, key) => {
  obj[key] = responsivePropType_default;
  return obj;
}, {}) : {};
spacing.filterProps = spacingKeys;
var spacing_default = spacing;

// node_modules/@mui/system/esm/createTheme/createSpacing.js
function createSpacing(spacingInput = 8, transform = createUnarySpacing({
  spacing: spacingInput
})) {
  if (spacingInput.mui) {
    return spacingInput;
  }
  const spacing2 = (...argsInput) => {
    if (true) {
      if (!(argsInput.length <= 4)) {
        console.error(`MUI: Too many arguments provided, expected between 0 and 4, got ${argsInput.length}`);
      }
    }
    const args = argsInput.length === 0 ? [1] : argsInput;
    return args.map((argument) => {
      const output = transform(argument);
      return typeof output === "number" ? `${output}px` : output;
    }).join(" ");
  };
  spacing2.mui = true;
  return spacing2;
}

// node_modules/@mui/system/esm/compose/compose.js
function compose(...styles) {
  const handlers = styles.reduce((acc, style4) => {
    style4.filterProps.forEach((prop) => {
      acc[prop] = style4;
    });
    return acc;
  }, {});
  const fn2 = (props) => {
    return Object.keys(props).reduce((acc, prop) => {
      if (handlers[prop]) {
        return merge_default(acc, handlers[prop](props));
      }
      return acc;
    }, {});
  };
  fn2.propTypes = true ? styles.reduce((acc, style4) => Object.assign(acc, style4.propTypes), {}) : {};
  fn2.filterProps = styles.reduce((acc, style4) => acc.concat(style4.filterProps), []);
  return fn2;
}
var compose_default = compose;

// node_modules/@mui/system/esm/borders/borders.js
function borderTransform(value) {
  if (typeof value !== "number") {
    return value;
  }
  return `${value}px solid`;
}
function createBorderStyle(prop, transform) {
  return style_default({
    prop,
    themeKey: "borders",
    transform
  });
}
var border = createBorderStyle("border", borderTransform);
var borderTop = createBorderStyle("borderTop", borderTransform);
var borderRight = createBorderStyle("borderRight", borderTransform);
var borderBottom = createBorderStyle("borderBottom", borderTransform);
var borderLeft = createBorderStyle("borderLeft", borderTransform);
var borderColor = createBorderStyle("borderColor");
var borderTopColor = createBorderStyle("borderTopColor");
var borderRightColor = createBorderStyle("borderRightColor");
var borderBottomColor = createBorderStyle("borderBottomColor");
var borderLeftColor = createBorderStyle("borderLeftColor");
var outline = createBorderStyle("outline", borderTransform);
var outlineColor = createBorderStyle("outlineColor");
var borderRadius = (props) => {
  if (props.borderRadius !== void 0 && props.borderRadius !== null) {
    const transformer3 = createUnaryUnit(props.theme, "shape.borderRadius", 4, "borderRadius");
    const styleFromPropValue = (propValue) => ({
      borderRadius: getValue(transformer3, propValue)
    });
    return handleBreakpoints(props, props.borderRadius, styleFromPropValue);
  }
  return null;
};
borderRadius.propTypes = true ? {
  borderRadius: responsivePropType_default
} : {};
borderRadius.filterProps = ["borderRadius"];
var borders = compose_default(border, borderTop, borderRight, borderBottom, borderLeft, borderColor, borderTopColor, borderRightColor, borderBottomColor, borderLeftColor, borderRadius, outline, outlineColor);
var borders_default = borders;

// node_modules/@mui/system/esm/cssGrid/cssGrid.js
var gap = (props) => {
  if (props.gap !== void 0 && props.gap !== null) {
    const transformer3 = createUnaryUnit(props.theme, "spacing", 8, "gap");
    const styleFromPropValue = (propValue) => ({
      gap: getValue(transformer3, propValue)
    });
    return handleBreakpoints(props, props.gap, styleFromPropValue);
  }
  return null;
};
gap.propTypes = true ? {
  gap: responsivePropType_default
} : {};
gap.filterProps = ["gap"];
var columnGap = (props) => {
  if (props.columnGap !== void 0 && props.columnGap !== null) {
    const transformer3 = createUnaryUnit(props.theme, "spacing", 8, "columnGap");
    const styleFromPropValue = (propValue) => ({
      columnGap: getValue(transformer3, propValue)
    });
    return handleBreakpoints(props, props.columnGap, styleFromPropValue);
  }
  return null;
};
columnGap.propTypes = true ? {
  columnGap: responsivePropType_default
} : {};
columnGap.filterProps = ["columnGap"];
var rowGap = (props) => {
  if (props.rowGap !== void 0 && props.rowGap !== null) {
    const transformer3 = createUnaryUnit(props.theme, "spacing", 8, "rowGap");
    const styleFromPropValue = (propValue) => ({
      rowGap: getValue(transformer3, propValue)
    });
    return handleBreakpoints(props, props.rowGap, styleFromPropValue);
  }
  return null;
};
rowGap.propTypes = true ? {
  rowGap: responsivePropType_default
} : {};
rowGap.filterProps = ["rowGap"];
var gridColumn = style_default({
  prop: "gridColumn"
});
var gridRow = style_default({
  prop: "gridRow"
});
var gridAutoFlow = style_default({
  prop: "gridAutoFlow"
});
var gridAutoColumns = style_default({
  prop: "gridAutoColumns"
});
var gridAutoRows = style_default({
  prop: "gridAutoRows"
});
var gridTemplateColumns = style_default({
  prop: "gridTemplateColumns"
});
var gridTemplateRows = style_default({
  prop: "gridTemplateRows"
});
var gridTemplateAreas = style_default({
  prop: "gridTemplateAreas"
});
var gridArea = style_default({
  prop: "gridArea"
});
var grid = compose_default(gap, columnGap, rowGap, gridColumn, gridRow, gridAutoFlow, gridAutoColumns, gridAutoRows, gridTemplateColumns, gridTemplateRows, gridTemplateAreas, gridArea);
var cssGrid_default = grid;

// node_modules/@mui/system/esm/palette/palette.js
function paletteTransform(value, userValue) {
  if (userValue === "grey") {
    return userValue;
  }
  return value;
}
var color2 = style_default({
  prop: "color",
  themeKey: "palette",
  transform: paletteTransform
});
var bgcolor = style_default({
  prop: "bgcolor",
  cssProperty: "backgroundColor",
  themeKey: "palette",
  transform: paletteTransform
});
var backgroundColor = style_default({
  prop: "backgroundColor",
  themeKey: "palette",
  transform: paletteTransform
});
var palette = compose_default(color2, bgcolor, backgroundColor);
var palette_default = palette;

// node_modules/@mui/system/esm/sizing/sizing.js
function sizingTransform(value) {
  return value <= 1 && value !== 0 ? `${value * 100}%` : value;
}
var width = style_default({
  prop: "width",
  transform: sizingTransform
});
var maxWidth = (props) => {
  if (props.maxWidth !== void 0 && props.maxWidth !== null) {
    const styleFromPropValue = (propValue) => {
      var _a, _b, _c, _d, _e2;
      const breakpoint = ((_c = (_b = (_a = props.theme) == null ? void 0 : _a.breakpoints) == null ? void 0 : _b.values) == null ? void 0 : _c[propValue]) || values[propValue];
      if (!breakpoint) {
        return {
          maxWidth: sizingTransform(propValue)
        };
      }
      if (((_e2 = (_d = props.theme) == null ? void 0 : _d.breakpoints) == null ? void 0 : _e2.unit) !== "px") {
        return {
          maxWidth: `${breakpoint}${props.theme.breakpoints.unit}`
        };
      }
      return {
        maxWidth: breakpoint
      };
    };
    return handleBreakpoints(props, props.maxWidth, styleFromPropValue);
  }
  return null;
};
maxWidth.filterProps = ["maxWidth"];
var minWidth = style_default({
  prop: "minWidth",
  transform: sizingTransform
});
var height = style_default({
  prop: "height",
  transform: sizingTransform
});
var maxHeight = style_default({
  prop: "maxHeight",
  transform: sizingTransform
});
var minHeight = style_default({
  prop: "minHeight",
  transform: sizingTransform
});
var sizeWidth = style_default({
  prop: "size",
  cssProperty: "width",
  transform: sizingTransform
});
var sizeHeight = style_default({
  prop: "size",
  cssProperty: "height",
  transform: sizingTransform
});
var boxSizing = style_default({
  prop: "boxSizing"
});
var sizing = compose_default(width, maxWidth, minWidth, height, maxHeight, minHeight, boxSizing);
var sizing_default = sizing;

// node_modules/@mui/system/esm/styleFunctionSx/defaultSxConfig.js
var defaultSxConfig = {
  // borders
  border: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderTop: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderRight: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderBottom: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderLeft: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderColor: {
    themeKey: "palette"
  },
  borderTopColor: {
    themeKey: "palette"
  },
  borderRightColor: {
    themeKey: "palette"
  },
  borderBottomColor: {
    themeKey: "palette"
  },
  borderLeftColor: {
    themeKey: "palette"
  },
  outline: {
    themeKey: "borders",
    transform: borderTransform
  },
  outlineColor: {
    themeKey: "palette"
  },
  borderRadius: {
    themeKey: "shape.borderRadius",
    style: borderRadius
  },
  // palette
  color: {
    themeKey: "palette",
    transform: paletteTransform
  },
  bgcolor: {
    themeKey: "palette",
    cssProperty: "backgroundColor",
    transform: paletteTransform
  },
  backgroundColor: {
    themeKey: "palette",
    transform: paletteTransform
  },
  // spacing
  p: {
    style: padding
  },
  pt: {
    style: padding
  },
  pr: {
    style: padding
  },
  pb: {
    style: padding
  },
  pl: {
    style: padding
  },
  px: {
    style: padding
  },
  py: {
    style: padding
  },
  padding: {
    style: padding
  },
  paddingTop: {
    style: padding
  },
  paddingRight: {
    style: padding
  },
  paddingBottom: {
    style: padding
  },
  paddingLeft: {
    style: padding
  },
  paddingX: {
    style: padding
  },
  paddingY: {
    style: padding
  },
  paddingInline: {
    style: padding
  },
  paddingInlineStart: {
    style: padding
  },
  paddingInlineEnd: {
    style: padding
  },
  paddingBlock: {
    style: padding
  },
  paddingBlockStart: {
    style: padding
  },
  paddingBlockEnd: {
    style: padding
  },
  m: {
    style: margin
  },
  mt: {
    style: margin
  },
  mr: {
    style: margin
  },
  mb: {
    style: margin
  },
  ml: {
    style: margin
  },
  mx: {
    style: margin
  },
  my: {
    style: margin
  },
  margin: {
    style: margin
  },
  marginTop: {
    style: margin
  },
  marginRight: {
    style: margin
  },
  marginBottom: {
    style: margin
  },
  marginLeft: {
    style: margin
  },
  marginX: {
    style: margin
  },
  marginY: {
    style: margin
  },
  marginInline: {
    style: margin
  },
  marginInlineStart: {
    style: margin
  },
  marginInlineEnd: {
    style: margin
  },
  marginBlock: {
    style: margin
  },
  marginBlockStart: {
    style: margin
  },
  marginBlockEnd: {
    style: margin
  },
  // display
  displayPrint: {
    cssProperty: false,
    transform: (value) => ({
      "@media print": {
        display: value
      }
    })
  },
  display: {},
  overflow: {},
  textOverflow: {},
  visibility: {},
  whiteSpace: {},
  // flexbox
  flexBasis: {},
  flexDirection: {},
  flexWrap: {},
  justifyContent: {},
  alignItems: {},
  alignContent: {},
  order: {},
  flex: {},
  flexGrow: {},
  flexShrink: {},
  alignSelf: {},
  justifyItems: {},
  justifySelf: {},
  // grid
  gap: {
    style: gap
  },
  rowGap: {
    style: rowGap
  },
  columnGap: {
    style: columnGap
  },
  gridColumn: {},
  gridRow: {},
  gridAutoFlow: {},
  gridAutoColumns: {},
  gridAutoRows: {},
  gridTemplateColumns: {},
  gridTemplateRows: {},
  gridTemplateAreas: {},
  gridArea: {},
  // positions
  position: {},
  zIndex: {
    themeKey: "zIndex"
  },
  top: {},
  right: {},
  bottom: {},
  left: {},
  // shadows
  boxShadow: {
    themeKey: "shadows"
  },
  // sizing
  width: {
    transform: sizingTransform
  },
  maxWidth: {
    style: maxWidth
  },
  minWidth: {
    transform: sizingTransform
  },
  height: {
    transform: sizingTransform
  },
  maxHeight: {
    transform: sizingTransform
  },
  minHeight: {
    transform: sizingTransform
  },
  boxSizing: {},
  // typography
  font: {
    themeKey: "font"
  },
  fontFamily: {
    themeKey: "typography"
  },
  fontSize: {
    themeKey: "typography"
  },
  fontStyle: {
    themeKey: "typography"
  },
  fontWeight: {
    themeKey: "typography"
  },
  letterSpacing: {},
  textTransform: {},
  lineHeight: {},
  textAlign: {},
  typography: {
    cssProperty: false,
    themeKey: "typography"
  }
};
var defaultSxConfig_default = defaultSxConfig;

// node_modules/@mui/system/esm/styleFunctionSx/styleFunctionSx.js
function objectsHaveSameKeys(...objects) {
  const allKeys = objects.reduce((keys, object) => keys.concat(Object.keys(object)), []);
  const union2 = new Set(allKeys);
  return objects.every((object) => union2.size === Object.keys(object).length);
}
function callIfFn(maybeFn, arg2) {
  return typeof maybeFn === "function" ? maybeFn(arg2) : maybeFn;
}
function unstable_createStyleFunctionSx() {
  function getThemeValue(prop, val, theme, config) {
    const props = {
      [prop]: val,
      theme
    };
    const options = config[prop];
    if (!options) {
      return {
        [prop]: val
      };
    }
    const {
      cssProperty = prop,
      themeKey,
      transform,
      style: style4
    } = options;
    if (val == null) {
      return null;
    }
    if (themeKey === "typography" && val === "inherit") {
      return {
        [prop]: val
      };
    }
    const themeMapping = getPath(theme, themeKey) || {};
    if (style4) {
      return style4(props);
    }
    const styleFromPropValue = (propValueFinal) => {
      let value = getStyleValue(themeMapping, transform, propValueFinal);
      if (propValueFinal === value && typeof propValueFinal === "string") {
        value = getStyleValue(themeMapping, transform, `${prop}${propValueFinal === "default" ? "" : capitalize(propValueFinal)}`, propValueFinal);
      }
      if (cssProperty === false) {
        return value;
      }
      return {
        [cssProperty]: value
      };
    };
    return handleBreakpoints(props, val, styleFromPropValue);
  }
  function styleFunctionSx2(props) {
    const {
      sx,
      theme = {}
    } = props || {};
    if (!sx) {
      return null;
    }
    const config = theme.unstable_sxConfig ?? defaultSxConfig_default;
    function traverse(sxInput) {
      let sxObject = sxInput;
      if (typeof sxInput === "function") {
        sxObject = sxInput(theme);
      } else if (typeof sxInput !== "object") {
        return sxInput;
      }
      if (!sxObject) {
        return null;
      }
      const emptyBreakpoints = createEmptyBreakpointObject(theme.breakpoints);
      const breakpointsKeys = Object.keys(emptyBreakpoints);
      let css = emptyBreakpoints;
      Object.keys(sxObject).forEach((styleKey) => {
        const value = callIfFn(sxObject[styleKey], theme);
        if (value !== null && value !== void 0) {
          if (typeof value === "object") {
            if (config[styleKey]) {
              css = merge_default(css, getThemeValue(styleKey, value, theme, config));
            } else {
              const breakpointsValues = handleBreakpoints({
                theme
              }, value, (x3) => ({
                [styleKey]: x3
              }));
              if (objectsHaveSameKeys(breakpointsValues, value)) {
                css[styleKey] = styleFunctionSx2({
                  sx: value,
                  theme
                });
              } else {
                css = merge_default(css, breakpointsValues);
              }
            }
          } else {
            css = merge_default(css, getThemeValue(styleKey, value, theme, config));
          }
        }
      });
      return sortContainerQueries(theme, removeUnusedBreakpoints(breakpointsKeys, css));
    }
    return Array.isArray(sx) ? sx.map(traverse) : traverse(sx);
  }
  return styleFunctionSx2;
}
var styleFunctionSx = unstable_createStyleFunctionSx();
styleFunctionSx.filterProps = ["sx"];
var styleFunctionSx_default = styleFunctionSx;

// node_modules/@mui/system/esm/createTheme/applyStyles.js
function applyStyles(key, styles) {
  var _a;
  const theme = this;
  if (theme.vars) {
    if (!((_a = theme.colorSchemes) == null ? void 0 : _a[key]) || typeof theme.getColorSchemeSelector !== "function") {
      return {};
    }
    let selector = theme.getColorSchemeSelector(key);
    if (selector === "&") {
      return styles;
    }
    if (selector.includes("data-") || selector.includes(".")) {
      selector = `*:where(${selector.replace(/\s*&$/, "")}) &`;
    }
    return {
      [selector]: styles
    };
  }
  if (theme.palette.mode === key) {
    return styles;
  }
  return {};
}

// node_modules/@mui/system/esm/createTheme/createTheme.js
function createTheme(options = {}, ...args) {
  const {
    breakpoints: breakpointsInput = {},
    palette: paletteInput = {},
    spacing: spacingInput,
    shape: shapeInput = {},
    ...other
  } = options;
  const breakpoints = createBreakpoints(breakpointsInput);
  const spacing2 = createSpacing(spacingInput);
  let muiTheme = deepmerge({
    breakpoints,
    direction: "ltr",
    components: {},
    // Inject component definitions.
    palette: {
      mode: "light",
      ...paletteInput
    },
    spacing: spacing2,
    shape: {
      ...shape_default,
      ...shapeInput
    }
  }, other);
  muiTheme = cssContainerQueries(muiTheme);
  muiTheme.applyStyles = applyStyles;
  muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);
  muiTheme.unstable_sxConfig = {
    ...defaultSxConfig_default,
    ...other == null ? void 0 : other.unstable_sxConfig
  };
  muiTheme.unstable_sx = function sx(props) {
    return styleFunctionSx_default({
      sx: props,
      theme: this
    });
  };
  return muiTheme;
}
var createTheme_default = createTheme;

// node_modules/@mui/system/esm/useThemeWithoutDefault/useThemeWithoutDefault.js
var React21 = __toESM(require_react(), 1);
function isObjectEmpty(obj) {
  return Object.keys(obj).length === 0;
}
function useTheme(defaultTheme5 = null) {
  const contextTheme = React21.useContext(et);
  return !contextTheme || isObjectEmpty(contextTheme) ? defaultTheme5 : contextTheme;
}
var useThemeWithoutDefault_default = useTheme;

// node_modules/@mui/system/esm/useTheme/useTheme.js
var systemDefaultTheme = createTheme_default();
function useTheme2(defaultTheme5 = systemDefaultTheme) {
  return useThemeWithoutDefault_default(defaultTheme5);
}
var useTheme_default = useTheme2;

// node_modules/@mui/system/esm/GlobalStyles/GlobalStyles.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
function GlobalStyles2({
  styles,
  themeId,
  defaultTheme: defaultTheme5 = {}
}) {
  const upperTheme = useTheme_default(defaultTheme5);
  const globalStyles = typeof styles === "function" ? styles(themeId ? upperTheme[themeId] || upperTheme : upperTheme) : styles;
  return (0, import_jsx_runtime2.jsx)(GlobalStyles_default, {
    styles: globalStyles
  });
}
true ? GlobalStyles2.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //  To update them, edit the TypeScript types and run `pnpm proptypes`. 
  // 
  /**
   * @ignore
   */
  defaultTheme: import_prop_types5.default.object,
  /**
   * @ignore
   */
  styles: import_prop_types5.default.oneOfType([import_prop_types5.default.array, import_prop_types5.default.func, import_prop_types5.default.number, import_prop_types5.default.object, import_prop_types5.default.string, import_prop_types5.default.bool]),
  /**
   * @ignore
   */
  themeId: import_prop_types5.default.string
} : void 0;
var GlobalStyles_default2 = GlobalStyles2;

// node_modules/@mui/system/esm/display/display.js
var displayPrint = style_default({
  prop: "displayPrint",
  cssProperty: false,
  transform: (value) => ({
    "@media print": {
      display: value
    }
  })
});
var displayRaw = style_default({
  prop: "display"
});
var overflow = style_default({
  prop: "overflow"
});
var textOverflow = style_default({
  prop: "textOverflow"
});
var visibility = style_default({
  prop: "visibility"
});
var whiteSpace = style_default({
  prop: "whiteSpace"
});
var display_default = compose_default(displayPrint, displayRaw, overflow, textOverflow, visibility, whiteSpace);

// node_modules/@mui/system/esm/flexbox/flexbox.js
var flexBasis = style_default({
  prop: "flexBasis"
});
var flexDirection = style_default({
  prop: "flexDirection"
});
var flexWrap = style_default({
  prop: "flexWrap"
});
var justifyContent = style_default({
  prop: "justifyContent"
});
var alignItems = style_default({
  prop: "alignItems"
});
var alignContent = style_default({
  prop: "alignContent"
});
var order = style_default({
  prop: "order"
});
var flex = style_default({
  prop: "flex"
});
var flexGrow = style_default({
  prop: "flexGrow"
});
var flexShrink = style_default({
  prop: "flexShrink"
});
var alignSelf = style_default({
  prop: "alignSelf"
});
var justifyItems = style_default({
  prop: "justifyItems"
});
var justifySelf = style_default({
  prop: "justifySelf"
});
var flexbox = compose_default(flexBasis, flexDirection, flexWrap, justifyContent, alignItems, alignContent, order, flex, flexGrow, flexShrink, alignSelf, justifyItems, justifySelf);
var flexbox_default = flexbox;

// node_modules/@mui/system/esm/positions/positions.js
var position2 = style_default({
  prop: "position"
});
var zIndex = style_default({
  prop: "zIndex",
  themeKey: "zIndex"
});
var top = style_default({
  prop: "top"
});
var right = style_default({
  prop: "right"
});
var bottom = style_default({
  prop: "bottom"
});
var left = style_default({
  prop: "left"
});
var positions_default = compose_default(position2, zIndex, top, right, bottom, left);

// node_modules/@mui/system/esm/shadows/shadows.js
var boxShadow = style_default({
  prop: "boxShadow",
  themeKey: "shadows"
});
var shadows_default = boxShadow;

// node_modules/@mui/system/esm/typography/typography.js
var fontFamily = style_default({
  prop: "fontFamily",
  themeKey: "typography"
});
var fontSize = style_default({
  prop: "fontSize",
  themeKey: "typography"
});
var fontStyle = style_default({
  prop: "fontStyle",
  themeKey: "typography"
});
var fontWeight = style_default({
  prop: "fontWeight",
  themeKey: "typography"
});
var letterSpacing = style_default({
  prop: "letterSpacing"
});
var textTransform = style_default({
  prop: "textTransform"
});
var lineHeight = style_default({
  prop: "lineHeight"
});
var textAlign = style_default({
  prop: "textAlign"
});
var typographyVariant = style_default({
  prop: "typography",
  cssProperty: false,
  themeKey: "typography"
});
var typography = compose_default(typographyVariant, fontFamily, fontSize, fontStyle, fontWeight, letterSpacing, lineHeight, textAlign, textTransform);
var typography_default = typography;

// node_modules/@mui/system/esm/styleFunctionSx/extendSxProp.js
var splitProps = (props) => {
  var _a;
  const result = {
    systemProps: {},
    otherProps: {}
  };
  const config = ((_a = props == null ? void 0 : props.theme) == null ? void 0 : _a.unstable_sxConfig) ?? defaultSxConfig_default;
  Object.keys(props).forEach((prop) => {
    if (config[prop]) {
      result.systemProps[prop] = props[prop];
    } else {
      result.otherProps[prop] = props[prop];
    }
  });
  return result;
};
function extendSxProp(props) {
  const {
    sx: inSx,
    ...other
  } = props;
  const {
    systemProps,
    otherProps
  } = splitProps(other);
  let finalSx;
  if (Array.isArray(inSx)) {
    finalSx = [systemProps, ...inSx];
  } else if (typeof inSx === "function") {
    finalSx = (...args) => {
      const result = inSx(...args);
      if (!isPlainObject(result)) {
        return systemProps;
      }
      return {
        ...systemProps,
        ...result
      };
    };
  } else {
    finalSx = {
      ...systemProps,
      ...inSx
    };
  }
  return {
    ...otherProps,
    sx: finalSx
  };
}

// node_modules/@mui/system/esm/getThemeValue/getThemeValue.js
var filterPropsMapping = {
  borders: borders_default.filterProps,
  display: display_default.filterProps,
  flexbox: flexbox_default.filterProps,
  grid: cssGrid_default.filterProps,
  positions: positions_default.filterProps,
  palette: palette_default.filterProps,
  shadows: shadows_default.filterProps,
  sizing: sizing_default.filterProps,
  spacing: spacing_default.filterProps,
  typography: typography_default.filterProps
};
var styleFunctionMapping = {
  borders: borders_default,
  display: display_default,
  flexbox: flexbox_default,
  grid: cssGrid_default,
  positions: positions_default,
  palette: palette_default,
  shadows: shadows_default,
  sizing: sizing_default,
  spacing: spacing_default,
  typography: typography_default
};
var propToStyleFunction = Object.keys(filterPropsMapping).reduce((acc, styleFnName) => {
  filterPropsMapping[styleFnName].forEach((propName) => {
    acc[propName] = styleFunctionMapping[styleFnName];
  });
  return acc;
}, {});

// node_modules/@mui/system/esm/Box/Box.js
var import_prop_types6 = __toESM(require_prop_types(), 1);

// node_modules/@mui/utils/esm/ClassNameGenerator/ClassNameGenerator.js
var defaultGenerator = (componentName) => componentName;
var createClassNameGenerator = () => {
  let generate = defaultGenerator;
  return {
    configure(generator) {
      generate = generator;
    },
    generate(componentName) {
      return generate(componentName);
    },
    reset() {
      generate = defaultGenerator;
    }
  };
};
var ClassNameGenerator = createClassNameGenerator();
var ClassNameGenerator_default = ClassNameGenerator;

// node_modules/@mui/system/esm/createBox/createBox.js
var React23 = __toESM(require_react(), 1);

// node_modules/clsx/dist/clsx.mjs
function r2(e) {
  var t, f2, n = "";
  if ("string" == typeof e || "number" == typeof e) n += e;
  else if ("object" == typeof e) if (Array.isArray(e)) {
    var o2 = e.length;
    for (t = 0; t < o2; t++) e[t] && (f2 = r2(e[t])) && (n && (n += " "), n += f2);
  } else for (f2 in e) e[f2] && (n && (n += " "), n += f2);
  return n;
}
function clsx() {
  for (var e, t, f2 = 0, n = "", o2 = arguments.length; f2 < o2; f2++) (e = arguments[f2]) && (t = r2(e)) && (n && (n += " "), n += t);
  return n;
}
var clsx_default = clsx;

// node_modules/@mui/system/esm/createBox/createBox.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
function createBox(options = {}) {
  const {
    themeId,
    defaultTheme: defaultTheme5,
    defaultClassName = "MuiBox-root",
    generateClassName
  } = options;
  const BoxRoot = styled("div", {
    shouldForwardProp: (prop) => prop !== "theme" && prop !== "sx" && prop !== "as"
  })(styleFunctionSx_default);
  const Box2 = React23.forwardRef(function Box3(inProps, ref) {
    const theme = useTheme_default(defaultTheme5);
    const {
      className,
      component = "div",
      ...other
    } = extendSxProp(inProps);
    return (0, import_jsx_runtime3.jsx)(BoxRoot, {
      as: component,
      ref,
      className: clsx_default(className, generateClassName ? generateClassName(defaultClassName) : defaultClassName),
      theme: themeId ? theme[themeId] || theme : theme,
      ...other
    });
  });
  return Box2;
}

// node_modules/@mui/utils/esm/generateUtilityClass/generateUtilityClass.js
var globalStateClasses = {
  active: "active",
  checked: "checked",
  completed: "completed",
  disabled: "disabled",
  error: "error",
  expanded: "expanded",
  focused: "focused",
  focusVisible: "focusVisible",
  open: "open",
  readOnly: "readOnly",
  required: "required",
  selected: "selected"
};
function generateUtilityClass(componentName, slot, globalStatePrefix = "Mui") {
  const globalStateClass = globalStateClasses[slot];
  return globalStateClass ? `${globalStatePrefix}-${globalStateClass}` : `${ClassNameGenerator_default.generate(componentName)}-${slot}`;
}

// node_modules/@mui/utils/esm/generateUtilityClasses/generateUtilityClasses.js
function generateUtilityClasses(componentName, slots, globalStatePrefix = "Mui") {
  const result = {};
  slots.forEach((slot) => {
    result[slot] = generateUtilityClass(componentName, slot, globalStatePrefix);
  });
  return result;
}

// node_modules/@mui/system/esm/Box/boxClasses.js
var boxClasses = generateUtilityClasses("MuiBox", ["root"]);
var boxClasses_default = boxClasses;

// node_modules/@mui/system/esm/Box/Box.js
var Box = createBox({
  defaultClassName: boxClasses_default.root,
  generateClassName: ClassNameGenerator_default.generate
});
true ? Box.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * @ignore
   */
  children: import_prop_types6.default.node,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: import_prop_types6.default.elementType,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types6.default.oneOfType([import_prop_types6.default.arrayOf(import_prop_types6.default.oneOfType([import_prop_types6.default.func, import_prop_types6.default.object, import_prop_types6.default.bool])), import_prop_types6.default.func, import_prop_types6.default.object])
} : void 0;

// node_modules/@mui/utils/esm/getDisplayName/getDisplayName.js
var import_react_is2 = __toESM(require_react_is(), 1);
function getFunctionComponentName(Component, fallback = "") {
  return Component.displayName || Component.name || fallback;
}
function getWrappedName(outerType, innerType, wrapperName) {
  const functionName = getFunctionComponentName(innerType);
  return outerType.displayName || (functionName !== "" ? `${wrapperName}(${functionName})` : wrapperName);
}
function getDisplayName(Component) {
  if (Component == null) {
    return void 0;
  }
  if (typeof Component === "string") {
    return Component;
  }
  if (typeof Component === "function") {
    return getFunctionComponentName(Component, "Component");
  }
  if (typeof Component === "object") {
    switch (Component.$$typeof) {
      case import_react_is2.ForwardRef:
        return getWrappedName(Component, Component.render, "ForwardRef");
      case import_react_is2.Memo:
        return getWrappedName(Component, Component.type, "memo");
      default:
        return void 0;
    }
  }
  return void 0;
}

// node_modules/@mui/system/esm/preprocessStyles.js
function preprocessStyles(input) {
  const {
    variants,
    ...style4
  } = input;
  const result = {
    variants,
    style: internal_serializeStyles(style4),
    isProcessed: true
  };
  if (result.style === style4) {
    return result;
  }
  if (variants) {
    variants.forEach((variant) => {
      if (typeof variant.style !== "function") {
        variant.style = internal_serializeStyles(variant.style);
      }
    });
  }
  return result;
}

// node_modules/@mui/system/esm/createStyled/createStyled.js
var systemDefaultTheme2 = createTheme_default();
function shouldForwardProp(prop) {
  return prop !== "ownerState" && prop !== "theme" && prop !== "sx" && prop !== "as";
}
function defaultOverridesResolver(slot) {
  if (!slot) {
    return null;
  }
  return (_props, styles) => styles[slot];
}
function attachTheme(props, themeId, defaultTheme5) {
  props.theme = isObjectEmpty2(props.theme) ? defaultTheme5 : props.theme[themeId] || props.theme;
}
function processStyle(props, style4) {
  const resolvedStyle = typeof style4 === "function" ? style4(props) : style4;
  if (Array.isArray(resolvedStyle)) {
    return resolvedStyle.flatMap((subStyle) => processStyle(props, subStyle));
  }
  if (Array.isArray(resolvedStyle == null ? void 0 : resolvedStyle.variants)) {
    let rootStyle;
    if (resolvedStyle.isProcessed) {
      rootStyle = resolvedStyle.style;
    } else {
      const {
        variants,
        ...otherStyles
      } = resolvedStyle;
      rootStyle = otherStyles;
    }
    return processStyleVariants(props, resolvedStyle.variants, [rootStyle]);
  }
  if (resolvedStyle == null ? void 0 : resolvedStyle.isProcessed) {
    return resolvedStyle.style;
  }
  return resolvedStyle;
}
function processStyleVariants(props, variants, results = []) {
  var _a;
  let mergedState;
  variantLoop: for (let i2 = 0; i2 < variants.length; i2 += 1) {
    const variant = variants[i2];
    if (typeof variant.props === "function") {
      mergedState ?? (mergedState = {
        ...props,
        ...props.ownerState,
        ownerState: props.ownerState
      });
      if (!variant.props(mergedState)) {
        continue;
      }
    } else {
      for (const key in variant.props) {
        if (props[key] !== variant.props[key] && ((_a = props.ownerState) == null ? void 0 : _a[key]) !== variant.props[key]) {
          continue variantLoop;
        }
      }
    }
    if (typeof variant.style === "function") {
      mergedState ?? (mergedState = {
        ...props,
        ...props.ownerState,
        ownerState: props.ownerState
      });
      results.push(variant.style(mergedState));
    } else {
      results.push(variant.style);
    }
  }
  return results;
}
function createStyled(input = {}) {
  const {
    themeId,
    defaultTheme: defaultTheme5 = systemDefaultTheme2,
    rootShouldForwardProp: rootShouldForwardProp2 = shouldForwardProp,
    slotShouldForwardProp: slotShouldForwardProp2 = shouldForwardProp
  } = input;
  function styleAttachTheme(props) {
    attachTheme(props, themeId, defaultTheme5);
  }
  const styled4 = (tag, inputOptions = {}) => {
    internal_mutateStyles(tag, (styles) => styles.filter((style4) => style4 !== styleFunctionSx_default));
    const {
      name: componentName,
      slot: componentSlot,
      skipVariantsResolver: inputSkipVariantsResolver,
      skipSx: inputSkipSx,
      // TODO v6: remove `lowercaseFirstLetter()` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      overridesResolver = defaultOverridesResolver(lowercaseFirstLetter(componentSlot)),
      ...options
    } = inputOptions;
    const skipVariantsResolver = inputSkipVariantsResolver !== void 0 ? inputSkipVariantsResolver : (
      // TODO v6: remove `Root` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      componentSlot && componentSlot !== "Root" && componentSlot !== "root" || false
    );
    const skipSx = inputSkipSx || false;
    let shouldForwardPropOption = shouldForwardProp;
    if (componentSlot === "Root" || componentSlot === "root") {
      shouldForwardPropOption = rootShouldForwardProp2;
    } else if (componentSlot) {
      shouldForwardPropOption = slotShouldForwardProp2;
    } else if (isStringTag(tag)) {
      shouldForwardPropOption = void 0;
    }
    const defaultStyledResolver = styled(tag, {
      shouldForwardProp: shouldForwardPropOption,
      label: generateStyledLabel(componentName, componentSlot),
      ...options
    });
    const transformStyle = (style4) => {
      if (typeof style4 === "function" && style4.__emotion_real !== style4) {
        return function styleFunctionProcessor(props) {
          return processStyle(props, style4);
        };
      }
      if (isPlainObject(style4)) {
        const serialized = preprocessStyles(style4);
        if (!serialized.variants) {
          return serialized.style;
        }
        return function styleObjectProcessor(props) {
          return processStyle(props, serialized);
        };
      }
      return style4;
    };
    const muiStyledResolver = (...expressionsInput) => {
      const expressionsHead = [];
      const expressionsBody = expressionsInput.map(transformStyle);
      const expressionsTail = [];
      expressionsHead.push(styleAttachTheme);
      if (componentName && overridesResolver) {
        expressionsTail.push(function styleThemeOverrides(props) {
          var _a, _b;
          const theme = props.theme;
          const styleOverrides = (_b = (_a = theme.components) == null ? void 0 : _a[componentName]) == null ? void 0 : _b.styleOverrides;
          if (!styleOverrides) {
            return null;
          }
          const resolvedStyleOverrides = {};
          for (const slotKey in styleOverrides) {
            resolvedStyleOverrides[slotKey] = processStyle(props, styleOverrides[slotKey]);
          }
          return overridesResolver(props, resolvedStyleOverrides);
        });
      }
      if (componentName && !skipVariantsResolver) {
        expressionsTail.push(function styleThemeVariants(props) {
          var _a, _b;
          const theme = props.theme;
          const themeVariants = (_b = (_a = theme == null ? void 0 : theme.components) == null ? void 0 : _a[componentName]) == null ? void 0 : _b.variants;
          if (!themeVariants) {
            return null;
          }
          return processStyleVariants(props, themeVariants);
        });
      }
      if (!skipSx) {
        expressionsTail.push(styleFunctionSx_default);
      }
      if (Array.isArray(expressionsBody[0])) {
        const inputStrings = expressionsBody.shift();
        const placeholdersHead = new Array(expressionsHead.length).fill("");
        const placeholdersTail = new Array(expressionsTail.length).fill("");
        let outputStrings;
        {
          outputStrings = [...placeholdersHead, ...inputStrings, ...placeholdersTail];
          outputStrings.raw = [...placeholdersHead, ...inputStrings.raw, ...placeholdersTail];
        }
        expressionsHead.unshift(outputStrings);
      }
      const expressions = [...expressionsHead, ...expressionsBody, ...expressionsTail];
      const Component = defaultStyledResolver(...expressions);
      if (tag.muiName) {
        Component.muiName = tag.muiName;
      }
      if (true) {
        Component.displayName = generateDisplayName(componentName, componentSlot, tag);
      }
      return Component;
    };
    if (defaultStyledResolver.withConfig) {
      muiStyledResolver.withConfig = defaultStyledResolver.withConfig;
    }
    return muiStyledResolver;
  };
  return styled4;
}
function generateDisplayName(componentName, componentSlot, tag) {
  if (componentName) {
    return `${componentName}${capitalize(componentSlot || "")}`;
  }
  return `Styled(${getDisplayName(tag)})`;
}
function generateStyledLabel(componentName, componentSlot) {
  let label;
  if (true) {
    if (componentName) {
      label = `${componentName}-${lowercaseFirstLetter(componentSlot || "Root")}`;
    }
  }
  return label;
}
function isObjectEmpty2(object) {
  for (const _2 in object) {
    return false;
  }
  return true;
}
function isStringTag(tag) {
  return typeof tag === "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  tag.charCodeAt(0) > 96;
}
function lowercaseFirstLetter(string) {
  if (!string) {
    return string;
  }
  return string.charAt(0).toLowerCase() + string.slice(1);
}

// node_modules/@mui/system/esm/styled/styled.js
var styled2 = createStyled();
var styled_default = styled2;

// node_modules/@mui/utils/esm/resolveProps/resolveProps.js
function resolveProps(defaultProps4, props) {
  const output = {
    ...props
  };
  for (const key in defaultProps4) {
    if (Object.prototype.hasOwnProperty.call(defaultProps4, key)) {
      const propName = key;
      if (propName === "components" || propName === "slots") {
        output[propName] = {
          ...defaultProps4[propName],
          ...output[propName]
        };
      } else if (propName === "componentsProps" || propName === "slotProps") {
        const defaultSlotProps = defaultProps4[propName];
        const slotProps = props[propName];
        if (!slotProps) {
          output[propName] = defaultSlotProps || {};
        } else if (!defaultSlotProps) {
          output[propName] = slotProps;
        } else {
          output[propName] = {
            ...slotProps
          };
          for (const slotKey in defaultSlotProps) {
            if (Object.prototype.hasOwnProperty.call(defaultSlotProps, slotKey)) {
              const slotPropName = slotKey;
              output[propName][slotPropName] = resolveProps(defaultSlotProps[slotPropName], slotProps[slotPropName]);
            }
          }
        }
      } else if (output[propName] === void 0) {
        output[propName] = defaultProps4[propName];
      }
    }
  }
  return output;
}

// node_modules/@mui/system/esm/useThemeProps/getThemeProps.js
function getThemeProps(params) {
  const {
    theme,
    name,
    props
  } = params;
  if (!theme || !theme.components || !theme.components[name] || !theme.components[name].defaultProps) {
    return props;
  }
  return resolveProps(theme.components[name].defaultProps, props);
}

// node_modules/@mui/system/esm/useThemeProps/useThemeProps.js
function useThemeProps({
  props,
  name,
  defaultTheme: defaultTheme5,
  themeId
}) {
  let theme = useTheme_default(defaultTheme5);
  if (themeId) {
    theme = theme[themeId] || theme;
  }
  return getThemeProps({
    theme,
    name,
    props
  });
}

// node_modules/@mui/system/esm/useMediaQuery/useMediaQuery.js
var React24 = __toESM(require_react(), 1);
function useMediaQueryOld(query, defaultMatches, matchMedia, ssrMatchMedia, noSsr) {
  const [match2, setMatch] = React24.useState(() => {
    if (noSsr && matchMedia) {
      return matchMedia(query).matches;
    }
    if (ssrMatchMedia) {
      return ssrMatchMedia(query).matches;
    }
    return defaultMatches;
  });
  useEnhancedEffect_default(() => {
    if (!matchMedia) {
      return void 0;
    }
    const queryList = matchMedia(query);
    const updateMatch = () => {
      setMatch(queryList.matches);
    };
    updateMatch();
    queryList.addEventListener("change", updateMatch);
    return () => {
      queryList.removeEventListener("change", updateMatch);
    };
  }, [query, matchMedia]);
  return match2;
}
var safeReact2 = {
  ...React24
};
var maybeReactUseSyncExternalStore = safeReact2.useSyncExternalStore;
function useMediaQueryNew(query, defaultMatches, matchMedia, ssrMatchMedia, noSsr) {
  const getDefaultSnapshot = React24.useCallback(() => defaultMatches, [defaultMatches]);
  const getServerSnapshot = React24.useMemo(() => {
    if (noSsr && matchMedia) {
      return () => matchMedia(query).matches;
    }
    if (ssrMatchMedia !== null) {
      const {
        matches
      } = ssrMatchMedia(query);
      return () => matches;
    }
    return getDefaultSnapshot;
  }, [getDefaultSnapshot, query, ssrMatchMedia, noSsr, matchMedia]);
  const [getSnapshot, subscribe] = React24.useMemo(() => {
    if (matchMedia === null) {
      return [getDefaultSnapshot, () => () => {
      }];
    }
    const mediaQueryList = matchMedia(query);
    return [() => mediaQueryList.matches, (notify) => {
      mediaQueryList.addEventListener("change", notify);
      return () => {
        mediaQueryList.removeEventListener("change", notify);
      };
    }];
  }, [getDefaultSnapshot, matchMedia, query]);
  const match2 = maybeReactUseSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
  return match2;
}
function unstable_createUseMediaQuery(params = {}) {
  const {
    themeId
  } = params;
  return function useMediaQuery2(queryInput, options = {}) {
    let theme = useThemeWithoutDefault_default();
    if (theme && themeId) {
      theme = theme[themeId] || theme;
    }
    const supportMatchMedia = typeof window !== "undefined" && typeof window.matchMedia !== "undefined";
    const {
      defaultMatches = false,
      matchMedia = supportMatchMedia ? window.matchMedia : null,
      ssrMatchMedia = null,
      noSsr = false
    } = getThemeProps({
      name: "MuiUseMediaQuery",
      props: options,
      theme
    });
    if (true) {
      if (typeof queryInput === "function" && theme === null) {
        console.error(["MUI: The `query` argument provided is invalid.", "You are providing a function without a theme in the context.", "One of the parent elements needs to use a ThemeProvider."].join("\n"));
      }
    }
    let query = typeof queryInput === "function" ? queryInput(theme) : queryInput;
    query = query.replace(/^@media( ?)/m, "");
    if (query.includes("print")) {
      console.warn([`MUI: You have provided a \`print\` query to the \`useMediaQuery\` hook.`, "Using the print media query to modify print styles can lead to unexpected results.", "Consider using the `displayPrint` field in the `sx` prop instead.", "More information about `displayPrint` on our docs: https://mui.com/system/display/#display-in-print."].join("\n"));
    }
    const useMediaQueryImplementation = maybeReactUseSyncExternalStore !== void 0 ? useMediaQueryNew : useMediaQueryOld;
    const match2 = useMediaQueryImplementation(query, defaultMatches, matchMedia, ssrMatchMedia, noSsr);
    if (true) {
      React24.useDebugValue({
        query,
        match: match2
      });
    }
    return match2;
  };
}
var useMediaQuery = unstable_createUseMediaQuery();

// node_modules/@mui/utils/esm/clamp/clamp.js
function clamp(val, min4 = Number.MIN_SAFE_INTEGER, max4 = Number.MAX_SAFE_INTEGER) {
  return Math.max(min4, Math.min(val, max4));
}
var clamp_default = clamp;

// node_modules/@mui/system/esm/colorManipulator/colorManipulator.js
function clampWrapper(value, min4 = 0, max4 = 1) {
  if (true) {
    if (value < min4 || value > max4) {
      console.error(`MUI: The value provided ${value} is out of range [${min4}, ${max4}].`);
    }
  }
  return clamp_default(value, min4, max4);
}
function hexToRgb(color3) {
  color3 = color3.slice(1);
  const re3 = new RegExp(`.{1,${color3.length >= 6 ? 2 : 1}}`, "g");
  let colors = color3.match(re3);
  if (colors && colors[0].length === 1) {
    colors = colors.map((n) => n + n);
  }
  if (true) {
    if (color3.length !== color3.trim().length) {
      console.error(`MUI: The color: "${color3}" is invalid. Make sure the color input doesn't contain leading/trailing space.`);
    }
  }
  return colors ? `rgb${colors.length === 4 ? "a" : ""}(${colors.map((n, index2) => {
    return index2 < 3 ? parseInt(n, 16) : Math.round(parseInt(n, 16) / 255 * 1e3) / 1e3;
  }).join(", ")})` : "";
}
function decomposeColor(color3) {
  if (color3.type) {
    return color3;
  }
  if (color3.charAt(0) === "#") {
    return decomposeColor(hexToRgb(color3));
  }
  const marker = color3.indexOf("(");
  const type = color3.substring(0, marker);
  if (!["rgb", "rgba", "hsl", "hsla", "color"].includes(type)) {
    throw new Error(true ? `MUI: Unsupported \`${color3}\` color.
The following formats are supported: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color().` : formatMuiErrorMessage(9, color3));
  }
  let values3 = color3.substring(marker + 1, color3.length - 1);
  let colorSpace;
  if (type === "color") {
    values3 = values3.split(" ");
    colorSpace = values3.shift();
    if (values3.length === 4 && values3[3].charAt(0) === "/") {
      values3[3] = values3[3].slice(1);
    }
    if (!["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].includes(colorSpace)) {
      throw new Error(true ? `MUI: unsupported \`${colorSpace}\` color space.
The following color spaces are supported: srgb, display-p3, a98-rgb, prophoto-rgb, rec-2020.` : formatMuiErrorMessage(10, colorSpace));
    }
  } else {
    values3 = values3.split(",");
  }
  values3 = values3.map((value) => parseFloat(value));
  return {
    type,
    values: values3,
    colorSpace
  };
}
var colorChannel = (color3) => {
  const decomposedColor = decomposeColor(color3);
  return decomposedColor.values.slice(0, 3).map((val, idx) => decomposedColor.type.includes("hsl") && idx !== 0 ? `${val}%` : val).join(" ");
};
var private_safeColorChannel = (color3, warning) => {
  try {
    return colorChannel(color3);
  } catch (error) {
    if (warning && true) {
      console.warn(warning);
    }
    return color3;
  }
};
function recomposeColor(color3) {
  const {
    type,
    colorSpace
  } = color3;
  let {
    values: values3
  } = color3;
  if (type.includes("rgb")) {
    values3 = values3.map((n, i2) => i2 < 3 ? parseInt(n, 10) : n);
  } else if (type.includes("hsl")) {
    values3[1] = `${values3[1]}%`;
    values3[2] = `${values3[2]}%`;
  }
  if (type.includes("color")) {
    values3 = `${colorSpace} ${values3.join(" ")}`;
  } else {
    values3 = `${values3.join(", ")}`;
  }
  return `${type}(${values3})`;
}
function hslToRgb(color3) {
  color3 = decomposeColor(color3);
  const {
    values: values3
  } = color3;
  const h = values3[0];
  const s3 = values3[1] / 100;
  const l2 = values3[2] / 100;
  const a3 = s3 * Math.min(l2, 1 - l2);
  const f2 = (n, k3 = (n + h / 30) % 12) => l2 - a3 * Math.max(Math.min(k3 - 3, 9 - k3, 1), -1);
  let type = "rgb";
  const rgb2 = [Math.round(f2(0) * 255), Math.round(f2(8) * 255), Math.round(f2(4) * 255)];
  if (color3.type === "hsla") {
    type += "a";
    rgb2.push(values3[3]);
  }
  return recomposeColor({
    type,
    values: rgb2
  });
}
function getLuminance(color3) {
  color3 = decomposeColor(color3);
  let rgb2 = color3.type === "hsl" || color3.type === "hsla" ? decomposeColor(hslToRgb(color3)).values : color3.values;
  rgb2 = rgb2.map((val) => {
    if (color3.type !== "color") {
      val /= 255;
    }
    return val <= 0.03928 ? val / 12.92 : ((val + 0.055) / 1.055) ** 2.4;
  });
  return Number((0.2126 * rgb2[0] + 0.7152 * rgb2[1] + 0.0722 * rgb2[2]).toFixed(3));
}
function getContrastRatio(foreground, background) {
  const lumA = getLuminance(foreground);
  const lumB = getLuminance(background);
  return (Math.max(lumA, lumB) + 0.05) / (Math.min(lumA, lumB) + 0.05);
}
function alpha(color3, value) {
  color3 = decomposeColor(color3);
  value = clampWrapper(value);
  if (color3.type === "rgb" || color3.type === "hsl") {
    color3.type += "a";
  }
  if (color3.type === "color") {
    color3.values[3] = `/${value}`;
  } else {
    color3.values[3] = value;
  }
  return recomposeColor(color3);
}
function private_safeAlpha(color3, value, warning) {
  try {
    return alpha(color3, value);
  } catch (error) {
    if (warning && true) {
      console.warn(warning);
    }
    return color3;
  }
}
function darken(color3, coefficient) {
  color3 = decomposeColor(color3);
  coefficient = clampWrapper(coefficient);
  if (color3.type.includes("hsl")) {
    color3.values[2] *= 1 - coefficient;
  } else if (color3.type.includes("rgb") || color3.type.includes("color")) {
    for (let i2 = 0; i2 < 3; i2 += 1) {
      color3.values[i2] *= 1 - coefficient;
    }
  }
  return recomposeColor(color3);
}
function private_safeDarken(color3, coefficient, warning) {
  try {
    return darken(color3, coefficient);
  } catch (error) {
    if (warning && true) {
      console.warn(warning);
    }
    return color3;
  }
}
function lighten(color3, coefficient) {
  color3 = decomposeColor(color3);
  coefficient = clampWrapper(coefficient);
  if (color3.type.includes("hsl")) {
    color3.values[2] += (100 - color3.values[2]) * coefficient;
  } else if (color3.type.includes("rgb")) {
    for (let i2 = 0; i2 < 3; i2 += 1) {
      color3.values[i2] += (255 - color3.values[i2]) * coefficient;
    }
  } else if (color3.type.includes("color")) {
    for (let i2 = 0; i2 < 3; i2 += 1) {
      color3.values[i2] += (1 - color3.values[i2]) * coefficient;
    }
  }
  return recomposeColor(color3);
}
function private_safeLighten(color3, coefficient, warning) {
  try {
    return lighten(color3, coefficient);
  } catch (error) {
    if (warning && true) {
      console.warn(warning);
    }
    return color3;
  }
}
function emphasize(color3, coefficient = 0.15) {
  return getLuminance(color3) > 0.5 ? darken(color3, coefficient) : lighten(color3, coefficient);
}
function private_safeEmphasize(color3, coefficient, warning) {
  try {
    return emphasize(color3, coefficient);
  } catch (error) {
    if (warning && true) {
      console.warn(warning);
    }
    return color3;
  }
}

// node_modules/@mui/system/esm/ThemeProvider/ThemeProvider.js
var React30 = __toESM(require_react(), 1);
var import_prop_types10 = __toESM(require_prop_types(), 1);

// node_modules/@mui/private-theming/esm/ThemeProvider/ThemeProvider.js
var React27 = __toESM(require_react(), 1);
var import_prop_types7 = __toESM(require_prop_types(), 1);

// node_modules/@mui/utils/esm/exactProp/exactProp.js
var specialProperty = "exact-prop: ";
function exactProp(propTypes) {
  if (false) {
    return propTypes;
  }
  return {
    ...propTypes,
    [specialProperty]: (props) => {
      const unsupportedProps = Object.keys(props).filter((prop) => !propTypes.hasOwnProperty(prop));
      if (unsupportedProps.length > 0) {
        return new Error(`The following props are not supported: ${unsupportedProps.map((prop) => `\`${prop}\``).join(", ")}. Please remove them.`);
      }
      return null;
    }
  };
}

// node_modules/@mui/private-theming/esm/useTheme/ThemeContext.js
var React25 = __toESM(require_react(), 1);
var ThemeContext = React25.createContext(null);
if (true) {
  ThemeContext.displayName = "ThemeContext";
}
var ThemeContext_default = ThemeContext;

// node_modules/@mui/private-theming/esm/useTheme/useTheme.js
var React26 = __toESM(require_react(), 1);
function useTheme3() {
  const theme = React26.useContext(ThemeContext_default);
  if (true) {
    React26.useDebugValue(theme);
  }
  return theme;
}

// node_modules/@mui/private-theming/esm/ThemeProvider/nested.js
var hasSymbol = typeof Symbol === "function" && Symbol.for;
var nested_default = hasSymbol ? Symbol.for("mui.nested") : "__THEME_NESTED__";

// node_modules/@mui/private-theming/esm/ThemeProvider/ThemeProvider.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
function mergeOuterLocalTheme(outerTheme, localTheme) {
  if (typeof localTheme === "function") {
    const mergedTheme = localTheme(outerTheme);
    if (true) {
      if (!mergedTheme) {
        console.error(["MUI: You should return an object from your theme function, i.e.", "<ThemeProvider theme={() => ({})} />"].join("\n"));
      }
    }
    return mergedTheme;
  }
  return {
    ...outerTheme,
    ...localTheme
  };
}
function ThemeProvider(props) {
  const {
    children: children2,
    theme: localTheme
  } = props;
  const outerTheme = useTheme3();
  if (true) {
    if (outerTheme === null && typeof localTheme === "function") {
      console.error(["MUI: You are providing a theme function prop to the ThemeProvider component:", "<ThemeProvider theme={outerTheme => outerTheme} />", "", "However, no outer theme is present.", "Make sure a theme is already injected higher in the React tree or provide a theme object."].join("\n"));
    }
  }
  const theme = React27.useMemo(() => {
    const output = outerTheme === null ? {
      ...localTheme
    } : mergeOuterLocalTheme(outerTheme, localTheme);
    if (output != null) {
      output[nested_default] = outerTheme !== null;
    }
    return output;
  }, [localTheme, outerTheme]);
  return (0, import_jsx_runtime4.jsx)(ThemeContext_default.Provider, {
    value: theme,
    children: children2
  });
}
true ? ThemeProvider.propTypes = {
  /**
   * Your component tree.
   */
  children: import_prop_types7.default.node,
  /**
   * A theme object. You can provide a function to extend the outer theme.
   */
  theme: import_prop_types7.default.oneOfType([import_prop_types7.default.object, import_prop_types7.default.func]).isRequired
} : void 0;
if (true) {
  true ? ThemeProvider.propTypes = exactProp(ThemeProvider.propTypes) : void 0;
}
var ThemeProvider_default = ThemeProvider;

// node_modules/@mui/system/esm/RtlProvider/index.js
var React28 = __toESM(require_react());
var import_prop_types8 = __toESM(require_prop_types());
var import_jsx_runtime5 = __toESM(require_jsx_runtime());
var RtlContext = React28.createContext();
function RtlProvider({
  value,
  ...props
}) {
  return (0, import_jsx_runtime5.jsx)(RtlContext.Provider, {
    value: value ?? true,
    ...props
  });
}
true ? RtlProvider.propTypes = {
  children: import_prop_types8.default.node,
  value: import_prop_types8.default.bool
} : void 0;
var useRtl = () => {
  const value = React28.useContext(RtlContext);
  return value ?? false;
};
var RtlProvider_default = RtlProvider;

// node_modules/@mui/system/esm/DefaultPropsProvider/DefaultPropsProvider.js
var React29 = __toESM(require_react(), 1);
var import_prop_types9 = __toESM(require_prop_types(), 1);
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var PropsContext = React29.createContext(void 0);
function DefaultPropsProvider({
  value,
  children: children2
}) {
  return (0, import_jsx_runtime6.jsx)(PropsContext.Provider, {
    value,
    children: children2
  });
}
true ? DefaultPropsProvider.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //  To update them, edit the TypeScript types and run `pnpm proptypes`. 
  // 
  /**
   * @ignore
   */
  children: import_prop_types9.default.node,
  /**
   * @ignore
   */
  value: import_prop_types9.default.object
} : void 0;
function getThemeProps2(params) {
  const {
    theme,
    name,
    props
  } = params;
  if (!theme || !theme.components || !theme.components[name]) {
    return props;
  }
  const config = theme.components[name];
  if (config.defaultProps) {
    return resolveProps(config.defaultProps, props);
  }
  if (!config.styleOverrides && !config.variants) {
    return resolveProps(config, props);
  }
  return props;
}
function useDefaultProps({
  props,
  name
}) {
  const ctx = React29.useContext(PropsContext);
  return getThemeProps2({
    props,
    name,
    theme: {
      components: ctx
    }
  });
}
var DefaultPropsProvider_default = DefaultPropsProvider;

// node_modules/@mui/system/esm/ThemeProvider/ThemeProvider.js
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var EMPTY_THEME = {};
function useThemeScoping(themeId, upperTheme, localTheme, isPrivate = false) {
  return React30.useMemo(() => {
    const resolvedTheme = themeId ? upperTheme[themeId] || upperTheme : upperTheme;
    if (typeof localTheme === "function") {
      const mergedTheme = localTheme(resolvedTheme);
      const result = themeId ? {
        ...upperTheme,
        [themeId]: mergedTheme
      } : mergedTheme;
      if (isPrivate) {
        return () => result;
      }
      return result;
    }
    return themeId ? {
      ...upperTheme,
      [themeId]: localTheme
    } : {
      ...upperTheme,
      ...localTheme
    };
  }, [themeId, upperTheme, localTheme, isPrivate]);
}
function ThemeProvider2(props) {
  const {
    children: children2,
    theme: localTheme,
    themeId
  } = props;
  const upperTheme = useThemeWithoutDefault_default(EMPTY_THEME);
  const upperPrivateTheme = useTheme3() || EMPTY_THEME;
  if (true) {
    if (upperTheme === null && typeof localTheme === "function" || themeId && upperTheme && !upperTheme[themeId] && typeof localTheme === "function") {
      console.error(["MUI: You are providing a theme function prop to the ThemeProvider component:", "<ThemeProvider theme={outerTheme => outerTheme} />", "", "However, no outer theme is present.", "Make sure a theme is already injected higher in the React tree or provide a theme object."].join("\n"));
    }
  }
  const engineTheme = useThemeScoping(themeId, upperTheme, localTheme);
  const privateTheme = useThemeScoping(themeId, upperPrivateTheme, localTheme, true);
  const rtlValue = (themeId ? engineTheme[themeId] : engineTheme).direction === "rtl";
  return (0, import_jsx_runtime7.jsx)(ThemeProvider_default, {
    theme: privateTheme,
    children: (0, import_jsx_runtime7.jsx)(et.Provider, {
      value: engineTheme,
      children: (0, import_jsx_runtime7.jsx)(RtlProvider_default, {
        value: rtlValue,
        children: (0, import_jsx_runtime7.jsx)(DefaultPropsProvider_default, {
          value: themeId ? engineTheme[themeId].components : engineTheme.components,
          children: children2
        })
      })
    })
  });
}
true ? ThemeProvider2.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * Your component tree.
   */
  children: import_prop_types10.default.node,
  /**
   * A theme object. You can provide a function to extend the outer theme.
   */
  theme: import_prop_types10.default.oneOfType([import_prop_types10.default.func, import_prop_types10.default.object]).isRequired,
  /**
   * The design system's unique id for getting the corresponded theme when there are multiple design systems.
   */
  themeId: import_prop_types10.default.string
} : void 0;
if (true) {
  true ? ThemeProvider2.propTypes = exactProp(ThemeProvider2.propTypes) : void 0;
}
var ThemeProvider_default2 = ThemeProvider2;

// node_modules/@mui/system/esm/memoTheme.js
var arg = {
  theme: void 0
};
function unstable_memoTheme(styleFn) {
  let lastValue;
  let lastTheme;
  return function styleMemoized(props) {
    let value = lastValue;
    if (value === void 0 || props.theme !== lastTheme) {
      arg.theme = props.theme;
      value = preprocessStyles(styleFn(arg));
      lastValue = value;
      lastTheme = props.theme;
    }
    return value;
  };
}

// node_modules/@mui/system/esm/cssVars/createCssVarsProvider.js
var React33 = __toESM(require_react(), 1);
var import_prop_types11 = __toESM(require_prop_types(), 1);

// node_modules/@mui/system/esm/InitColorSchemeScript/InitColorSchemeScript.js
var React31 = __toESM(require_react(), 1);
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var DEFAULT_MODE_STORAGE_KEY = "mode";
var DEFAULT_COLOR_SCHEME_STORAGE_KEY = "color-scheme";
var DEFAULT_ATTRIBUTE = "data-color-scheme";
function InitColorSchemeScript(options) {
  const {
    defaultMode = "system",
    defaultLightColorScheme = "light",
    defaultDarkColorScheme = "dark",
    modeStorageKey = DEFAULT_MODE_STORAGE_KEY,
    colorSchemeStorageKey = DEFAULT_COLOR_SCHEME_STORAGE_KEY,
    attribute: initialAttribute = DEFAULT_ATTRIBUTE,
    colorSchemeNode = "document.documentElement",
    nonce
  } = options || {};
  let setter = "";
  let attribute = initialAttribute;
  if (initialAttribute === "class") {
    attribute = ".%s";
  }
  if (initialAttribute === "data") {
    attribute = "[data-%s]";
  }
  if (attribute.startsWith(".")) {
    const selector = attribute.substring(1);
    setter += `${colorSchemeNode}.classList.remove('${selector}'.replace('%s', light), '${selector}'.replace('%s', dark));
      ${colorSchemeNode}.classList.add('${selector}'.replace('%s', colorScheme));`;
  }
  const matches = attribute.match(/\[([^\]]+)\]/);
  if (matches) {
    const [attr, value] = matches[1].split("=");
    if (!value) {
      setter += `${colorSchemeNode}.removeAttribute('${attr}'.replace('%s', light));
      ${colorSchemeNode}.removeAttribute('${attr}'.replace('%s', dark));`;
    }
    setter += `
      ${colorSchemeNode}.setAttribute('${attr}'.replace('%s', colorScheme), ${value ? `${value}.replace('%s', colorScheme)` : '""'});`;
  } else {
    setter += `${colorSchemeNode}.setAttribute('${attribute}', colorScheme);`;
  }
  return (0, import_jsx_runtime8.jsx)("script", {
    suppressHydrationWarning: true,
    nonce: typeof window === "undefined" ? nonce : "",
    dangerouslySetInnerHTML: {
      __html: `(function() {
try {
  let colorScheme = '';
  const mode = localStorage.getItem('${modeStorageKey}') || '${defaultMode}';
  const dark = localStorage.getItem('${colorSchemeStorageKey}-dark') || '${defaultDarkColorScheme}';
  const light = localStorage.getItem('${colorSchemeStorageKey}-light') || '${defaultLightColorScheme}';
  if (mode === 'system') {
    // handle system mode
    const mql = window.matchMedia('(prefers-color-scheme: dark)');
    if (mql.matches) {
      colorScheme = dark
    } else {
      colorScheme = light
    }
  }
  if (mode === 'light') {
    colorScheme = light;
  }
  if (mode === 'dark') {
    colorScheme = dark;
  }
  if (colorScheme) {
    ${setter}
  }
} catch(e){}})();`
    }
  }, "mui-color-scheme-init");
}

// node_modules/@mui/system/esm/cssVars/useCurrentColorScheme.js
var React32 = __toESM(require_react(), 1);

// node_modules/@mui/system/esm/cssVars/localStorageManager.js
function noop() {
}
var localStorageManager = ({
  key,
  storageWindow
}) => {
  if (!storageWindow && typeof window !== "undefined") {
    storageWindow = window;
  }
  return {
    get(defaultValue) {
      if (typeof window === "undefined") {
        return void 0;
      }
      if (!storageWindow) {
        return defaultValue;
      }
      let value;
      try {
        value = storageWindow.localStorage.getItem(key);
      } catch {
      }
      return value || defaultValue;
    },
    set: (value) => {
      if (storageWindow) {
        try {
          storageWindow.localStorage.setItem(key, value);
        } catch {
        }
      }
    },
    subscribe: (handler) => {
      if (!storageWindow) {
        return noop;
      }
      const listener = (event) => {
        const value = event.newValue;
        if (event.key === key) {
          handler(value);
        }
      };
      storageWindow.addEventListener("storage", listener);
      return () => {
        storageWindow.removeEventListener("storage", listener);
      };
    }
  };
};
var localStorageManager_default = localStorageManager;

// node_modules/@mui/system/esm/cssVars/useCurrentColorScheme.js
function noop2() {
}
function getSystemMode(mode2) {
  if (typeof window !== "undefined" && typeof window.matchMedia === "function" && mode2 === "system") {
    const mql = window.matchMedia("(prefers-color-scheme: dark)");
    if (mql.matches) {
      return "dark";
    }
    return "light";
  }
  return void 0;
}
function processState(state, callback) {
  if (state.mode === "light" || state.mode === "system" && state.systemMode === "light") {
    return callback("light");
  }
  if (state.mode === "dark" || state.mode === "system" && state.systemMode === "dark") {
    return callback("dark");
  }
  return void 0;
}
function getColorScheme(state) {
  return processState(state, (mode2) => {
    if (mode2 === "light") {
      return state.lightColorScheme;
    }
    if (mode2 === "dark") {
      return state.darkColorScheme;
    }
    return void 0;
  });
}
function useCurrentColorScheme(options) {
  const {
    defaultMode = "light",
    defaultLightColorScheme,
    defaultDarkColorScheme,
    supportedColorSchemes = [],
    modeStorageKey = DEFAULT_MODE_STORAGE_KEY,
    colorSchemeStorageKey = DEFAULT_COLOR_SCHEME_STORAGE_KEY,
    storageWindow = typeof window === "undefined" ? void 0 : window,
    storageManager = localStorageManager_default,
    noSsr = false
  } = options;
  const joinedColorSchemes = supportedColorSchemes.join(",");
  const isMultiSchemes = supportedColorSchemes.length > 1;
  const modeStorage = React32.useMemo(() => storageManager == null ? void 0 : storageManager({
    key: modeStorageKey,
    storageWindow
  }), [storageManager, modeStorageKey, storageWindow]);
  const lightStorage = React32.useMemo(() => storageManager == null ? void 0 : storageManager({
    key: `${colorSchemeStorageKey}-light`,
    storageWindow
  }), [storageManager, colorSchemeStorageKey, storageWindow]);
  const darkStorage = React32.useMemo(() => storageManager == null ? void 0 : storageManager({
    key: `${colorSchemeStorageKey}-dark`,
    storageWindow
  }), [storageManager, colorSchemeStorageKey, storageWindow]);
  const [state, setState] = React32.useState(() => {
    const initialMode = (modeStorage == null ? void 0 : modeStorage.get(defaultMode)) || defaultMode;
    const lightColorScheme = (lightStorage == null ? void 0 : lightStorage.get(defaultLightColorScheme)) || defaultLightColorScheme;
    const darkColorScheme = (darkStorage == null ? void 0 : darkStorage.get(defaultDarkColorScheme)) || defaultDarkColorScheme;
    return {
      mode: initialMode,
      systemMode: getSystemMode(initialMode),
      lightColorScheme,
      darkColorScheme
    };
  });
  const [isClient, setIsClient] = React32.useState(noSsr || !isMultiSchemes);
  React32.useEffect(() => {
    setIsClient(true);
  }, []);
  const colorScheme = getColorScheme(state);
  const setMode = React32.useCallback((mode2) => {
    setState((currentState) => {
      if (mode2 === currentState.mode) {
        return currentState;
      }
      const newMode = mode2 ?? defaultMode;
      modeStorage == null ? void 0 : modeStorage.set(newMode);
      return {
        ...currentState,
        mode: newMode,
        systemMode: getSystemMode(newMode)
      };
    });
  }, [modeStorage, defaultMode]);
  const setColorScheme = React32.useCallback((value) => {
    if (!value) {
      setState((currentState) => {
        lightStorage == null ? void 0 : lightStorage.set(defaultLightColorScheme);
        darkStorage == null ? void 0 : darkStorage.set(defaultDarkColorScheme);
        return {
          ...currentState,
          lightColorScheme: defaultLightColorScheme,
          darkColorScheme: defaultDarkColorScheme
        };
      });
    } else if (typeof value === "string") {
      if (value && !joinedColorSchemes.includes(value)) {
        console.error(`\`${value}\` does not exist in \`theme.colorSchemes\`.`);
      } else {
        setState((currentState) => {
          const newState = {
            ...currentState
          };
          processState(currentState, (mode2) => {
            if (mode2 === "light") {
              lightStorage == null ? void 0 : lightStorage.set(value);
              newState.lightColorScheme = value;
            }
            if (mode2 === "dark") {
              darkStorage == null ? void 0 : darkStorage.set(value);
              newState.darkColorScheme = value;
            }
          });
          return newState;
        });
      }
    } else {
      setState((currentState) => {
        const newState = {
          ...currentState
        };
        const newLightColorScheme = value.light === null ? defaultLightColorScheme : value.light;
        const newDarkColorScheme = value.dark === null ? defaultDarkColorScheme : value.dark;
        if (newLightColorScheme) {
          if (!joinedColorSchemes.includes(newLightColorScheme)) {
            console.error(`\`${newLightColorScheme}\` does not exist in \`theme.colorSchemes\`.`);
          } else {
            newState.lightColorScheme = newLightColorScheme;
            lightStorage == null ? void 0 : lightStorage.set(newLightColorScheme);
          }
        }
        if (newDarkColorScheme) {
          if (!joinedColorSchemes.includes(newDarkColorScheme)) {
            console.error(`\`${newDarkColorScheme}\` does not exist in \`theme.colorSchemes\`.`);
          } else {
            newState.darkColorScheme = newDarkColorScheme;
            darkStorage == null ? void 0 : darkStorage.set(newDarkColorScheme);
          }
        }
        return newState;
      });
    }
  }, [joinedColorSchemes, lightStorage, darkStorage, defaultLightColorScheme, defaultDarkColorScheme]);
  const handleMediaQuery = React32.useCallback((event) => {
    if (state.mode === "system") {
      setState((currentState) => {
        const systemMode = (event == null ? void 0 : event.matches) ? "dark" : "light";
        if (currentState.systemMode === systemMode) {
          return currentState;
        }
        return {
          ...currentState,
          systemMode
        };
      });
    }
  }, [state.mode]);
  const mediaListener = React32.useRef(handleMediaQuery);
  mediaListener.current = handleMediaQuery;
  React32.useEffect(() => {
    if (typeof window.matchMedia !== "function" || !isMultiSchemes) {
      return void 0;
    }
    const handler = (...args) => mediaListener.current(...args);
    const media = window.matchMedia("(prefers-color-scheme: dark)");
    media.addListener(handler);
    handler(media);
    return () => {
      media.removeListener(handler);
    };
  }, [isMultiSchemes]);
  React32.useEffect(() => {
    if (isMultiSchemes) {
      const unsubscribeMode = (modeStorage == null ? void 0 : modeStorage.subscribe((value) => {
        if (!value || ["light", "dark", "system"].includes(value)) {
          setMode(value || defaultMode);
        }
      })) || noop2;
      const unsubscribeLight = (lightStorage == null ? void 0 : lightStorage.subscribe((value) => {
        if (!value || joinedColorSchemes.match(value)) {
          setColorScheme({
            light: value
          });
        }
      })) || noop2;
      const unsubscribeDark = (darkStorage == null ? void 0 : darkStorage.subscribe((value) => {
        if (!value || joinedColorSchemes.match(value)) {
          setColorScheme({
            dark: value
          });
        }
      })) || noop2;
      return () => {
        unsubscribeMode();
        unsubscribeLight();
        unsubscribeDark();
      };
    }
    return void 0;
  }, [setColorScheme, setMode, joinedColorSchemes, defaultMode, storageWindow, isMultiSchemes, modeStorage, lightStorage, darkStorage]);
  return {
    ...state,
    mode: isClient ? state.mode : void 0,
    systemMode: isClient ? state.systemMode : void 0,
    colorScheme: isClient ? colorScheme : void 0,
    setMode,
    setColorScheme
  };
}

// node_modules/@mui/system/esm/cssVars/createCssVarsProvider.js
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var DISABLE_CSS_TRANSITION = "*{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}";
function createCssVarsProvider(options) {
  const {
    themeId,
    /**
     * This `theme` object needs to follow a certain structure to
     * be used correctly by the finel `CssVarsProvider`. It should have a
     * `colorSchemes` key with the light and dark (and any other) palette.
     * It should also ideally have a vars object created using `prepareCssVars`.
     */
    theme: defaultTheme5 = {},
    modeStorageKey: defaultModeStorageKey = DEFAULT_MODE_STORAGE_KEY,
    colorSchemeStorageKey: defaultColorSchemeStorageKey = DEFAULT_COLOR_SCHEME_STORAGE_KEY,
    disableTransitionOnChange: designSystemTransitionOnChange = false,
    defaultColorScheme,
    resolveTheme
  } = options;
  const defaultContext = {
    allColorSchemes: [],
    colorScheme: void 0,
    darkColorScheme: void 0,
    lightColorScheme: void 0,
    mode: void 0,
    setColorScheme: () => {
    },
    setMode: () => {
    },
    systemMode: void 0
  };
  const ColorSchemeContext = React33.createContext(void 0);
  if (true) {
    ColorSchemeContext.displayName = "ColorSchemeContext";
  }
  const useColorScheme2 = () => React33.useContext(ColorSchemeContext) || defaultContext;
  const defaultColorSchemes = {};
  const defaultComponents = {};
  function CssVarsProvider2(props) {
    var _a, _b, _c, _d;
    const {
      children: children2,
      theme: themeProp,
      modeStorageKey = defaultModeStorageKey,
      colorSchemeStorageKey = defaultColorSchemeStorageKey,
      disableTransitionOnChange = designSystemTransitionOnChange,
      storageManager,
      storageWindow = typeof window === "undefined" ? void 0 : window,
      documentNode = typeof document === "undefined" ? void 0 : document,
      colorSchemeNode = typeof document === "undefined" ? void 0 : document.documentElement,
      disableNestedContext = false,
      disableStyleSheetGeneration = false,
      defaultMode: initialMode = "system",
      forceThemeRerender = false,
      noSsr
    } = props;
    const hasMounted = React33.useRef(false);
    const upperTheme = useTheme3();
    const ctx = React33.useContext(ColorSchemeContext);
    const nested = !!ctx && !disableNestedContext;
    const initialTheme = React33.useMemo(() => {
      if (themeProp) {
        return themeProp;
      }
      return typeof defaultTheme5 === "function" ? defaultTheme5() : defaultTheme5;
    }, [themeProp]);
    const scopedTheme = initialTheme[themeId];
    const restThemeProp = scopedTheme || initialTheme;
    const {
      colorSchemes = defaultColorSchemes,
      components = defaultComponents,
      cssVarPrefix
    } = restThemeProp;
    const joinedColorSchemes = Object.keys(colorSchemes).filter((k3) => !!colorSchemes[k3]).join(",");
    const allColorSchemes = React33.useMemo(() => joinedColorSchemes.split(","), [joinedColorSchemes]);
    const defaultLightColorScheme2 = typeof defaultColorScheme === "string" ? defaultColorScheme : defaultColorScheme.light;
    const defaultDarkColorScheme2 = typeof defaultColorScheme === "string" ? defaultColorScheme : defaultColorScheme.dark;
    const defaultMode = colorSchemes[defaultLightColorScheme2] && colorSchemes[defaultDarkColorScheme2] ? initialMode : ((_b = (_a = colorSchemes[restThemeProp.defaultColorScheme]) == null ? void 0 : _a.palette) == null ? void 0 : _b.mode) || ((_c = restThemeProp.palette) == null ? void 0 : _c.mode);
    const {
      mode: stateMode,
      setMode,
      systemMode,
      lightColorScheme,
      darkColorScheme,
      colorScheme: stateColorScheme,
      setColorScheme
    } = useCurrentColorScheme({
      supportedColorSchemes: allColorSchemes,
      defaultLightColorScheme: defaultLightColorScheme2,
      defaultDarkColorScheme: defaultDarkColorScheme2,
      modeStorageKey,
      colorSchemeStorageKey,
      defaultMode,
      storageManager,
      storageWindow,
      noSsr
    });
    let mode2 = stateMode;
    let colorScheme = stateColorScheme;
    if (nested) {
      mode2 = ctx.mode;
      colorScheme = ctx.colorScheme;
    }
    if (true) {
      if (forceThemeRerender && !restThemeProp.vars) {
        console.warn(["MUI: The `forceThemeRerender` prop should only be used with CSS theme variables.", "Note that it will slow down the app when changing between modes, so only do this when you cannot find a better solution."].join("\n"));
      }
    }
    let calculatedColorScheme = colorScheme || restThemeProp.defaultColorScheme;
    if (restThemeProp.vars && !forceThemeRerender) {
      calculatedColorScheme = restThemeProp.defaultColorScheme;
    }
    const memoTheme2 = React33.useMemo(() => {
      var _a2;
      const themeVars = ((_a2 = restThemeProp.generateThemeVars) == null ? void 0 : _a2.call(restThemeProp)) || restThemeProp.vars;
      const theme = {
        ...restThemeProp,
        components,
        colorSchemes,
        cssVarPrefix,
        vars: themeVars
      };
      if (typeof theme.generateSpacing === "function") {
        theme.spacing = theme.generateSpacing();
      }
      if (calculatedColorScheme) {
        const scheme = colorSchemes[calculatedColorScheme];
        if (scheme && typeof scheme === "object") {
          Object.keys(scheme).forEach((schemeKey) => {
            if (scheme[schemeKey] && typeof scheme[schemeKey] === "object") {
              theme[schemeKey] = {
                ...theme[schemeKey],
                ...scheme[schemeKey]
              };
            } else {
              theme[schemeKey] = scheme[schemeKey];
            }
          });
        }
      }
      return resolveTheme ? resolveTheme(theme) : theme;
    }, [restThemeProp, calculatedColorScheme, components, colorSchemes, cssVarPrefix]);
    const colorSchemeSelector = restThemeProp.colorSchemeSelector;
    useEnhancedEffect_default(() => {
      if (colorScheme && colorSchemeNode && colorSchemeSelector && colorSchemeSelector !== "media") {
        const selector = colorSchemeSelector;
        let rule = colorSchemeSelector;
        if (selector === "class") {
          rule = `.%s`;
        }
        if (selector === "data") {
          rule = `[data-%s]`;
        }
        if ((selector == null ? void 0 : selector.startsWith("data-")) && !selector.includes("%s")) {
          rule = `[${selector}="%s"]`;
        }
        if (rule.startsWith(".")) {
          colorSchemeNode.classList.remove(...allColorSchemes.map((scheme) => rule.substring(1).replace("%s", scheme)));
          colorSchemeNode.classList.add(rule.substring(1).replace("%s", colorScheme));
        } else {
          const matches = rule.replace("%s", colorScheme).match(/\[([^\]]+)\]/);
          if (matches) {
            const [attr, value] = matches[1].split("=");
            if (!value) {
              allColorSchemes.forEach((scheme) => {
                colorSchemeNode.removeAttribute(attr.replace(colorScheme, scheme));
              });
            }
            colorSchemeNode.setAttribute(attr, value ? value.replace(/"|'/g, "") : "");
          } else {
            colorSchemeNode.setAttribute(rule, colorScheme);
          }
        }
      }
    }, [colorScheme, colorSchemeSelector, colorSchemeNode, allColorSchemes]);
    React33.useEffect(() => {
      let timer2;
      if (disableTransitionOnChange && hasMounted.current && documentNode) {
        const css = documentNode.createElement("style");
        css.appendChild(documentNode.createTextNode(DISABLE_CSS_TRANSITION));
        documentNode.head.appendChild(css);
        (() => window.getComputedStyle(documentNode.body))();
        timer2 = setTimeout(() => {
          documentNode.head.removeChild(css);
        }, 1);
      }
      return () => {
        clearTimeout(timer2);
      };
    }, [colorScheme, disableTransitionOnChange, documentNode]);
    React33.useEffect(() => {
      hasMounted.current = true;
      return () => {
        hasMounted.current = false;
      };
    }, []);
    const contextValue = React33.useMemo(() => ({
      allColorSchemes,
      colorScheme,
      darkColorScheme,
      lightColorScheme,
      mode: mode2,
      setColorScheme,
      setMode: false ? setMode : (newMode) => {
        if (memoTheme2.colorSchemeSelector === "media") {
          console.error(["MUI: The `setMode` function has no effect if `colorSchemeSelector` is `media` (`media` is the default value).", "To toggle the mode manually, please configure `colorSchemeSelector` to use a class or data attribute.", "To learn more, visit https://mui.com/material-ui/customization/css-theme-variables/configuration/#toggling-dark-mode-manually"].join("\n"));
        }
        setMode(newMode);
      },
      systemMode
    }), [allColorSchemes, colorScheme, darkColorScheme, lightColorScheme, mode2, setColorScheme, setMode, systemMode, memoTheme2.colorSchemeSelector]);
    let shouldGenerateStyleSheet = true;
    if (disableStyleSheetGeneration || restThemeProp.cssVariables === false || nested && (upperTheme == null ? void 0 : upperTheme.cssVarPrefix) === cssVarPrefix) {
      shouldGenerateStyleSheet = false;
    }
    const element = (0, import_jsx_runtime9.jsxs)(React33.Fragment, {
      children: [(0, import_jsx_runtime9.jsx)(ThemeProvider_default2, {
        themeId: scopedTheme ? themeId : void 0,
        theme: memoTheme2,
        children: children2
      }), shouldGenerateStyleSheet && (0, import_jsx_runtime9.jsx)(GlobalStyles_default, {
        styles: ((_d = memoTheme2.generateStyleSheets) == null ? void 0 : _d.call(memoTheme2)) || []
      })]
    });
    if (nested) {
      return element;
    }
    return (0, import_jsx_runtime9.jsx)(ColorSchemeContext.Provider, {
      value: contextValue,
      children: element
    });
  }
  true ? CssVarsProvider2.propTypes = {
    /**
     * The component tree.
     */
    children: import_prop_types11.default.node,
    /**
     * The node used to attach the color-scheme attribute
     */
    colorSchemeNode: import_prop_types11.default.any,
    /**
     * localStorage key used to store `colorScheme`
     */
    colorSchemeStorageKey: import_prop_types11.default.string,
    /**
     * The default mode when the storage is empty,
     * require the theme to have `colorSchemes` with light and dark.
     */
    defaultMode: import_prop_types11.default.string,
    /**
     * If `true`, the provider creates its own context and generate stylesheet as if it is a root `CssVarsProvider`.
     */
    disableNestedContext: import_prop_types11.default.bool,
    /**
     * If `true`, the style sheet won't be generated.
     *
     * This is useful for controlling nested CssVarsProvider behavior.
     */
    disableStyleSheetGeneration: import_prop_types11.default.bool,
    /**
     * Disable CSS transitions when switching between modes or color schemes.
     */
    disableTransitionOnChange: import_prop_types11.default.bool,
    /**
     * The document to attach the attribute to.
     */
    documentNode: import_prop_types11.default.any,
    /**
     * If `true`, theme values are recalculated when the mode changes.
     */
    forceThemeRerender: import_prop_types11.default.bool,
    /**
     * The key in the local storage used to store current color scheme.
     */
    modeStorageKey: import_prop_types11.default.string,
    /**
     * If `true`, the mode will be the same value as the storage without an extra rerendering after the hydration.
     * You should use this option in conjuction with `InitColorSchemeScript` component.
     */
    noSsr: import_prop_types11.default.bool,
    /**
     * The storage manager to be used for storing the mode and color scheme
     * @default using `window.localStorage`
     */
    storageManager: import_prop_types11.default.func,
    /**
     * The window that attaches the 'storage' event listener.
     * @default window
     */
    storageWindow: import_prop_types11.default.any,
    /**
     * The calculated theme object that will be passed through context.
     */
    theme: import_prop_types11.default.object
  } : void 0;
  const defaultLightColorScheme = typeof defaultColorScheme === "string" ? defaultColorScheme : defaultColorScheme.light;
  const defaultDarkColorScheme = typeof defaultColorScheme === "string" ? defaultColorScheme : defaultColorScheme.dark;
  const getInitColorSchemeScript = (params) => InitColorSchemeScript({
    colorSchemeStorageKey: defaultColorSchemeStorageKey,
    defaultLightColorScheme,
    defaultDarkColorScheme,
    modeStorageKey: defaultModeStorageKey,
    ...params
  });
  return {
    CssVarsProvider: CssVarsProvider2,
    useColorScheme: useColorScheme2,
    getInitColorSchemeScript
  };
}

// node_modules/@mui/system/esm/cssVars/createGetCssVar.js
function createGetCssVar(prefix2 = "") {
  function appendVar(...vars) {
    if (!vars.length) {
      return "";
    }
    const value = vars[0];
    if (typeof value === "string" && !value.match(/(#|\(|\)|(-?(\d*\.)?\d+)(px|em|%|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc))|^(-?(\d*\.)?\d+)$|(\d+ \d+ \d+)/)) {
      return `, var(--${prefix2 ? `${prefix2}-` : ""}${value}${appendVar(...vars.slice(1))})`;
    }
    return `, ${value}`;
  }
  const getCssVar = (field, ...fallbacks) => {
    return `var(--${prefix2 ? `${prefix2}-` : ""}${field}${appendVar(...fallbacks)})`;
  };
  return getCssVar;
}

// node_modules/@mui/system/esm/cssVars/cssVarsParser.js
var assignNestedKeys = (obj, keys, value, arrayKeys = []) => {
  let temp = obj;
  keys.forEach((k3, index2) => {
    if (index2 === keys.length - 1) {
      if (Array.isArray(temp)) {
        temp[Number(k3)] = value;
      } else if (temp && typeof temp === "object") {
        temp[k3] = value;
      }
    } else if (temp && typeof temp === "object") {
      if (!temp[k3]) {
        temp[k3] = arrayKeys.includes(k3) ? [] : {};
      }
      temp = temp[k3];
    }
  });
};
var walkObjectDeep = (obj, callback, shouldSkipPaths) => {
  function recurse(object, parentKeys = [], arrayKeys = []) {
    Object.entries(object).forEach(([key, value]) => {
      if (!shouldSkipPaths || shouldSkipPaths && !shouldSkipPaths([...parentKeys, key])) {
        if (value !== void 0 && value !== null) {
          if (typeof value === "object" && Object.keys(value).length > 0) {
            recurse(value, [...parentKeys, key], Array.isArray(value) ? [...arrayKeys, key] : arrayKeys);
          } else {
            callback([...parentKeys, key], value, arrayKeys);
          }
        }
      }
    });
  }
  recurse(obj);
};
var getCssValue = (keys, value) => {
  if (typeof value === "number") {
    if (["lineHeight", "fontWeight", "opacity", "zIndex"].some((prop) => keys.includes(prop))) {
      return value;
    }
    const lastKey = keys[keys.length - 1];
    if (lastKey.toLowerCase().includes("opacity")) {
      return value;
    }
    return `${value}px`;
  }
  return value;
};
function cssVarsParser(theme, options) {
  const {
    prefix: prefix2,
    shouldSkipGeneratingVar: shouldSkipGeneratingVar2
  } = options || {};
  const css = {};
  const vars = {};
  const varsWithDefaults = {};
  walkObjectDeep(
    theme,
    (keys, value, arrayKeys) => {
      if (typeof value === "string" || typeof value === "number") {
        if (!shouldSkipGeneratingVar2 || !shouldSkipGeneratingVar2(keys, value)) {
          const cssVar = `--${prefix2 ? `${prefix2}-` : ""}${keys.join("-")}`;
          const resolvedValue = getCssValue(keys, value);
          Object.assign(css, {
            [cssVar]: resolvedValue
          });
          assignNestedKeys(vars, keys, `var(${cssVar})`, arrayKeys);
          assignNestedKeys(varsWithDefaults, keys, `var(${cssVar}, ${resolvedValue})`, arrayKeys);
        }
      }
    },
    (keys) => keys[0] === "vars"
    // skip 'vars/*' paths
  );
  return {
    css,
    vars,
    varsWithDefaults
  };
}

// node_modules/@mui/system/esm/cssVars/prepareCssVars.js
function prepareCssVars(theme, parserConfig = {}) {
  const {
    getSelector = defaultGetSelector,
    disableCssColorScheme,
    colorSchemeSelector: selector
  } = parserConfig;
  const {
    colorSchemes = {},
    components,
    defaultColorScheme = "light",
    ...otherTheme
  } = theme;
  const {
    vars: rootVars,
    css: rootCss,
    varsWithDefaults: rootVarsWithDefaults
  } = cssVarsParser(otherTheme, parserConfig);
  let themeVars = rootVarsWithDefaults;
  const colorSchemesMap = {};
  const {
    [defaultColorScheme]: defaultScheme,
    ...otherColorSchemes
  } = colorSchemes;
  Object.entries(otherColorSchemes || {}).forEach(([key, scheme]) => {
    const {
      vars,
      css,
      varsWithDefaults
    } = cssVarsParser(scheme, parserConfig);
    themeVars = deepmerge(themeVars, varsWithDefaults);
    colorSchemesMap[key] = {
      css,
      vars
    };
  });
  if (defaultScheme) {
    const {
      css,
      vars,
      varsWithDefaults
    } = cssVarsParser(defaultScheme, parserConfig);
    themeVars = deepmerge(themeVars, varsWithDefaults);
    colorSchemesMap[defaultColorScheme] = {
      css,
      vars
    };
  }
  function defaultGetSelector(colorScheme, cssObject) {
    var _a, _b;
    let rule = selector;
    if (selector === "class") {
      rule = ".%s";
    }
    if (selector === "data") {
      rule = "[data-%s]";
    }
    if ((selector == null ? void 0 : selector.startsWith("data-")) && !selector.includes("%s")) {
      rule = `[${selector}="%s"]`;
    }
    if (colorScheme) {
      if (rule === "media") {
        if (theme.defaultColorScheme === colorScheme) {
          return ":root";
        }
        const mode2 = ((_b = (_a = colorSchemes[colorScheme]) == null ? void 0 : _a.palette) == null ? void 0 : _b.mode) || colorScheme;
        return {
          [`@media (prefers-color-scheme: ${mode2})`]: {
            ":root": cssObject
          }
        };
      }
      if (rule) {
        if (theme.defaultColorScheme === colorScheme) {
          return `:root, ${rule.replace("%s", String(colorScheme))}`;
        }
        return rule.replace("%s", String(colorScheme));
      }
    }
    return ":root";
  }
  const generateThemeVars = () => {
    let vars = {
      ...rootVars
    };
    Object.entries(colorSchemesMap).forEach(([, {
      vars: schemeVars
    }]) => {
      vars = deepmerge(vars, schemeVars);
    });
    return vars;
  };
  const generateStyleSheets = () => {
    var _a, _b;
    const stylesheets = [];
    const colorScheme = theme.defaultColorScheme || "light";
    function insertStyleSheet(key, css) {
      if (Object.keys(css).length) {
        stylesheets.push(typeof key === "string" ? {
          [key]: {
            ...css
          }
        } : key);
      }
    }
    insertStyleSheet(getSelector(void 0, {
      ...rootCss
    }), rootCss);
    const {
      [colorScheme]: defaultSchemeVal,
      ...other
    } = colorSchemesMap;
    if (defaultSchemeVal) {
      const {
        css
      } = defaultSchemeVal;
      const cssColorSheme = (_b = (_a = colorSchemes[colorScheme]) == null ? void 0 : _a.palette) == null ? void 0 : _b.mode;
      const finalCss = !disableCssColorScheme && cssColorSheme ? {
        colorScheme: cssColorSheme,
        ...css
      } : {
        ...css
      };
      insertStyleSheet(getSelector(colorScheme, {
        ...finalCss
      }), finalCss);
    }
    Object.entries(other).forEach(([key, {
      css
    }]) => {
      var _a2, _b2;
      const cssColorSheme = (_b2 = (_a2 = colorSchemes[key]) == null ? void 0 : _a2.palette) == null ? void 0 : _b2.mode;
      const finalCss = !disableCssColorScheme && cssColorSheme ? {
        colorScheme: cssColorSheme,
        ...css
      } : {
        ...css
      };
      insertStyleSheet(getSelector(key, {
        ...finalCss
      }), finalCss);
    });
    return stylesheets;
  };
  return {
    vars: themeVars,
    generateThemeVars,
    generateStyleSheets
  };
}
var prepareCssVars_default = prepareCssVars;

// node_modules/@mui/system/esm/cssVars/getColorSchemeSelector.js
function createGetColorSchemeSelector(selector) {
  return function getColorSchemeSelector(colorScheme) {
    if (selector === "media") {
      if (true) {
        if (colorScheme !== "light" && colorScheme !== "dark") {
          console.error(`MUI: @media (prefers-color-scheme) supports only 'light' or 'dark', but receive '${colorScheme}'.`);
        }
      }
      return `@media (prefers-color-scheme: ${colorScheme})`;
    }
    if (selector) {
      if (selector.startsWith("data-") && !selector.includes("%s")) {
        return `[${selector}="${colorScheme}"] &`;
      }
      if (selector === "class") {
        return `.${colorScheme} &`;
      }
      if (selector === "data") {
        return `[data-${colorScheme}] &`;
      }
      return `${selector.replace("%s", colorScheme)} &`;
    }
    return "&";
  };
}

// node_modules/@mui/system/esm/version/index.js
var major = Number("7");
var minor = Number("1");
var patch = Number("0");

// node_modules/@mui/system/esm/Container/createContainer.js
var React34 = __toESM(require_react(), 1);
var import_prop_types12 = __toESM(require_prop_types(), 1);

// node_modules/@mui/utils/esm/composeClasses/composeClasses.js
function composeClasses(slots, getUtilityClass, classes = void 0) {
  const output = {};
  for (const slotName in slots) {
    const slot = slots[slotName];
    let buffer = "";
    let start2 = true;
    for (let i2 = 0; i2 < slot.length; i2 += 1) {
      const value = slot[i2];
      if (value) {
        buffer += (start2 === true ? "" : " ") + getUtilityClass(value);
        start2 = false;
        if (classes && classes[value]) {
          buffer += " " + classes[value];
        }
      }
    }
    output[slotName] = buffer;
  }
  return output;
}

// node_modules/@mui/system/esm/Container/createContainer.js
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
var defaultTheme = createTheme_default();
var defaultCreateStyledComponent = styled_default("div", {
  name: "MuiContainer",
  slot: "Root",
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [styles.root, styles[`maxWidth${capitalize(String(ownerState.maxWidth))}`], ownerState.fixed && styles.fixed, ownerState.disableGutters && styles.disableGutters];
  }
});
var useThemePropsDefault = (inProps) => useThemeProps({
  props: inProps,
  name: "MuiContainer",
  defaultTheme
});
var useUtilityClasses = (ownerState, componentName) => {
  const getContainerUtilityClass = (slot) => {
    return generateUtilityClass(componentName, slot);
  };
  const {
    classes,
    fixed,
    disableGutters,
    maxWidth: maxWidth2
  } = ownerState;
  const slots = {
    root: ["root", maxWidth2 && `maxWidth${capitalize(String(maxWidth2))}`, fixed && "fixed", disableGutters && "disableGutters"]
  };
  return composeClasses(slots, getContainerUtilityClass, classes);
};
function createContainer(options = {}) {
  const {
    // This will allow adding custom styled fn (for example for custom sx style function)
    createStyledComponent = defaultCreateStyledComponent,
    useThemeProps: useThemeProps3 = useThemePropsDefault,
    componentName = "MuiContainer"
  } = options;
  const ContainerRoot = createStyledComponent(({
    theme,
    ownerState
  }) => ({
    width: "100%",
    marginLeft: "auto",
    boxSizing: "border-box",
    marginRight: "auto",
    ...!ownerState.disableGutters && {
      paddingLeft: theme.spacing(2),
      paddingRight: theme.spacing(2),
      // @ts-ignore module augmentation fails if custom breakpoints are used
      [theme.breakpoints.up("sm")]: {
        paddingLeft: theme.spacing(3),
        paddingRight: theme.spacing(3)
      }
    }
  }), ({
    theme,
    ownerState
  }) => ownerState.fixed && Object.keys(theme.breakpoints.values).reduce((acc, breakpointValueKey) => {
    const breakpoint = breakpointValueKey;
    const value = theme.breakpoints.values[breakpoint];
    if (value !== 0) {
      acc[theme.breakpoints.up(breakpoint)] = {
        maxWidth: `${value}${theme.breakpoints.unit}`
      };
    }
    return acc;
  }, {}), ({
    theme,
    ownerState
  }) => ({
    // @ts-ignore module augmentation fails if custom breakpoints are used
    ...ownerState.maxWidth === "xs" && {
      // @ts-ignore module augmentation fails if custom breakpoints are used
      [theme.breakpoints.up("xs")]: {
        // @ts-ignore module augmentation fails if custom breakpoints are used
        maxWidth: Math.max(theme.breakpoints.values.xs, 444)
      }
    },
    ...ownerState.maxWidth && // @ts-ignore module augmentation fails if custom breakpoints are used
    ownerState.maxWidth !== "xs" && {
      // @ts-ignore module augmentation fails if custom breakpoints are used
      [theme.breakpoints.up(ownerState.maxWidth)]: {
        // @ts-ignore module augmentation fails if custom breakpoints are used
        maxWidth: `${theme.breakpoints.values[ownerState.maxWidth]}${theme.breakpoints.unit}`
      }
    }
  }));
  const Container2 = React34.forwardRef(function Container3(inProps, ref) {
    const props = useThemeProps3(inProps);
    const {
      className,
      component = "div",
      disableGutters = false,
      fixed = false,
      maxWidth: maxWidth2 = "lg",
      classes: classesProp,
      ...other
    } = props;
    const ownerState = {
      ...props,
      component,
      disableGutters,
      fixed,
      maxWidth: maxWidth2
    };
    const classes = useUtilityClasses(ownerState, componentName);
    return (
      // @ts-ignore theme is injected by the styled util
      (0, import_jsx_runtime10.jsx)(ContainerRoot, {
        as: component,
        ownerState,
        className: clsx_default(classes.root, className),
        ref,
        ...other
      })
    );
  });
  true ? Container2.propTypes = {
    children: import_prop_types12.default.node,
    classes: import_prop_types12.default.object,
    className: import_prop_types12.default.string,
    component: import_prop_types12.default.elementType,
    disableGutters: import_prop_types12.default.bool,
    fixed: import_prop_types12.default.bool,
    maxWidth: import_prop_types12.default.oneOfType([import_prop_types12.default.oneOf(["xs", "sm", "md", "lg", "xl", false]), import_prop_types12.default.string]),
    sx: import_prop_types12.default.oneOfType([import_prop_types12.default.arrayOf(import_prop_types12.default.oneOfType([import_prop_types12.default.func, import_prop_types12.default.object, import_prop_types12.default.bool])), import_prop_types12.default.func, import_prop_types12.default.object])
  } : void 0;
  return Container2;
}

// node_modules/@mui/system/esm/Container/Container.js
var import_prop_types13 = __toESM(require_prop_types(), 1);
var Container = createContainer();
true ? Container.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //  To update them, edit the TypeScript types and run `pnpm proptypes`. 
  // 
  /**
   * @ignore
   */
  children: import_prop_types13.default.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types13.default.object,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: import_prop_types13.default.elementType,
  /**
   * If `true`, the left and right padding is removed.
   * @default false
   */
  disableGutters: import_prop_types13.default.bool,
  /**
   * Set the max-width to match the min-width of the current breakpoint.
   * This is useful if you'd prefer to design for a fixed set of sizes
   * instead of trying to accommodate a fully fluid viewport.
   * It's fluid by default.
   * @default false
   */
  fixed: import_prop_types13.default.bool,
  /**
   * Determine the max-width of the container.
   * The container width grows with the size of the screen.
   * Set to `false` to disable `maxWidth`.
   * @default 'lg'
   */
  maxWidth: import_prop_types13.default.oneOfType([import_prop_types13.default.oneOf(["xs", "sm", "md", "lg", "xl", false]), import_prop_types13.default.string]),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types13.default.oneOfType([import_prop_types13.default.arrayOf(import_prop_types13.default.oneOfType([import_prop_types13.default.func, import_prop_types13.default.object, import_prop_types13.default.bool])), import_prop_types13.default.func, import_prop_types13.default.object])
} : void 0;

// node_modules/@mui/system/esm/Container/containerClasses.js
var containerClasses = generateUtilityClasses("MuiContainer", ["root", "disableGutters", "fixed", "maxWidthXs", "maxWidthSm", "maxWidthMd", "maxWidthLg", "maxWidthXl"]);

// node_modules/@mui/system/esm/Grid/Grid.js
var import_prop_types15 = __toESM(require_prop_types(), 1);

// node_modules/@mui/system/esm/Grid/createGrid.js
var React36 = __toESM(require_react(), 1);
var import_prop_types14 = __toESM(require_prop_types(), 1);

// node_modules/@mui/utils/esm/isMuiElement/isMuiElement.js
var React35 = __toESM(require_react(), 1);
function isMuiElement(element, muiNames) {
  var _a, _b, _c;
  return React35.isValidElement(element) && muiNames.indexOf(
    // For server components `muiName` is avaialble in element.type._payload.value.muiName
    // relevant info - https://github.com/facebook/react/blob/2807d781a08db8e9873687fccc25c0f12b4fb3d4/packages/react/src/ReactLazy.js#L45
    // eslint-disable-next-line no-underscore-dangle
    element.type.muiName ?? ((_c = (_b = (_a = element.type) == null ? void 0 : _a._payload) == null ? void 0 : _b.value) == null ? void 0 : _c.muiName)
  ) !== -1;
}

// node_modules/@mui/system/esm/Grid/traverseBreakpoints.js
var filterBreakpointKeys = (breakpointsKeys, responsiveKeys) => breakpointsKeys.filter((key) => responsiveKeys.includes(key));
var traverseBreakpoints = (breakpoints, responsive, iterator) => {
  const smallestBreakpoint = breakpoints.keys[0];
  if (Array.isArray(responsive)) {
    responsive.forEach((breakpointValue, index2) => {
      iterator((responsiveStyles, style4) => {
        if (index2 <= breakpoints.keys.length - 1) {
          if (index2 === 0) {
            Object.assign(responsiveStyles, style4);
          } else {
            responsiveStyles[breakpoints.up(breakpoints.keys[index2])] = style4;
          }
        }
      }, breakpointValue);
    });
  } else if (responsive && typeof responsive === "object") {
    const keys = Object.keys(responsive).length > breakpoints.keys.length ? breakpoints.keys : filterBreakpointKeys(breakpoints.keys, Object.keys(responsive));
    keys.forEach((key) => {
      if (breakpoints.keys.includes(key)) {
        const breakpointValue = responsive[key];
        if (breakpointValue !== void 0) {
          iterator((responsiveStyles, style4) => {
            if (smallestBreakpoint === key) {
              Object.assign(responsiveStyles, style4);
            } else {
              responsiveStyles[breakpoints.up(key)] = style4;
            }
          }, breakpointValue);
        }
      }
    });
  } else if (typeof responsive === "number" || typeof responsive === "string") {
    iterator((responsiveStyles, style4) => {
      Object.assign(responsiveStyles, style4);
    }, responsive);
  }
};

// node_modules/@mui/system/esm/Grid/gridGenerator.js
function getSelfSpacingVar(axis) {
  return `--Grid-${axis}Spacing`;
}
function getParentSpacingVar(axis) {
  return `--Grid-parent-${axis}Spacing`;
}
var selfColumnsVar = "--Grid-columns";
var parentColumnsVar = "--Grid-parent-columns";
var generateGridSizeStyles = ({
  theme,
  ownerState
}) => {
  const styles = {};
  traverseBreakpoints(theme.breakpoints, ownerState.size, (appendStyle, value) => {
    let style4 = {};
    if (value === "grow") {
      style4 = {
        flexBasis: 0,
        flexGrow: 1,
        maxWidth: "100%"
      };
    }
    if (value === "auto") {
      style4 = {
        flexBasis: "auto",
        flexGrow: 0,
        flexShrink: 0,
        maxWidth: "none",
        width: "auto"
      };
    }
    if (typeof value === "number") {
      style4 = {
        flexGrow: 0,
        flexBasis: "auto",
        width: `calc(100% * ${value} / var(${parentColumnsVar}) - (var(${parentColumnsVar}) - ${value}) * (var(${getParentSpacingVar("column")}) / var(${parentColumnsVar})))`
      };
    }
    appendStyle(styles, style4);
  });
  return styles;
};
var generateGridOffsetStyles = ({
  theme,
  ownerState
}) => {
  const styles = {};
  traverseBreakpoints(theme.breakpoints, ownerState.offset, (appendStyle, value) => {
    let style4 = {};
    if (value === "auto") {
      style4 = {
        marginLeft: "auto"
      };
    }
    if (typeof value === "number") {
      style4 = {
        marginLeft: value === 0 ? "0px" : `calc(100% * ${value} / var(${parentColumnsVar}) + var(${getParentSpacingVar("column")}) * ${value} / var(${parentColumnsVar}))`
      };
    }
    appendStyle(styles, style4);
  });
  return styles;
};
var generateGridColumnsStyles = ({
  theme,
  ownerState
}) => {
  if (!ownerState.container) {
    return {};
  }
  const styles = {
    [selfColumnsVar]: 12
  };
  traverseBreakpoints(theme.breakpoints, ownerState.columns, (appendStyle, value) => {
    const columns = value ?? 12;
    appendStyle(styles, {
      [selfColumnsVar]: columns,
      "> *": {
        [parentColumnsVar]: columns
      }
    });
  });
  return styles;
};
var generateGridRowSpacingStyles = ({
  theme,
  ownerState
}) => {
  if (!ownerState.container) {
    return {};
  }
  const styles = {};
  traverseBreakpoints(theme.breakpoints, ownerState.rowSpacing, (appendStyle, value) => {
    var _a;
    const spacing2 = typeof value === "string" ? value : (_a = theme.spacing) == null ? void 0 : _a.call(theme, value);
    appendStyle(styles, {
      [getSelfSpacingVar("row")]: spacing2,
      "> *": {
        [getParentSpacingVar("row")]: spacing2
      }
    });
  });
  return styles;
};
var generateGridColumnSpacingStyles = ({
  theme,
  ownerState
}) => {
  if (!ownerState.container) {
    return {};
  }
  const styles = {};
  traverseBreakpoints(theme.breakpoints, ownerState.columnSpacing, (appendStyle, value) => {
    var _a;
    const spacing2 = typeof value === "string" ? value : (_a = theme.spacing) == null ? void 0 : _a.call(theme, value);
    appendStyle(styles, {
      [getSelfSpacingVar("column")]: spacing2,
      "> *": {
        [getParentSpacingVar("column")]: spacing2
      }
    });
  });
  return styles;
};
var generateGridDirectionStyles = ({
  theme,
  ownerState
}) => {
  if (!ownerState.container) {
    return {};
  }
  const styles = {};
  traverseBreakpoints(theme.breakpoints, ownerState.direction, (appendStyle, value) => {
    appendStyle(styles, {
      flexDirection: value
    });
  });
  return styles;
};
var generateGridStyles = ({
  ownerState
}) => {
  return {
    minWidth: 0,
    boxSizing: "border-box",
    ...ownerState.container && {
      display: "flex",
      flexWrap: "wrap",
      ...ownerState.wrap && ownerState.wrap !== "wrap" && {
        flexWrap: ownerState.wrap
      },
      gap: `var(${getSelfSpacingVar("row")}) var(${getSelfSpacingVar("column")})`
    }
  };
};
var generateSizeClassNames = (size) => {
  const classNames = [];
  Object.entries(size).forEach(([key, value]) => {
    if (value !== false && value !== void 0) {
      classNames.push(`grid-${key}-${String(value)}`);
    }
  });
  return classNames;
};
var generateSpacingClassNames = (spacing2, smallestBreakpoint = "xs") => {
  function isValidSpacing(val) {
    if (val === void 0) {
      return false;
    }
    return typeof val === "string" && !Number.isNaN(Number(val)) || typeof val === "number" && val > 0;
  }
  if (isValidSpacing(spacing2)) {
    return [`spacing-${smallestBreakpoint}-${String(spacing2)}`];
  }
  if (typeof spacing2 === "object" && !Array.isArray(spacing2)) {
    const classNames = [];
    Object.entries(spacing2).forEach(([key, value]) => {
      if (isValidSpacing(value)) {
        classNames.push(`spacing-${key}-${String(value)}`);
      }
    });
    return classNames;
  }
  return [];
};
var generateDirectionClasses = (direction) => {
  if (direction === void 0) {
    return [];
  }
  if (typeof direction === "object") {
    return Object.entries(direction).map(([key, value]) => `direction-${key}-${value}`);
  }
  return [`direction-xs-${String(direction)}`];
};

// node_modules/@mui/system/esm/Grid/deleteLegacyGridProps.js
var getLegacyGridWarning = (propName) => {
  if (["item", "zeroMinWidth"].includes(propName)) {
    return `The \`${propName}\` prop has been removed and is no longer necessary. You can safely remove it.`;
  }
  return `The \`${propName}\` prop has been removed. See https://mui.com/material-ui/migration/upgrade-to-grid-v2/ for migration instructions.`;
};
var warnedAboutProps = [];
function deleteLegacyGridProps(props, breakpoints) {
  const propsToWarn = [];
  if (props.item !== void 0) {
    delete props.item;
    propsToWarn.push("item");
  }
  if (props.zeroMinWidth !== void 0) {
    delete props.zeroMinWidth;
    propsToWarn.push("zeroMinWidth");
  }
  breakpoints.keys.forEach((breakpoint) => {
    if (props[breakpoint] !== void 0) {
      propsToWarn.push(breakpoint);
      delete props[breakpoint];
    }
  });
  if (true) {
    propsToWarn.forEach((prop) => {
      if (!warnedAboutProps.includes(prop)) {
        warnedAboutProps.push(prop);
        console.warn(`MUI Grid: ${getLegacyGridWarning(prop)}
`);
      }
    });
  }
}

// node_modules/@mui/system/esm/Grid/createGrid.js
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
var defaultTheme2 = createTheme_default();
var defaultCreateStyledComponent2 = styled_default("div", {
  name: "MuiGrid",
  slot: "Root"
});
function useThemePropsDefault2(props) {
  return useThemeProps({
    props,
    name: "MuiGrid",
    defaultTheme: defaultTheme2
  });
}
function createGrid(options = {}) {
  const {
    // This will allow adding custom styled fn (for example for custom sx style function)
    createStyledComponent = defaultCreateStyledComponent2,
    useThemeProps: useThemeProps3 = useThemePropsDefault2,
    useTheme: useTheme5 = useTheme_default,
    componentName = "MuiGrid"
  } = options;
  const useUtilityClasses31 = (ownerState, theme) => {
    const {
      container,
      direction,
      spacing: spacing2,
      wrap,
      size
    } = ownerState;
    const slots = {
      root: ["root", container && "container", wrap !== "wrap" && `wrap-xs-${String(wrap)}`, ...generateDirectionClasses(direction), ...generateSizeClassNames(size), ...container ? generateSpacingClassNames(spacing2, theme.breakpoints.keys[0]) : []]
    };
    return composeClasses(slots, (slot) => generateUtilityClass(componentName, slot), {});
  };
  function parseResponsiveProp(propValue, breakpoints, shouldUseValue = () => true) {
    const parsedProp = {};
    if (propValue === null) {
      return parsedProp;
    }
    if (Array.isArray(propValue)) {
      propValue.forEach((value, index2) => {
        if (value !== null && shouldUseValue(value) && breakpoints.keys[index2]) {
          parsedProp[breakpoints.keys[index2]] = value;
        }
      });
    } else if (typeof propValue === "object") {
      Object.keys(propValue).forEach((key) => {
        const value = propValue[key];
        if (value !== null && value !== void 0 && shouldUseValue(value)) {
          parsedProp[key] = value;
        }
      });
    } else {
      parsedProp[breakpoints.keys[0]] = propValue;
    }
    return parsedProp;
  }
  const GridRoot2 = createStyledComponent(generateGridColumnsStyles, generateGridColumnSpacingStyles, generateGridRowSpacingStyles, generateGridSizeStyles, generateGridDirectionStyles, generateGridStyles, generateGridOffsetStyles);
  const Grid2 = React36.forwardRef(function Grid3(inProps, ref) {
    const theme = useTheme5();
    const themeProps = useThemeProps3(inProps);
    const props = extendSxProp(themeProps);
    deleteLegacyGridProps(props, theme.breakpoints);
    const {
      className,
      children: children2,
      columns: columnsProp = 12,
      container = false,
      component = "div",
      direction = "row",
      wrap = "wrap",
      size: sizeProp = {},
      offset: offsetProp = {},
      spacing: spacingProp = 0,
      rowSpacing: rowSpacingProp = spacingProp,
      columnSpacing: columnSpacingProp = spacingProp,
      unstable_level: level = 0,
      ...other
    } = props;
    const size = parseResponsiveProp(sizeProp, theme.breakpoints, (val) => val !== false);
    const offset2 = parseResponsiveProp(offsetProp, theme.breakpoints);
    const columns = inProps.columns ?? (level ? void 0 : columnsProp);
    const spacing2 = inProps.spacing ?? (level ? void 0 : spacingProp);
    const rowSpacing = inProps.rowSpacing ?? inProps.spacing ?? (level ? void 0 : rowSpacingProp);
    const columnSpacing = inProps.columnSpacing ?? inProps.spacing ?? (level ? void 0 : columnSpacingProp);
    const ownerState = {
      ...props,
      level,
      columns,
      container,
      direction,
      wrap,
      spacing: spacing2,
      rowSpacing,
      columnSpacing,
      size,
      offset: offset2
    };
    const classes = useUtilityClasses31(ownerState, theme);
    return (0, import_jsx_runtime11.jsx)(GridRoot2, {
      ref,
      as: component,
      ownerState,
      className: clsx_default(classes.root, className),
      ...other,
      children: React36.Children.map(children2, (child) => {
        var _a;
        if (React36.isValidElement(child) && isMuiElement(child, ["Grid"]) && container && child.props.container) {
          return React36.cloneElement(child, {
            unstable_level: ((_a = child.props) == null ? void 0 : _a.unstable_level) ?? level + 1
          });
        }
        return child;
      })
    });
  });
  true ? Grid2.propTypes = {
    children: import_prop_types14.default.node,
    className: import_prop_types14.default.string,
    columns: import_prop_types14.default.oneOfType([import_prop_types14.default.arrayOf(import_prop_types14.default.number), import_prop_types14.default.number, import_prop_types14.default.object]),
    columnSpacing: import_prop_types14.default.oneOfType([import_prop_types14.default.arrayOf(import_prop_types14.default.oneOfType([import_prop_types14.default.number, import_prop_types14.default.string])), import_prop_types14.default.number, import_prop_types14.default.object, import_prop_types14.default.string]),
    component: import_prop_types14.default.elementType,
    container: import_prop_types14.default.bool,
    direction: import_prop_types14.default.oneOfType([import_prop_types14.default.oneOf(["column-reverse", "column", "row-reverse", "row"]), import_prop_types14.default.arrayOf(import_prop_types14.default.oneOf(["column-reverse", "column", "row-reverse", "row"])), import_prop_types14.default.object]),
    offset: import_prop_types14.default.oneOfType([import_prop_types14.default.string, import_prop_types14.default.number, import_prop_types14.default.arrayOf(import_prop_types14.default.oneOfType([import_prop_types14.default.string, import_prop_types14.default.number])), import_prop_types14.default.object]),
    rowSpacing: import_prop_types14.default.oneOfType([import_prop_types14.default.arrayOf(import_prop_types14.default.oneOfType([import_prop_types14.default.number, import_prop_types14.default.string])), import_prop_types14.default.number, import_prop_types14.default.object, import_prop_types14.default.string]),
    size: import_prop_types14.default.oneOfType([import_prop_types14.default.string, import_prop_types14.default.bool, import_prop_types14.default.number, import_prop_types14.default.arrayOf(import_prop_types14.default.oneOfType([import_prop_types14.default.string, import_prop_types14.default.bool, import_prop_types14.default.number])), import_prop_types14.default.object]),
    spacing: import_prop_types14.default.oneOfType([import_prop_types14.default.arrayOf(import_prop_types14.default.oneOfType([import_prop_types14.default.number, import_prop_types14.default.string])), import_prop_types14.default.number, import_prop_types14.default.object, import_prop_types14.default.string]),
    sx: import_prop_types14.default.oneOfType([import_prop_types14.default.arrayOf(import_prop_types14.default.oneOfType([import_prop_types14.default.func, import_prop_types14.default.object, import_prop_types14.default.bool])), import_prop_types14.default.func, import_prop_types14.default.object]),
    wrap: import_prop_types14.default.oneOf(["nowrap", "wrap-reverse", "wrap"])
  } : void 0;
  Grid2.muiName = "Grid";
  return Grid2;
}

// node_modules/@mui/system/esm/Grid/Grid.js
var Grid = createGrid();
true ? Grid.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //  To update them, edit the TypeScript types and run `pnpm proptypes`. 
  // 
  /**
   * The content of the component.
   */
  children: import_prop_types15.default.node,
  /**
   * The number of columns.
   * @default 12
   */
  columns: import_prop_types15.default.oneOfType([import_prop_types15.default.arrayOf(import_prop_types15.default.number), import_prop_types15.default.number, import_prop_types15.default.object]),
  /**
   * Defines the horizontal space between the type `item` components.
   * It overrides the value of the `spacing` prop.
   */
  columnSpacing: import_prop_types15.default.oneOfType([import_prop_types15.default.arrayOf(import_prop_types15.default.oneOfType([import_prop_types15.default.number, import_prop_types15.default.string])), import_prop_types15.default.number, import_prop_types15.default.object, import_prop_types15.default.string]),
  /**
   * If `true`, the component will have the flex *container* behavior.
   * You should be wrapping *items* with a *container*.
   * @default false
   */
  container: import_prop_types15.default.bool,
  /**
   * Defines the `flex-direction` style property.
   * It is applied for all screen sizes.
   * @default 'row'
   */
  direction: import_prop_types15.default.oneOfType([import_prop_types15.default.oneOf(["column-reverse", "column", "row-reverse", "row"]), import_prop_types15.default.arrayOf(import_prop_types15.default.oneOf(["column-reverse", "column", "row-reverse", "row"])), import_prop_types15.default.object]),
  /**
   * Defines the offset value for the type `item` components.
   */
  offset: import_prop_types15.default.oneOfType([import_prop_types15.default.string, import_prop_types15.default.number, import_prop_types15.default.arrayOf(import_prop_types15.default.oneOfType([import_prop_types15.default.string, import_prop_types15.default.number])), import_prop_types15.default.object]),
  /**
   * Defines the vertical space between the type `item` components.
   * It overrides the value of the `spacing` prop.
   */
  rowSpacing: import_prop_types15.default.oneOfType([import_prop_types15.default.arrayOf(import_prop_types15.default.oneOfType([import_prop_types15.default.number, import_prop_types15.default.string])), import_prop_types15.default.number, import_prop_types15.default.object, import_prop_types15.default.string]),
  /**
   * Defines the size of the the type `item` components.
   */
  size: import_prop_types15.default.oneOfType([import_prop_types15.default.string, import_prop_types15.default.bool, import_prop_types15.default.number, import_prop_types15.default.arrayOf(import_prop_types15.default.oneOfType([import_prop_types15.default.string, import_prop_types15.default.bool, import_prop_types15.default.number])), import_prop_types15.default.object]),
  /**
   * Defines the space between the type `item` components.
   * It can only be used on a type `container` component.
   * @default 0
   */
  spacing: import_prop_types15.default.oneOfType([import_prop_types15.default.arrayOf(import_prop_types15.default.oneOfType([import_prop_types15.default.number, import_prop_types15.default.string])), import_prop_types15.default.number, import_prop_types15.default.object, import_prop_types15.default.string]),
  /**
   * @ignore
   */
  sx: import_prop_types15.default.oneOfType([import_prop_types15.default.arrayOf(import_prop_types15.default.oneOfType([import_prop_types15.default.func, import_prop_types15.default.object, import_prop_types15.default.bool])), import_prop_types15.default.func, import_prop_types15.default.object]),
  /**
   * @internal
   * The level of the grid starts from `0` and increases when the grid nests
   * inside another grid. Nesting is defined as a container Grid being a direct
   * child of a container Grid.
   *
   * ```js
   * <Grid container> // level 0
   *   <Grid container> // level 1
   *     <Grid container> // level 2
   * ```
   *
   * Only consecutive grid is considered nesting. A grid container will start at
   * `0` if there are non-Grid container element above it.
   *
   * ```js
   * <Grid container> // level 0
   *   <div>
   *     <Grid container> // level 0
   * ```
   *
   * ```js
   * <Grid container> // level 0
   *   <Grid>
   *     <Grid container> // level 0
   * ```
   */
  unstable_level: import_prop_types15.default.number,
  /**
   * Defines the `flex-wrap` style property.
   * It's applied for all screen sizes.
   * @default 'wrap'
   */
  wrap: import_prop_types15.default.oneOf(["nowrap", "wrap-reverse", "wrap"])
} : void 0;

// node_modules/@mui/system/esm/Grid/gridClasses.js
var SPACINGS = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
var DIRECTIONS = ["column-reverse", "column", "row-reverse", "row"];
var WRAPS = ["nowrap", "wrap-reverse", "wrap"];
var GRID_SIZES = ["auto", "grow", 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
var gridClasses = generateUtilityClasses("MuiGrid", [
  "root",
  "container",
  "item",
  // spacings
  ...SPACINGS.map((spacing2) => `spacing-xs-${spacing2}`),
  // direction values
  ...DIRECTIONS.map((direction) => `direction-xs-${direction}`),
  // wrap values
  ...WRAPS.map((wrap) => `wrap-xs-${wrap}`),
  // grid sizes for all breakpoints
  ...GRID_SIZES.map((size) => `grid-xs-${size}`),
  ...GRID_SIZES.map((size) => `grid-sm-${size}`),
  ...GRID_SIZES.map((size) => `grid-md-${size}`),
  ...GRID_SIZES.map((size) => `grid-lg-${size}`),
  ...GRID_SIZES.map((size) => `grid-xl-${size}`)
]);

// node_modules/@mui/system/esm/Stack/Stack.js
var import_prop_types17 = __toESM(require_prop_types(), 1);

// node_modules/@mui/system/esm/Stack/createStack.js
var React37 = __toESM(require_react(), 1);
var import_prop_types16 = __toESM(require_prop_types(), 1);
var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
var defaultTheme3 = createTheme_default();
var defaultCreateStyledComponent3 = styled_default("div", {
  name: "MuiStack",
  slot: "Root"
});
function useThemePropsDefault3(props) {
  return useThemeProps({
    props,
    name: "MuiStack",
    defaultTheme: defaultTheme3
  });
}
function joinChildren(children2, separator) {
  const childrenArray = React37.Children.toArray(children2).filter(Boolean);
  return childrenArray.reduce((output, child, index2) => {
    output.push(child);
    if (index2 < childrenArray.length - 1) {
      output.push(React37.cloneElement(separator, {
        key: `separator-${index2}`
      }));
    }
    return output;
  }, []);
}
var getSideFromDirection = (direction) => {
  return {
    row: "Left",
    "row-reverse": "Right",
    column: "Top",
    "column-reverse": "Bottom"
  }[direction];
};
var style3 = ({
  ownerState,
  theme
}) => {
  let styles = {
    display: "flex",
    flexDirection: "column",
    ...handleBreakpoints({
      theme
    }, resolveBreakpointValues({
      values: ownerState.direction,
      breakpoints: theme.breakpoints.values
    }), (propValue) => ({
      flexDirection: propValue
    }))
  };
  if (ownerState.spacing) {
    const transformer3 = createUnarySpacing(theme);
    const base = Object.keys(theme.breakpoints.values).reduce((acc, breakpoint) => {
      if (typeof ownerState.spacing === "object" && ownerState.spacing[breakpoint] != null || typeof ownerState.direction === "object" && ownerState.direction[breakpoint] != null) {
        acc[breakpoint] = true;
      }
      return acc;
    }, {});
    const directionValues = resolveBreakpointValues({
      values: ownerState.direction,
      base
    });
    const spacingValues = resolveBreakpointValues({
      values: ownerState.spacing,
      base
    });
    if (typeof directionValues === "object") {
      Object.keys(directionValues).forEach((breakpoint, index2, breakpoints) => {
        const directionValue = directionValues[breakpoint];
        if (!directionValue) {
          const previousDirectionValue = index2 > 0 ? directionValues[breakpoints[index2 - 1]] : "column";
          directionValues[breakpoint] = previousDirectionValue;
        }
      });
    }
    const styleFromPropValue = (propValue, breakpoint) => {
      if (ownerState.useFlexGap) {
        return {
          gap: getValue(transformer3, propValue)
        };
      }
      return {
        // The useFlexGap={false} implement relies on each child to give up control of the margin.
        // We need to reset the margin to avoid double spacing.
        "& > :not(style):not(style)": {
          margin: 0
        },
        "& > :not(style) ~ :not(style)": {
          [`margin${getSideFromDirection(breakpoint ? directionValues[breakpoint] : ownerState.direction)}`]: getValue(transformer3, propValue)
        }
      };
    };
    styles = deepmerge(styles, handleBreakpoints({
      theme
    }, spacingValues, styleFromPropValue));
  }
  styles = mergeBreakpointsInOrder(theme.breakpoints, styles);
  return styles;
};
function createStack(options = {}) {
  const {
    // This will allow adding custom styled fn (for example for custom sx style function)
    createStyledComponent = defaultCreateStyledComponent3,
    useThemeProps: useThemeProps3 = useThemePropsDefault3,
    componentName = "MuiStack"
  } = options;
  const useUtilityClasses31 = () => {
    const slots = {
      root: ["root"]
    };
    return composeClasses(slots, (slot) => generateUtilityClass(componentName, slot), {});
  };
  const StackRoot = createStyledComponent(style3);
  const Stack2 = React37.forwardRef(function Grid2(inProps, ref) {
    const themeProps = useThemeProps3(inProps);
    const props = extendSxProp(themeProps);
    const {
      component = "div",
      direction = "column",
      spacing: spacing2 = 0,
      divider,
      children: children2,
      className,
      useFlexGap = false,
      ...other
    } = props;
    const ownerState = {
      direction,
      spacing: spacing2,
      useFlexGap
    };
    const classes = useUtilityClasses31();
    return (0, import_jsx_runtime12.jsx)(StackRoot, {
      as: component,
      ownerState,
      ref,
      className: clsx_default(classes.root, className),
      ...other,
      children: divider ? joinChildren(children2, divider) : children2
    });
  });
  true ? Stack2.propTypes = {
    children: import_prop_types16.default.node,
    direction: import_prop_types16.default.oneOfType([import_prop_types16.default.oneOf(["column-reverse", "column", "row-reverse", "row"]), import_prop_types16.default.arrayOf(import_prop_types16.default.oneOf(["column-reverse", "column", "row-reverse", "row"])), import_prop_types16.default.object]),
    divider: import_prop_types16.default.node,
    spacing: import_prop_types16.default.oneOfType([import_prop_types16.default.arrayOf(import_prop_types16.default.oneOfType([import_prop_types16.default.number, import_prop_types16.default.string])), import_prop_types16.default.number, import_prop_types16.default.object, import_prop_types16.default.string]),
    sx: import_prop_types16.default.oneOfType([import_prop_types16.default.arrayOf(import_prop_types16.default.oneOfType([import_prop_types16.default.func, import_prop_types16.default.object, import_prop_types16.default.bool])), import_prop_types16.default.func, import_prop_types16.default.object])
  } : void 0;
  return Stack2;
}

// node_modules/@mui/system/esm/Stack/Stack.js
var Stack = createStack();
true ? Stack.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //  To update them, edit the TypeScript types and run `pnpm proptypes`. 
  // 
  /**
   * The content of the component.
   */
  children: import_prop_types17.default.node,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: import_prop_types17.default.elementType,
  /**
   * Defines the `flex-direction` style property.
   * It is applied for all screen sizes.
   * @default 'column'
   */
  direction: import_prop_types17.default.oneOfType([import_prop_types17.default.oneOf(["column-reverse", "column", "row-reverse", "row"]), import_prop_types17.default.arrayOf(import_prop_types17.default.oneOf(["column-reverse", "column", "row-reverse", "row"])), import_prop_types17.default.object]),
  /**
   * Add an element between each child.
   */
  divider: import_prop_types17.default.node,
  /**
   * Defines the space between immediate children.
   * @default 0
   */
  spacing: import_prop_types17.default.oneOfType([import_prop_types17.default.arrayOf(import_prop_types17.default.oneOfType([import_prop_types17.default.number, import_prop_types17.default.string])), import_prop_types17.default.number, import_prop_types17.default.object, import_prop_types17.default.string]),
  /**
   * The system prop, which allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types17.default.oneOfType([import_prop_types17.default.arrayOf(import_prop_types17.default.oneOfType([import_prop_types17.default.func, import_prop_types17.default.object, import_prop_types17.default.bool])), import_prop_types17.default.func, import_prop_types17.default.object]),
  /**
   * If `true`, the CSS flexbox `gap` is used instead of applying `margin` to children.
   *
   * While CSS `gap` removes the [known limitations](https://mui.com/joy-ui/react-stack/#limitations),
   * it is not fully supported in some browsers. We recommend checking https://caniuse.com/?search=flex%20gap before using this flag.
   *
   * To enable this flag globally, follow the theme's default props configuration.
   * @default false
   */
  useFlexGap: import_prop_types17.default.bool
} : void 0;

// node_modules/@mui/system/esm/Stack/stackClasses.js
var stackClasses = generateUtilityClasses("MuiStack", ["root"]);

// node_modules/@mui/material/esm/colors/common.js
var common = {
  black: "#000",
  white: "#fff"
};
var common_default = common;

// node_modules/@mui/material/esm/colors/grey.js
var grey = {
  50: "#fafafa",
  100: "#f5f5f5",
  200: "#eeeeee",
  300: "#e0e0e0",
  400: "#bdbdbd",
  500: "#9e9e9e",
  600: "#757575",
  700: "#616161",
  800: "#424242",
  900: "#212121",
  A100: "#f5f5f5",
  A200: "#eeeeee",
  A400: "#bdbdbd",
  A700: "#616161"
};
var grey_default = grey;

// node_modules/@mui/material/esm/colors/purple.js
var purple = {
  50: "#f3e5f5",
  100: "#e1bee7",
  200: "#ce93d8",
  300: "#ba68c8",
  400: "#ab47bc",
  500: "#9c27b0",
  600: "#8e24aa",
  700: "#7b1fa2",
  800: "#6a1b9a",
  900: "#4a148c",
  A100: "#ea80fc",
  A200: "#e040fb",
  A400: "#d500f9",
  A700: "#aa00ff"
};
var purple_default = purple;

// node_modules/@mui/material/esm/colors/red.js
var red = {
  50: "#ffebee",
  100: "#ffcdd2",
  200: "#ef9a9a",
  300: "#e57373",
  400: "#ef5350",
  500: "#f44336",
  600: "#e53935",
  700: "#d32f2f",
  800: "#c62828",
  900: "#b71c1c",
  A100: "#ff8a80",
  A200: "#ff5252",
  A400: "#ff1744",
  A700: "#d50000"
};
var red_default = red;

// node_modules/@mui/material/esm/colors/orange.js
var orange = {
  50: "#fff3e0",
  100: "#ffe0b2",
  200: "#ffcc80",
  300: "#ffb74d",
  400: "#ffa726",
  500: "#ff9800",
  600: "#fb8c00",
  700: "#f57c00",
  800: "#ef6c00",
  900: "#e65100",
  A100: "#ffd180",
  A200: "#ffab40",
  A400: "#ff9100",
  A700: "#ff6d00"
};
var orange_default = orange;

// node_modules/@mui/material/esm/colors/blue.js
var blue = {
  50: "#e3f2fd",
  100: "#bbdefb",
  200: "#90caf9",
  300: "#64b5f6",
  400: "#42a5f5",
  500: "#2196f3",
  600: "#1e88e5",
  700: "#1976d2",
  800: "#1565c0",
  900: "#0d47a1",
  A100: "#82b1ff",
  A200: "#448aff",
  A400: "#2979ff",
  A700: "#2962ff"
};
var blue_default = blue;

// node_modules/@mui/material/esm/colors/lightBlue.js
var lightBlue = {
  50: "#e1f5fe",
  100: "#b3e5fc",
  200: "#81d4fa",
  300: "#4fc3f7",
  400: "#29b6f6",
  500: "#03a9f4",
  600: "#039be5",
  700: "#0288d1",
  800: "#0277bd",
  900: "#01579b",
  A100: "#80d8ff",
  A200: "#40c4ff",
  A400: "#00b0ff",
  A700: "#0091ea"
};
var lightBlue_default = lightBlue;

// node_modules/@mui/material/esm/colors/green.js
var green = {
  50: "#e8f5e9",
  100: "#c8e6c9",
  200: "#a5d6a7",
  300: "#81c784",
  400: "#66bb6a",
  500: "#4caf50",
  600: "#43a047",
  700: "#388e3c",
  800: "#2e7d32",
  900: "#1b5e20",
  A100: "#b9f6ca",
  A200: "#69f0ae",
  A400: "#00e676",
  A700: "#00c853"
};
var green_default = green;

// node_modules/@mui/material/esm/styles/createPalette.js
function getLight() {
  return {
    // The colors used to style the text.
    text: {
      // The most important text.
      primary: "rgba(0, 0, 0, 0.87)",
      // Secondary text.
      secondary: "rgba(0, 0, 0, 0.6)",
      // Disabled text have even lower visual prominence.
      disabled: "rgba(0, 0, 0, 0.38)"
    },
    // The color used to divide different elements.
    divider: "rgba(0, 0, 0, 0.12)",
    // The background colors used to style the surfaces.
    // Consistency between these values is important.
    background: {
      paper: common_default.white,
      default: common_default.white
    },
    // The colors used to style the action elements.
    action: {
      // The color of an active action like an icon button.
      active: "rgba(0, 0, 0, 0.54)",
      // The color of an hovered action.
      hover: "rgba(0, 0, 0, 0.04)",
      hoverOpacity: 0.04,
      // The color of a selected action.
      selected: "rgba(0, 0, 0, 0.08)",
      selectedOpacity: 0.08,
      // The color of a disabled action.
      disabled: "rgba(0, 0, 0, 0.26)",
      // The background color of a disabled action.
      disabledBackground: "rgba(0, 0, 0, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(0, 0, 0, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.12
    }
  };
}
var light = getLight();
function getDark() {
  return {
    text: {
      primary: common_default.white,
      secondary: "rgba(255, 255, 255, 0.7)",
      disabled: "rgba(255, 255, 255, 0.5)",
      icon: "rgba(255, 255, 255, 0.5)"
    },
    divider: "rgba(255, 255, 255, 0.12)",
    background: {
      paper: "#121212",
      default: "#121212"
    },
    action: {
      active: common_default.white,
      hover: "rgba(255, 255, 255, 0.08)",
      hoverOpacity: 0.08,
      selected: "rgba(255, 255, 255, 0.16)",
      selectedOpacity: 0.16,
      disabled: "rgba(255, 255, 255, 0.3)",
      disabledBackground: "rgba(255, 255, 255, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(255, 255, 255, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.24
    }
  };
}
var dark = getDark();
function addLightOrDark(intent, direction, shade, tonalOffset) {
  const tonalOffsetLight = tonalOffset.light || tonalOffset;
  const tonalOffsetDark = tonalOffset.dark || tonalOffset * 1.5;
  if (!intent[direction]) {
    if (intent.hasOwnProperty(shade)) {
      intent[direction] = intent[shade];
    } else if (direction === "light") {
      intent.light = lighten(intent.main, tonalOffsetLight);
    } else if (direction === "dark") {
      intent.dark = darken(intent.main, tonalOffsetDark);
    }
  }
}
function getDefaultPrimary(mode2 = "light") {
  if (mode2 === "dark") {
    return {
      main: blue_default[200],
      light: blue_default[50],
      dark: blue_default[400]
    };
  }
  return {
    main: blue_default[700],
    light: blue_default[400],
    dark: blue_default[800]
  };
}
function getDefaultSecondary(mode2 = "light") {
  if (mode2 === "dark") {
    return {
      main: purple_default[200],
      light: purple_default[50],
      dark: purple_default[400]
    };
  }
  return {
    main: purple_default[500],
    light: purple_default[300],
    dark: purple_default[700]
  };
}
function getDefaultError(mode2 = "light") {
  if (mode2 === "dark") {
    return {
      main: red_default[500],
      light: red_default[300],
      dark: red_default[700]
    };
  }
  return {
    main: red_default[700],
    light: red_default[400],
    dark: red_default[800]
  };
}
function getDefaultInfo(mode2 = "light") {
  if (mode2 === "dark") {
    return {
      main: lightBlue_default[400],
      light: lightBlue_default[300],
      dark: lightBlue_default[700]
    };
  }
  return {
    main: lightBlue_default[700],
    light: lightBlue_default[500],
    dark: lightBlue_default[900]
  };
}
function getDefaultSuccess(mode2 = "light") {
  if (mode2 === "dark") {
    return {
      main: green_default[400],
      light: green_default[300],
      dark: green_default[700]
    };
  }
  return {
    main: green_default[800],
    light: green_default[500],
    dark: green_default[900]
  };
}
function getDefaultWarning(mode2 = "light") {
  if (mode2 === "dark") {
    return {
      main: orange_default[400],
      light: orange_default[300],
      dark: orange_default[700]
    };
  }
  return {
    main: "#ed6c02",
    // closest to orange[800] that pass 3:1.
    light: orange_default[500],
    dark: orange_default[900]
  };
}
function createPalette(palette2) {
  const {
    mode: mode2 = "light",
    contrastThreshold = 3,
    tonalOffset = 0.2,
    ...other
  } = palette2;
  const primary = palette2.primary || getDefaultPrimary(mode2);
  const secondary = palette2.secondary || getDefaultSecondary(mode2);
  const error = palette2.error || getDefaultError(mode2);
  const info = palette2.info || getDefaultInfo(mode2);
  const success = palette2.success || getDefaultSuccess(mode2);
  const warning = palette2.warning || getDefaultWarning(mode2);
  function getContrastText(background) {
    const contrastText = getContrastRatio(background, dark.text.primary) >= contrastThreshold ? dark.text.primary : light.text.primary;
    if (true) {
      const contrast = getContrastRatio(background, contrastText);
      if (contrast < 3) {
        console.error([`MUI: The contrast ratio of ${contrast}:1 for ${contrastText} on ${background}`, "falls below the WCAG recommended absolute minimum contrast ratio of 3:1.", "https://www.w3.org/TR/2008/REC-WCAG20-20081211/#visual-audio-contrast-contrast"].join("\n"));
      }
    }
    return contrastText;
  }
  const augmentColor = ({
    color: color3,
    name,
    mainShade = 500,
    lightShade = 300,
    darkShade = 700
  }) => {
    color3 = {
      ...color3
    };
    if (!color3.main && color3[mainShade]) {
      color3.main = color3[mainShade];
    }
    if (!color3.hasOwnProperty("main")) {
      throw new Error(true ? `MUI: The color${name ? ` (${name})` : ""} provided to augmentColor(color) is invalid.
The color object needs to have a \`main\` property or a \`${mainShade}\` property.` : formatMuiErrorMessage(11, name ? ` (${name})` : "", mainShade));
    }
    if (typeof color3.main !== "string") {
      throw new Error(true ? `MUI: The color${name ? ` (${name})` : ""} provided to augmentColor(color) is invalid.
\`color.main\` should be a string, but \`${JSON.stringify(color3.main)}\` was provided instead.

Did you intend to use one of the following approaches?

import { green } from "@mui/material/colors";

const theme1 = createTheme({ palette: {
  primary: green,
} });

const theme2 = createTheme({ palette: {
  primary: { main: green[500] },
} });` : formatMuiErrorMessage(12, name ? ` (${name})` : "", JSON.stringify(color3.main)));
    }
    addLightOrDark(color3, "light", lightShade, tonalOffset);
    addLightOrDark(color3, "dark", darkShade, tonalOffset);
    if (!color3.contrastText) {
      color3.contrastText = getContrastText(color3.main);
    }
    return color3;
  };
  let modeHydrated;
  if (mode2 === "light") {
    modeHydrated = getLight();
  } else if (mode2 === "dark") {
    modeHydrated = getDark();
  }
  if (true) {
    if (!modeHydrated) {
      console.error(`MUI: The palette mode \`${mode2}\` is not supported.`);
    }
  }
  const paletteOutput = deepmerge({
    // A collection of common colors.
    common: {
      ...common_default
    },
    // prevent mutable object.
    // The palette mode, can be light or dark.
    mode: mode2,
    // The colors used to represent primary interface elements for a user.
    primary: augmentColor({
      color: primary,
      name: "primary"
    }),
    // The colors used to represent secondary interface elements for a user.
    secondary: augmentColor({
      color: secondary,
      name: "secondary",
      mainShade: "A400",
      lightShade: "A200",
      darkShade: "A700"
    }),
    // The colors used to represent interface elements that the user should be made aware of.
    error: augmentColor({
      color: error,
      name: "error"
    }),
    // The colors used to represent potentially dangerous actions or important messages.
    warning: augmentColor({
      color: warning,
      name: "warning"
    }),
    // The colors used to present information to the user that is neutral and not necessarily important.
    info: augmentColor({
      color: info,
      name: "info"
    }),
    // The colors used to indicate the successful completion of an action that user triggered.
    success: augmentColor({
      color: success,
      name: "success"
    }),
    // The grey colors.
    grey: grey_default,
    // Used by `getContrastText()` to maximize the contrast between
    // the background and the text.
    contrastThreshold,
    // Takes a background color and returns the text color that maximizes the contrast.
    getContrastText,
    // Generate a rich color object.
    augmentColor,
    // Used by the functions below to shift a color's luminance by approximately
    // two indexes within its tonal palette.
    // E.g., shift from Red 500 to Red 300 or Red 700.
    tonalOffset,
    // The light and dark mode object.
    ...modeHydrated
  }, other);
  return paletteOutput;
}

// node_modules/@mui/system/esm/cssVars/prepareTypographyVars.js
function prepareTypographyVars(typography2) {
  const vars = {};
  const entries = Object.entries(typography2);
  entries.forEach((entry) => {
    const [key, value] = entry;
    if (typeof value === "object") {
      vars[key] = `${value.fontStyle ? `${value.fontStyle} ` : ""}${value.fontVariant ? `${value.fontVariant} ` : ""}${value.fontWeight ? `${value.fontWeight} ` : ""}${value.fontStretch ? `${value.fontStretch} ` : ""}${value.fontSize || ""}${value.lineHeight ? `/${value.lineHeight} ` : ""}${value.fontFamily || ""}`;
    }
  });
  return vars;
}

// node_modules/@mui/material/esm/styles/createMixins.js
function createMixins(breakpoints, mixins) {
  return {
    toolbar: {
      minHeight: 56,
      [breakpoints.up("xs")]: {
        "@media (orientation: landscape)": {
          minHeight: 48
        }
      },
      [breakpoints.up("sm")]: {
        minHeight: 64
      }
    },
    ...mixins
  };
}

// node_modules/@mui/material/esm/styles/createTypography.js
function round(value) {
  return Math.round(value * 1e5) / 1e5;
}
var caseAllCaps = {
  textTransform: "uppercase"
};
var defaultFontFamily = '"Roboto", "Helvetica", "Arial", sans-serif';
function createTypography(palette2, typography2) {
  const {
    fontFamily: fontFamily2 = defaultFontFamily,
    // The default font size of the Material Specification.
    fontSize: fontSize2 = 14,
    // px
    fontWeightLight = 300,
    fontWeightRegular = 400,
    fontWeightMedium = 500,
    fontWeightBold = 700,
    // Tell MUI what's the font-size on the html element.
    // 16px is the default font-size used by browsers.
    htmlFontSize = 16,
    // Apply the CSS properties to all the variants.
    allVariants,
    pxToRem: pxToRem2,
    ...other
  } = typeof typography2 === "function" ? typography2(palette2) : typography2;
  if (true) {
    if (typeof fontSize2 !== "number") {
      console.error("MUI: `fontSize` is required to be a number.");
    }
    if (typeof htmlFontSize !== "number") {
      console.error("MUI: `htmlFontSize` is required to be a number.");
    }
  }
  const coef = fontSize2 / 14;
  const pxToRem = pxToRem2 || ((size) => `${size / htmlFontSize * coef}rem`);
  const buildVariant = (fontWeight2, size, lineHeight2, letterSpacing2, casing) => ({
    fontFamily: fontFamily2,
    fontWeight: fontWeight2,
    fontSize: pxToRem(size),
    // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
    lineHeight: lineHeight2,
    // The letter spacing was designed for the Roboto font-family. Using the same letter-spacing
    // across font-families can cause issues with the kerning.
    ...fontFamily2 === defaultFontFamily ? {
      letterSpacing: `${round(letterSpacing2 / size)}em`
    } : {},
    ...casing,
    ...allVariants
  });
  const variants = {
    h1: buildVariant(fontWeightLight, 96, 1.167, -1.5),
    h2: buildVariant(fontWeightLight, 60, 1.2, -0.5),
    h3: buildVariant(fontWeightRegular, 48, 1.167, 0),
    h4: buildVariant(fontWeightRegular, 34, 1.235, 0.25),
    h5: buildVariant(fontWeightRegular, 24, 1.334, 0),
    h6: buildVariant(fontWeightMedium, 20, 1.6, 0.15),
    subtitle1: buildVariant(fontWeightRegular, 16, 1.75, 0.15),
    subtitle2: buildVariant(fontWeightMedium, 14, 1.57, 0.1),
    body1: buildVariant(fontWeightRegular, 16, 1.5, 0.15),
    body2: buildVariant(fontWeightRegular, 14, 1.43, 0.15),
    button: buildVariant(fontWeightMedium, 14, 1.75, 0.4, caseAllCaps),
    caption: buildVariant(fontWeightRegular, 12, 1.66, 0.4),
    overline: buildVariant(fontWeightRegular, 12, 2.66, 1, caseAllCaps),
    // TODO v6: Remove handling of 'inherit' variant from the theme as it is already handled in Material UI's Typography component. Also, remember to remove the associated types.
    inherit: {
      fontFamily: "inherit",
      fontWeight: "inherit",
      fontSize: "inherit",
      lineHeight: "inherit",
      letterSpacing: "inherit"
    }
  };
  return deepmerge({
    htmlFontSize,
    pxToRem,
    fontFamily: fontFamily2,
    fontSize: fontSize2,
    fontWeightLight,
    fontWeightRegular,
    fontWeightMedium,
    fontWeightBold,
    ...variants
  }, other, {
    clone: false
    // No need to clone deep
  });
}

// node_modules/@mui/material/esm/styles/shadows.js
var shadowKeyUmbraOpacity = 0.2;
var shadowKeyPenumbraOpacity = 0.14;
var shadowAmbientShadowOpacity = 0.12;
function createShadow(...px) {
  return [`${px[0]}px ${px[1]}px ${px[2]}px ${px[3]}px rgba(0,0,0,${shadowKeyUmbraOpacity})`, `${px[4]}px ${px[5]}px ${px[6]}px ${px[7]}px rgba(0,0,0,${shadowKeyPenumbraOpacity})`, `${px[8]}px ${px[9]}px ${px[10]}px ${px[11]}px rgba(0,0,0,${shadowAmbientShadowOpacity})`].join(",");
}
var shadows = ["none", createShadow(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), createShadow(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), createShadow(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), createShadow(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), createShadow(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), createShadow(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), createShadow(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), createShadow(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), createShadow(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), createShadow(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), createShadow(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), createShadow(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), createShadow(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), createShadow(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), createShadow(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), createShadow(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), createShadow(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), createShadow(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), createShadow(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), createShadow(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), createShadow(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), createShadow(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), createShadow(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), createShadow(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)];
var shadows_default2 = shadows;

// node_modules/@mui/material/esm/styles/createTransitions.js
var easing = {
  // This is the most common easing curve.
  easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
  // Objects enter the screen at full velocity from off-screen and
  // slowly decelerate to a resting point.
  easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
  // Objects leave the screen at full velocity. They do not decelerate when off-screen.
  easeIn: "cubic-bezier(0.4, 0, 1, 1)",
  // The sharp curve is used by objects that may return to the screen at any time.
  sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
};
var duration = {
  shortest: 150,
  shorter: 200,
  short: 250,
  // most basic recommended timing
  standard: 300,
  // this is to be used in complex animations
  complex: 375,
  // recommended when something is entering screen
  enteringScreen: 225,
  // recommended when something is leaving screen
  leavingScreen: 195
};
function formatMs(milliseconds2) {
  return `${Math.round(milliseconds2)}ms`;
}
function getAutoHeightDuration(height2) {
  if (!height2) {
    return 0;
  }
  const constant2 = height2 / 36;
  return Math.min(Math.round((4 + 15 * constant2 ** 0.25 + constant2 / 5) * 10), 3e3);
}
function createTransitions(inputTransitions) {
  const mergedEasing = {
    ...easing,
    ...inputTransitions.easing
  };
  const mergedDuration = {
    ...duration,
    ...inputTransitions.duration
  };
  const create = (props = ["all"], options = {}) => {
    const {
      duration: durationOption = mergedDuration.standard,
      easing: easingOption = mergedEasing.easeInOut,
      delay = 0,
      ...other
    } = options;
    if (true) {
      const isString = (value) => typeof value === "string";
      const isNumber = (value) => !Number.isNaN(parseFloat(value));
      if (!isString(props) && !Array.isArray(props)) {
        console.error('MUI: Argument "props" must be a string or Array.');
      }
      if (!isNumber(durationOption) && !isString(durationOption)) {
        console.error(`MUI: Argument "duration" must be a number or a string but found ${durationOption}.`);
      }
      if (!isString(easingOption)) {
        console.error('MUI: Argument "easing" must be a string.');
      }
      if (!isNumber(delay) && !isString(delay)) {
        console.error('MUI: Argument "delay" must be a number or a string.');
      }
      if (typeof options !== "object") {
        console.error(["MUI: Secong argument of transition.create must be an object.", "Arguments should be either `create('prop1', options)` or `create(['prop1', 'prop2'], options)`"].join("\n"));
      }
      if (Object.keys(other).length !== 0) {
        console.error(`MUI: Unrecognized argument(s) [${Object.keys(other).join(",")}].`);
      }
    }
    return (Array.isArray(props) ? props : [props]).map((animatedProp) => `${animatedProp} ${typeof durationOption === "string" ? durationOption : formatMs(durationOption)} ${easingOption} ${typeof delay === "string" ? delay : formatMs(delay)}`).join(",");
  };
  return {
    getAutoHeightDuration,
    create,
    ...inputTransitions,
    easing: mergedEasing,
    duration: mergedDuration
  };
}

// node_modules/@mui/material/esm/styles/zIndex.js
var zIndex2 = {
  mobileStepper: 1e3,
  fab: 1050,
  speedDial: 1050,
  appBar: 1100,
  drawer: 1200,
  modal: 1300,
  snackbar: 1400,
  tooltip: 1500
};
var zIndex_default = zIndex2;

// node_modules/@mui/material/esm/styles/stringifyTheme.js
function isSerializable(val) {
  return isPlainObject(val) || typeof val === "undefined" || typeof val === "string" || typeof val === "boolean" || typeof val === "number" || Array.isArray(val);
}
function stringifyTheme(baseTheme = {}) {
  const serializableTheme = {
    ...baseTheme
  };
  function serializeTheme(object) {
    const array2 = Object.entries(object);
    for (let index2 = 0; index2 < array2.length; index2++) {
      const [key, value] = array2[index2];
      if (!isSerializable(value) || key.startsWith("unstable_")) {
        delete object[key];
      } else if (isPlainObject(value)) {
        object[key] = {
          ...value
        };
        serializeTheme(object[key]);
      }
    }
  }
  serializeTheme(serializableTheme);
  return `import { unstable_createBreakpoints as createBreakpoints, createTransitions } from '@mui/material/styles';

const theme = ${JSON.stringify(serializableTheme, null, 2)};

theme.breakpoints = createBreakpoints(theme.breakpoints || {});
theme.transitions = createTransitions(theme.transitions || {});

export default theme;`;
}

// node_modules/@mui/material/esm/styles/createThemeNoVars.js
function createThemeNoVars(options = {}, ...args) {
  const {
    breakpoints: breakpointsInput,
    mixins: mixinsInput = {},
    spacing: spacingInput,
    palette: paletteInput = {},
    transitions: transitionsInput = {},
    typography: typographyInput = {},
    shape: shapeInput,
    ...other
  } = options;
  if (options.vars && // The error should throw only for the root theme creation because user is not allowed to use a custom node `vars`.
  // `generateThemeVars` is the closest identifier for checking that the `options` is a result of `createTheme` with CSS variables so that user can create new theme for nested ThemeProvider.
  options.generateThemeVars === void 0) {
    throw new Error(true ? "MUI: `vars` is a private field used for CSS variables support.\nPlease use another name or follow the [docs](https://mui.com/material-ui/customization/css-theme-variables/usage/) to enable the feature." : formatMuiErrorMessage(20));
  }
  const palette2 = createPalette(paletteInput);
  const systemTheme = createTheme_default(options);
  let muiTheme = deepmerge(systemTheme, {
    mixins: createMixins(systemTheme.breakpoints, mixinsInput),
    palette: palette2,
    // Don't use [...shadows] until you've verified its transpiled code is not invoking the iterator protocol.
    shadows: shadows_default2.slice(),
    typography: createTypography(palette2, typographyInput),
    transitions: createTransitions(transitionsInput),
    zIndex: {
      ...zIndex_default
    }
  });
  muiTheme = deepmerge(muiTheme, other);
  muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);
  if (true) {
    const stateClasses = ["active", "checked", "completed", "disabled", "error", "expanded", "focused", "focusVisible", "required", "selected"];
    const traverse = (node2, component) => {
      let key;
      for (key in node2) {
        const child = node2[key];
        if (stateClasses.includes(key) && Object.keys(child).length > 0) {
          if (true) {
            const stateClass = generateUtilityClass("", key);
            console.error([`MUI: The \`${component}\` component increases the CSS specificity of the \`${key}\` internal state.`, "You can not override it like this: ", JSON.stringify(node2, null, 2), "", `Instead, you need to use the '&.${stateClass}' syntax:`, JSON.stringify({
              root: {
                [`&.${stateClass}`]: child
              }
            }, null, 2), "", "https://mui.com/r/state-classes-guide"].join("\n"));
          }
          node2[key] = {};
        }
      }
    };
    Object.keys(muiTheme.components).forEach((component) => {
      const styleOverrides = muiTheme.components[component].styleOverrides;
      if (styleOverrides && component.startsWith("Mui")) {
        traverse(styleOverrides, component);
      }
    });
  }
  muiTheme.unstable_sxConfig = {
    ...defaultSxConfig_default,
    ...other == null ? void 0 : other.unstable_sxConfig
  };
  muiTheme.unstable_sx = function sx(props) {
    return styleFunctionSx_default({
      sx: props,
      theme: this
    });
  };
  muiTheme.toRuntimeSource = stringifyTheme;
  return muiTheme;
}
var createThemeNoVars_default = createThemeNoVars;

// node_modules/@mui/material/esm/styles/getOverlayAlpha.js
function getOverlayAlpha(elevation) {
  let alphaValue;
  if (elevation < 1) {
    alphaValue = 5.11916 * elevation ** 2;
  } else {
    alphaValue = 4.5 * Math.log(elevation + 1) + 2;
  }
  return Math.round(alphaValue * 10) / 1e3;
}

// node_modules/@mui/material/esm/styles/createColorScheme.js
var defaultDarkOverlays = [...Array(25)].map((_2, index2) => {
  if (index2 === 0) {
    return "none";
  }
  const overlay = getOverlayAlpha(index2);
  return `linear-gradient(rgba(255 255 255 / ${overlay}), rgba(255 255 255 / ${overlay}))`;
});
function getOpacity(mode2) {
  return {
    inputPlaceholder: mode2 === "dark" ? 0.5 : 0.42,
    inputUnderline: mode2 === "dark" ? 0.7 : 0.42,
    switchTrackDisabled: mode2 === "dark" ? 0.2 : 0.12,
    switchTrack: mode2 === "dark" ? 0.3 : 0.38
  };
}
function getOverlays(mode2) {
  return mode2 === "dark" ? defaultDarkOverlays : [];
}
function createColorScheme(options) {
  const {
    palette: paletteInput = {
      mode: "light"
    },
    // need to cast to avoid module augmentation test
    opacity,
    overlays,
    ...rest
  } = options;
  const palette2 = createPalette(paletteInput);
  return {
    palette: palette2,
    opacity: {
      ...getOpacity(palette2.mode),
      ...opacity
    },
    overlays: overlays || getOverlays(palette2.mode),
    ...rest
  };
}

// node_modules/@mui/material/esm/styles/shouldSkipGeneratingVar.js
function shouldSkipGeneratingVar(keys) {
  var _a;
  return !!keys[0].match(/(cssVarPrefix|colorSchemeSelector|rootSelector|typography|mixins|breakpoints|direction|transitions)/) || !!keys[0].match(/sxConfig$/) || // ends with sxConfig
  keys[0] === "palette" && !!((_a = keys[1]) == null ? void 0 : _a.match(/(mode|contrastThreshold|tonalOffset)/));
}

// node_modules/@mui/material/esm/styles/excludeVariablesFromRoot.js
var excludeVariablesFromRoot = (cssVarPrefix) => [...[...Array(25)].map((_2, index2) => `--${cssVarPrefix ? `${cssVarPrefix}-` : ""}overlays-${index2}`), `--${cssVarPrefix ? `${cssVarPrefix}-` : ""}palette-AppBar-darkBg`, `--${cssVarPrefix ? `${cssVarPrefix}-` : ""}palette-AppBar-darkColor`];
var excludeVariablesFromRoot_default = excludeVariablesFromRoot;

// node_modules/@mui/material/esm/styles/createGetSelector.js
var createGetSelector_default = (theme) => (colorScheme, css) => {
  const root = theme.rootSelector || ":root";
  const selector = theme.colorSchemeSelector;
  let rule = selector;
  if (selector === "class") {
    rule = ".%s";
  }
  if (selector === "data") {
    rule = "[data-%s]";
  }
  if ((selector == null ? void 0 : selector.startsWith("data-")) && !selector.includes("%s")) {
    rule = `[${selector}="%s"]`;
  }
  if (theme.defaultColorScheme === colorScheme) {
    if (colorScheme === "dark") {
      const excludedVariables = {};
      excludeVariablesFromRoot_default(theme.cssVarPrefix).forEach((cssVar) => {
        excludedVariables[cssVar] = css[cssVar];
        delete css[cssVar];
      });
      if (rule === "media") {
        return {
          [root]: css,
          [`@media (prefers-color-scheme: dark)`]: {
            [root]: excludedVariables
          }
        };
      }
      if (rule) {
        return {
          [rule.replace("%s", colorScheme)]: excludedVariables,
          [`${root}, ${rule.replace("%s", colorScheme)}`]: css
        };
      }
      return {
        [root]: {
          ...css,
          ...excludedVariables
        }
      };
    }
    if (rule && rule !== "media") {
      return `${root}, ${rule.replace("%s", String(colorScheme))}`;
    }
  } else if (colorScheme) {
    if (rule === "media") {
      return {
        [`@media (prefers-color-scheme: ${String(colorScheme)})`]: {
          [root]: css
        }
      };
    }
    if (rule) {
      return rule.replace("%s", String(colorScheme));
    }
  }
  return root;
};

// node_modules/@mui/material/esm/styles/createThemeWithVars.js
function assignNode(obj, keys) {
  keys.forEach((k3) => {
    if (!obj[k3]) {
      obj[k3] = {};
    }
  });
}
function setColor(obj, key, defaultValue) {
  if (!obj[key] && defaultValue) {
    obj[key] = defaultValue;
  }
}
function toRgb(color3) {
  if (typeof color3 !== "string" || !color3.startsWith("hsl")) {
    return color3;
  }
  return hslToRgb(color3);
}
function setColorChannel(obj, key) {
  if (!(`${key}Channel` in obj)) {
    obj[`${key}Channel`] = private_safeColorChannel(toRgb(obj[key]), `MUI: Can't create \`palette.${key}Channel\` because \`palette.${key}\` is not one of these formats: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color().
To suppress this warning, you need to explicitly provide the \`palette.${key}Channel\` as a string (in rgb format, for example "12 12 12") or undefined if you want to remove the channel token.`);
  }
}
function getSpacingVal(spacingInput) {
  if (typeof spacingInput === "number") {
    return `${spacingInput}px`;
  }
  if (typeof spacingInput === "string" || typeof spacingInput === "function" || Array.isArray(spacingInput)) {
    return spacingInput;
  }
  return "8px";
}
var silent = (fn2) => {
  try {
    return fn2();
  } catch (error) {
  }
  return void 0;
};
var createGetCssVar2 = (cssVarPrefix = "mui") => createGetCssVar(cssVarPrefix);
function attachColorScheme(colorSchemes, scheme, restTheme, colorScheme) {
  if (!scheme) {
    return void 0;
  }
  scheme = scheme === true ? {} : scheme;
  const mode2 = colorScheme === "dark" ? "dark" : "light";
  if (!restTheme) {
    colorSchemes[colorScheme] = createColorScheme({
      ...scheme,
      palette: {
        mode: mode2,
        ...scheme == null ? void 0 : scheme.palette
      }
    });
    return void 0;
  }
  const {
    palette: palette2,
    ...muiTheme
  } = createThemeNoVars_default({
    ...restTheme,
    palette: {
      mode: mode2,
      ...scheme == null ? void 0 : scheme.palette
    }
  });
  colorSchemes[colorScheme] = {
    ...scheme,
    palette: palette2,
    opacity: {
      ...getOpacity(mode2),
      ...scheme == null ? void 0 : scheme.opacity
    },
    overlays: (scheme == null ? void 0 : scheme.overlays) || getOverlays(mode2)
  };
  return muiTheme;
}
function createThemeWithVars(options = {}, ...args) {
  const {
    colorSchemes: colorSchemesInput = {
      light: true
    },
    defaultColorScheme: defaultColorSchemeInput,
    disableCssColorScheme = false,
    cssVarPrefix = "mui",
    shouldSkipGeneratingVar: shouldSkipGeneratingVar2 = shouldSkipGeneratingVar,
    colorSchemeSelector: selector = colorSchemesInput.light && colorSchemesInput.dark ? "media" : void 0,
    rootSelector = ":root",
    ...input
  } = options;
  const firstColorScheme = Object.keys(colorSchemesInput)[0];
  const defaultColorScheme = defaultColorSchemeInput || (colorSchemesInput.light && firstColorScheme !== "light" ? "light" : firstColorScheme);
  const getCssVar = createGetCssVar2(cssVarPrefix);
  const {
    [defaultColorScheme]: defaultSchemeInput,
    light: builtInLight,
    dark: builtInDark,
    ...customColorSchemes
  } = colorSchemesInput;
  const colorSchemes = {
    ...customColorSchemes
  };
  let defaultScheme = defaultSchemeInput;
  if (defaultColorScheme === "dark" && !("dark" in colorSchemesInput) || defaultColorScheme === "light" && !("light" in colorSchemesInput)) {
    defaultScheme = true;
  }
  if (!defaultScheme) {
    throw new Error(true ? `MUI: The \`colorSchemes.${defaultColorScheme}\` option is either missing or invalid.` : formatMuiErrorMessage(21, defaultColorScheme));
  }
  const muiTheme = attachColorScheme(colorSchemes, defaultScheme, input, defaultColorScheme);
  if (builtInLight && !colorSchemes.light) {
    attachColorScheme(colorSchemes, builtInLight, void 0, "light");
  }
  if (builtInDark && !colorSchemes.dark) {
    attachColorScheme(colorSchemes, builtInDark, void 0, "dark");
  }
  let theme = {
    defaultColorScheme,
    ...muiTheme,
    cssVarPrefix,
    colorSchemeSelector: selector,
    rootSelector,
    getCssVar,
    colorSchemes,
    font: {
      ...prepareTypographyVars(muiTheme.typography),
      ...muiTheme.font
    },
    spacing: getSpacingVal(input.spacing)
  };
  Object.keys(theme.colorSchemes).forEach((key) => {
    const palette2 = theme.colorSchemes[key].palette;
    const setCssVarColor = (cssVar) => {
      const tokens = cssVar.split("-");
      const color3 = tokens[1];
      const colorToken = tokens[2];
      return getCssVar(cssVar, palette2[color3][colorToken]);
    };
    if (palette2.mode === "light") {
      setColor(palette2.common, "background", "#fff");
      setColor(palette2.common, "onBackground", "#000");
    }
    if (palette2.mode === "dark") {
      setColor(palette2.common, "background", "#000");
      setColor(palette2.common, "onBackground", "#fff");
    }
    assignNode(palette2, ["Alert", "AppBar", "Avatar", "Button", "Chip", "FilledInput", "LinearProgress", "Skeleton", "Slider", "SnackbarContent", "SpeedDialAction", "StepConnector", "StepContent", "Switch", "TableCell", "Tooltip"]);
    if (palette2.mode === "light") {
      setColor(palette2.Alert, "errorColor", private_safeDarken(palette2.error.light, 0.6));
      setColor(palette2.Alert, "infoColor", private_safeDarken(palette2.info.light, 0.6));
      setColor(palette2.Alert, "successColor", private_safeDarken(palette2.success.light, 0.6));
      setColor(palette2.Alert, "warningColor", private_safeDarken(palette2.warning.light, 0.6));
      setColor(palette2.Alert, "errorFilledBg", setCssVarColor("palette-error-main"));
      setColor(palette2.Alert, "infoFilledBg", setCssVarColor("palette-info-main"));
      setColor(palette2.Alert, "successFilledBg", setCssVarColor("palette-success-main"));
      setColor(palette2.Alert, "warningFilledBg", setCssVarColor("palette-warning-main"));
      setColor(palette2.Alert, "errorFilledColor", silent(() => palette2.getContrastText(palette2.error.main)));
      setColor(palette2.Alert, "infoFilledColor", silent(() => palette2.getContrastText(palette2.info.main)));
      setColor(palette2.Alert, "successFilledColor", silent(() => palette2.getContrastText(palette2.success.main)));
      setColor(palette2.Alert, "warningFilledColor", silent(() => palette2.getContrastText(palette2.warning.main)));
      setColor(palette2.Alert, "errorStandardBg", private_safeLighten(palette2.error.light, 0.9));
      setColor(palette2.Alert, "infoStandardBg", private_safeLighten(palette2.info.light, 0.9));
      setColor(palette2.Alert, "successStandardBg", private_safeLighten(palette2.success.light, 0.9));
      setColor(palette2.Alert, "warningStandardBg", private_safeLighten(palette2.warning.light, 0.9));
      setColor(palette2.Alert, "errorIconColor", setCssVarColor("palette-error-main"));
      setColor(palette2.Alert, "infoIconColor", setCssVarColor("palette-info-main"));
      setColor(palette2.Alert, "successIconColor", setCssVarColor("palette-success-main"));
      setColor(palette2.Alert, "warningIconColor", setCssVarColor("palette-warning-main"));
      setColor(palette2.AppBar, "defaultBg", setCssVarColor("palette-grey-100"));
      setColor(palette2.Avatar, "defaultBg", setCssVarColor("palette-grey-400"));
      setColor(palette2.Button, "inheritContainedBg", setCssVarColor("palette-grey-300"));
      setColor(palette2.Button, "inheritContainedHoverBg", setCssVarColor("palette-grey-A100"));
      setColor(palette2.Chip, "defaultBorder", setCssVarColor("palette-grey-400"));
      setColor(palette2.Chip, "defaultAvatarColor", setCssVarColor("palette-grey-700"));
      setColor(palette2.Chip, "defaultIconColor", setCssVarColor("palette-grey-700"));
      setColor(palette2.FilledInput, "bg", "rgba(0, 0, 0, 0.06)");
      setColor(palette2.FilledInput, "hoverBg", "rgba(0, 0, 0, 0.09)");
      setColor(palette2.FilledInput, "disabledBg", "rgba(0, 0, 0, 0.12)");
      setColor(palette2.LinearProgress, "primaryBg", private_safeLighten(palette2.primary.main, 0.62));
      setColor(palette2.LinearProgress, "secondaryBg", private_safeLighten(palette2.secondary.main, 0.62));
      setColor(palette2.LinearProgress, "errorBg", private_safeLighten(palette2.error.main, 0.62));
      setColor(palette2.LinearProgress, "infoBg", private_safeLighten(palette2.info.main, 0.62));
      setColor(palette2.LinearProgress, "successBg", private_safeLighten(palette2.success.main, 0.62));
      setColor(palette2.LinearProgress, "warningBg", private_safeLighten(palette2.warning.main, 0.62));
      setColor(palette2.Skeleton, "bg", `rgba(${setCssVarColor("palette-text-primaryChannel")} / 0.11)`);
      setColor(palette2.Slider, "primaryTrack", private_safeLighten(palette2.primary.main, 0.62));
      setColor(palette2.Slider, "secondaryTrack", private_safeLighten(palette2.secondary.main, 0.62));
      setColor(palette2.Slider, "errorTrack", private_safeLighten(palette2.error.main, 0.62));
      setColor(palette2.Slider, "infoTrack", private_safeLighten(palette2.info.main, 0.62));
      setColor(palette2.Slider, "successTrack", private_safeLighten(palette2.success.main, 0.62));
      setColor(palette2.Slider, "warningTrack", private_safeLighten(palette2.warning.main, 0.62));
      const snackbarContentBackground = private_safeEmphasize(palette2.background.default, 0.8);
      setColor(palette2.SnackbarContent, "bg", snackbarContentBackground);
      setColor(palette2.SnackbarContent, "color", silent(() => palette2.getContrastText(snackbarContentBackground)));
      setColor(palette2.SpeedDialAction, "fabHoverBg", private_safeEmphasize(palette2.background.paper, 0.15));
      setColor(palette2.StepConnector, "border", setCssVarColor("palette-grey-400"));
      setColor(palette2.StepContent, "border", setCssVarColor("palette-grey-400"));
      setColor(palette2.Switch, "defaultColor", setCssVarColor("palette-common-white"));
      setColor(palette2.Switch, "defaultDisabledColor", setCssVarColor("palette-grey-100"));
      setColor(palette2.Switch, "primaryDisabledColor", private_safeLighten(palette2.primary.main, 0.62));
      setColor(palette2.Switch, "secondaryDisabledColor", private_safeLighten(palette2.secondary.main, 0.62));
      setColor(palette2.Switch, "errorDisabledColor", private_safeLighten(palette2.error.main, 0.62));
      setColor(palette2.Switch, "infoDisabledColor", private_safeLighten(palette2.info.main, 0.62));
      setColor(palette2.Switch, "successDisabledColor", private_safeLighten(palette2.success.main, 0.62));
      setColor(palette2.Switch, "warningDisabledColor", private_safeLighten(palette2.warning.main, 0.62));
      setColor(palette2.TableCell, "border", private_safeLighten(private_safeAlpha(palette2.divider, 1), 0.88));
      setColor(palette2.Tooltip, "bg", private_safeAlpha(palette2.grey[700], 0.92));
    }
    if (palette2.mode === "dark") {
      setColor(palette2.Alert, "errorColor", private_safeLighten(palette2.error.light, 0.6));
      setColor(palette2.Alert, "infoColor", private_safeLighten(palette2.info.light, 0.6));
      setColor(palette2.Alert, "successColor", private_safeLighten(palette2.success.light, 0.6));
      setColor(palette2.Alert, "warningColor", private_safeLighten(palette2.warning.light, 0.6));
      setColor(palette2.Alert, "errorFilledBg", setCssVarColor("palette-error-dark"));
      setColor(palette2.Alert, "infoFilledBg", setCssVarColor("palette-info-dark"));
      setColor(palette2.Alert, "successFilledBg", setCssVarColor("palette-success-dark"));
      setColor(palette2.Alert, "warningFilledBg", setCssVarColor("palette-warning-dark"));
      setColor(palette2.Alert, "errorFilledColor", silent(() => palette2.getContrastText(palette2.error.dark)));
      setColor(palette2.Alert, "infoFilledColor", silent(() => palette2.getContrastText(palette2.info.dark)));
      setColor(palette2.Alert, "successFilledColor", silent(() => palette2.getContrastText(palette2.success.dark)));
      setColor(palette2.Alert, "warningFilledColor", silent(() => palette2.getContrastText(palette2.warning.dark)));
      setColor(palette2.Alert, "errorStandardBg", private_safeDarken(palette2.error.light, 0.9));
      setColor(palette2.Alert, "infoStandardBg", private_safeDarken(palette2.info.light, 0.9));
      setColor(palette2.Alert, "successStandardBg", private_safeDarken(palette2.success.light, 0.9));
      setColor(palette2.Alert, "warningStandardBg", private_safeDarken(palette2.warning.light, 0.9));
      setColor(palette2.Alert, "errorIconColor", setCssVarColor("palette-error-main"));
      setColor(palette2.Alert, "infoIconColor", setCssVarColor("palette-info-main"));
      setColor(palette2.Alert, "successIconColor", setCssVarColor("palette-success-main"));
      setColor(palette2.Alert, "warningIconColor", setCssVarColor("palette-warning-main"));
      setColor(palette2.AppBar, "defaultBg", setCssVarColor("palette-grey-900"));
      setColor(palette2.AppBar, "darkBg", setCssVarColor("palette-background-paper"));
      setColor(palette2.AppBar, "darkColor", setCssVarColor("palette-text-primary"));
      setColor(palette2.Avatar, "defaultBg", setCssVarColor("palette-grey-600"));
      setColor(palette2.Button, "inheritContainedBg", setCssVarColor("palette-grey-800"));
      setColor(palette2.Button, "inheritContainedHoverBg", setCssVarColor("palette-grey-700"));
      setColor(palette2.Chip, "defaultBorder", setCssVarColor("palette-grey-700"));
      setColor(palette2.Chip, "defaultAvatarColor", setCssVarColor("palette-grey-300"));
      setColor(palette2.Chip, "defaultIconColor", setCssVarColor("palette-grey-300"));
      setColor(palette2.FilledInput, "bg", "rgba(255, 255, 255, 0.09)");
      setColor(palette2.FilledInput, "hoverBg", "rgba(255, 255, 255, 0.13)");
      setColor(palette2.FilledInput, "disabledBg", "rgba(255, 255, 255, 0.12)");
      setColor(palette2.LinearProgress, "primaryBg", private_safeDarken(palette2.primary.main, 0.5));
      setColor(palette2.LinearProgress, "secondaryBg", private_safeDarken(palette2.secondary.main, 0.5));
      setColor(palette2.LinearProgress, "errorBg", private_safeDarken(palette2.error.main, 0.5));
      setColor(palette2.LinearProgress, "infoBg", private_safeDarken(palette2.info.main, 0.5));
      setColor(palette2.LinearProgress, "successBg", private_safeDarken(palette2.success.main, 0.5));
      setColor(palette2.LinearProgress, "warningBg", private_safeDarken(palette2.warning.main, 0.5));
      setColor(palette2.Skeleton, "bg", `rgba(${setCssVarColor("palette-text-primaryChannel")} / 0.13)`);
      setColor(palette2.Slider, "primaryTrack", private_safeDarken(palette2.primary.main, 0.5));
      setColor(palette2.Slider, "secondaryTrack", private_safeDarken(palette2.secondary.main, 0.5));
      setColor(palette2.Slider, "errorTrack", private_safeDarken(palette2.error.main, 0.5));
      setColor(palette2.Slider, "infoTrack", private_safeDarken(palette2.info.main, 0.5));
      setColor(palette2.Slider, "successTrack", private_safeDarken(palette2.success.main, 0.5));
      setColor(palette2.Slider, "warningTrack", private_safeDarken(palette2.warning.main, 0.5));
      const snackbarContentBackground = private_safeEmphasize(palette2.background.default, 0.98);
      setColor(palette2.SnackbarContent, "bg", snackbarContentBackground);
      setColor(palette2.SnackbarContent, "color", silent(() => palette2.getContrastText(snackbarContentBackground)));
      setColor(palette2.SpeedDialAction, "fabHoverBg", private_safeEmphasize(palette2.background.paper, 0.15));
      setColor(palette2.StepConnector, "border", setCssVarColor("palette-grey-600"));
      setColor(palette2.StepContent, "border", setCssVarColor("palette-grey-600"));
      setColor(palette2.Switch, "defaultColor", setCssVarColor("palette-grey-300"));
      setColor(palette2.Switch, "defaultDisabledColor", setCssVarColor("palette-grey-600"));
      setColor(palette2.Switch, "primaryDisabledColor", private_safeDarken(palette2.primary.main, 0.55));
      setColor(palette2.Switch, "secondaryDisabledColor", private_safeDarken(palette2.secondary.main, 0.55));
      setColor(palette2.Switch, "errorDisabledColor", private_safeDarken(palette2.error.main, 0.55));
      setColor(palette2.Switch, "infoDisabledColor", private_safeDarken(palette2.info.main, 0.55));
      setColor(palette2.Switch, "successDisabledColor", private_safeDarken(palette2.success.main, 0.55));
      setColor(palette2.Switch, "warningDisabledColor", private_safeDarken(palette2.warning.main, 0.55));
      setColor(palette2.TableCell, "border", private_safeDarken(private_safeAlpha(palette2.divider, 1), 0.68));
      setColor(palette2.Tooltip, "bg", private_safeAlpha(palette2.grey[700], 0.92));
    }
    setColorChannel(palette2.background, "default");
    setColorChannel(palette2.background, "paper");
    setColorChannel(palette2.common, "background");
    setColorChannel(palette2.common, "onBackground");
    setColorChannel(palette2, "divider");
    Object.keys(palette2).forEach((color3) => {
      const colors = palette2[color3];
      if (color3 !== "tonalOffset" && colors && typeof colors === "object") {
        if (colors.main) {
          setColor(palette2[color3], "mainChannel", private_safeColorChannel(toRgb(colors.main)));
        }
        if (colors.light) {
          setColor(palette2[color3], "lightChannel", private_safeColorChannel(toRgb(colors.light)));
        }
        if (colors.dark) {
          setColor(palette2[color3], "darkChannel", private_safeColorChannel(toRgb(colors.dark)));
        }
        if (colors.contrastText) {
          setColor(palette2[color3], "contrastTextChannel", private_safeColorChannel(toRgb(colors.contrastText)));
        }
        if (color3 === "text") {
          setColorChannel(palette2[color3], "primary");
          setColorChannel(palette2[color3], "secondary");
        }
        if (color3 === "action") {
          if (colors.active) {
            setColorChannel(palette2[color3], "active");
          }
          if (colors.selected) {
            setColorChannel(palette2[color3], "selected");
          }
        }
      }
    });
  });
  theme = args.reduce((acc, argument) => deepmerge(acc, argument), theme);
  const parserConfig = {
    prefix: cssVarPrefix,
    disableCssColorScheme,
    shouldSkipGeneratingVar: shouldSkipGeneratingVar2,
    getSelector: createGetSelector_default(theme)
  };
  const {
    vars,
    generateThemeVars,
    generateStyleSheets
  } = prepareCssVars_default(theme, parserConfig);
  theme.vars = vars;
  Object.entries(theme.colorSchemes[theme.defaultColorScheme]).forEach(([key, value]) => {
    theme[key] = value;
  });
  theme.generateThemeVars = generateThemeVars;
  theme.generateStyleSheets = generateStyleSheets;
  theme.generateSpacing = function generateSpacing() {
    return createSpacing(input.spacing, createUnarySpacing(this));
  };
  theme.getColorSchemeSelector = createGetColorSchemeSelector(selector);
  theme.spacing = theme.generateSpacing();
  theme.shouldSkipGeneratingVar = shouldSkipGeneratingVar2;
  theme.unstable_sxConfig = {
    ...defaultSxConfig_default,
    ...input == null ? void 0 : input.unstable_sxConfig
  };
  theme.unstable_sx = function sx(props) {
    return styleFunctionSx_default({
      sx: props,
      theme: this
    });
  };
  theme.toRuntimeSource = stringifyTheme;
  return theme;
}

// node_modules/@mui/material/esm/styles/createTheme.js
function attachColorScheme2(theme, scheme, colorScheme) {
  if (!theme.colorSchemes) {
    return void 0;
  }
  if (colorScheme) {
    theme.colorSchemes[scheme] = {
      ...colorScheme !== true && colorScheme,
      palette: createPalette({
        ...colorScheme === true ? {} : colorScheme.palette,
        mode: scheme
      })
      // cast type to skip module augmentation test
    };
  }
}
function createTheme2(options = {}, ...args) {
  const {
    palette: palette2,
    cssVariables = false,
    colorSchemes: initialColorSchemes = !palette2 ? {
      light: true
    } : void 0,
    defaultColorScheme: initialDefaultColorScheme = palette2 == null ? void 0 : palette2.mode,
    ...rest
  } = options;
  const defaultColorSchemeInput = initialDefaultColorScheme || "light";
  const defaultScheme = initialColorSchemes == null ? void 0 : initialColorSchemes[defaultColorSchemeInput];
  const colorSchemesInput = {
    ...initialColorSchemes,
    ...palette2 ? {
      [defaultColorSchemeInput]: {
        ...typeof defaultScheme !== "boolean" && defaultScheme,
        palette: palette2
      }
    } : void 0
  };
  if (cssVariables === false) {
    if (!("colorSchemes" in options)) {
      return createThemeNoVars_default(options, ...args);
    }
    let paletteOptions = palette2;
    if (!("palette" in options)) {
      if (colorSchemesInput[defaultColorSchemeInput]) {
        if (colorSchemesInput[defaultColorSchemeInput] !== true) {
          paletteOptions = colorSchemesInput[defaultColorSchemeInput].palette;
        } else if (defaultColorSchemeInput === "dark") {
          paletteOptions = {
            mode: "dark"
          };
        }
      }
    }
    const theme = createThemeNoVars_default({
      ...options,
      palette: paletteOptions
    }, ...args);
    theme.defaultColorScheme = defaultColorSchemeInput;
    theme.colorSchemes = colorSchemesInput;
    if (theme.palette.mode === "light") {
      theme.colorSchemes.light = {
        ...colorSchemesInput.light !== true && colorSchemesInput.light,
        palette: theme.palette
      };
      attachColorScheme2(theme, "dark", colorSchemesInput.dark);
    }
    if (theme.palette.mode === "dark") {
      theme.colorSchemes.dark = {
        ...colorSchemesInput.dark !== true && colorSchemesInput.dark,
        palette: theme.palette
      };
      attachColorScheme2(theme, "light", colorSchemesInput.light);
    }
    return theme;
  }
  if (!palette2 && !("light" in colorSchemesInput) && defaultColorSchemeInput === "light") {
    colorSchemesInput.light = true;
  }
  return createThemeWithVars({
    ...rest,
    colorSchemes: colorSchemesInput,
    defaultColorScheme: defaultColorSchemeInput,
    ...typeof cssVariables !== "boolean" && cssVariables
  }, ...args);
}

// node_modules/@mui/material/esm/styles/useTheme.js
var React38 = __toESM(require_react(), 1);

// node_modules/@mui/material/esm/styles/defaultTheme.js
var defaultTheme4 = createTheme2();
var defaultTheme_default = defaultTheme4;

// node_modules/@mui/material/esm/styles/useTheme.js
function useTheme4() {
  const theme = useTheme_default(defaultTheme_default);
  if (true) {
    React38.useDebugValue(theme);
  }
  return theme[identifier_default] || theme;
}

// node_modules/@mui/material/esm/styles/useThemeProps.js
function useThemeProps2({
  props,
  name
}) {
  return useThemeProps({
    props,
    name,
    defaultTheme: defaultTheme_default,
    themeId: identifier_default
  });
}

// node_modules/@mui/material/esm/styles/slotShouldForwardProp.js
function slotShouldForwardProp(prop) {
  return prop !== "ownerState" && prop !== "theme" && prop !== "sx" && prop !== "as";
}
var slotShouldForwardProp_default = slotShouldForwardProp;

// node_modules/@mui/material/esm/styles/rootShouldForwardProp.js
var rootShouldForwardProp = (prop) => slotShouldForwardProp_default(prop) && prop !== "classes";
var rootShouldForwardProp_default = rootShouldForwardProp;

// node_modules/@mui/material/esm/styles/styled.js
var styled3 = createStyled({
  themeId: identifier_default,
  defaultTheme: defaultTheme_default,
  rootShouldForwardProp: rootShouldForwardProp_default
});
var styled_default2 = styled3;

// node_modules/@mui/material/esm/styles/ThemeProvider.js
var React42 = __toESM(require_react(), 1);

// node_modules/@mui/material/esm/styles/ThemeProviderNoVars.js
var React39 = __toESM(require_react(), 1);
var import_jsx_runtime13 = __toESM(require_jsx_runtime(), 1);

// node_modules/@mui/material/esm/styles/ThemeProviderWithVars.js
var React41 = __toESM(require_react(), 1);

// node_modules/@mui/material/esm/InitColorSchemeScript/InitColorSchemeScript.js
var React40 = __toESM(require_react(), 1);
var import_prop_types18 = __toESM(require_prop_types(), 1);
var import_jsx_runtime14 = __toESM(require_jsx_runtime(), 1);
var defaultConfig = {
  attribute: "data-mui-color-scheme",
  colorSchemeStorageKey: "mui-color-scheme",
  defaultLightColorScheme: "light",
  defaultDarkColorScheme: "dark",
  modeStorageKey: "mui-mode"
};
function InitColorSchemeScript2(props) {
  const {
    defaultMode = "system",
    defaultLightColorScheme = defaultConfig.defaultLightColorScheme,
    defaultDarkColorScheme = defaultConfig.defaultDarkColorScheme,
    modeStorageKey = defaultConfig.modeStorageKey,
    colorSchemeStorageKey = defaultConfig.colorSchemeStorageKey,
    attribute: initialAttribute = defaultConfig.attribute,
    colorSchemeNode = "document.documentElement",
    nonce
  } = props;
  return (0, import_jsx_runtime14.jsx)(InitColorSchemeScript, {
    defaultMode,
    defaultLightColorScheme,
    defaultDarkColorScheme,
    modeStorageKey,
    colorSchemeStorageKey,
    attribute: initialAttribute,
    colorSchemeNode,
    nonce
  });
}
true ? InitColorSchemeScript2.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //  To update them, edit the TypeScript types and run `pnpm proptypes`. 
  // 
  /**
   * DOM attribute for applying a color scheme.
   * @default 'data-mui-color-scheme'
   * @example '.mode-%s' // for class based color scheme
   * @example '[data-mode-%s]' // for data-attribute without '='
   */
  attribute: import_prop_types18.default.string,
  /**
   * The node (provided as string) used to attach the color-scheme attribute.
   * @default 'document.documentElement'
   */
  colorSchemeNode: import_prop_types18.default.string,
  /**
   * localStorage key used to store `colorScheme`.
   * @default 'mui-color-scheme'
   */
  colorSchemeStorageKey: import_prop_types18.default.string,
  /**
   * The default color scheme to be used in dark mode.
   * @default 'dark'
   */
  defaultDarkColorScheme: import_prop_types18.default.string,
  /**
   * The default color scheme to be used in light mode.
   * @default 'light'
   */
  defaultLightColorScheme: import_prop_types18.default.string,
  /**
   * The default mode when the storage is empty (user's first visit).
   * @default 'system'
   */
  defaultMode: import_prop_types18.default.oneOf(["dark", "light", "system"]),
  /**
   * localStorage key used to store `mode`.
   * @default 'mui-mode'
   */
  modeStorageKey: import_prop_types18.default.string,
  /**
   * Nonce string to pass to the inline script for CSP headers.
   */
  nonce: import_prop_types18.default.string
} : void 0;

// node_modules/@mui/material/esm/styles/ThemeProviderWithVars.js
var import_jsx_runtime15 = __toESM(require_jsx_runtime(), 1);
var {
  CssVarsProvider: InternalCssVarsProvider,
  useColorScheme,
  getInitColorSchemeScript: deprecatedGetInitColorSchemeScript
} = createCssVarsProvider({
  themeId: identifier_default,
  // @ts-ignore ignore module augmentation tests
  theme: () => createTheme2({
    cssVariables: true
  }),
  colorSchemeStorageKey: defaultConfig.colorSchemeStorageKey,
  modeStorageKey: defaultConfig.modeStorageKey,
  defaultColorScheme: {
    light: defaultConfig.defaultLightColorScheme,
    dark: defaultConfig.defaultDarkColorScheme
  },
  resolveTheme: (theme) => {
    const newTheme = {
      ...theme,
      typography: createTypography(theme.palette, theme.typography)
    };
    newTheme.unstable_sx = function sx(props) {
      return styleFunctionSx_default({
        sx: props,
        theme: this
      });
    };
    return newTheme;
  }
});

// node_modules/@mui/material/esm/styles/ThemeProvider.js
var import_jsx_runtime16 = __toESM(require_jsx_runtime(), 1);

// node_modules/@mui/x-charts/esm/locales/utils/getChartsLocalization.js
var getChartsLocalization = (chartsTranslations) => {
  return {
    components: {
      MuiChartsLocalizationProvider: {
        defaultProps: {
          localeText: _extends({}, chartsTranslations)
        }
      }
    }
  };
};

// node_modules/@mui/x-charts/esm/locales/enUS.js
var enUSLocaleText = {
  // Overlay
  loading: "Loading data",
  noData: "No data to display",
  zoomIn: "Zoom in",
  zoomOut: "Zoom out"
};
var DEFAULT_LOCALE = enUSLocaleText;
var enUS = getChartsLocalization(enUSLocaleText);

// node_modules/@mui/x-charts/esm/ChartsLocalizationProvider/ChartsLocalizationProvider.js
var import_jsx_runtime17 = __toESM(require_jsx_runtime(), 1);
var _excluded2 = ["localeText"];
var ChartsLocalizationContext = React43.createContext(null);
if (true) {
  ChartsLocalizationContext.displayName = "ChartsLocalizationContext";
}
function ChartsLocalizationProvider(inProps) {
  const {
    localeText: inLocaleText
  } = inProps, other = _objectWithoutPropertiesLoose(inProps, _excluded2);
  const {
    localeText: parentLocaleText
  } = React43.useContext(ChartsLocalizationContext) ?? {
    localeText: void 0
  };
  const props = useThemeProps2({
    // We don't want to pass the `localeText` prop to the theme, that way it will always return the theme value,
    // We will then merge this theme value with our value manually
    props: other,
    name: "MuiChartsLocalizationProvider"
  });
  const {
    children: children2,
    localeText: themeLocaleText
  } = props;
  const localeText = React43.useMemo(() => _extends({}, DEFAULT_LOCALE, themeLocaleText, parentLocaleText, inLocaleText), [themeLocaleText, parentLocaleText, inLocaleText]);
  const contextValue = React43.useMemo(() => {
    return {
      localeText
    };
  }, [localeText]);
  return (0, import_jsx_runtime17.jsx)(ChartsLocalizationContext.Provider, {
    value: contextValue,
    children: children2
  });
}
true ? ChartsLocalizationProvider.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  children: import_prop_types19.default.node,
  /**
   * Localized text for chart components.
   */
  localeText: import_prop_types19.default.object
} : void 0;

// node_modules/@mui/x-charts/esm/hooks/useChartsLocalization.js
var useChartsLocalization = () => {
  const localization = React44.useContext(ChartsLocalizationContext);
  if (localization === null) {
    throw new Error(["MUI X Charts: Can not find the charts localization context.", "It looks like you forgot to wrap your component in ChartsLocalizationProvider.", "This can also happen if you are bundling multiple versions of the `@mui/x-charts` package"].join("\n"));
  }
  return localization;
};

// node_modules/@mui/x-charts/esm/models/seriesType/index.js
function isDefaultizedBarSeries(series) {
  return series.type === "bar";
}
function isBarSeries(series) {
  return series.type === "bar";
}

// node_modules/@mui/x-charts/esm/ChartsClipPath/ChartsClipPath.js
var React45 = __toESM(require_react(), 1);
var import_prop_types20 = __toESM(require_prop_types(), 1);
var import_jsx_runtime18 = __toESM(require_jsx_runtime(), 1);
function ChartsClipPath(props) {
  const {
    id,
    offset: offsetProps
  } = props;
  const {
    left: left3,
    top: top3,
    width: width2,
    height: height2
  } = useDrawingArea();
  const offset2 = _extends({
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  }, offsetProps);
  return (0, import_jsx_runtime18.jsx)("clipPath", {
    id,
    children: (0, import_jsx_runtime18.jsx)("rect", {
      x: left3 - offset2.left,
      y: top3 - offset2.top,
      width: width2 + offset2.left + offset2.right,
      height: height2 + offset2.top + offset2.bottom
    })
  });
}
true ? ChartsClipPath.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The id of the clip path.
   */
  id: import_prop_types20.default.string.isRequired,
  /**
   * Offset, in pixels, of the clip path rectangle from the drawing area.
   *
   * A positive value will move the rectangle outside the drawing area.
   */
  offset: import_prop_types20.default.shape({
    bottom: import_prop_types20.default.number,
    left: import_prop_types20.default.number,
    right: import_prop_types20.default.number,
    top: import_prop_types20.default.number
  })
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsReferenceLine/ChartsReferenceLine.js
var React50 = __toESM(require_react(), 1);
var import_prop_types22 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/ChartsReferenceLine/ChartsXReferenceLine.js
var React48 = __toESM(require_react(), 1);

// node_modules/@mui/x-charts/esm/ChartsReferenceLine/chartsReferenceLineClasses.js
function getReferenceLineUtilityClass(slot) {
  return generateUtilityClass("MuiChartsReferenceLine", slot);
}
var referenceLineClasses = generateUtilityClasses("MuiChartsReferenceLine", ["root", "vertical", "horizontal", "line", "label"]);

// node_modules/@mui/x-charts/esm/ChartsReferenceLine/common.js
var ReferenceLineRoot = styled_default2("g")(({
  theme
}) => ({
  [`& .${referenceLineClasses.line}`]: {
    fill: "none",
    stroke: (theme.vars || theme).palette.text.primary,
    shapeRendering: "crispEdges",
    strokeWidth: 1,
    pointerEvents: "none"
  },
  [`& .${referenceLineClasses.label}`]: _extends({
    fill: (theme.vars || theme).palette.text.primary,
    stroke: "none",
    pointerEvents: "none",
    fontSize: 12
  }, theme.typography.body1)
}));

// node_modules/@mui/x-charts/esm/ChartsText/ChartsText.js
var React47 = __toESM(require_react(), 1);
var import_prop_types21 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/internals/domUtils.js
function isSsr() {
  return typeof window === "undefined";
}
var stringCache = {
  widthCache: {},
  cacheCount: 0
};
var MAX_CACHE_NUM = 2e3;
var SPAN_STYLE = {
  position: "absolute",
  top: "-20000px",
  left: 0,
  padding: 0,
  margin: 0,
  border: "none",
  whiteSpace: "pre"
};
var STYLE_LIST = ["minWidth", "maxWidth", "width", "minHeight", "maxHeight", "height", "top", "left", "fontSize", "padding", "margin", "paddingLeft", "paddingRight", "paddingTop", "paddingBottom", "marginLeft", "marginRight", "marginTop", "marginBottom"];
var MEASUREMENT_SPAN_ID = "mui_measurement_span";
function autoCompleteStyle(name, value) {
  if (STYLE_LIST.indexOf(name) >= 0 && value === +value) {
    return `${value}px`;
  }
  return value;
}
function camelToMiddleLine(text) {
  const strs = text.split("");
  const formatStrs = strs.reduce((result, entry) => {
    if (entry === entry.toUpperCase()) {
      return [...result, "-", entry.toLowerCase()];
    }
    return [...result, entry];
  }, []);
  return formatStrs.join("");
}
var getStyleString = (style4) => Object.keys(style4).sort().reduce((result, s3) => `${result}${camelToMiddleLine(s3)}:${autoCompleteStyle(s3, style4[s3])};`, "");
var domCleanTimeout;
var getStringSize = (text, style4 = {}) => {
  if (text === void 0 || text === null || isSsr()) {
    return {
      width: 0,
      height: 0
    };
  }
  const str = `${text}`;
  const styleString = getStyleString(style4);
  const cacheKey = `${str}-${styleString}`;
  if (stringCache.widthCache[cacheKey]) {
    return stringCache.widthCache[cacheKey];
  }
  try {
    let measurementSpan = document.getElementById(MEASUREMENT_SPAN_ID);
    if (measurementSpan === null) {
      measurementSpan = document.createElement("span");
      measurementSpan.setAttribute("id", MEASUREMENT_SPAN_ID);
      measurementSpan.setAttribute("aria-hidden", "true");
      document.body.appendChild(measurementSpan);
    }
    const measurementSpanStyle = _extends({}, SPAN_STYLE, style4);
    Object.keys(measurementSpanStyle).map((styleKey) => {
      measurementSpan.style[camelToMiddleLine(styleKey)] = autoCompleteStyle(styleKey, measurementSpanStyle[styleKey]);
      return styleKey;
    });
    measurementSpan.textContent = str;
    const rect = measurementSpan.getBoundingClientRect();
    const result = {
      width: rect.width,
      height: rect.height
    };
    stringCache.widthCache[cacheKey] = result;
    if (stringCache.cacheCount + 1 > MAX_CACHE_NUM) {
      stringCache.cacheCount = 0;
      stringCache.widthCache = {};
    } else {
      stringCache.cacheCount += 1;
    }
    if (false) {
      measurementSpan.textContent = "";
    } else {
      if (domCleanTimeout) {
        clearTimeout(domCleanTimeout);
      }
      domCleanTimeout = setTimeout(() => {
        measurementSpan.textContent = "";
      }, 0);
    }
    return result;
  } catch {
    return {
      width: 0,
      height: 0
    };
  }
};

// node_modules/@mui/x-charts/esm/internals/getWordsByLines.js
function getWordsByLines({
  style: style4,
  needsComputation,
  text
}) {
  return text.split("\n").map((subText) => _extends({
    text: subText
  }, needsComputation ? getStringSize(subText, style4) : {
    width: 0,
    height: 0
  }));
}

// node_modules/@mui/x-charts/esm/hooks/useIsHydrated.js
var React46 = __toESM(require_react(), 1);
function useIsHydrated() {
  const [isHydrated, setIsHydrated] = React46.useState(typeof window !== "undefined" || false);
  React46.useEffect(() => {
    setIsHydrated(true);
  }, []);
  return isHydrated;
}

// node_modules/@mui/x-charts/esm/ChartsText/ChartsText.js
var import_jsx_runtime19 = __toESM(require_jsx_runtime(), 1);
var _excluded3 = ["x", "y", "style", "text", "ownerState"];
var _excluded22 = ["angle", "textAnchor", "dominantBaseline"];
function ChartsText(props) {
  const {
    x: x3,
    y: y3,
    style: styleProps,
    text
  } = props, textProps = _objectWithoutPropertiesLoose(props, _excluded3);
  const _ref = styleProps ?? {}, {
    angle,
    textAnchor,
    dominantBaseline
  } = _ref, style4 = _objectWithoutPropertiesLoose(_ref, _excluded22);
  const isHydrated = useIsHydrated();
  const wordsByLines = React47.useMemo(() => getWordsByLines({
    style: style4,
    needsComputation: isHydrated && text.includes("\n"),
    text
  }), [style4, text, isHydrated]);
  let startDy;
  switch (dominantBaseline) {
    case "hanging":
    case "text-before-edge":
      startDy = 0;
      break;
    case "central":
      startDy = (wordsByLines.length - 1) / 2 * -wordsByLines[0].height;
      break;
    default:
      startDy = (wordsByLines.length - 1) * -wordsByLines[0].height;
      break;
  }
  return (0, import_jsx_runtime19.jsx)("text", _extends({}, textProps, {
    transform: angle ? `rotate(${angle}, ${x3}, ${y3})` : void 0,
    x: x3,
    y: y3,
    textAnchor,
    dominantBaseline,
    style: style4,
    children: wordsByLines.map((line2, index2) => (0, import_jsx_runtime19.jsx)("tspan", {
      x: x3,
      dy: `${index2 === 0 ? startDy : wordsByLines[0].height}px`,
      dominantBaseline,
      children: line2.text
    }, index2))
  }));
}
true ? ChartsText.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Height of a text line (in `em`).
   */
  lineHeight: import_prop_types21.default.number,
  /**
   * If `true`, the line width is computed.
   * @default false
   */
  needsComputation: import_prop_types21.default.bool,
  ownerState: import_prop_types21.default.any,
  /**
   * Style applied to text elements.
   */
  style: import_prop_types21.default.object,
  /**
   * Text displayed.
   */
  text: import_prop_types21.default.string.isRequired
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsReferenceLine/ChartsXReferenceLine.js
var import_jsx_runtime20 = __toESM(require_jsx_runtime(), 1);
var getTextParams = ({
  top: top3,
  height: height2,
  spacingY,
  labelAlign = "middle"
}) => {
  switch (labelAlign) {
    case "start":
      return {
        y: top3 + spacingY,
        style: {
          dominantBaseline: "hanging",
          textAnchor: "start"
        }
      };
    case "end":
      return {
        y: top3 + height2 - spacingY,
        style: {
          dominantBaseline: "auto",
          textAnchor: "start"
        }
      };
    default:
      return {
        y: top3 + height2 / 2,
        style: {
          dominantBaseline: "central",
          textAnchor: "start"
        }
      };
  }
};
function getXReferenceLineClasses(classes) {
  return composeClasses({
    root: ["root", "vertical"],
    line: ["line"],
    label: ["label"]
  }, getReferenceLineUtilityClass, classes);
}
function ChartsXReferenceLine(props) {
  const {
    x: x3,
    label = "",
    spacing: spacing2 = 5,
    classes: inClasses,
    labelAlign,
    lineStyle,
    labelStyle,
    axisId
  } = props;
  const {
    top: top3,
    height: height2
  } = useDrawingArea();
  const xAxisScale = useXScale(axisId);
  const xPosition = xAxisScale(x3);
  if (xPosition === void 0) {
    if (true) {
      warnOnce(`MUI X Charts: the value ${x3} does not exist in the data of x axis with id ${axisId}.`, "error");
    }
    return null;
  }
  const d = `M ${xPosition} ${top3} l 0 ${height2}`;
  const classes = getXReferenceLineClasses(inClasses);
  const spacingX = typeof spacing2 === "object" ? spacing2.x ?? 0 : spacing2;
  const spacingY = typeof spacing2 === "object" ? spacing2.y ?? 0 : spacing2;
  const textParams = _extends({
    x: xPosition + spacingX,
    text: label,
    fontSize: 12
  }, getTextParams({
    top: top3,
    height: height2,
    spacingY,
    labelAlign
  }), {
    className: classes.label
  });
  return (0, import_jsx_runtime20.jsxs)(ReferenceLineRoot, {
    className: classes.root,
    children: [(0, import_jsx_runtime20.jsx)("path", {
      d,
      className: classes.line,
      style: lineStyle
    }), (0, import_jsx_runtime20.jsx)(ChartsText, _extends({}, textParams, {
      style: _extends({}, textParams.style, labelStyle)
    }))]
  });
}

// node_modules/@mui/x-charts/esm/ChartsReferenceLine/ChartsYReferenceLine.js
var React49 = __toESM(require_react(), 1);
var import_jsx_runtime21 = __toESM(require_jsx_runtime(), 1);
var getTextParams2 = ({
  left: left3,
  width: width2,
  spacingX,
  labelAlign = "middle"
}) => {
  switch (labelAlign) {
    case "start":
      return {
        x: left3 + spacingX,
        style: {
          dominantBaseline: "auto",
          textAnchor: "start"
        }
      };
    case "end":
      return {
        x: left3 + width2 - spacingX,
        style: {
          dominantBaseline: "auto",
          textAnchor: "end"
        }
      };
    default:
      return {
        x: left3 + width2 / 2,
        style: {
          dominantBaseline: "auto",
          textAnchor: "middle"
        }
      };
  }
};
function getYReferenceLineClasses(classes) {
  return composeClasses({
    root: ["root", "horizontal"],
    line: ["line"],
    label: ["label"]
  }, getReferenceLineUtilityClass, classes);
}
function ChartsYReferenceLine(props) {
  const {
    y: y3,
    label = "",
    spacing: spacing2 = 5,
    classes: inClasses,
    labelAlign,
    lineStyle,
    labelStyle,
    axisId
  } = props;
  const {
    left: left3,
    width: width2
  } = useDrawingArea();
  const yAxisScale = useYScale(axisId);
  const yPosition = yAxisScale(y3);
  if (yPosition === void 0) {
    if (true) {
      warnOnce(`MUI X Charts: the value ${y3} does not exist in the data of y axis with id ${axisId}.`, "error");
    }
    return null;
  }
  const d = `M ${left3} ${yPosition} l ${width2} 0`;
  const classes = getYReferenceLineClasses(inClasses);
  const spacingX = typeof spacing2 === "object" ? spacing2.x ?? 0 : spacing2;
  const spacingY = typeof spacing2 === "object" ? spacing2.y ?? 0 : spacing2;
  const textParams = _extends({
    y: yPosition - spacingY,
    text: label,
    fontSize: 12
  }, getTextParams2({
    left: left3,
    width: width2,
    spacingX,
    labelAlign
  }), {
    className: classes.label
  });
  return (0, import_jsx_runtime21.jsxs)(ReferenceLineRoot, {
    className: classes.root,
    children: [(0, import_jsx_runtime21.jsx)("path", {
      d,
      className: classes.line,
      style: lineStyle
    }), (0, import_jsx_runtime21.jsx)(ChartsText, _extends({}, textParams, {
      style: _extends({}, textParams.style, labelStyle)
    }))]
  });
}

// node_modules/@mui/x-charts/esm/ChartsReferenceLine/ChartsReferenceLine.js
var import_jsx_runtime22 = __toESM(require_jsx_runtime(), 1);
function ChartsReferenceLine(props) {
  const {
    x: x3,
    y: y3
  } = props;
  if (x3 !== void 0 && y3 !== void 0) {
    throw new Error("MUI X Charts: The ChartsReferenceLine cannot have both `x` and `y` props set.");
  }
  if (x3 === void 0 && y3 === void 0) {
    throw new Error("MUI X Charts: The ChartsReferenceLine should have a value in `x` or `y` prop.");
  }
  if (x3 !== void 0) {
    return (0, import_jsx_runtime22.jsx)(ChartsXReferenceLine, _extends({}, props));
  }
  return (0, import_jsx_runtime22.jsx)(ChartsYReferenceLine, _extends({}, props));
}
true ? ChartsReferenceLine.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The id of the axis used for the reference value.
   * @default The `id` of the first defined axis.
   */
  axisId: import_prop_types22.default.oneOfType([import_prop_types22.default.number, import_prop_types22.default.string]),
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types22.default.object,
  /**
   * The label to display along the reference line.
   */
  label: import_prop_types22.default.string,
  /**
   * The alignment if the label is in the chart drawing area.
   * @default 'middle'
   */
  labelAlign: import_prop_types22.default.oneOf(["end", "middle", "start"]),
  /**
   * The style applied to the label.
   */
  labelStyle: import_prop_types22.default.object,
  /**
   * The style applied to the line.
   */
  lineStyle: import_prop_types22.default.object,
  /**
   * Additional space around the label in px.
   * Can be a number or an object `{ x, y }` to distinguish space with the reference line and space with axes.
   * @default 5
   */
  spacing: import_prop_types22.default.oneOfType([import_prop_types22.default.number, import_prop_types22.default.shape({
    x: import_prop_types22.default.number,
    y: import_prop_types22.default.number
  })]),
  /**
   * The x value associated with the reference line.
   * If defined the reference line will be vertical.
   */
  x: import_prop_types22.default.oneOfType([import_prop_types22.default.instanceOf(Date), import_prop_types22.default.number, import_prop_types22.default.string]),
  /**
   * The y value associated with the reference line.
   * If defined the reference line will be horizontal.
   */
  y: import_prop_types22.default.oneOfType([import_prop_types22.default.instanceOf(Date), import_prop_types22.default.number, import_prop_types22.default.string])
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsAxis/ChartsAxis.js
var React54 = __toESM(require_react(), 1);
var import_prop_types25 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/ChartsXAxis/ChartsXAxis.js
var React52 = __toESM(require_react(), 1);
var import_prop_types23 = __toESM(require_prop_types(), 1);

// node_modules/@mui/utils/esm/isHostComponent/isHostComponent.js
function isHostComponent(element) {
  return typeof element === "string";
}
var isHostComponent_default = isHostComponent;

// node_modules/@mui/utils/esm/appendOwnerState/appendOwnerState.js
function appendOwnerState(elementType, otherProps, ownerState) {
  if (elementType === void 0 || isHostComponent_default(elementType)) {
    return otherProps;
  }
  return {
    ...otherProps,
    ownerState: {
      ...otherProps.ownerState,
      ...ownerState
    }
  };
}
var appendOwnerState_default = appendOwnerState;

// node_modules/@mui/utils/esm/extractEventHandlers/extractEventHandlers.js
function extractEventHandlers(object, excludeKeys = []) {
  if (object === void 0) {
    return {};
  }
  const result = {};
  Object.keys(object).filter((prop) => prop.match(/^on[A-Z]/) && typeof object[prop] === "function" && !excludeKeys.includes(prop)).forEach((prop) => {
    result[prop] = object[prop];
  });
  return result;
}
var extractEventHandlers_default = extractEventHandlers;

// node_modules/@mui/utils/esm/omitEventHandlers/omitEventHandlers.js
function omitEventHandlers(object) {
  if (object === void 0) {
    return {};
  }
  const result = {};
  Object.keys(object).filter((prop) => !(prop.match(/^on[A-Z]/) && typeof object[prop] === "function")).forEach((prop) => {
    result[prop] = object[prop];
  });
  return result;
}
var omitEventHandlers_default = omitEventHandlers;

// node_modules/@mui/utils/esm/mergeSlotProps/mergeSlotProps.js
function mergeSlotProps(parameters) {
  const {
    getSlotProps,
    additionalProps,
    externalSlotProps,
    externalForwardedProps,
    className
  } = parameters;
  if (!getSlotProps) {
    const joinedClasses2 = clsx_default(additionalProps == null ? void 0 : additionalProps.className, className, externalForwardedProps == null ? void 0 : externalForwardedProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className);
    const mergedStyle2 = {
      ...additionalProps == null ? void 0 : additionalProps.style,
      ...externalForwardedProps == null ? void 0 : externalForwardedProps.style,
      ...externalSlotProps == null ? void 0 : externalSlotProps.style
    };
    const props2 = {
      ...additionalProps,
      ...externalForwardedProps,
      ...externalSlotProps
    };
    if (joinedClasses2.length > 0) {
      props2.className = joinedClasses2;
    }
    if (Object.keys(mergedStyle2).length > 0) {
      props2.style = mergedStyle2;
    }
    return {
      props: props2,
      internalRef: void 0
    };
  }
  const eventHandlers = extractEventHandlers_default({
    ...externalForwardedProps,
    ...externalSlotProps
  });
  const componentsPropsWithoutEventHandlers = omitEventHandlers_default(externalSlotProps);
  const otherPropsWithoutEventHandlers = omitEventHandlers_default(externalForwardedProps);
  const internalSlotProps = getSlotProps(eventHandlers);
  const joinedClasses = clsx_default(internalSlotProps == null ? void 0 : internalSlotProps.className, additionalProps == null ? void 0 : additionalProps.className, className, externalForwardedProps == null ? void 0 : externalForwardedProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className);
  const mergedStyle = {
    ...internalSlotProps == null ? void 0 : internalSlotProps.style,
    ...additionalProps == null ? void 0 : additionalProps.style,
    ...externalForwardedProps == null ? void 0 : externalForwardedProps.style,
    ...externalSlotProps == null ? void 0 : externalSlotProps.style
  };
  const props = {
    ...internalSlotProps,
    ...additionalProps,
    ...otherPropsWithoutEventHandlers,
    ...componentsPropsWithoutEventHandlers
  };
  if (joinedClasses.length > 0) {
    props.className = joinedClasses;
  }
  if (Object.keys(mergedStyle).length > 0) {
    props.style = mergedStyle;
  }
  return {
    props,
    internalRef: internalSlotProps.ref
  };
}
var mergeSlotProps_default = mergeSlotProps;

// node_modules/@mui/utils/esm/resolveComponentProps/resolveComponentProps.js
function resolveComponentProps(componentProps, ownerState, slotState) {
  if (typeof componentProps === "function") {
    return componentProps(ownerState, slotState);
  }
  return componentProps;
}
var resolveComponentProps_default = resolveComponentProps;

// node_modules/@mui/utils/esm/useSlotProps/useSlotProps.js
function useSlotProps(parameters) {
  var _a;
  const {
    elementType,
    externalSlotProps,
    ownerState,
    skipResolvingSlotProps = false,
    ...other
  } = parameters;
  const resolvedComponentsProps = skipResolvingSlotProps ? {} : resolveComponentProps_default(externalSlotProps, ownerState);
  const {
    props: mergedProps,
    internalRef
  } = mergeSlotProps_default({
    ...other,
    externalSlotProps: resolvedComponentsProps
  });
  const ref = useForkRef(internalRef, resolvedComponentsProps == null ? void 0 : resolvedComponentsProps.ref, (_a = parameters.additionalProps) == null ? void 0 : _a.ref);
  const props = appendOwnerState_default(elementType, {
    ...mergedProps,
    ref
  }, ownerState);
  return props;
}
var useSlotProps_default = useSlotProps;

// node_modules/@mui/x-charts/esm/internals/clampAngle.js
function clampAngle(angle) {
  return (angle % 360 + 360) % 360;
}
var TWO_PI = 2 * Math.PI;
function clampAngleRad(angle) {
  return (angle % TWO_PI + TWO_PI) % TWO_PI;
}

// node_modules/@mui/x-charts/esm/internals/getGraphemeCount.js
var segmenter = typeof window !== "undefined" && "Intl" in window && "Segmenter" in Intl ? new Intl.Segmenter(void 0, {
  granularity: "grapheme"
}) : null;
function getGraphemeCountFallback(text) {
  return text.length;
}
function getGraphemeCountModern(text) {
  const segments = segmenter.segment(text);
  let count2 = 0;
  for (const _unused of segments) {
    count2 += 1;
  }
  return count2;
}
var getGraphemeCount = segmenter ? getGraphemeCountModern : getGraphemeCountFallback;

// node_modules/@mui/x-charts/esm/internals/degToRad.js
function degToRad(degrees3) {
  return degrees3 * (Math.PI / 180);
}

// node_modules/@mui/x-charts/esm/internals/sliceUntil.js
var segmenter2 = typeof window !== "undefined" && "Intl" in window && "Segmenter" in Intl ? new Intl.Segmenter(void 0, {
  granularity: "grapheme"
}) : null;
function sliceUntilFallback(text, endIndex) {
  return text.slice(0, endIndex);
}
function sliceUntilModern(text, endIndex) {
  const segments = segmenter2.segment(text);
  let newText = "";
  let i2 = 0;
  for (const segment of segments) {
    newText += segment.segment;
    i2 += 1;
    if (i2 >= endIndex) {
      break;
    }
  }
  return newText;
}
var sliceUntil = segmenter2 ? sliceUntilModern : sliceUntilFallback;

// node_modules/@mui/x-charts/esm/internals/ellipsize.js
var ELLIPSIS = "";
function doesTextFitInRect(text, config) {
  const {
    width: width2,
    height: height2,
    measureText
  } = config;
  const angle = degToRad(config.angle);
  const textSize = measureText(text);
  const angledWidth = Math.abs(textSize.width * Math.cos(angle)) + Math.abs(textSize.height * Math.sin(angle));
  const angledHeight = Math.abs(textSize.width * Math.sin(angle)) + Math.abs(textSize.height * Math.cos(angle));
  return angledWidth <= width2 && angledHeight <= height2;
}
function ellipsize(text, doesTextFit) {
  if (doesTextFit(text)) {
    return text;
  }
  let shortenedText = text;
  let step = 1;
  let by = 1 / 2;
  const graphemeCount = getGraphemeCount(text);
  let newLength = graphemeCount;
  let lastLength = graphemeCount;
  let longestFittingText = null;
  do {
    lastLength = newLength;
    newLength = Math.floor(graphemeCount * by);
    if (newLength === 0) {
      break;
    }
    shortenedText = sliceUntil(text, newLength).trim();
    const fits = doesTextFit(shortenedText + ELLIPSIS);
    step += 1;
    if (fits) {
      longestFittingText = shortenedText;
      by += 1 / 2 ** step;
    } else {
      by -= 1 / 2 ** step;
    }
  } while (Math.abs(newLength - lastLength) !== 1);
  return longestFittingText ? longestFittingText + ELLIPSIS : "";
}

// node_modules/@mui/x-charts/esm/ChartsAxis/axisClasses.js
function getAxisUtilityClass(slot) {
  return generateUtilityClass("MuiChartsAxis", slot);
}
var axisClasses = generateUtilityClasses("MuiChartsAxis", ["root", "line", "tickContainer", "tick", "tickLabel", "label", "directionX", "directionY", "top", "bottom", "left", "right"]);

// node_modules/@mui/x-charts/esm/internals/components/AxisSharedComponents.js
var AxisRoot = styled_default2("g", {
  name: "MuiChartsAxis",
  slot: "Root"
})(({
  theme
}) => ({
  [`& .${axisClasses.tickLabel}`]: _extends({}, theme.typography.caption, {
    fill: (theme.vars || theme).palette.text.primary
  }),
  [`& .${axisClasses.label}`]: {
    fill: (theme.vars || theme).palette.text.primary
  },
  [`& .${axisClasses.line}`]: {
    stroke: (theme.vars || theme).palette.text.primary,
    shapeRendering: "crispEdges",
    strokeWidth: 1
  },
  [`& .${axisClasses.tick}`]: {
    stroke: (theme.vars || theme).palette.text.primary,
    shapeRendering: "crispEdges"
  }
}));

// node_modules/@mui/x-charts/esm/internals/geometry.js
var ANGLE_APPROX = 5;
function getMinXTranslation(width2, height2, angle = 0) {
  if (true) {
    if (angle > 90 && angle < -90) {
      warnOnce([`MUI X Charts: It seems you applied an angle larger than 90 or smaller than -90 to an axis text.`, `This could cause some text overlapping.`, `If you encounter a use case where it's needed, please open an issue.`]);
    }
  }
  const standardAngle = Math.min(Math.abs(angle) % 180, Math.abs(Math.abs(angle) % 180 - 180) % 180);
  if (standardAngle < ANGLE_APPROX) {
    return width2;
  }
  if (standardAngle > 90 - ANGLE_APPROX) {
    return height2;
  }
  const radAngle = deg2rad(standardAngle);
  const angleSwich = Math.atan2(height2, width2);
  if (radAngle < angleSwich) {
    return width2 / Math.cos(radAngle);
  }
  return height2 / Math.sin(radAngle);
}

// node_modules/@mui/x-charts/esm/hooks/useMounted.js
var React51 = __toESM(require_react(), 1);
function useMounted(defer = false) {
  const [mountedState, setMountedState] = React51.useState(false);
  useEnhancedEffect_default(() => {
    if (!defer) {
      setMountedState(true);
    }
  }, [defer]);
  React51.useEffect(() => {
    if (defer) {
      setMountedState(true);
    }
  }, [defer]);
  return mountedState;
}

// node_modules/@mui/x-charts/esm/ChartsText/defaultTextPlacement.js
function getDefaultTextAnchor(angle) {
  const adjustedAngle = clampAngle(angle);
  if (adjustedAngle <= 30 || adjustedAngle >= 330) {
    return "middle";
  }
  if (adjustedAngle <= 210 && adjustedAngle >= 150) {
    return "middle";
  }
  if (adjustedAngle <= 180) {
    return "end";
  }
  return "start";
}
function getDefaultBaseline(angle) {
  const adjustedAngle = clampAngle(angle);
  if (adjustedAngle <= 30 || adjustedAngle >= 330) {
    return "hanging";
  }
  if (adjustedAngle <= 210 && adjustedAngle >= 150) {
    return "auto";
  }
  return "central";
}

// node_modules/@mui/x-charts/esm/internals/invertTextAnchor.js
function invertTextAnchor(textAnchor) {
  switch (textAnchor) {
    case "start":
      return "end";
    case "end":
      return "start";
    default:
      return textAnchor;
  }
}

// node_modules/@mui/x-charts/esm/ChartsXAxis/ChartsXAxis.js
var import_jsx_runtime23 = __toESM(require_jsx_runtime(), 1);
var _excluded4 = ["scale", "tickNumber", "reverse"];
var useUtilityClasses2 = (ownerState) => {
  const {
    classes,
    position: position3
  } = ownerState;
  const slots = {
    root: ["root", "directionX", position3],
    line: ["line"],
    tickContainer: ["tickContainer"],
    tick: ["tick"],
    tickLabel: ["tickLabel"],
    label: ["label"]
  };
  return composeClasses(slots, getAxisUtilityClass, classes);
};
var TICK_LABEL_GAP = 3;
var AXIS_LABEL_TICK_LABEL_GAP = 4;
function getVisibleLabels(xTicks, {
  tickLabelStyle: style4,
  tickLabelInterval,
  tickLabelMinGap,
  reverse: reverse2,
  isMounted,
  isPointInside
}) {
  const getTickLabelSize = (tick) => {
    if (!isMounted || tick.formattedValue === void 0) {
      return {
        width: 0,
        height: 0
      };
    }
    const tickSizes = getWordsByLines({
      style: style4,
      needsComputation: true,
      text: tick.formattedValue
    });
    return {
      width: Math.max(...tickSizes.map((size) => size.width)),
      height: Math.max(tickSizes.length * tickSizes[0].height)
    };
  };
  if (typeof tickLabelInterval === "function") {
    return new Set(xTicks.filter((item, index2) => tickLabelInterval(item.value, index2)));
  }
  let previousTextLimit = 0;
  const direction = reverse2 ? -1 : 1;
  return new Set(xTicks.filter((item, labelIndex) => {
    const {
      offset: offset2,
      labelOffset
    } = item;
    const textPosition = offset2 + labelOffset;
    if (labelIndex > 0 && direction * textPosition < direction * (previousTextLimit + tickLabelMinGap)) {
      return false;
    }
    if (!isPointInside(textPosition)) {
      return false;
    }
    const {
      width: width2,
      height: height2
    } = getTickLabelSize(item);
    const distance = getMinXTranslation(width2, height2, style4 == null ? void 0 : style4.angle);
    const currentTextLimit = textPosition - direction * distance / 2;
    if (labelIndex > 0 && direction * currentTextLimit < direction * (previousTextLimit + tickLabelMinGap)) {
      return false;
    }
    previousTextLimit = textPosition + direction * distance / 2;
    return true;
  }));
}
function shortenLabels(visibleLabels, drawingArea, maxHeight2, isRtl, tickLabelStyle) {
  const shortenedLabels = /* @__PURE__ */ new Map();
  const angle = clampAngle((tickLabelStyle == null ? void 0 : tickLabelStyle.angle) ?? 0);
  let leftBoundFactor = 1;
  let rightBoundFactor = 1;
  if ((tickLabelStyle == null ? void 0 : tickLabelStyle.textAnchor) === "start") {
    leftBoundFactor = Infinity;
    rightBoundFactor = 1;
  } else if ((tickLabelStyle == null ? void 0 : tickLabelStyle.textAnchor) === "end") {
    leftBoundFactor = 1;
    rightBoundFactor = Infinity;
  } else {
    leftBoundFactor = 2;
    rightBoundFactor = 2;
  }
  if (angle > 90 && angle < 270) {
    [leftBoundFactor, rightBoundFactor] = [rightBoundFactor, leftBoundFactor];
  }
  if (isRtl) {
    [leftBoundFactor, rightBoundFactor] = [rightBoundFactor, leftBoundFactor];
  }
  for (const item of visibleLabels) {
    if (item.formattedValue) {
      const width2 = Math.min((item.offset + item.labelOffset) * leftBoundFactor, (drawingArea.left + drawingArea.width + drawingArea.right - item.offset - item.labelOffset) * rightBoundFactor);
      const doesTextFit = (text) => doesTextFitInRect(text, {
        width: width2,
        height: maxHeight2,
        angle,
        measureText: (string) => getStringSize(string, tickLabelStyle)
      });
      shortenedLabels.set(item, ellipsize(item.formattedValue.toString(), doesTextFit));
    }
  }
  return shortenedLabels;
}
var XAxisRoot = styled_default2(AxisRoot, {
  name: "MuiChartsXAxis",
  slot: "Root"
})({});
var defaultProps = {
  disableLine: false,
  disableTicks: false,
  tickSize: 6,
  tickLabelMinGap: 4
};
function ChartsXAxis(inProps) {
  const {
    xAxis,
    xAxisIds
  } = useXAxes();
  const _xAxis = xAxis[inProps.axisId ?? xAxisIds[0]], {
    scale: xScale,
    tickNumber,
    reverse: reverse2
  } = _xAxis, settings = _objectWithoutPropertiesLoose(_xAxis, _excluded4);
  const isMounted = useMounted();
  const themedProps = useThemeProps2({
    props: _extends({}, settings, inProps),
    name: "MuiChartsXAxis"
  });
  const defaultizedProps = _extends({}, defaultProps, themedProps);
  const {
    position: position3,
    disableLine,
    disableTicks,
    tickLabelStyle,
    label,
    labelStyle,
    tickSize: tickSizeProp,
    valueFormatter,
    slots,
    slotProps,
    tickInterval,
    tickLabelInterval,
    tickPlacement,
    tickLabelPlacement,
    tickLabelMinGap,
    sx,
    offset: offset2,
    height: axisHeight
  } = defaultizedProps;
  const theme = useTheme4();
  const isRtl = useRtl();
  const classes = useUtilityClasses2(defaultizedProps);
  const drawingArea = useDrawingArea();
  const {
    left: left3,
    top: top3,
    width: width2,
    height: height2
  } = drawingArea;
  const {
    instance
  } = useChartContext();
  const isHydrated = useIsHydrated();
  const tickSize = disableTicks ? 4 : tickSizeProp;
  const positionSign = position3 === "bottom" ? 1 : -1;
  const Line = (slots == null ? void 0 : slots.axisLine) ?? "line";
  const Tick = (slots == null ? void 0 : slots.axisTick) ?? "line";
  const TickLabel = (slots == null ? void 0 : slots.axisTickLabel) ?? ChartsText;
  const Label = (slots == null ? void 0 : slots.axisLabel) ?? ChartsText;
  const defaultTextAnchor = getDefaultTextAnchor((position3 === "bottom" ? 0 : 180) - ((tickLabelStyle == null ? void 0 : tickLabelStyle.angle) ?? 0));
  const defaultDominantBaseline = getDefaultBaseline((position3 === "bottom" ? 0 : 180) - ((tickLabelStyle == null ? void 0 : tickLabelStyle.angle) ?? 0));
  const axisTickLabelProps = useSlotProps_default({
    elementType: TickLabel,
    externalSlotProps: slotProps == null ? void 0 : slotProps.axisTickLabel,
    additionalProps: {
      style: _extends({}, theme.typography.caption, {
        fontSize: 12,
        lineHeight: 1.25,
        textAnchor: isRtl ? invertTextAnchor(defaultTextAnchor) : defaultTextAnchor,
        dominantBaseline: defaultDominantBaseline
      }, tickLabelStyle)
    },
    className: classes.tickLabel,
    ownerState: {}
  });
  const xTicks = useTicks({
    scale: xScale,
    tickNumber,
    valueFormatter,
    tickInterval,
    tickPlacement,
    tickLabelPlacement
  });
  const visibleLabels = getVisibleLabels(xTicks, {
    tickLabelStyle: axisTickLabelProps.style,
    tickLabelInterval,
    tickLabelMinGap,
    reverse: reverse2,
    isMounted,
    isPointInside: (x3) => instance.isPointInside({
      x: x3,
      y: -1
    }, {
      direction: "x"
    })
  });
  const axisLabelProps = useSlotProps_default({
    elementType: Label,
    externalSlotProps: slotProps == null ? void 0 : slotProps.axisLabel,
    additionalProps: {
      style: _extends({}, theme.typography.body1, {
        lineHeight: 1,
        fontSize: 14,
        textAnchor: "middle",
        dominantBaseline: position3 === "bottom" ? "text-after-edge" : "text-before-edge"
      }, labelStyle)
    },
    ownerState: {}
  });
  const domain = xScale.domain();
  const ordinalAxis = isBandScale(xScale);
  if (ordinalAxis && domain.length === 0 || !ordinalAxis && domain.some(isInfinity) || position3 === "none") {
    return null;
  }
  const labelHeight = label ? getStringSize(label, axisLabelProps.style).height : 0;
  const labelRefPoint = {
    x: left3 + width2 / 2,
    y: positionSign * axisHeight
  };
  const tickLabelsMaxHeight = Math.max(0, axisHeight - (label ? labelHeight + AXIS_LABEL_TICK_LABEL_GAP : 0) - tickSize - TICK_LABEL_GAP);
  const tickLabels = isHydrated ? shortenLabels(visibleLabels, drawingArea, tickLabelsMaxHeight, isRtl, axisTickLabelProps.style) : new Map(Array.from(visibleLabels).map((item) => [item, item.formattedValue]));
  return (0, import_jsx_runtime23.jsxs)(XAxisRoot, {
    transform: `translate(0, ${position3 === "bottom" ? top3 + height2 + offset2 : top3 - offset2})`,
    className: classes.root,
    sx,
    children: [!disableLine && (0, import_jsx_runtime23.jsx)(Line, _extends({
      x1: left3,
      x2: left3 + width2,
      className: classes.line
    }, slotProps == null ? void 0 : slotProps.axisLine)), xTicks.map((item, index2) => {
      const {
        offset: tickOffset,
        labelOffset
      } = item;
      const xTickLabel = labelOffset ?? 0;
      const yTickLabel = positionSign * (tickSize + TICK_LABEL_GAP);
      const showTick = instance.isPointInside({
        x: tickOffset,
        y: -1
      }, {
        direction: "x"
      });
      const tickLabel = tickLabels.get(item);
      const showTickLabel = visibleLabels.has(item);
      return (0, import_jsx_runtime23.jsxs)("g", {
        transform: `translate(${tickOffset}, 0)`,
        className: classes.tickContainer,
        children: [!disableTicks && showTick && (0, import_jsx_runtime23.jsx)(Tick, _extends({
          y2: positionSign * tickSize,
          className: classes.tick
        }, slotProps == null ? void 0 : slotProps.axisTick)), tickLabel !== void 0 && showTickLabel && (0, import_jsx_runtime23.jsx)(TickLabel, _extends({
          x: xTickLabel,
          y: yTickLabel
        }, axisTickLabelProps, {
          text: tickLabel
        }))]
      }, index2);
    }), label && (0, import_jsx_runtime23.jsx)("g", {
      className: classes.label,
      children: (0, import_jsx_runtime23.jsx)(Label, _extends({}, labelRefPoint, axisLabelProps, {
        text: label
      }))
    })]
  });
}
true ? ChartsXAxis.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  axis: import_prop_types23.default.oneOf(["x"]),
  /**
   * The id of the axis to render.
   * If undefined, it will be the first defined axis.
   */
  axisId: import_prop_types23.default.oneOfType([import_prop_types23.default.number, import_prop_types23.default.string]),
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types23.default.object,
  /**
   * If true, the axis line is disabled.
   * @default false
   */
  disableLine: import_prop_types23.default.bool,
  /**
   * If true, the ticks are disabled.
   * @default false
   */
  disableTicks: import_prop_types23.default.bool,
  /**
   * The fill color of the axis text.
   * @default 'currentColor'
   */
  fill: import_prop_types23.default.string,
  /**
   * The label of the axis.
   */
  label: import_prop_types23.default.string,
  /**
   * The style applied to the axis label.
   */
  labelStyle: import_prop_types23.default.object,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types23.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types23.default.object,
  /**
   * The stroke color of the axis line.
   * @default 'currentColor'
   */
  stroke: import_prop_types23.default.string,
  sx: import_prop_types23.default.oneOfType([import_prop_types23.default.arrayOf(import_prop_types23.default.oneOfType([import_prop_types23.default.func, import_prop_types23.default.object, import_prop_types23.default.bool])), import_prop_types23.default.func, import_prop_types23.default.object]),
  /**
   * Defines which ticks are displayed.
   * Its value can be:
   * - 'auto' In such case the ticks are computed based on axis scale and other parameters.
   * - a filtering function of the form `(value, index) => boolean` which is available only if the axis has "point" scale.
   * - an array containing the values where ticks should be displayed.
   * @see See {@link https://mui.com/x/react-charts/axis/#fixed-tick-positions}
   * @default 'auto'
   */
  tickInterval: import_prop_types23.default.oneOfType([import_prop_types23.default.oneOf(["auto"]), import_prop_types23.default.array, import_prop_types23.default.func]),
  /**
   * Defines which ticks get its label displayed. Its value can be:
   * - 'auto' In such case, labels are displayed if they do not overlap with the previous one.
   * - a filtering function of the form (value, index) => boolean. Warning: the index is tick index, not data ones.
   * @default 'auto'
   */
  tickLabelInterval: import_prop_types23.default.oneOfType([import_prop_types23.default.oneOf(["auto"]), import_prop_types23.default.func]),
  /**
   * The minimum gap in pixels between two tick labels.
   * If two tick labels are closer than this minimum gap, one of them will be hidden.
   * @default 4
   */
  tickLabelMinGap: import_prop_types23.default.number,
  /**
   * The placement of ticks label. Can be the middle of the band, or the tick position.
   * Only used if scale is 'band'.
   * @default 'middle'
   */
  tickLabelPlacement: import_prop_types23.default.oneOf(["middle", "tick"]),
  /**
   * The style applied to ticks text.
   */
  tickLabelStyle: import_prop_types23.default.object,
  /**
   * Maximal step between two ticks.
   * When using time data, the value is assumed to be in ms.
   * Not supported by categorical axis (band, points).
   */
  tickMaxStep: import_prop_types23.default.number,
  /**
   * Minimal step between two ticks.
   * When using time data, the value is assumed to be in ms.
   * Not supported by categorical axis (band, points).
   */
  tickMinStep: import_prop_types23.default.number,
  /**
   * The number of ticks. This number is not guaranteed.
   * Not supported by categorical axis (band, points).
   */
  tickNumber: import_prop_types23.default.number,
  /**
   * The placement of ticks in regard to the band interval.
   * Only used if scale is 'band'.
   * @default 'extremities'
   */
  tickPlacement: import_prop_types23.default.oneOf(["end", "extremities", "middle", "start"]),
  /**
   * The size of the ticks.
   * @default 6
   */
  tickSize: import_prop_types23.default.number
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsYAxis/ChartsYAxis.js
var React53 = __toESM(require_react(), 1);
var import_prop_types24 = __toESM(require_prop_types(), 1);
var import_jsx_runtime24 = __toESM(require_jsx_runtime(), 1);
var _excluded5 = ["scale", "tickNumber"];
var useUtilityClasses3 = (ownerState) => {
  const {
    classes,
    position: position3
  } = ownerState;
  const slots = {
    root: ["root", "directionY", position3],
    line: ["line"],
    tickContainer: ["tickContainer"],
    tick: ["tick"],
    tickLabel: ["tickLabel"],
    label: ["label"]
  };
  return composeClasses(slots, getAxisUtilityClass, classes);
};
var TICK_LABEL_GAP2 = 2;
var AXIS_LABEL_TICK_LABEL_GAP2 = 2;
function shortenLabels2(visibleLabels, drawingArea, maxWidth2, isRtl, tickLabelStyle) {
  const shortenedLabels = /* @__PURE__ */ new Map();
  const angle = clampAngle((tickLabelStyle == null ? void 0 : tickLabelStyle.angle) ?? 0);
  let topBoundFactor = 1;
  let bottomBoundFactor = 1;
  if ((tickLabelStyle == null ? void 0 : tickLabelStyle.textAnchor) === "start") {
    topBoundFactor = Infinity;
    bottomBoundFactor = 1;
  } else if ((tickLabelStyle == null ? void 0 : tickLabelStyle.textAnchor) === "end") {
    topBoundFactor = 1;
    bottomBoundFactor = Infinity;
  } else {
    topBoundFactor = 2;
    bottomBoundFactor = 2;
  }
  if (angle > 180) {
    [topBoundFactor, bottomBoundFactor] = [bottomBoundFactor, topBoundFactor];
  }
  if (isRtl) {
    [topBoundFactor, bottomBoundFactor] = [bottomBoundFactor, topBoundFactor];
  }
  for (const item of visibleLabels) {
    if (item.formattedValue) {
      const height2 = Math.min((item.offset + item.labelOffset) * topBoundFactor, (drawingArea.top + drawingArea.height + drawingArea.bottom - item.offset - item.labelOffset) * bottomBoundFactor);
      const doesTextFit = (text) => doesTextFitInRect(text, {
        width: maxWidth2,
        height: height2,
        angle,
        measureText: (string) => getStringSize(string, tickLabelStyle)
      });
      shortenedLabels.set(item, ellipsize(item.formattedValue.toString(), doesTextFit));
    }
  }
  return shortenedLabels;
}
var YAxisRoot = styled_default2(AxisRoot, {
  name: "MuiChartsYAxis",
  slot: "Root"
})({});
var defaultProps2 = {
  disableLine: false,
  disableTicks: false,
  tickSize: 6
};
function ChartsYAxis(inProps) {
  const {
    yAxisIds,
    yAxis
  } = useYAxes();
  const _yAxis = yAxis[inProps.axisId ?? yAxisIds[0]], {
    scale: yScale,
    tickNumber
  } = _yAxis, settings = _objectWithoutPropertiesLoose(_yAxis, _excluded5);
  const themedProps = useThemeProps2({
    props: _extends({}, settings, inProps),
    name: "MuiChartsYAxis"
  });
  const defaultizedProps = _extends({}, defaultProps2, themedProps);
  const {
    position: position3,
    disableLine,
    disableTicks,
    label,
    labelStyle,
    tickLabelStyle,
    tickSize: tickSizeProp,
    valueFormatter,
    slots,
    slotProps,
    tickPlacement,
    tickLabelPlacement,
    tickInterval,
    tickLabelInterval,
    sx,
    offset: offset2,
    width: axisWidth
  } = defaultizedProps;
  const theme = useTheme4();
  const isRtl = useRtl();
  const isHydrated = useIsHydrated();
  const classes = useUtilityClasses3(defaultizedProps);
  const {
    instance
  } = useChartContext();
  const drawingArea = useDrawingArea();
  const {
    left: left3,
    top: top3,
    width: width2,
    height: height2
  } = drawingArea;
  const tickSize = disableTicks ? 4 : tickSizeProp;
  const yTicks = useTicks({
    scale: yScale,
    tickNumber,
    valueFormatter,
    tickPlacement,
    tickLabelPlacement,
    tickInterval
  });
  const positionSign = position3 === "right" ? 1 : -1;
  const tickFontSize = typeof (tickLabelStyle == null ? void 0 : tickLabelStyle.fontSize) === "number" ? tickLabelStyle.fontSize : 12;
  const Line = (slots == null ? void 0 : slots.axisLine) ?? "line";
  const Tick = (slots == null ? void 0 : slots.axisTick) ?? "line";
  const TickLabel = (slots == null ? void 0 : slots.axisTickLabel) ?? ChartsText;
  const Label = (slots == null ? void 0 : slots.axisLabel) ?? ChartsText;
  const defaultTextAnchor = getDefaultTextAnchor((position3 === "right" ? -90 : 90) - ((tickLabelStyle == null ? void 0 : tickLabelStyle.angle) ?? 0));
  const defaultDominantBaseline = getDefaultBaseline((position3 === "right" ? -90 : 90) - ((tickLabelStyle == null ? void 0 : tickLabelStyle.angle) ?? 0));
  const axisTickLabelProps = useSlotProps_default({
    elementType: TickLabel,
    externalSlotProps: slotProps == null ? void 0 : slotProps.axisTickLabel,
    additionalProps: {
      style: _extends({}, theme.typography.caption, {
        fontSize: tickFontSize,
        textAnchor: isRtl ? invertTextAnchor(defaultTextAnchor) : defaultTextAnchor,
        dominantBaseline: defaultDominantBaseline
      }, tickLabelStyle)
    },
    className: classes.tickLabel,
    ownerState: {}
  });
  const axisLabelProps = useSlotProps_default({
    elementType: Label,
    externalSlotProps: slotProps == null ? void 0 : slotProps.axisLabel,
    additionalProps: {
      style: _extends({}, theme.typography.body1, {
        lineHeight: 1,
        fontSize: 14,
        angle: positionSign * 90,
        textAnchor: "middle",
        dominantBaseline: "text-before-edge"
      }, labelStyle)
    },
    ownerState: {}
  });
  const lineSlotProps = useSlotProps_default({
    elementType: Line,
    externalSlotProps: slotProps == null ? void 0 : slotProps.axisLine,
    additionalProps: {
      strokeLinecap: "square"
    },
    ownerState: {}
  });
  const domain = yScale.domain();
  const ordinalAxis = isBandScale(yScale);
  if (ordinalAxis && domain.length === 0 || !ordinalAxis && domain.some(isInfinity) || position3 === "none") {
    return null;
  }
  const labelRefPoint = {
    x: positionSign * axisWidth,
    y: top3 + height2 / 2
  };
  const tickLabelsMaxWidth = Math.max(0, axisWidth - (label ? getStringSize(label, axisLabelProps.style).height + AXIS_LABEL_TICK_LABEL_GAP2 : 0) - tickSize - TICK_LABEL_GAP2);
  const tickLabels = isHydrated ? shortenLabels2(yTicks, drawingArea, tickLabelsMaxWidth, isRtl, axisTickLabelProps.style) : new Map(Array.from(yTicks).map((item) => [item, item.formattedValue]));
  return (0, import_jsx_runtime24.jsxs)(YAxisRoot, {
    transform: `translate(${position3 === "right" ? left3 + width2 + offset2 : left3 - offset2}, 0)`,
    className: classes.root,
    sx,
    children: [!disableLine && (0, import_jsx_runtime24.jsx)(Line, _extends({
      y1: top3,
      y2: top3 + height2,
      className: classes.line
    }, lineSlotProps)), yTicks.map((item, index2) => {
      const {
        offset: tickOffset,
        labelOffset,
        value
      } = item;
      const xTickLabel = positionSign * (tickSize + TICK_LABEL_GAP2);
      const yTickLabel = labelOffset;
      const skipLabel = typeof tickLabelInterval === "function" && !(tickLabelInterval == null ? void 0 : tickLabelInterval(value, index2));
      const showLabel = instance.isPointInside({
        x: -1,
        y: tickOffset
      }, {
        direction: "y"
      });
      const tickLabel = tickLabels.get(item);
      if (!showLabel) {
        return null;
      }
      return (0, import_jsx_runtime24.jsxs)("g", {
        transform: `translate(0, ${tickOffset})`,
        className: classes.tickContainer,
        children: [!disableTicks && (0, import_jsx_runtime24.jsx)(Tick, _extends({
          x2: positionSign * tickSize,
          className: classes.tick
        }, slotProps == null ? void 0 : slotProps.axisTick)), tickLabel !== void 0 && !skipLabel && (0, import_jsx_runtime24.jsx)(TickLabel, _extends({
          x: xTickLabel,
          y: yTickLabel,
          text: tickLabel
        }, axisTickLabelProps))]
      }, index2);
    }), label && isHydrated && (0, import_jsx_runtime24.jsx)("g", {
      className: classes.label,
      children: (0, import_jsx_runtime24.jsx)(Label, _extends({}, labelRefPoint, axisLabelProps, {
        text: label
      }))
    })]
  });
}
true ? ChartsYAxis.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  axis: import_prop_types24.default.oneOf(["y"]),
  /**
   * The id of the axis to render.
   * If undefined, it will be the first defined axis.
   */
  axisId: import_prop_types24.default.oneOfType([import_prop_types24.default.number, import_prop_types24.default.string]),
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types24.default.object,
  /**
   * If true, the axis line is disabled.
   * @default false
   */
  disableLine: import_prop_types24.default.bool,
  /**
   * If true, the ticks are disabled.
   * @default false
   */
  disableTicks: import_prop_types24.default.bool,
  /**
   * The fill color of the axis text.
   * @default 'currentColor'
   */
  fill: import_prop_types24.default.string,
  /**
   * The label of the axis.
   */
  label: import_prop_types24.default.string,
  /**
   * The style applied to the axis label.
   */
  labelStyle: import_prop_types24.default.object,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types24.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types24.default.object,
  /**
   * The stroke color of the axis line.
   * @default 'currentColor'
   */
  stroke: import_prop_types24.default.string,
  sx: import_prop_types24.default.oneOfType([import_prop_types24.default.arrayOf(import_prop_types24.default.oneOfType([import_prop_types24.default.func, import_prop_types24.default.object, import_prop_types24.default.bool])), import_prop_types24.default.func, import_prop_types24.default.object]),
  /**
   * Defines which ticks are displayed.
   * Its value can be:
   * - 'auto' In such case the ticks are computed based on axis scale and other parameters.
   * - a filtering function of the form `(value, index) => boolean` which is available only if the axis has "point" scale.
   * - an array containing the values where ticks should be displayed.
   * @see See {@link https://mui.com/x/react-charts/axis/#fixed-tick-positions}
   * @default 'auto'
   */
  tickInterval: import_prop_types24.default.oneOfType([import_prop_types24.default.oneOf(["auto"]), import_prop_types24.default.array, import_prop_types24.default.func]),
  /**
   * Defines which ticks get its label displayed. Its value can be:
   * - 'auto' In such case, labels are displayed if they do not overlap with the previous one.
   * - a filtering function of the form (value, index) => boolean. Warning: the index is tick index, not data ones.
   * @default 'auto'
   */
  tickLabelInterval: import_prop_types24.default.oneOfType([import_prop_types24.default.oneOf(["auto"]), import_prop_types24.default.func]),
  /**
   * The placement of ticks label. Can be the middle of the band, or the tick position.
   * Only used if scale is 'band'.
   * @default 'middle'
   */
  tickLabelPlacement: import_prop_types24.default.oneOf(["middle", "tick"]),
  /**
   * The style applied to ticks text.
   */
  tickLabelStyle: import_prop_types24.default.object,
  /**
   * Maximal step between two ticks.
   * When using time data, the value is assumed to be in ms.
   * Not supported by categorical axis (band, points).
   */
  tickMaxStep: import_prop_types24.default.number,
  /**
   * Minimal step between two ticks.
   * When using time data, the value is assumed to be in ms.
   * Not supported by categorical axis (band, points).
   */
  tickMinStep: import_prop_types24.default.number,
  /**
   * The number of ticks. This number is not guaranteed.
   * Not supported by categorical axis (band, points).
   */
  tickNumber: import_prop_types24.default.number,
  /**
   * The placement of ticks in regard to the band interval.
   * Only used if scale is 'band'.
   * @default 'extremities'
   */
  tickPlacement: import_prop_types24.default.oneOf(["end", "extremities", "middle", "start"]),
  /**
   * The size of the ticks.
   * @default 6
   */
  tickSize: import_prop_types24.default.number
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsAxis/ChartsAxis.js
var import_jsx_runtime25 = __toESM(require_jsx_runtime(), 1);
function ChartsAxis(props) {
  const {
    slots,
    slotProps
  } = props;
  const {
    xAxisIds,
    xAxis
  } = useXAxes();
  const {
    yAxisIds,
    yAxis
  } = useYAxes();
  return (0, import_jsx_runtime25.jsxs)(React54.Fragment, {
    children: [xAxisIds.map((axisId) => {
      if (!xAxis[axisId].position || xAxis[axisId].position === "none") {
        return null;
      }
      return (0, import_jsx_runtime25.jsx)(ChartsXAxis, {
        slots,
        slotProps,
        axisId
      }, axisId);
    }), yAxisIds.map((axisId) => {
      if (!yAxis[axisId].position || yAxis[axisId].position === "none") {
        return null;
      }
      return (0, import_jsx_runtime25.jsx)(ChartsYAxis, {
        slots,
        slotProps,
        axisId
      }, axisId);
    })]
  });
}
true ? ChartsAxis.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types25.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types25.default.object
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsGrid/ChartsGrid.js
var React57 = __toESM(require_react(), 1);
var import_prop_types26 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/ChartsGrid/chartsGridClasses.js
function getChartsGridUtilityClass(slot) {
  return generateUtilityClass("MuiChartsGrid", slot);
}
var chartsGridClasses = generateUtilityClasses("MuiChartsGrid", ["root", "line", "horizontalLine", "verticalLine"]);

// node_modules/@mui/x-charts/esm/ChartsGrid/styledComponents.js
var GridRoot = styled_default2("g", {
  name: "MuiChartsGrid",
  slot: "Root",
  overridesResolver: (props, styles) => [{
    [`&.${chartsGridClasses.verticalLine}`]: styles.verticalLine
  }, {
    [`&.${chartsGridClasses.horizontalLine}`]: styles.horizontalLine
  }, styles.root]
})({});
var GridLine = styled_default2("line", {
  name: "MuiChartsGrid",
  slot: "Line"
})(({
  theme
}) => ({
  stroke: (theme.vars || theme).palette.divider,
  shapeRendering: "crispEdges",
  strokeWidth: 1
}));

// node_modules/@mui/x-charts/esm/ChartsGrid/ChartsVerticalGrid.js
var React55 = __toESM(require_react(), 1);
var import_jsx_runtime26 = __toESM(require_jsx_runtime(), 1);
function ChartsGridVertical(props) {
  const {
    axis,
    start: start2,
    end: end2,
    classes
  } = props;
  const {
    scale: scale2,
    tickNumber,
    tickInterval
  } = axis;
  const xTicks = useTicks({
    scale: scale2,
    tickNumber,
    tickInterval
  });
  return (0, import_jsx_runtime26.jsx)(React55.Fragment, {
    children: xTicks.map(({
      value,
      offset: offset2
    }) => {
      var _a;
      return (0, import_jsx_runtime26.jsx)(GridLine, {
        y1: start2,
        y2: end2,
        x1: offset2,
        x2: offset2,
        className: classes.verticalLine
      }, `vertical-${((_a = value.getTime) == null ? void 0 : _a.call(value)) ?? value}`);
    })
  });
}

// node_modules/@mui/x-charts/esm/ChartsGrid/ChartsHorizontalGrid.js
var React56 = __toESM(require_react(), 1);
var import_jsx_runtime27 = __toESM(require_jsx_runtime(), 1);
function ChartsGridHorizontal(props) {
  const {
    axis,
    start: start2,
    end: end2,
    classes
  } = props;
  const {
    scale: scale2,
    tickNumber,
    tickInterval
  } = axis;
  const yTicks = useTicks({
    scale: scale2,
    tickNumber,
    tickInterval
  });
  return (0, import_jsx_runtime27.jsx)(React56.Fragment, {
    children: yTicks.map(({
      value,
      offset: offset2
    }) => {
      var _a;
      return (0, import_jsx_runtime27.jsx)(GridLine, {
        y1: offset2,
        y2: offset2,
        x1: start2,
        x2: end2,
        className: classes.horizontalLine
      }, `horizontal-${((_a = value.getTime) == null ? void 0 : _a.call(value)) ?? value}`);
    })
  });
}

// node_modules/@mui/x-charts/esm/ChartsGrid/ChartsGrid.js
var import_jsx_runtime28 = __toESM(require_jsx_runtime(), 1);
var _excluded6 = ["vertical", "horizontal"];
var useUtilityClasses4 = ({
  classes
}) => {
  const slots = {
    root: ["root"],
    verticalLine: ["line", "verticalLine"],
    horizontalLine: ["line", "horizontalLine"]
  };
  return composeClasses(slots, getChartsGridUtilityClass, classes);
};
function ChartsGrid(inProps) {
  const props = useThemeProps2({
    props: inProps,
    name: "MuiChartsGrid"
  });
  const drawingArea = useDrawingArea();
  const {
    vertical,
    horizontal
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded6);
  const {
    xAxis,
    xAxisIds
  } = useXAxes();
  const {
    yAxis,
    yAxisIds
  } = useYAxes();
  const classes = useUtilityClasses4(props);
  const horizontalAxis = yAxis[yAxisIds[0]];
  const verticalAxis = xAxis[xAxisIds[0]];
  return (0, import_jsx_runtime28.jsxs)(GridRoot, _extends({}, other, {
    className: classes.root,
    children: [vertical && (0, import_jsx_runtime28.jsx)(ChartsGridVertical, {
      axis: verticalAxis,
      start: drawingArea.top,
      end: drawingArea.height + drawingArea.top,
      classes
    }), horizontal && (0, import_jsx_runtime28.jsx)(ChartsGridHorizontal, {
      axis: horizontalAxis,
      start: drawingArea.left,
      end: drawingArea.width + drawingArea.left,
      classes
    })]
  }));
}
true ? ChartsGrid.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types26.default.object,
  /**
   * Displays horizontal grid.
   */
  horizontal: import_prop_types26.default.bool,
  /**
   * Displays vertical grid.
   */
  vertical: import_prop_types26.default.bool
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsTooltip/ChartsTooltip.js
var React75 = __toESM(require_react(), 1);
var import_prop_types39 = __toESM(require_prop_types(), 1);

// node_modules/@mui/utils/esm/HTMLElementType/HTMLElementType.js
function HTMLElementType(props, propName, componentName, location, propFullName) {
  if (false) {
    return null;
  }
  const propValue = props[propName];
  const safePropName = propFullName || propName;
  if (propValue == null) {
    return null;
  }
  if (propValue && propValue.nodeType !== 1) {
    return new Error(`Invalid ${location} \`${safePropName}\` supplied to \`${componentName}\`. Expected an HTMLElement.`);
  }
  return null;
}

// node_modules/@mui/x-charts/esm/ChartsTooltip/ChartsItemTooltipContent.js
var React64 = __toESM(require_react(), 1);
var import_prop_types31 = __toESM(require_prop_types(), 1);

// node_modules/@mui/material/esm/Typography/Typography.js
var React61 = __toESM(require_react(), 1);
var import_prop_types29 = __toESM(require_prop_types(), 1);

// node_modules/@mui/material/esm/zero-styled/index.js
var React59 = __toESM(require_react(), 1);

// node_modules/@mui/material/esm/GlobalStyles/GlobalStyles.js
var React58 = __toESM(require_react(), 1);
var import_prop_types27 = __toESM(require_prop_types(), 1);
var import_jsx_runtime29 = __toESM(require_jsx_runtime(), 1);
function GlobalStyles3(props) {
  return (0, import_jsx_runtime29.jsx)(GlobalStyles_default2, {
    ...props,
    defaultTheme: defaultTheme_default,
    themeId: identifier_default
  });
}
true ? GlobalStyles3.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * The styles you want to apply globally.
   */
  styles: import_prop_types27.default.oneOfType([import_prop_types27.default.array, import_prop_types27.default.func, import_prop_types27.default.number, import_prop_types27.default.object, import_prop_types27.default.string, import_prop_types27.default.bool])
} : void 0;

// node_modules/@mui/material/esm/zero-styled/index.js
var import_jsx_runtime30 = __toESM(require_jsx_runtime(), 1);
function internal_createExtendSxProp() {
  return extendSxProp;
}

// node_modules/@mui/material/esm/utils/memoTheme.js
var memoTheme = unstable_memoTheme;
var memoTheme_default = memoTheme;

// node_modules/@mui/material/esm/DefaultPropsProvider/DefaultPropsProvider.js
var React60 = __toESM(require_react(), 1);
var import_prop_types28 = __toESM(require_prop_types(), 1);
var import_jsx_runtime31 = __toESM(require_jsx_runtime(), 1);
function DefaultPropsProvider2(props) {
  return (0, import_jsx_runtime31.jsx)(DefaultPropsProvider_default, {
    ...props
  });
}
true ? DefaultPropsProvider2.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //  To update them, edit the TypeScript types and run `pnpm proptypes`. 
  // 
  /**
   * @ignore
   */
  children: import_prop_types28.default.node,
  /**
   * @ignore
   */
  value: import_prop_types28.default.object.isRequired
} : void 0;
function useDefaultProps2(params) {
  return useDefaultProps(params);
}

// node_modules/@mui/material/esm/utils/capitalize.js
var capitalize_default = capitalize;

// node_modules/@mui/material/esm/utils/createSimplePaletteValueFilter.js
function hasCorrectMainProperty(obj) {
  return typeof obj.main === "string";
}
function checkSimplePaletteColorValues(obj, additionalPropertiesToCheck = []) {
  if (!hasCorrectMainProperty(obj)) {
    return false;
  }
  for (const value of additionalPropertiesToCheck) {
    if (!obj.hasOwnProperty(value) || typeof obj[value] !== "string") {
      return false;
    }
  }
  return true;
}
function createSimplePaletteValueFilter(additionalPropertiesToCheck = []) {
  return ([, value]) => value && checkSimplePaletteColorValues(value, additionalPropertiesToCheck);
}

// node_modules/@mui/material/esm/Typography/typographyClasses.js
function getTypographyUtilityClass(slot) {
  return generateUtilityClass("MuiTypography", slot);
}
var typographyClasses = generateUtilityClasses("MuiTypography", ["root", "h1", "h2", "h3", "h4", "h5", "h6", "subtitle1", "subtitle2", "body1", "body2", "inherit", "button", "caption", "overline", "alignLeft", "alignRight", "alignCenter", "alignJustify", "noWrap", "gutterBottom", "paragraph"]);

// node_modules/@mui/material/esm/Typography/Typography.js
var import_jsx_runtime32 = __toESM(require_jsx_runtime(), 1);
var v6Colors = {
  primary: true,
  secondary: true,
  error: true,
  info: true,
  success: true,
  warning: true,
  textPrimary: true,
  textSecondary: true,
  textDisabled: true
};
var extendSxProp2 = internal_createExtendSxProp();
var useUtilityClasses5 = (ownerState) => {
  const {
    align,
    gutterBottom,
    noWrap,
    paragraph,
    variant,
    classes
  } = ownerState;
  const slots = {
    root: ["root", variant, ownerState.align !== "inherit" && `align${capitalize_default(align)}`, gutterBottom && "gutterBottom", noWrap && "noWrap", paragraph && "paragraph"]
  };
  return composeClasses(slots, getTypographyUtilityClass, classes);
};
var TypographyRoot = styled_default2("span", {
  name: "MuiTypography",
  slot: "Root",
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [styles.root, ownerState.variant && styles[ownerState.variant], ownerState.align !== "inherit" && styles[`align${capitalize_default(ownerState.align)}`], ownerState.noWrap && styles.noWrap, ownerState.gutterBottom && styles.gutterBottom, ownerState.paragraph && styles.paragraph];
  }
})(memoTheme_default(({
  theme
}) => {
  var _a;
  return {
    margin: 0,
    variants: [{
      props: {
        variant: "inherit"
      },
      style: {
        // Some elements, like <button> on Chrome have default font that doesn't inherit, reset this.
        font: "inherit",
        lineHeight: "inherit",
        letterSpacing: "inherit"
      }
    }, ...Object.entries(theme.typography).filter(([variant, value]) => variant !== "inherit" && value && typeof value === "object").map(([variant, value]) => ({
      props: {
        variant
      },
      style: value
    })), ...Object.entries(theme.palette).filter(createSimplePaletteValueFilter()).map(([color3]) => ({
      props: {
        color: color3
      },
      style: {
        color: (theme.vars || theme).palette[color3].main
      }
    })), ...Object.entries(((_a = theme.palette) == null ? void 0 : _a.text) || {}).filter(([, value]) => typeof value === "string").map(([color3]) => ({
      props: {
        color: `text${capitalize_default(color3)}`
      },
      style: {
        color: (theme.vars || theme).palette.text[color3]
      }
    })), {
      props: ({
        ownerState
      }) => ownerState.align !== "inherit",
      style: {
        textAlign: "var(--Typography-textAlign)"
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.noWrap,
      style: {
        overflow: "hidden",
        textOverflow: "ellipsis",
        whiteSpace: "nowrap"
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.gutterBottom,
      style: {
        marginBottom: "0.35em"
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.paragraph,
      style: {
        marginBottom: 16
      }
    }]
  };
}));
var defaultVariantMapping = {
  h1: "h1",
  h2: "h2",
  h3: "h3",
  h4: "h4",
  h5: "h5",
  h6: "h6",
  subtitle1: "h6",
  subtitle2: "h6",
  body1: "p",
  body2: "p",
  inherit: "p"
};
var Typography = React61.forwardRef(function Typography2(inProps, ref) {
  const {
    color: color3,
    ...themeProps
  } = useDefaultProps2({
    props: inProps,
    name: "MuiTypography"
  });
  const isSxColor = !v6Colors[color3];
  const props = extendSxProp2({
    ...themeProps,
    ...isSxColor && {
      color: color3
    }
  });
  const {
    align = "inherit",
    className,
    component,
    gutterBottom = false,
    noWrap = false,
    paragraph = false,
    variant = "body1",
    variantMapping = defaultVariantMapping,
    ...other
  } = props;
  const ownerState = {
    ...props,
    align,
    color: color3,
    className,
    component,
    gutterBottom,
    noWrap,
    paragraph,
    variant,
    variantMapping
  };
  const Component = component || (paragraph ? "p" : variantMapping[variant] || defaultVariantMapping[variant]) || "span";
  const classes = useUtilityClasses5(ownerState);
  return (0, import_jsx_runtime32.jsx)(TypographyRoot, {
    as: Component,
    ref,
    className: clsx_default(classes.root, className),
    ...other,
    ownerState,
    style: {
      ...align !== "inherit" && {
        "--Typography-textAlign": align
      },
      ...other.style
    }
  });
});
true ? Typography.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * Set the text-align on the component.
   * @default 'inherit'
   */
  align: import_prop_types29.default.oneOf(["center", "inherit", "justify", "left", "right"]),
  /**
   * The content of the component.
   */
  children: import_prop_types29.default.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types29.default.object,
  /**
   * @ignore
   */
  className: import_prop_types29.default.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).
   */
  color: import_prop_types29.default.oneOfType([import_prop_types29.default.oneOf(["primary", "secondary", "success", "error", "info", "warning", "textPrimary", "textSecondary", "textDisabled"]), import_prop_types29.default.string]),
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: import_prop_types29.default.elementType,
  /**
   * If `true`, the text will have a bottom margin.
   * @default false
   */
  gutterBottom: import_prop_types29.default.bool,
  /**
   * If `true`, the text will not wrap, but instead will truncate with a text overflow ellipsis.
   *
   * Note that text overflow can only happen with block or inline-block level elements
   * (the element needs to have a width in order to overflow).
   * @default false
   */
  noWrap: import_prop_types29.default.bool,
  /**
   * If `true`, the element will be a paragraph element.
   * @default false
   * @deprecated Use the `component` prop instead. This prop will be removed in a future major release. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
   */
  paragraph: import_prop_types29.default.bool,
  /**
   * @ignore
   */
  style: import_prop_types29.default.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types29.default.oneOfType([import_prop_types29.default.arrayOf(import_prop_types29.default.oneOfType([import_prop_types29.default.func, import_prop_types29.default.object, import_prop_types29.default.bool])), import_prop_types29.default.func, import_prop_types29.default.object]),
  /**
   * Applies the theme typography styles.
   * @default 'body1'
   */
  variant: import_prop_types29.default.oneOfType([import_prop_types29.default.oneOf(["body1", "body2", "button", "caption", "h1", "h2", "h3", "h4", "h5", "h6", "inherit", "overline", "subtitle1", "subtitle2"]), import_prop_types29.default.string]),
  /**
   * The component maps the variant prop to a range of different HTML element types.
   * For instance, subtitle1 to `<h6>`.
   * If you wish to change that mapping, you can provide your own.
   * Alternatively, you can use the `component` prop.
   * @default {
   *   h1: 'h1',
   *   h2: 'h2',
   *   h3: 'h3',
   *   h4: 'h4',
   *   h5: 'h5',
   *   h6: 'h6',
   *   subtitle1: 'h6',
   *   subtitle2: 'h6',
   *   body1: 'p',
   *   body2: 'p',
   *   inherit: 'p',
   * }
   */
  variantMapping: import_prop_types29.default.object
} : void 0;
var Typography_default = Typography;

// node_modules/@mui/x-charts/esm/ChartsTooltip/chartsTooltipClasses.js
function getChartsTooltipUtilityClass(slot) {
  return generateUtilityClass("MuiChartsTooltip", slot);
}
var chartsTooltipClasses = generateUtilityClasses("MuiChartsTooltip", ["root", "paper", "table", "row", "cell", "mark", "markContainer", "labelCell", "valueCell", "axisValueCell"]);
var useUtilityClasses6 = (classes) => {
  const slots = {
    root: ["root"],
    paper: ["paper"],
    table: ["table"],
    row: ["row"],
    cell: ["cell"],
    mark: ["mark"],
    markContainer: ["markContainer"],
    labelCell: ["labelCell"],
    valueCell: ["valueCell"],
    axisValueCell: ["axisValueCell"]
  };
  return composeClasses(slots, getChartsTooltipUtilityClass, classes);
};

// node_modules/@mui/x-charts/esm/ChartsTooltip/useItemTooltip.js
function useInternalItemTooltip() {
  var _a, _b, _c;
  const store = useStore();
  const identifier2 = useSelector(store, selectorChartsInteractionItem);
  const seriesConfig5 = useSelector(store, selectorChartSeriesConfig);
  const series = useSeries();
  const {
    xAxis,
    xAxisIds
  } = useXAxes();
  const {
    yAxis,
    yAxisIds
  } = useYAxes();
  const {
    zAxis,
    zAxisIds
  } = useZAxes();
  const {
    rotationAxis,
    rotationAxisIds
  } = useRotationAxes();
  const {
    radiusAxis,
    radiusAxisIds
  } = useRadiusAxes();
  const xAxisId = series.xAxisId ?? xAxisIds[0];
  const yAxisId = series.yAxisId ?? yAxisIds[0];
  const zAxisId = series.zAxisId ?? zAxisIds[0];
  const rotationAxisId = series.rotationAxisId ?? rotationAxisIds[0];
  const radiusAxisId = series.radiusAxisId ?? radiusAxisIds[0];
  if (!identifier2) {
    return null;
  }
  const itemSeries = (_a = series[identifier2.type]) == null ? void 0 : _a.series[identifier2.seriesId];
  if (!itemSeries) {
    return null;
  }
  const getColor6 = ((_c = (_b = seriesConfig5[itemSeries.type]).colorProcessor) == null ? void 0 : _c.call(_b, itemSeries, xAxisId && xAxis[xAxisId], yAxisId && yAxis[yAxisId], zAxisId && zAxis[zAxisId])) ?? (() => "");
  const axesConfig = {};
  if (xAxisId !== void 0) {
    axesConfig.x = xAxis[xAxisId];
  }
  if (yAxisId !== void 0) {
    axesConfig.y = yAxis[yAxisId];
  }
  if (rotationAxisId !== void 0) {
    axesConfig.rotation = rotationAxis[rotationAxisId];
  }
  if (radiusAxisId !== void 0) {
    axesConfig.radius = radiusAxis[radiusAxisId];
  }
  return seriesConfig5[itemSeries.type].tooltipGetter({
    series: itemSeries,
    axesConfig,
    getColor: getColor6,
    identifier: identifier2
  });
}
var useItemTooltip = () => {
  return useInternalItemTooltip();
};
var useRadarItemTooltip = () => {
  return useInternalItemTooltip();
};

// node_modules/@mui/x-charts/esm/ChartsTooltip/ChartsTooltipTable.js
var ChartsTooltipPaper = styled_default2("div", {
  name: "MuiChartsTooltip",
  slot: "Container",
  overridesResolver: (props, styles) => styles.paper
  // FIXME: Inconsistent naming with slot
})(({
  theme
}) => {
  var _a;
  return {
    backgroundColor: (theme.vars || theme).palette.background.paper,
    color: (theme.vars || theme).palette.text.primary,
    borderRadius: (_a = (theme.vars || theme).shape) == null ? void 0 : _a.borderRadius,
    border: `solid ${(theme.vars || theme).palette.divider} 1px`
  };
});
var ChartsTooltipTable = styled_default2("table", {
  name: "MuiChartsTooltip",
  slot: "Table"
})(({
  theme
}) => ({
  borderSpacing: 0,
  [`& .${chartsTooltipClasses.markContainer}`]: {
    display: "inline-block",
    width: `calc(20px + ${theme.spacing(1.5)})`,
    verticalAlign: "middle"
  },
  "& caption": {
    borderBottom: `solid ${(theme.vars || theme).palette.divider} 1px`,
    padding: theme.spacing(0.5, 1.5),
    textAlign: "start",
    whiteSpace: "nowrap",
    "& span": {
      marginRight: theme.spacing(1.5)
    }
  }
}));
var ChartsTooltipRow = styled_default2("tr", {
  name: "MuiChartsTooltip",
  slot: "Row"
})(({
  theme
}) => ({
  "tr:first-of-type& td": {
    paddingTop: theme.spacing(0.5)
  },
  "tr:last-of-type& td": {
    paddingBottom: theme.spacing(0.5)
  }
}));
var ChartsTooltipCell = styled_default2(Typography_default, {
  name: "MuiChartsTooltip",
  slot: "Cell"
})(({
  theme
}) => ({
  verticalAlign: "middle",
  color: (theme.vars || theme).palette.text.secondary,
  textAlign: "start",
  [`&.${chartsTooltipClasses.cell}`]: {
    paddingLeft: theme.spacing(1),
    paddingRight: theme.spacing(1)
  },
  [`&.${chartsTooltipClasses.labelCell}`]: {
    fontWeight: theme.typography.fontWeightRegular
  },
  [`&.${chartsTooltipClasses.valueCell}, &.${chartsTooltipClasses.axisValueCell}`]: {
    color: (theme.vars || theme).palette.text.primary,
    fontWeight: theme.typography.fontWeightMedium
  },
  [`&.${chartsTooltipClasses.valueCell}`]: {
    paddingLeft: theme.spacing(1.5),
    paddingRight: theme.spacing(1.5)
  },
  "td:first-of-type&, th:first-of-type&": {
    paddingLeft: theme.spacing(1.5)
  },
  "td:last-of-type&, th:last-of-type&": {
    paddingRight: theme.spacing(1.5)
  }
}));

// node_modules/@mui/x-charts/esm/ChartsLabel/ChartsLabelMark.js
var React63 = __toESM(require_react(), 1);
var import_prop_types30 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/ChartsLabel/labelMarkClasses.js
function getLabelMarkUtilityClass(slot) {
  return generateUtilityClass("MuiChartsLabelMark", slot);
}
var labelMarkClasses = generateUtilityClasses("MuiChartsLabelMark", ["root", "line", "square", "circle", "mask", "fill"]);
var useUtilityClasses7 = (props) => {
  const {
    type
  } = props;
  const slots = {
    root: typeof type === "function" ? ["root"] : ["root", type],
    mask: ["mask"],
    fill: ["fill"]
  };
  return composeClasses(slots, getLabelMarkUtilityClass, props.classes);
};

// node_modules/@mui/x-charts/esm/internals/consumeThemeProps.js
var React62 = __toESM(require_react(), 1);
var import_jsx_runtime33 = __toESM(require_jsx_runtime(), 1);
var consumeThemeProps = (name, options, InComponent) => React62.forwardRef(function ConsumeThemeInternal(props, ref) {
  var _a;
  const themedProps = useThemeProps2({
    props,
    // eslint-disable-next-line material-ui/mui-name-matches-component-name
    name
  });
  const defaultProps4 = typeof options.defaultProps === "function" ? options.defaultProps(themedProps) : options.defaultProps ?? {};
  const outProps = resolveProps(defaultProps4, themedProps);
  const theme = useTheme4();
  const classes = (_a = options.classesResolver) == null ? void 0 : _a.call(options, outProps, theme);
  const OutComponent = React62.forwardRef(InComponent);
  if (true) {
    OutComponent.displayName = `consumeThemeProps(${name})`;
  }
  return (0, import_jsx_runtime33.jsx)(OutComponent, _extends({}, outProps, {
    classes,
    ref
  }));
});

// node_modules/@mui/x-charts/esm/ChartsLabel/ChartsLabelMark.js
var import_jsx_runtime34 = __toESM(require_jsx_runtime(), 1);
var _excluded7 = ["type", "color", "className", "classes"];
var Root = styled_default2("div", {
  name: "MuiChartsLabelMark",
  slot: "Root"
})(() => {
  return {
    display: "flex",
    width: 14,
    height: 14,
    [`&.${labelMarkClasses.line}`]: {
      width: 16,
      height: "unset",
      alignItems: "center",
      [`.${labelMarkClasses.mask}`]: {
        height: 4,
        width: "100%",
        borderRadius: 1,
        overflow: "hidden"
      }
    },
    [`&.${labelMarkClasses.square}`]: {
      height: 13,
      width: 13,
      borderRadius: 2,
      overflow: "hidden"
    },
    [`&.${labelMarkClasses.circle}`]: {
      height: 15,
      width: 15
    },
    svg: {
      display: "block"
    },
    [`& .${labelMarkClasses.mask} > *`]: {
      height: "100%",
      width: "100%"
    },
    [`& .${labelMarkClasses.mask}`]: {
      height: "100%",
      width: "100%"
    }
  };
});
var ChartsLabelMark = consumeThemeProps("MuiChartsLabelMark", {
  defaultProps: {
    type: "square"
  },
  classesResolver: useUtilityClasses7
}, function ChartsLabelMark2(props, ref) {
  const {
    type,
    color: color3,
    className,
    classes
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded7);
  const Component = type;
  return (0, import_jsx_runtime34.jsx)(Root, _extends({
    className: clsx_default(classes == null ? void 0 : classes.root, className),
    ownerState: props,
    "aria-hidden": "true",
    ref
  }, other, {
    children: (0, import_jsx_runtime34.jsx)("div", {
      className: classes == null ? void 0 : classes.mask,
      children: typeof Component === "function" ? (0, import_jsx_runtime34.jsx)(Component, {
        className: classes == null ? void 0 : classes.fill,
        color: color3
      }) : (0, import_jsx_runtime34.jsx)("svg", {
        viewBox: "0 0 24 24",
        preserveAspectRatio: type === "line" ? "none" : void 0,
        children: type === "circle" ? (0, import_jsx_runtime34.jsx)("circle", {
          className: classes == null ? void 0 : classes.fill,
          r: "12",
          cx: "12",
          cy: "12",
          fill: color3
        }) : (0, import_jsx_runtime34.jsx)("rect", {
          className: classes == null ? void 0 : classes.fill,
          width: "24",
          height: "24",
          fill: color3
        })
      })
    })
  }));
});
true ? ChartsLabelMark.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types30.default.object,
  /**
   * The color of the mark.
   */
  color: import_prop_types30.default.string,
  /**
   * The type of the mark.
   * @default 'square'
   */
  type: import_prop_types30.default.oneOf(["circle", "line", "square"])
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsTooltip/ChartsItemTooltipContent.js
var import_jsx_runtime35 = __toESM(require_jsx_runtime(), 1);
function ChartsItemTooltipContent(props) {
  const {
    classes: propClasses,
    sx
  } = props;
  const tooltipData = useInternalItemTooltip();
  const classes = useUtilityClasses6(propClasses);
  if (!tooltipData) {
    return null;
  }
  if ("values" in tooltipData) {
    const {
      label: seriesLabel,
      color: color4,
      markType: markType2
    } = tooltipData;
    return (0, import_jsx_runtime35.jsx)(ChartsTooltipPaper, {
      sx,
      className: classes.paper,
      children: (0, import_jsx_runtime35.jsxs)(ChartsTooltipTable, {
        className: classes.table,
        children: [(0, import_jsx_runtime35.jsxs)(Typography_default, {
          component: "caption",
          children: [(0, import_jsx_runtime35.jsx)("div", {
            className: classes.markContainer,
            children: (0, import_jsx_runtime35.jsx)(ChartsLabelMark, {
              type: markType2,
              color: color4,
              className: classes.mark
            })
          }), seriesLabel]
        }), (0, import_jsx_runtime35.jsx)("tbody", {
          children: tooltipData.values.map(({
            formattedValue: formattedValue2,
            label: label2
          }) => (0, import_jsx_runtime35.jsxs)(ChartsTooltipRow, {
            className: classes.row,
            children: [(0, import_jsx_runtime35.jsx)(ChartsTooltipCell, {
              className: clsx_default(classes.labelCell, classes.cell),
              component: "th",
              children: label2
            }), (0, import_jsx_runtime35.jsx)(ChartsTooltipCell, {
              className: clsx_default(classes.valueCell, classes.cell),
              component: "td",
              children: formattedValue2
            })]
          }, label2))
        })]
      })
    });
  }
  const {
    color: color3,
    label,
    formattedValue,
    markType
  } = tooltipData;
  return (0, import_jsx_runtime35.jsx)(ChartsTooltipPaper, {
    sx,
    className: classes.paper,
    children: (0, import_jsx_runtime35.jsx)(ChartsTooltipTable, {
      className: classes.table,
      children: (0, import_jsx_runtime35.jsx)("tbody", {
        children: (0, import_jsx_runtime35.jsxs)(ChartsTooltipRow, {
          className: classes.row,
          children: [(0, import_jsx_runtime35.jsxs)(ChartsTooltipCell, {
            className: clsx_default(classes.labelCell, classes.cell),
            component: "th",
            children: [(0, import_jsx_runtime35.jsx)("div", {
              className: classes.markContainer,
              children: (0, import_jsx_runtime35.jsx)(ChartsLabelMark, {
                type: markType,
                color: color3,
                className: classes.mark
              })
            }), label]
          }), (0, import_jsx_runtime35.jsx)(ChartsTooltipCell, {
            className: clsx_default(classes.valueCell, classes.cell),
            component: "td",
            children: formattedValue
          })]
        })
      })
    })
  });
}
true ? ChartsItemTooltipContent.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types31.default.object,
  sx: import_prop_types31.default.oneOfType([import_prop_types31.default.arrayOf(import_prop_types31.default.oneOfType([import_prop_types31.default.func, import_prop_types31.default.object, import_prop_types31.default.bool])), import_prop_types31.default.func, import_prop_types31.default.object])
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsTooltip/ChartsAxisTooltipContent.js
var React67 = __toESM(require_react(), 1);
var import_prop_types32 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/internals/plugins/corePlugins/useChartSeries/useColorProcessor.js
var React65 = __toESM(require_react(), 1);
function useColorProcessor(seriesType) {
  const store = useStore();
  const seriesConfig5 = useSelector(store, selectorChartSeriesConfig);
  const colorProcessors = React65.useMemo(() => {
    const rep = {};
    Object.keys(seriesConfig5).forEach((seriesT) => {
      rep[seriesT] = seriesConfig5[seriesT].colorProcessor;
    });
    return rep;
  }, [seriesConfig5]);
  if (!seriesType) {
    return colorProcessors;
  }
  return colorProcessors[seriesType];
}

// node_modules/@mui/x-charts/esm/ChartsTooltip/utils.js
var React66 = __toESM(require_react(), 1);
function useMouseTracker() {
  const svgRef = useSvgRef();
  const [mousePosition, setMousePosition] = React66.useState(null);
  React66.useEffect(() => {
    const element = svgRef.current;
    if (element === null) {
      return () => {
      };
    }
    const controller = new AbortController();
    const handleOut = (event) => {
      if (event.pointerType !== "mouse") {
        setMousePosition(null);
      }
    };
    const handleMove = (event) => {
      setMousePosition({
        x: event.clientX,
        y: event.clientY,
        height: event.height,
        pointerType: event.pointerType
      });
    };
    element.addEventListener("pointerdown", handleMove, {
      signal: controller.signal
    });
    element.addEventListener("pointermove", handleMove, {
      signal: controller.signal
    });
    element.addEventListener("pointerup", handleOut, {
      signal: controller.signal
    });
    return () => {
      controller.abort();
    };
  }, [svgRef]);
  return mousePosition;
}
function usePointerType() {
  const svgRef = useSvgRef();
  const [pointerType, setPointerType] = React66.useState(null);
  React66.useEffect(() => {
    const element = svgRef.current;
    if (element === null) {
      return () => {
      };
    }
    const handleOut = (event) => {
      if (event.pointerType !== "mouse") {
        setPointerType(null);
      }
    };
    const handleEnter = (event) => {
      setPointerType({
        pointerType: event.pointerType
      });
    };
    element.addEventListener("pointerenter", handleEnter);
    element.addEventListener("pointerup", handleOut);
    return () => {
      element.removeEventListener("pointerenter", handleEnter);
      element.removeEventListener("pointerup", handleOut);
    };
  }, [svgRef]);
  return pointerType;
}
function utcFormatter(v3) {
  if (v3 instanceof Date) {
    return v3.toUTCString();
  }
  return v3.toLocaleString();
}

// node_modules/@mui/x-charts/esm/internals/plugins/featurePlugins/useChartPolarAxis/getAxisIndex.js
function getAxisIndex2(axisConfig, pointerValue) {
  const {
    scale: scale2,
    data: axisData,
    reverse: reverse2
  } = axisConfig;
  if (!isBandScale(scale2)) {
    throw new Error("MUI X Charts: getAxisValue is not implemented for polare continuous axes.");
  }
  if (!axisData) {
    return -1;
  }
  const angleGap = clampAngleRad(pointerValue - Math.min(...scale2.range()));
  const dataIndex = scale2.bandwidth() === 0 ? Math.floor((angleGap + scale2.step() / 2) / scale2.step()) % axisData.length : Math.floor(angleGap / scale2.step());
  if (dataIndex < 0 || dataIndex >= axisData.length) {
    return -1;
  }
  return reverse2 ? axisData.length - 1 - dataIndex : dataIndex;
}

// node_modules/@mui/x-charts/esm/internals/plugins/featurePlugins/useChartPolarAxis/useChartPolarInteraction.selectors.js
var optionalGetAxisId2 = (_2, id) => id;
var optionalGetAxisIds = (_2, ids) => ids;
function indexGetter2(value, axes, ids) {
  return Array.isArray(ids) ? ids.map((id) => getAxisIndex2(axes.axis[id], value)) : getAxisIndex2(axes.axis[ids], value);
}
var selectorChartsInteractionRotationAngle = createSelector2([selectorChartsInteractionPointerX, selectorChartsInteractionPointerY, selectorChartPolarCenter], (x3, y3, center) => {
  if (x3 === null || y3 === null) {
    return null;
  }
  return generateSvg2rotation(center)(x3, y3);
});
var selectorChartsInteractionRotationAxisIndex = createSelector2([selectorChartsInteractionRotationAngle, selectorChartRotationAxis, optionalGetAxisId2], (rotation, rotationAxis, id = rotationAxis.axisIds[0]) => rotation === null ? null : indexGetter2(rotation, rotationAxis, id));
var selectorChartsInteractionRotationAxisIndexes = createSelector2([selectorChartsInteractionRotationAngle, selectorChartRotationAxis, optionalGetAxisIds], (rotation, rotationAxis, ids = rotationAxis.axisIds) => rotation === null ? null : indexGetter2(rotation, rotationAxis, ids));
var selectorChartsInteractionRotationAxisValue = createSelector2([selectorChartRotationAxis, selectorChartsInteractionRotationAxisIndex, optionalGetAxisId2], (rotationAxis, rotationIndex, id = rotationAxis.axisIds[0]) => {
  var _a;
  if (rotationIndex === null || rotationIndex === -1 || rotationAxis.axisIds.length === 0) {
    return null;
  }
  const data = (_a = rotationAxis.axis[id]) == null ? void 0 : _a.data;
  if (!data) {
    return null;
  }
  return data[rotationIndex];
});
var selectorChartsInteractionRotationAxisValues = createSelector2([selectorChartRotationAxis, selectorChartsInteractionRotationAxisIndexes, optionalGetAxisIds], (rotationAxis, rotationIndexes, ids = rotationAxis.axisIds) => {
  if (rotationIndexes === null) {
    return null;
  }
  return ids.map((id, axisIndex) => {
    var _a;
    const rotationIndex = rotationIndexes[axisIndex];
    if (rotationIndex === -1) {
      return null;
    }
    return (_a = rotationAxis.axis[id].data) == null ? void 0 : _a[rotationIndex];
  });
});
var selectorChartsInteractionTooltipRotationAxes = createSelector2([selectorChartsInteractionRotationAxisIndexes, selectorChartRotationAxis], (indexes2, axes) => {
  if (indexes2 === null) {
    return [];
  }
  return axes.axisIds.map((axisId, axisIndex) => ({
    axisId,
    dataIndex: indexes2[axisIndex]
  })).filter(({
    axisId,
    dataIndex
  }) => axes.axis[axisId].triggerTooltip && dataIndex >= 0);
}, {
  memoizeOptions: {
    // Keep the same reference if array content is the same.
    // If possible, avoid this pattern by creating selectors that
    // uses string/number as arguments.
    resultEqualityCheck: isDeepEqual
  }
});
var selectorChartsInteractionTooltipRadiusAxes = createSelector2([], () => {
  return [];
});
var selectorChartsInteractionPolarAxisTooltip = createSelector2([selectorChartsInteractionTooltipRotationAxes], (rotationTooltip) => rotationTooltip.length > 0);

// node_modules/@mui/x-charts/esm/ChartsTooltip/useAxisTooltip.js
function defaultAxisTooltipConfig(axis, dataIndex, axisDirection) {
  var _a;
  const axisValue = ((_a = axis.data) == null ? void 0 : _a[dataIndex]) ?? null;
  const axisFormatter = axis.valueFormatter ?? ((v3) => axis.scaleType === "utc" ? utcFormatter(v3) : v3.toLocaleString());
  const axisFormattedValue = axisFormatter(axisValue, {
    location: "tooltip",
    scale: axis.scale
  });
  return {
    axisDirection,
    axisId: axis.id,
    mainAxis: axis,
    dataIndex,
    axisValue,
    axisFormattedValue,
    seriesItems: []
  };
}
function useAxisTooltip(params = {}) {
  const {
    multipleAxes,
    directions: directions2
  } = params;
  const defaultXAxis = useXAxis();
  const defaultYAxis = useYAxis();
  const defaultRotationAxis = useRotationAxis();
  const store = useStore();
  const tooltipXAxes = useSelector(store, selectorChartsInteractionTooltipXAxes);
  const tooltipYAxes = useSelector(store, selectorChartsInteractionTooltipYAxes);
  const tooltipRotationAxes = useSelector(store, selectorChartsInteractionTooltipRotationAxes);
  const series = useSeries();
  const {
    xAxis
  } = useXAxes();
  const {
    yAxis
  } = useYAxes();
  const {
    zAxis,
    zAxisIds
  } = useZAxes();
  const {
    rotationAxis
  } = useRotationAxes();
  const colorProcessors = useColorProcessor();
  if (tooltipXAxes.length === 0 && tooltipYAxes.length === 0 && tooltipRotationAxes.length === 0) {
    return null;
  }
  const tooltipAxes = [];
  if (directions2 === void 0 || directions2.includes("x")) {
    tooltipXAxes.forEach(({
      axisId,
      dataIndex
    }) => {
      if (!multipleAxes && tooltipAxes.length > 1) {
        return;
      }
      tooltipAxes.push(defaultAxisTooltipConfig(xAxis[axisId], dataIndex, "x"));
    });
  }
  if (directions2 === void 0 || directions2.includes("y")) {
    tooltipYAxes.forEach(({
      axisId,
      dataIndex
    }) => {
      if (!multipleAxes && tooltipAxes.length > 1) {
        return;
      }
      tooltipAxes.push(defaultAxisTooltipConfig(yAxis[axisId], dataIndex, "y"));
    });
  }
  if (directions2 === void 0 || directions2.includes("rotation")) {
    tooltipRotationAxes.forEach(({
      axisId,
      dataIndex
    }) => {
      if (!multipleAxes && tooltipAxes.length > 1) {
        return;
      }
      tooltipAxes.push(defaultAxisTooltipConfig(rotationAxis[axisId], dataIndex, "rotation"));
    });
  }
  Object.keys(series).filter(isCartesianSeriesType).forEach((seriesType) => {
    const seriesOfType = series[seriesType];
    if (!seriesOfType) {
      return [];
    }
    return seriesOfType.seriesOrder.forEach((seriesId) => {
      var _a;
      const seriesToAdd = seriesOfType.series[seriesId];
      const providedXAxisId = seriesToAdd.xAxisId ?? defaultXAxis.id;
      const providedYAxisId = seriesToAdd.yAxisId ?? defaultYAxis.id;
      const tooltipItemIndex = tooltipAxes.findIndex(({
        axisDirection,
        axisId
      }) => axisDirection === "x" && axisId === providedXAxisId || axisDirection === "y" && axisId === providedYAxisId);
      if (tooltipItemIndex >= 0) {
        const zAxisId = "zAxisId" in seriesToAdd ? seriesToAdd.zAxisId : zAxisIds[0];
        const {
          dataIndex
        } = tooltipAxes[tooltipItemIndex];
        const color3 = ((_a = colorProcessors[seriesType]) == null ? void 0 : _a.call(colorProcessors, seriesToAdd, xAxis[providedXAxisId], yAxis[providedYAxisId], zAxisId ? zAxis[zAxisId] : void 0)(dataIndex)) ?? "";
        const value = seriesToAdd.data[dataIndex] ?? null;
        const formattedValue = seriesToAdd.valueFormatter(value, {
          dataIndex
        });
        const formattedLabel = getLabel(seriesToAdd.label, "tooltip") ?? null;
        tooltipAxes[tooltipItemIndex].seriesItems.push({
          seriesId,
          color: color3,
          value,
          formattedValue,
          formattedLabel,
          markType: seriesToAdd.labelMarkType
        });
      }
    });
  });
  Object.keys(series).filter(isPolarSeriesType).forEach((seriesType) => {
    const seriesOfType = series[seriesType];
    if (!seriesOfType) {
      return [];
    }
    return seriesOfType.seriesOrder.forEach((seriesId) => {
      var _a;
      const seriesToAdd = seriesOfType.series[seriesId];
      const providedRotationAxisId = (
        // @ts-expect-error Should be fixed when we introduce a polar series with a rotationAxisId
        seriesToAdd.rotationAxisId ?? (defaultRotationAxis == null ? void 0 : defaultRotationAxis.id)
      );
      const tooltipItemIndex = tooltipAxes.findIndex(({
        axisDirection,
        axisId
      }) => axisDirection === "rotation" && axisId === providedRotationAxisId);
      if (tooltipItemIndex >= 0) {
        const {
          dataIndex
        } = tooltipAxes[tooltipItemIndex];
        const color3 = ((_a = colorProcessors[seriesType]) == null ? void 0 : _a.call(colorProcessors, seriesToAdd)(dataIndex)) ?? "";
        const value = seriesToAdd.data[dataIndex] ?? null;
        const formattedValue = seriesToAdd.valueFormatter(value, {
          dataIndex
        });
        const formattedLabel = getLabel(seriesToAdd.label, "tooltip") ?? null;
        tooltipAxes[tooltipItemIndex].seriesItems.push({
          seriesId,
          color: color3,
          value,
          formattedValue,
          formattedLabel,
          markType: seriesToAdd.labelMarkType
        });
      }
    });
  });
  if (!multipleAxes) {
    return tooltipAxes.length === 0 ? tooltipAxes[0] : null;
  }
  return tooltipAxes;
}

// node_modules/@mui/x-charts/esm/ChartsTooltip/useAxesTooltip.js
function useAxesTooltip(params) {
  return useAxisTooltip(_extends({}, params, {
    multipleAxes: true
  }));
}

// node_modules/@mui/x-charts/esm/ChartsTooltip/ChartsAxisTooltipContent.js
var import_jsx_runtime36 = __toESM(require_jsx_runtime(), 1);
function ChartsAxisTooltipContent(props) {
  const classes = useUtilityClasses6(props.classes);
  const tooltipData = useAxesTooltip();
  if (tooltipData === null) {
    return null;
  }
  return (0, import_jsx_runtime36.jsx)(ChartsTooltipPaper, {
    sx: props.sx,
    className: classes.paper,
    children: tooltipData.map(({
      axisId,
      mainAxis,
      axisValue,
      axisFormattedValue,
      seriesItems
    }) => {
      return (0, import_jsx_runtime36.jsxs)(ChartsTooltipTable, {
        className: classes.table,
        children: [axisValue != null && !mainAxis.hideTooltip && (0, import_jsx_runtime36.jsx)(Typography_default, {
          component: "caption",
          children: axisFormattedValue
        }), (0, import_jsx_runtime36.jsx)("tbody", {
          children: seriesItems.map(({
            seriesId,
            color: color3,
            formattedValue,
            formattedLabel,
            markType
          }) => {
            if (formattedValue == null) {
              return null;
            }
            return (0, import_jsx_runtime36.jsxs)(ChartsTooltipRow, {
              className: classes.row,
              children: [(0, import_jsx_runtime36.jsxs)(ChartsTooltipCell, {
                className: clsx_default(classes.labelCell, classes.cell),
                component: "th",
                children: [(0, import_jsx_runtime36.jsx)("div", {
                  className: classes.markContainer,
                  children: (0, import_jsx_runtime36.jsx)(ChartsLabelMark, {
                    type: markType,
                    color: color3,
                    className: classes.mark
                  })
                }), formattedLabel || null]
              }), (0, import_jsx_runtime36.jsx)(ChartsTooltipCell, {
                className: clsx_default(classes.valueCell, classes.cell),
                component: "td",
                children: formattedValue
              })]
            }, seriesId);
          })
        })]
      }, axisId);
    })
  });
}
true ? ChartsAxisTooltipContent.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types32.default.object,
  sx: import_prop_types32.default.oneOfType([import_prop_types32.default.arrayOf(import_prop_types32.default.oneOfType([import_prop_types32.default.func, import_prop_types32.default.object, import_prop_types32.default.bool])), import_prop_types32.default.func, import_prop_types32.default.object])
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsTooltip/ChartsTooltipContainer.js
var React74 = __toESM(require_react(), 1);
var import_prop_types38 = __toESM(require_prop_types(), 1);

// node_modules/@mui/utils/esm/useLazyRef/useLazyRef.js
var React68 = __toESM(require_react(), 1);
var UNINITIALIZED = {};
function useLazyRef(init, initArg) {
  const ref = React68.useRef(UNINITIALIZED);
  if (ref.current === UNINITIALIZED) {
    ref.current = init(initArg);
  }
  return ref;
}

// node_modules/@mui/utils/esm/refType/refType.js
var import_prop_types33 = __toESM(require_prop_types(), 1);
var refType = import_prop_types33.default.oneOfType([import_prop_types33.default.func, import_prop_types33.default.object]);
var refType_default = refType;

// node_modules/@mui/material/esm/Popper/Popper.js
var import_prop_types36 = __toESM(require_prop_types(), 1);
var React72 = __toESM(require_react(), 1);

// node_modules/@mui/material/esm/Popper/BasePopper.js
var React71 = __toESM(require_react(), 1);

// node_modules/@mui/utils/esm/chainPropTypes/chainPropTypes.js
function chainPropTypes(propType1, propType2) {
  if (false) {
    return () => null;
  }
  return function validate(...args) {
    return propType1(...args) || propType2(...args);
  };
}

// node_modules/@popperjs/core/lib/enums.js
var top2 = "top";
var bottom2 = "bottom";
var right2 = "right";
var left2 = "left";
var auto = "auto";
var basePlacements = [top2, bottom2, right2, left2];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

// node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}

// node_modules/@popperjs/core/lib/dom-utils/getWindow.js
function getWindow(node2) {
  if (node2 == null) {
    return window;
  }
  if (node2.toString() !== "[object Window]") {
    var ownerDocument2 = node2.ownerDocument;
    return ownerDocument2 ? ownerDocument2.defaultView || window : window;
  }
  return node2;
}

// node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
function isElement(node2) {
  var OwnElement = getWindow(node2).Element;
  return node2 instanceof OwnElement || node2 instanceof Element;
}
function isHTMLElement(node2) {
  var OwnElement = getWindow(node2).HTMLElement;
  return node2 instanceof OwnElement || node2 instanceof HTMLElement;
}
function isShadowRoot(node2) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node2).ShadowRoot;
  return node2 instanceof OwnElement || node2 instanceof ShadowRoot;
}

// node_modules/@popperjs/core/lib/modifiers/applyStyles.js
function applyStyles2(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style4 = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name];
    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style4);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element.removeAttribute(name2);
      } else {
        element.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style4 = styleProperties.reduce(function(style5, property) {
        style5[property] = "";
        return style5;
      }, {});
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style4);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles_default = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles2,
  effect,
  requires: ["computeStyles"]
};

// node_modules/@popperjs/core/lib/utils/getBasePlacement.js
function getBasePlacement(placement) {
  return placement.split("-")[0];
}

// node_modules/@popperjs/core/lib/utils/math.js
var max3 = Math.max;
var min3 = Math.min;
var round2 = Math.round;

// node_modules/@popperjs/core/lib/utils/userAgent.js
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}

// node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}

// node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement(element)) {
    scaleX = element.offsetWidth > 0 ? round2(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round2(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x3 = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y3 = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width2 = clientRect.width / scaleX;
  var height2 = clientRect.height / scaleY;
  return {
    width: width2,
    height: height2,
    top: y3,
    right: x3 + width2,
    bottom: y3 + height2,
    left: x3,
    x: x3,
    y: y3
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element);
  var width2 = element.offsetWidth;
  var height2 = element.offsetHeight;
  if (Math.abs(clientRect.width - width2) <= 1) {
    width2 = clientRect.width;
  }
  if (Math.abs(clientRect.height - height2) <= 1) {
    height2 = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width: width2,
    height: height2
  };
}

// node_modules/@popperjs/core/lib/dom-utils/contains.js
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next2 = child;
    do {
      if (next2 && parent.isSameNode(next2)) {
        return true;
      }
      next2 = next2.parentNode || next2.host;
    } while (next2);
  }
  return false;
}

// node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
function getComputedStyle(element) {
  return getWindow(element).getComputedStyle(element);
}

// node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
function getDocumentElement(element) {
  return ((isElement(element) ? element.ownerDocument : (
    // $FlowFixMe[prop-missing]
    element.document
  )) || window.document).documentElement;
}

// node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
function getParentNode(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || // DOM Element detected
    (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element)
  );
}

// node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement(element)) {
    var elementCss = getComputedStyle(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  var window2 = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}

// node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}

// node_modules/@popperjs/core/lib/utils/within.js
function within(min4, value, max4) {
  return max3(min4, min3(value, max4));
}
function withinMaxClamp(min4, value, max4) {
  var v3 = within(min4, value, max4);
  return v3 > max4 ? max4 : v3;
}

// node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

// node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}

// node_modules/@popperjs/core/lib/utils/expandToHashMap.js
function expandToHashMap(value, keys) {
  return keys.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

// node_modules/@popperjs/core/lib/modifiers/arrow.js
var toPaddingObject = function toPaddingObject2(padding2, state) {
  padding2 = typeof padding2 === "function" ? padding2(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding2;
  return mergePaddingObject(typeof padding2 !== "number" ? padding2 : expandToHashMap(padding2, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left2, right2].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top2 : left2;
  var maxProp = axis === "y" ? bottom2 : right2;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min4 = paddingObject[minProp];
  var max4 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min4, center, max4);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect2(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    return;
  }
  state.elements.arrow = arrowElement;
}
var arrow_default = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect2,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};

// node_modules/@popperjs/core/lib/utils/getVariation.js
function getVariation(placement) {
  return placement.split("-")[1];
}

// node_modules/@popperjs/core/lib/modifiers/computeStyles.js
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref, win) {
  var x3 = _ref.x, y3 = _ref.y;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round2(x3 * dpr) / dpr || 0,
    y: round2(y3 * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position3 = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x3 = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y3 = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x: x3,
    y: y3
  }) : {
    x: x3,
    y: y3
  };
  x3 = _ref3.x;
  y3 = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left2;
  var sideY = top2;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle(offsetParent).position !== "static" && position3 === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top2 || (placement === left2 || placement === right2) && variation === end) {
      sideY = bottom2;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        offsetParent[heightProp]
      );
      y3 -= offsetY - popperRect.height;
      y3 *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left2 || (placement === top2 || placement === bottom2) && variation === end) {
      sideX = right2;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        offsetParent[widthProp]
      );
      x3 -= offsetX - popperRect.width;
      x3 *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position: position3
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x: x3,
    y: y3
  }, getWindow(popper2)) : {
    x: x3,
    y: y3
  };
  x3 = _ref4.x;
  y3 = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x3 + "px, " + y3 + "px)" : "translate3d(" + x3 + "px, " + y3 + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y3 + "px" : "", _Object$assign2[sideX] = hasX ? x3 + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
var computeStyles_default = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};

// node_modules/@popperjs/core/lib/modifiers/eventListeners.js
var passive = {
  passive: true
};
function effect3(_ref) {
  var state = _ref.state, instance = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
var eventListeners_default = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect: effect3,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
var hash2 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash2[matched];
  });
}

// node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
var hash3 = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash3[matched];
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
function getWindowScroll(node2) {
  var win = getWindow(node2);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}

// node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
function getViewportRect(element, strategy) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width2 = html.clientWidth;
  var height2 = html.clientHeight;
  var x3 = 0;
  var y3 = 0;
  if (visualViewport) {
    width2 = visualViewport.width;
    height2 = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x3 = visualViewport.offsetLeft;
      y3 = visualViewport.offsetTop;
    }
  }
  return {
    width: width2,
    height: height2,
    x: x3 + getWindowScrollBarX(element),
    y: y3
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width2 = max3(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height2 = max3(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x3 = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y3 = -winScroll.scrollTop;
  if (getComputedStyle(body || html).direction === "rtl") {
    x3 += max3(html.clientWidth, body ? body.clientWidth : 0) - width2;
  }
  return {
    width: width2,
    height: height2,
    x: x3,
    y: y3
  };
}

// node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle(element), overflow2 = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow2 + overflowY + overflowX);
}

// node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
function getScrollParent(node2) {
  if (["html", "body", "#document"].indexOf(getNodeName(node2)) >= 0) {
    return node2.ownerDocument.body;
  }
  if (isHTMLElement(node2) && isScrollParent(node2)) {
    return node2;
  }
  return getScrollParent(getParentNode(node2));
}

// node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode(target)))
  );
}

// node_modules/@popperjs/core/lib/utils/rectToClientRect.js
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
function getInnerBoundingClientRect(element, strategy) {
  var rect = getBoundingClientRect(element, false, strategy === "fixed");
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = max3(rect.top, accRect.top);
    accRect.right = min3(rect.right, accRect.right);
    accRect.bottom = min3(rect.bottom, accRect.bottom);
    accRect.left = max3(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

// node_modules/@popperjs/core/lib/utils/computeOffsets.js
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top2:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom2:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right2:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left2:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
        break;
      default:
    }
  }
  return offsets;
}

// node_modules/@popperjs/core/lib/utils/detectOverflow.js
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding2 = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding2 !== "number" ? padding2 : expandToHashMap(padding2, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right2, bottom2].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top2, bottom2].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}

// node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding2 = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements2.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements2;
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding: padding2
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a3, b2) {
    return overflows[a3] - overflows[b2];
  });
}

// node_modules/@popperjs/core/lib/modifiers/flip.js
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding2 = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding: padding2,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i2 = 0; i2 < placements2.length; i2++) {
    var placement = placements2[i2];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top2, bottom2].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow2 = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding: padding2
    });
    var mainVariationSide = isVertical ? isStartVariation ? right2 : left2 : isStartVariation ? bottom2 : top2;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow2[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow2[mainVariationSide] <= 0, overflow2[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break") break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip_default = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};

// node_modules/@popperjs/core/lib/modifiers/hide.js
function getSideOffsets(overflow2, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow2.top - rect.height - preventedOffsets.y,
    right: overflow2.right - rect.width + preventedOffsets.x,
    bottom: overflow2.bottom - rect.height + preventedOffsets.y,
    left: overflow2.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow2) {
  return [top2, right2, bottom2, left2].some(function(side) {
    return overflow2[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state, name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
var hide_default = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};

// node_modules/@popperjs/core/lib/modifiers/offset.js
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left2, top2].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left2, right2].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x3 = _data$state$placement.x, y3 = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x3;
    state.modifiersData.popperOffsets.y += y3;
  }
  state.modifiersData[name] = data;
}
var offset_default = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};

// node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
function popperOffsets(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
var popperOffsets_default = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getAltAxis.js
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}

// node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
function preventOverflow(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding2 = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow2 = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding: padding2,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top2 : left2;
    var altSide = mainAxis === "y" ? bottom2 : right2;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min4 = offset2 + overflow2[mainSide];
    var max4 = offset2 - overflow2[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min3(min4, tetherMin) : min4, offset2, tether ? max3(max4, tetherMax) : max4);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top2 : left2;
    var _altSide = mainAxis === "x" ? bottom2 : right2;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow2[_mainSide];
    var _max = _offset - overflow2[_altSide];
    var isOriginSide = [top2, left2].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
}
var preventOverflow_default = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};

// node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
function getNodeScroll(node2) {
  if (node2 === getWindow(node2) || !isHTMLElement(node2)) {
    return getWindowScroll(node2);
  } else {
    return getHTMLElementScroll(node2);
  }
}

// node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round2(rect.width) / element.offsetWidth || 1;
  var scaleY = round2(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

// node_modules/@popperjs/core/lib/utils/orderModifiers.js
function order2(modifiers) {
  var map4 = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map4.set(modifier.name, modifier);
  });
  function sort2(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map4.get(dep);
        if (depModifier) {
          sort2(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort2(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order2(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

// node_modules/@popperjs/core/lib/utils/debounce.js
function debounce(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn2());
        });
      });
    }
    return pending;
  };
}

// node_modules/@popperjs/core/lib/utils/mergeByName.js
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}

// node_modules/@popperjs/core/lib/createPopper.js
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers3 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper4(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options2);
        state.scrollParents = {
          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers3, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m2) {
          return m2.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      // Sync update  it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index2 = 0; index2 < state.orderedModifiers.length; index2++) {
          if (state.reset === true) {
            state.reset = false;
            index2 = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index2], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state = fn2({
              state,
              options: _options,
              name,
              instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update  it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce(function() {
        return new Promise(function(resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      return instance;
    }
    instance.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref) {
        var name = _ref.name, _ref$options = _ref.options, options2 = _ref$options === void 0 ? {} : _ref$options, effect4 = _ref.effect;
        if (typeof effect4 === "function") {
          var cleanupFn = effect4({
            state,
            name,
            instance,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}
var createPopper = popperGenerator();

// node_modules/@popperjs/core/lib/popper-lite.js
var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default];
var createPopper2 = popperGenerator({
  defaultModifiers
});

// node_modules/@popperjs/core/lib/popper.js
var defaultModifiers2 = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
var createPopper3 = popperGenerator({
  defaultModifiers: defaultModifiers2
});

// node_modules/@mui/material/esm/Popper/BasePopper.js
var import_prop_types35 = __toESM(require_prop_types(), 1);

// node_modules/@mui/material/esm/Portal/Portal.js
var React70 = __toESM(require_react(), 1);
var ReactDOM = __toESM(require_react_dom(), 1);
var import_prop_types34 = __toESM(require_prop_types(), 1);

// node_modules/@mui/utils/esm/setRef/setRef.js
function setRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
}

// node_modules/@mui/utils/esm/getReactElementRef/getReactElementRef.js
var React69 = __toESM(require_react(), 1);
function getReactElementRef(element) {
  var _a;
  if (parseInt(React69.version, 10) >= 19) {
    return ((_a = element == null ? void 0 : element.props) == null ? void 0 : _a.ref) || null;
  }
  return (element == null ? void 0 : element.ref) || null;
}

// node_modules/@mui/material/esm/Portal/Portal.js
function getContainer(container) {
  return typeof container === "function" ? container() : container;
}
var Portal = React70.forwardRef(function Portal2(props, forwardedRef) {
  const {
    children: children2,
    container,
    disablePortal = false
  } = props;
  const [mountNode, setMountNode] = React70.useState(null);
  const handleRef = useForkRef(React70.isValidElement(children2) ? getReactElementRef(children2) : null, forwardedRef);
  useEnhancedEffect_default(() => {
    if (!disablePortal) {
      setMountNode(getContainer(container) || document.body);
    }
  }, [container, disablePortal]);
  useEnhancedEffect_default(() => {
    if (mountNode && !disablePortal) {
      setRef(forwardedRef, mountNode);
      return () => {
        setRef(forwardedRef, null);
      };
    }
    return void 0;
  }, [forwardedRef, mountNode, disablePortal]);
  if (disablePortal) {
    if (React70.isValidElement(children2)) {
      const newProps = {
        ref: handleRef
      };
      return React70.cloneElement(children2, newProps);
    }
    return children2;
  }
  return mountNode ? ReactDOM.createPortal(children2, mountNode) : mountNode;
});
true ? Portal.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //  To update them, edit the TypeScript types and run `pnpm proptypes`. 
  // 
  /**
   * The children to render into the `container`.
   */
  children: import_prop_types34.default.node,
  /**
   * An HTML element or function that returns one.
   * The `container` will have the portal children appended to it.
   *
   * You can also provide a callback, which is called in a React layout effect.
   * This lets you set the container from a ref, and also makes server-side rendering possible.
   *
   * By default, it uses the body of the top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: import_prop_types34.default.oneOfType([HTMLElementType, import_prop_types34.default.func]),
  /**
   * The `children` will be under the DOM hierarchy of the parent component.
   * @default false
   */
  disablePortal: import_prop_types34.default.bool
} : void 0;
if (true) {
  Portal["propTypes"] = exactProp(Portal.propTypes);
}
var Portal_default = Portal;

// node_modules/@mui/material/esm/Popper/popperClasses.js
function getPopperUtilityClass(slot) {
  return generateUtilityClass("MuiPopper", slot);
}
var popperClasses = generateUtilityClasses("MuiPopper", ["root"]);

// node_modules/@mui/material/esm/Popper/BasePopper.js
var import_jsx_runtime37 = __toESM(require_jsx_runtime(), 1);
function flipPlacement(placement, direction) {
  if (direction === "ltr") {
    return placement;
  }
  switch (placement) {
    case "bottom-end":
      return "bottom-start";
    case "bottom-start":
      return "bottom-end";
    case "top-end":
      return "top-start";
    case "top-start":
      return "top-end";
    default:
      return placement;
  }
}
function resolveAnchorEl(anchorEl) {
  return typeof anchorEl === "function" ? anchorEl() : anchorEl;
}
function isHTMLElement2(element) {
  return element.nodeType !== void 0;
}
function isVirtualElement(element) {
  return !isHTMLElement2(element);
}
var useUtilityClasses8 = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getPopperUtilityClass, classes);
};
var defaultPopperOptions = {};
var PopperTooltip = React71.forwardRef(function PopperTooltip2(props, forwardedRef) {
  const {
    anchorEl,
    children: children2,
    direction,
    disablePortal,
    modifiers,
    open,
    placement: initialPlacement,
    popperOptions,
    popperRef: popperRefProp,
    slotProps = {},
    slots = {},
    TransitionProps,
    // @ts-ignore internal logic
    ownerState: ownerStateProp,
    // prevent from spreading to DOM, it can come from the parent component e.g. Select.
    ...other
  } = props;
  const tooltipRef = React71.useRef(null);
  const ownRef = useForkRef(tooltipRef, forwardedRef);
  const popperRef = React71.useRef(null);
  const handlePopperRef = useForkRef(popperRef, popperRefProp);
  const handlePopperRefRef = React71.useRef(handlePopperRef);
  useEnhancedEffect_default(() => {
    handlePopperRefRef.current = handlePopperRef;
  }, [handlePopperRef]);
  React71.useImperativeHandle(popperRefProp, () => popperRef.current, []);
  const rtlPlacement = flipPlacement(initialPlacement, direction);
  const [placement, setPlacement] = React71.useState(rtlPlacement);
  const [resolvedAnchorElement, setResolvedAnchorElement] = React71.useState(resolveAnchorEl(anchorEl));
  React71.useEffect(() => {
    if (popperRef.current) {
      popperRef.current.forceUpdate();
    }
  });
  React71.useEffect(() => {
    if (anchorEl) {
      setResolvedAnchorElement(resolveAnchorEl(anchorEl));
    }
  }, [anchorEl]);
  useEnhancedEffect_default(() => {
    if (!resolvedAnchorElement || !open) {
      return void 0;
    }
    const handlePopperUpdate = (data) => {
      setPlacement(data.placement);
    };
    if (true) {
      if (resolvedAnchorElement && isHTMLElement2(resolvedAnchorElement) && resolvedAnchorElement.nodeType === 1) {
        const box = resolvedAnchorElement.getBoundingClientRect();
        if (box.top === 0 && box.left === 0 && box.right === 0 && box.bottom === 0) {
          console.warn(["MUI: The `anchorEl` prop provided to the component is invalid.", "The anchor element should be part of the document layout.", "Make sure the element is present in the document or that it's not display none."].join("\n"));
        }
      }
    }
    let popperModifiers = [{
      name: "preventOverflow",
      options: {
        altBoundary: disablePortal
      }
    }, {
      name: "flip",
      options: {
        altBoundary: disablePortal
      }
    }, {
      name: "onUpdate",
      enabled: true,
      phase: "afterWrite",
      fn: ({
        state
      }) => {
        handlePopperUpdate(state);
      }
    }];
    if (modifiers != null) {
      popperModifiers = popperModifiers.concat(modifiers);
    }
    if (popperOptions && popperOptions.modifiers != null) {
      popperModifiers = popperModifiers.concat(popperOptions.modifiers);
    }
    const popper2 = createPopper3(resolvedAnchorElement, tooltipRef.current, {
      placement: rtlPlacement,
      ...popperOptions,
      modifiers: popperModifiers
    });
    handlePopperRefRef.current(popper2);
    return () => {
      popper2.destroy();
      handlePopperRefRef.current(null);
    };
  }, [resolvedAnchorElement, disablePortal, modifiers, open, popperOptions, rtlPlacement]);
  const childProps = {
    placement
  };
  if (TransitionProps !== null) {
    childProps.TransitionProps = TransitionProps;
  }
  const classes = useUtilityClasses8(props);
  const Root4 = slots.root ?? "div";
  const rootProps = useSlotProps_default({
    elementType: Root4,
    externalSlotProps: slotProps.root,
    externalForwardedProps: other,
    additionalProps: {
      role: "tooltip",
      ref: ownRef
    },
    ownerState: props,
    className: classes.root
  });
  return (0, import_jsx_runtime37.jsx)(Root4, {
    ...rootProps,
    children: typeof children2 === "function" ? children2(childProps) : children2
  });
});
var Popper = React71.forwardRef(function Popper2(props, forwardedRef) {
  const {
    anchorEl,
    children: children2,
    container: containerProp,
    direction = "ltr",
    disablePortal = false,
    keepMounted = false,
    modifiers,
    open,
    placement = "bottom",
    popperOptions = defaultPopperOptions,
    popperRef,
    style: style4,
    transition = false,
    slotProps = {},
    slots = {},
    ...other
  } = props;
  const [exited, setExited] = React71.useState(true);
  const handleEnter = () => {
    setExited(false);
  };
  const handleExited = () => {
    setExited(true);
  };
  if (!keepMounted && !open && (!transition || exited)) {
    return null;
  }
  let container;
  if (containerProp) {
    container = containerProp;
  } else if (anchorEl) {
    const resolvedAnchorEl = resolveAnchorEl(anchorEl);
    container = resolvedAnchorEl && isHTMLElement2(resolvedAnchorEl) ? ownerDocument(resolvedAnchorEl).body : ownerDocument(null).body;
  }
  const display = !open && keepMounted && (!transition || exited) ? "none" : void 0;
  const transitionProps = transition ? {
    in: open,
    onEnter: handleEnter,
    onExited: handleExited
  } : void 0;
  return (0, import_jsx_runtime37.jsx)(Portal_default, {
    disablePortal,
    container,
    children: (0, import_jsx_runtime37.jsx)(PopperTooltip, {
      anchorEl,
      direction,
      disablePortal,
      modifiers,
      ref: forwardedRef,
      open: transition ? !exited : open,
      placement,
      popperOptions,
      popperRef,
      slotProps,
      slots,
      ...other,
      style: {
        // Prevents scroll issue, waiting for Popper.js to add this style once initiated.
        position: "fixed",
        // Fix Popper.js display issue
        top: 0,
        left: 0,
        display,
        ...style4
      },
      TransitionProps: transitionProps,
      children: children2
    })
  });
});
true ? Popper.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //  To update them, edit the TypeScript types and run `pnpm proptypes`. 
  // 
  /**
   * An HTML element, [virtualElement](https://popper.js.org/docs/v2/virtual-elements/),
   * or a function that returns either.
   * It's used to set the position of the popper.
   * The return value will passed as the reference object of the Popper instance.
   */
  anchorEl: chainPropTypes(import_prop_types35.default.oneOfType([HTMLElementType, import_prop_types35.default.object, import_prop_types35.default.func]), (props) => {
    if (props.open) {
      const resolvedAnchorEl = resolveAnchorEl(props.anchorEl);
      if (resolvedAnchorEl && isHTMLElement2(resolvedAnchorEl) && resolvedAnchorEl.nodeType === 1) {
        const box = resolvedAnchorEl.getBoundingClientRect();
        if (box.top === 0 && box.left === 0 && box.right === 0 && box.bottom === 0) {
          return new Error(["MUI: The `anchorEl` prop provided to the component is invalid.", "The anchor element should be part of the document layout.", "Make sure the element is present in the document or that it's not display none."].join("\n"));
        }
      } else if (!resolvedAnchorEl || typeof resolvedAnchorEl.getBoundingClientRect !== "function" || isVirtualElement(resolvedAnchorEl) && resolvedAnchorEl.contextElement != null && resolvedAnchorEl.contextElement.nodeType !== 1) {
        return new Error(["MUI: The `anchorEl` prop provided to the component is invalid.", "It should be an HTML element instance or a virtualElement ", "(https://popper.js.org/docs/v2/virtual-elements/)."].join("\n"));
      }
    }
    return null;
  }),
  /**
   * Popper render function or node.
   */
  children: import_prop_types35.default.oneOfType([import_prop_types35.default.node, import_prop_types35.default.func]),
  /**
   * An HTML element or function that returns one.
   * The `container` will have the portal children appended to it.
   *
   * You can also provide a callback, which is called in a React layout effect.
   * This lets you set the container from a ref, and also makes server-side rendering possible.
   *
   * By default, it uses the body of the top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: import_prop_types35.default.oneOfType([HTMLElementType, import_prop_types35.default.func]),
  /**
   * Direction of the text.
   * @default 'ltr'
   */
  direction: import_prop_types35.default.oneOf(["ltr", "rtl"]),
  /**
   * The `children` will be under the DOM hierarchy of the parent component.
   * @default false
   */
  disablePortal: import_prop_types35.default.bool,
  /**
   * Always keep the children in the DOM.
   * This prop can be useful in SEO situation or
   * when you want to maximize the responsiveness of the Popper.
   * @default false
   */
  keepMounted: import_prop_types35.default.bool,
  /**
   * Popper.js is based on a "plugin-like" architecture,
   * most of its features are fully encapsulated "modifiers".
   *
   * A modifier is a function that is called each time Popper.js needs to
   * compute the position of the popper.
   * For this reason, modifiers should be very performant to avoid bottlenecks.
   * To learn how to create a modifier, [read the modifiers documentation](https://popper.js.org/docs/v2/modifiers/).
   */
  modifiers: import_prop_types35.default.arrayOf(import_prop_types35.default.shape({
    data: import_prop_types35.default.object,
    effect: import_prop_types35.default.func,
    enabled: import_prop_types35.default.bool,
    fn: import_prop_types35.default.func,
    name: import_prop_types35.default.any,
    options: import_prop_types35.default.object,
    phase: import_prop_types35.default.oneOf(["afterMain", "afterRead", "afterWrite", "beforeMain", "beforeRead", "beforeWrite", "main", "read", "write"]),
    requires: import_prop_types35.default.arrayOf(import_prop_types35.default.string),
    requiresIfExists: import_prop_types35.default.arrayOf(import_prop_types35.default.string)
  })),
  /**
   * If `true`, the component is shown.
   */
  open: import_prop_types35.default.bool.isRequired,
  /**
   * Popper placement.
   * @default 'bottom'
   */
  placement: import_prop_types35.default.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
  /**
   * Options provided to the [`Popper.js`](https://popper.js.org/docs/v2/constructors/#options) instance.
   * @default {}
   */
  popperOptions: import_prop_types35.default.shape({
    modifiers: import_prop_types35.default.array,
    onFirstUpdate: import_prop_types35.default.func,
    placement: import_prop_types35.default.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
    strategy: import_prop_types35.default.oneOf(["absolute", "fixed"])
  }),
  /**
   * A ref that points to the used popper instance.
   */
  popperRef: refType_default,
  /**
   * The props used for each slot inside the Popper.
   * @default {}
   */
  slotProps: import_prop_types35.default.shape({
    root: import_prop_types35.default.oneOfType([import_prop_types35.default.func, import_prop_types35.default.object])
  }),
  /**
   * The components used for each slot inside the Popper.
   * Either a string to use a HTML element or a component.
   * @default {}
   */
  slots: import_prop_types35.default.shape({
    root: import_prop_types35.default.elementType
  }),
  /**
   * Help supporting a react-transition-group/Transition component.
   * @default false
   */
  transition: import_prop_types35.default.bool
} : void 0;
var BasePopper_default = Popper;

// node_modules/@mui/material/esm/Popper/Popper.js
var import_jsx_runtime38 = __toESM(require_jsx_runtime(), 1);
var PopperRoot = styled_default2(BasePopper_default, {
  name: "MuiPopper",
  slot: "Root"
})({});
var Popper3 = React72.forwardRef(function Popper4(inProps, ref) {
  const isRtl = useRtl();
  const props = useDefaultProps2({
    props: inProps,
    name: "MuiPopper"
  });
  const {
    anchorEl,
    component,
    components,
    componentsProps,
    container,
    disablePortal,
    keepMounted,
    modifiers,
    open,
    placement,
    popperOptions,
    popperRef,
    transition,
    slots,
    slotProps,
    ...other
  } = props;
  const RootComponent = (slots == null ? void 0 : slots.root) ?? (components == null ? void 0 : components.Root);
  const otherProps = {
    anchorEl,
    container,
    disablePortal,
    keepMounted,
    modifiers,
    open,
    placement,
    popperOptions,
    popperRef,
    transition,
    ...other
  };
  return (0, import_jsx_runtime38.jsx)(PopperRoot, {
    as: component,
    direction: isRtl ? "rtl" : "ltr",
    slots: {
      root: RootComponent
    },
    slotProps: slotProps ?? componentsProps,
    ...otherProps,
    ref
  });
});
true ? Popper3.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //  To update them, edit the TypeScript types and run `pnpm proptypes`. 
  // 
  /**
   * An HTML element, [virtualElement](https://popper.js.org/docs/v2/virtual-elements/),
   * or a function that returns either.
   * It's used to set the position of the popper.
   * The return value will passed as the reference object of the Popper instance.
   */
  anchorEl: import_prop_types36.default.oneOfType([HTMLElementType, import_prop_types36.default.object, import_prop_types36.default.func]),
  /**
   * Popper render function or node.
   */
  children: import_prop_types36.default.oneOfType([import_prop_types36.default.node, import_prop_types36.default.func]),
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: import_prop_types36.default.elementType,
  /**
   * The components used for each slot inside the Popper.
   * Either a string to use a HTML element or a component.
   *
   * @deprecated use the `slots` prop instead. This prop will be removed in a future major release. [How to migrate](/material-ui/migration/migrating-from-deprecated-apis/).
   * @default {}
   */
  components: import_prop_types36.default.shape({
    Root: import_prop_types36.default.elementType
  }),
  /**
   * The props used for each slot inside the Popper.
   *
   * @deprecated use the `slotProps` prop instead. This prop will be removed in a future major release. [How to migrate](/material-ui/migration/migrating-from-deprecated-apis/).
   * @default {}
   */
  componentsProps: import_prop_types36.default.shape({
    root: import_prop_types36.default.oneOfType([import_prop_types36.default.func, import_prop_types36.default.object])
  }),
  /**
   * An HTML element or function that returns one.
   * The `container` will have the portal children appended to it.
   *
   * You can also provide a callback, which is called in a React layout effect.
   * This lets you set the container from a ref, and also makes server-side rendering possible.
   *
   * By default, it uses the body of the top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: import_prop_types36.default.oneOfType([HTMLElementType, import_prop_types36.default.func]),
  /**
   * The `children` will be under the DOM hierarchy of the parent component.
   * @default false
   */
  disablePortal: import_prop_types36.default.bool,
  /**
   * Always keep the children in the DOM.
   * This prop can be useful in SEO situation or
   * when you want to maximize the responsiveness of the Popper.
   * @default false
   */
  keepMounted: import_prop_types36.default.bool,
  /**
   * Popper.js is based on a "plugin-like" architecture,
   * most of its features are fully encapsulated "modifiers".
   *
   * A modifier is a function that is called each time Popper.js needs to
   * compute the position of the popper.
   * For this reason, modifiers should be very performant to avoid bottlenecks.
   * To learn how to create a modifier, [read the modifiers documentation](https://popper.js.org/docs/v2/modifiers/).
   */
  modifiers: import_prop_types36.default.arrayOf(import_prop_types36.default.shape({
    data: import_prop_types36.default.object,
    effect: import_prop_types36.default.func,
    enabled: import_prop_types36.default.bool,
    fn: import_prop_types36.default.func,
    name: import_prop_types36.default.any,
    options: import_prop_types36.default.object,
    phase: import_prop_types36.default.oneOf(["afterMain", "afterRead", "afterWrite", "beforeMain", "beforeRead", "beforeWrite", "main", "read", "write"]),
    requires: import_prop_types36.default.arrayOf(import_prop_types36.default.string),
    requiresIfExists: import_prop_types36.default.arrayOf(import_prop_types36.default.string)
  })),
  /**
   * If `true`, the component is shown.
   */
  open: import_prop_types36.default.bool.isRequired,
  /**
   * Popper placement.
   * @default 'bottom'
   */
  placement: import_prop_types36.default.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
  /**
   * Options provided to the [`Popper.js`](https://popper.js.org/docs/v2/constructors/#options) instance.
   * @default {}
   */
  popperOptions: import_prop_types36.default.shape({
    modifiers: import_prop_types36.default.array,
    onFirstUpdate: import_prop_types36.default.func,
    placement: import_prop_types36.default.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
    strategy: import_prop_types36.default.oneOf(["absolute", "fixed"])
  }),
  /**
   * A ref that points to the used popper instance.
   */
  popperRef: refType_default,
  /**
   * The props used for each slot inside the Popper.
   * @default {}
   */
  slotProps: import_prop_types36.default.shape({
    root: import_prop_types36.default.oneOfType([import_prop_types36.default.func, import_prop_types36.default.object])
  }),
  /**
   * The components used for each slot inside the Popper.
   * Either a string to use a HTML element or a component.
   * @default {}
   */
  slots: import_prop_types36.default.shape({
    root: import_prop_types36.default.elementType
  }),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types36.default.oneOfType([import_prop_types36.default.arrayOf(import_prop_types36.default.oneOfType([import_prop_types36.default.func, import_prop_types36.default.object, import_prop_types36.default.bool])), import_prop_types36.default.func, import_prop_types36.default.object]),
  /**
   * Help supporting a react-transition-group/Transition component.
   * @default false
   */
  transition: import_prop_types36.default.bool
} : void 0;
var Popper_default = Popper3;

// node_modules/@mui/material/esm/NoSsr/NoSsr.js
var React73 = __toESM(require_react(), 1);
var import_prop_types37 = __toESM(require_prop_types(), 1);
function NoSsr(props) {
  const {
    children: children2,
    defer = false,
    fallback = null
  } = props;
  const [mountedState, setMountedState] = React73.useState(false);
  useEnhancedEffect_default(() => {
    if (!defer) {
      setMountedState(true);
    }
  }, [defer]);
  React73.useEffect(() => {
    if (defer) {
      setMountedState(true);
    }
  }, [defer]);
  return mountedState ? children2 : fallback;
}
true ? NoSsr.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //  To update them, edit the TypeScript types and run `pnpm proptypes`. 
  // 
  /**
   * You can wrap a node.
   */
  children: import_prop_types37.default.node,
  /**
   * If `true`, the component will not only prevent server-side rendering.
   * It will also defer the rendering of the children into a different screen frame.
   * @default false
   */
  defer: import_prop_types37.default.bool,
  /**
   * The fallback content to display.
   * @default null
   */
  fallback: import_prop_types37.default.node
} : void 0;
if (true) {
  NoSsr["propTypes"] = exactProp(NoSsr.propTypes);
}
var NoSsr_default = NoSsr;

// node_modules/@mui/x-charts/esm/hooks/useAxisSystem.js
function useAxisSystem() {
  const store = useStore();
  const rawRotationAxis = useSelector(store, selectorChartRawRotationAxis);
  const rawXAxis = useSelector(store, selectorChartRawXAxis);
  if (rawRotationAxis !== void 0) {
    return "polar";
  }
  if (rawXAxis !== void 0) {
    return "cartesian";
  }
  return "none";
}

// node_modules/@mui/x-charts/esm/ChartsTooltip/ChartsTooltipContainer.js
var import_jsx_runtime39 = __toESM(require_jsx_runtime(), 1);
var _excluded8 = ["trigger", "classes", "children"];
var noAxis = () => false;
var ChartsTooltipRoot = styled_default2(Popper_default, {
  name: "MuiChartsTooltip",
  slot: "Root"
})(({
  theme
}) => ({
  pointerEvents: "none",
  zIndex: theme.zIndex.modal
}));
function ChartsTooltipContainer(inProps) {
  const props = useThemeProps2({
    props: inProps,
    name: "MuiChartsTooltipContainer"
  });
  const {
    trigger = "axis",
    classes,
    children: children2
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded8);
  const svgRef = useSvgRef();
  const pointerType = usePointerType();
  const popperRef = React74.useRef(null);
  const positionRef = useLazyRef(() => ({
    x: 0,
    y: 0
  }));
  const axisSystem = useAxisSystem();
  const store = useStore();
  const isOpen = useSelector(store, trigger === "axis" ? axisSystem === "polar" && selectorChartsInteractionPolarAxisTooltip || axisSystem === "cartesian" && selectorChartsInteractionAxisTooltip || noAxis : selectorChartsInteractionItemIsDefined);
  const popperOpen = pointerType !== null && isOpen;
  React74.useEffect(() => {
    const element = svgRef.current;
    if (element === null) {
      return () => {
      };
    }
    const handleMove = (event) => {
      var _a;
      positionRef.current = {
        x: event.clientX,
        y: event.clientY
      };
      (_a = popperRef.current) == null ? void 0 : _a.update();
    };
    element.addEventListener("pointermove", handleMove);
    return () => {
      element.removeEventListener("pointermove", handleMove);
    };
  }, [svgRef, positionRef]);
  const anchorEl = React74.useMemo(() => ({
    getBoundingClientRect: () => ({
      x: positionRef.current.x,
      y: positionRef.current.y,
      top: positionRef.current.y,
      left: positionRef.current.x,
      right: positionRef.current.x,
      bottom: positionRef.current.y,
      width: 0,
      height: 0,
      toJSON: () => ""
    })
  }), [positionRef]);
  const modifiers = React74.useMemo(() => [{
    name: "offset",
    options: {
      offset: () => {
        if ((pointerType == null ? void 0 : pointerType.pointerType) !== "touch") {
          return [0, 8];
        }
        return [0, 64];
      }
    }
  }, ...(pointerType == null ? void 0 : pointerType.pointerType) === "mouse" ? [] : [{
    name: "flip",
    options: {
      fallbackPlacements: ["top-end", "top-start", "bottom-end", "bottom"]
    }
  }]], [pointerType]);
  if (trigger === "none") {
    return null;
  }
  return (0, import_jsx_runtime39.jsx)(NoSsr_default, {
    children: popperOpen && (0, import_jsx_runtime39.jsx)(ChartsTooltipRoot, _extends({
      className: classes == null ? void 0 : classes.root,
      open: popperOpen,
      placement: (pointerType == null ? void 0 : pointerType.pointerType) === "mouse" ? "right-start" : "top",
      popperRef,
      anchorEl,
      modifiers
    }, other, {
      children: children2
    }))
  });
}
true ? ChartsTooltipContainer.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * An HTML element, [virtualElement](https://popper.js.org/docs/v2/virtual-elements/),
   * or a function that returns either.
   * It's used to set the position of the popper.
   * The return value will passed as the reference object of the Popper instance.
   */
  anchorEl: import_prop_types38.default.oneOfType([HTMLElementType, import_prop_types38.default.object, import_prop_types38.default.func]),
  /**
   * Popper render function or node.
   */
  children: import_prop_types38.default.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types38.default.object,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: import_prop_types38.default.elementType,
  /**
   * The components used for each slot inside the Popper.
   * Either a string to use a HTML element or a component.
   *
   * @deprecated use the `slots` prop instead. This prop will be removed in a future major release. [How to migrate](/material-ui/migration/migrating-from-deprecated-apis/).
   * @default {}
   */
  components: import_prop_types38.default.shape({
    Root: import_prop_types38.default.elementType
  }),
  /**
   * The props used for each slot inside the Popper.
   *
   * @deprecated use the `slotProps` prop instead. This prop will be removed in a future major release. [How to migrate](/material-ui/migration/migrating-from-deprecated-apis/).
   * @default {}
   */
  componentsProps: import_prop_types38.default.shape({
    root: import_prop_types38.default.oneOfType([import_prop_types38.default.func, import_prop_types38.default.object])
  }),
  /**
   * An HTML element or function that returns one.
   * The `container` will have the portal children appended to it.
   *
   * You can also provide a callback, which is called in a React layout effect.
   * This lets you set the container from a ref, and also makes server-side rendering possible.
   *
   * By default, it uses the body of the top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: import_prop_types38.default.oneOfType([(props, propName) => {
    if (props[propName] == null) {
      return new Error(`Prop '${propName}' is required but wasn't specified`);
    }
    if (typeof props[propName] !== "object" || props[propName].nodeType !== 1) {
      return new Error(`Expected prop '${propName}' to be of type Element`);
    }
    return null;
  }, import_prop_types38.default.func]),
  /**
   * The `children` will be under the DOM hierarchy of the parent component.
   * @default false
   */
  disablePortal: import_prop_types38.default.bool,
  /**
   * Always keep the children in the DOM.
   * This prop can be useful in SEO situation or
   * when you want to maximize the responsiveness of the Popper.
   * @default false
   */
  keepMounted: import_prop_types38.default.bool,
  /**
   * Popper.js is based on a "plugin-like" architecture,
   * most of its features are fully encapsulated "modifiers".
   *
   * A modifier is a function that is called each time Popper.js needs to
   * compute the position of the popper.
   * For this reason, modifiers should be very performant to avoid bottlenecks.
   * To learn how to create a modifier, [read the modifiers documentation](https://popper.js.org/docs/v2/modifiers/).
   */
  modifiers: import_prop_types38.default.arrayOf(import_prop_types38.default.shape({
    data: import_prop_types38.default.object,
    effect: import_prop_types38.default.func,
    enabled: import_prop_types38.default.bool,
    fn: import_prop_types38.default.func,
    name: import_prop_types38.default.any,
    options: import_prop_types38.default.object,
    phase: import_prop_types38.default.oneOf(["afterMain", "afterRead", "afterWrite", "beforeMain", "beforeRead", "beforeWrite", "main", "read", "write"]),
    requires: import_prop_types38.default.arrayOf(import_prop_types38.default.string),
    requiresIfExists: import_prop_types38.default.arrayOf(import_prop_types38.default.string)
  })),
  /**
   * If `true`, the component is shown.
   */
  open: import_prop_types38.default.bool,
  /**
   * Popper placement.
   * @default 'bottom'
   */
  placement: import_prop_types38.default.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
  /**
   * Options provided to the [`Popper.js`](https://popper.js.org/docs/v2/constructors/#options) instance.
   * @default {}
   */
  popperOptions: import_prop_types38.default.shape({
    modifiers: import_prop_types38.default.array,
    onFirstUpdate: import_prop_types38.default.func,
    placement: import_prop_types38.default.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
    strategy: import_prop_types38.default.oneOf(["absolute", "fixed"])
  }),
  /**
   * A ref that points to the used popper instance.
   */
  popperRef: import_prop_types38.default.oneOfType([import_prop_types38.default.func, import_prop_types38.default.shape({
    current: import_prop_types38.default.shape({
      destroy: import_prop_types38.default.func.isRequired,
      forceUpdate: import_prop_types38.default.func.isRequired,
      setOptions: import_prop_types38.default.func.isRequired,
      state: import_prop_types38.default.shape({
        attributes: import_prop_types38.default.object.isRequired,
        elements: import_prop_types38.default.object.isRequired,
        modifiersData: import_prop_types38.default.object.isRequired,
        options: import_prop_types38.default.object.isRequired,
        orderedModifiers: import_prop_types38.default.arrayOf(import_prop_types38.default.object).isRequired,
        placement: import_prop_types38.default.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]).isRequired,
        rects: import_prop_types38.default.object.isRequired,
        reset: import_prop_types38.default.bool.isRequired,
        scrollParents: import_prop_types38.default.object.isRequired,
        strategy: import_prop_types38.default.oneOf(["absolute", "fixed"]).isRequired,
        styles: import_prop_types38.default.object.isRequired
      }).isRequired,
      update: import_prop_types38.default.func.isRequired
    })
  })]),
  /**
   * The props used for each slot inside the Popper.
   * @default {}
   */
  slotProps: import_prop_types38.default.object,
  /**
   * The components used for each slot inside the Popper.
   * Either a string to use a HTML element or a component.
   * @default {}
   */
  slots: import_prop_types38.default.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types38.default.oneOfType([import_prop_types38.default.arrayOf(import_prop_types38.default.oneOfType([import_prop_types38.default.func, import_prop_types38.default.object, import_prop_types38.default.bool])), import_prop_types38.default.func, import_prop_types38.default.object]),
  /**
   * Help supporting a react-transition-group/Transition component.
   * @default false
   */
  transition: import_prop_types38.default.bool,
  /**
   * Select the kind of tooltip to display
   * - 'item': Shows data about the item below the mouse.
   * - 'axis': Shows values associated with the hovered x value
   * - 'none': Does not display tooltip
   * @default 'axis'
   */
  trigger: import_prop_types38.default.oneOf(["axis", "item", "none"])
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsTooltip/ChartsTooltip.js
var import_jsx_runtime40 = __toESM(require_jsx_runtime(), 1);
function ChartsTooltip(props) {
  const {
    classes: propClasses,
    trigger = "axis"
  } = props;
  const classes = useUtilityClasses6(propClasses);
  return (0, import_jsx_runtime40.jsx)(ChartsTooltipContainer, _extends({}, props, {
    classes,
    children: trigger === "axis" ? (0, import_jsx_runtime40.jsx)(ChartsAxisTooltipContent, {
      classes
    }) : (0, import_jsx_runtime40.jsx)(ChartsItemTooltipContent, {
      classes
    })
  }));
}
true ? ChartsTooltip.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * An HTML element, [virtualElement](https://popper.js.org/docs/v2/virtual-elements/),
   * or a function that returns either.
   * It's used to set the position of the popper.
   * The return value will passed as the reference object of the Popper instance.
   */
  anchorEl: import_prop_types39.default.oneOfType([HTMLElementType, import_prop_types39.default.object, import_prop_types39.default.func]),
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types39.default.object,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: import_prop_types39.default.elementType,
  /**
   * The components used for each slot inside the Popper.
   * Either a string to use a HTML element or a component.
   *
   * @deprecated use the `slots` prop instead. This prop will be removed in a future major release. [How to migrate](/material-ui/migration/migrating-from-deprecated-apis/).
   * @default {}
   */
  components: import_prop_types39.default.shape({
    Root: import_prop_types39.default.elementType
  }),
  /**
   * The props used for each slot inside the Popper.
   *
   * @deprecated use the `slotProps` prop instead. This prop will be removed in a future major release. [How to migrate](/material-ui/migration/migrating-from-deprecated-apis/).
   * @default {}
   */
  componentsProps: import_prop_types39.default.shape({
    root: import_prop_types39.default.oneOfType([import_prop_types39.default.func, import_prop_types39.default.object])
  }),
  /**
   * An HTML element or function that returns one.
   * The `container` will have the portal children appended to it.
   *
   * You can also provide a callback, which is called in a React layout effect.
   * This lets you set the container from a ref, and also makes server-side rendering possible.
   *
   * By default, it uses the body of the top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: import_prop_types39.default.oneOfType([(props, propName) => {
    if (props[propName] == null) {
      return new Error(`Prop '${propName}' is required but wasn't specified`);
    }
    if (typeof props[propName] !== "object" || props[propName].nodeType !== 1) {
      return new Error(`Expected prop '${propName}' to be of type Element`);
    }
    return null;
  }, import_prop_types39.default.func]),
  /**
   * The `children` will be under the DOM hierarchy of the parent component.
   * @default false
   */
  disablePortal: import_prop_types39.default.bool,
  /**
   * Always keep the children in the DOM.
   * This prop can be useful in SEO situation or
   * when you want to maximize the responsiveness of the Popper.
   * @default false
   */
  keepMounted: import_prop_types39.default.bool,
  /**
   * Popper.js is based on a "plugin-like" architecture,
   * most of its features are fully encapsulated "modifiers".
   *
   * A modifier is a function that is called each time Popper.js needs to
   * compute the position of the popper.
   * For this reason, modifiers should be very performant to avoid bottlenecks.
   * To learn how to create a modifier, [read the modifiers documentation](https://popper.js.org/docs/v2/modifiers/).
   */
  modifiers: import_prop_types39.default.arrayOf(import_prop_types39.default.shape({
    data: import_prop_types39.default.object,
    effect: import_prop_types39.default.func,
    enabled: import_prop_types39.default.bool,
    fn: import_prop_types39.default.func,
    name: import_prop_types39.default.any,
    options: import_prop_types39.default.object,
    phase: import_prop_types39.default.oneOf(["afterMain", "afterRead", "afterWrite", "beforeMain", "beforeRead", "beforeWrite", "main", "read", "write"]),
    requires: import_prop_types39.default.arrayOf(import_prop_types39.default.string),
    requiresIfExists: import_prop_types39.default.arrayOf(import_prop_types39.default.string)
  })),
  /**
   * If `true`, the component is shown.
   */
  open: import_prop_types39.default.bool,
  /**
   * Popper placement.
   * @default 'bottom'
   */
  placement: import_prop_types39.default.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
  /**
   * Options provided to the [`Popper.js`](https://popper.js.org/docs/v2/constructors/#options) instance.
   * @default {}
   */
  popperOptions: import_prop_types39.default.shape({
    modifiers: import_prop_types39.default.array,
    onFirstUpdate: import_prop_types39.default.func,
    placement: import_prop_types39.default.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
    strategy: import_prop_types39.default.oneOf(["absolute", "fixed"])
  }),
  /**
   * A ref that points to the used popper instance.
   */
  popperRef: import_prop_types39.default.oneOfType([import_prop_types39.default.func, import_prop_types39.default.shape({
    current: import_prop_types39.default.shape({
      destroy: import_prop_types39.default.func.isRequired,
      forceUpdate: import_prop_types39.default.func.isRequired,
      setOptions: import_prop_types39.default.func.isRequired,
      state: import_prop_types39.default.shape({
        attributes: import_prop_types39.default.object.isRequired,
        elements: import_prop_types39.default.object.isRequired,
        modifiersData: import_prop_types39.default.object.isRequired,
        options: import_prop_types39.default.object.isRequired,
        orderedModifiers: import_prop_types39.default.arrayOf(import_prop_types39.default.object).isRequired,
        placement: import_prop_types39.default.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]).isRequired,
        rects: import_prop_types39.default.object.isRequired,
        reset: import_prop_types39.default.bool.isRequired,
        scrollParents: import_prop_types39.default.object.isRequired,
        strategy: import_prop_types39.default.oneOf(["absolute", "fixed"]).isRequired,
        styles: import_prop_types39.default.object.isRequired
      }).isRequired,
      update: import_prop_types39.default.func.isRequired
    })
  })]),
  /**
   * The props used for each slot inside the Popper.
   * @default {}
   */
  slotProps: import_prop_types39.default.object,
  /**
   * The components used for each slot inside the Popper.
   * Either a string to use a HTML element or a component.
   * @default {}
   */
  slots: import_prop_types39.default.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types39.default.oneOfType([import_prop_types39.default.arrayOf(import_prop_types39.default.oneOfType([import_prop_types39.default.func, import_prop_types39.default.object, import_prop_types39.default.bool])), import_prop_types39.default.func, import_prop_types39.default.object]),
  /**
   * Help supporting a react-transition-group/Transition component.
   * @default false
   */
  transition: import_prop_types39.default.bool,
  /**
   * Select the kind of tooltip to display
   * - 'item': Shows data about the item below the mouse.
   * - 'axis': Shows values associated with the hovered x value
   * - 'none': Does not display tooltip
   * @default 'axis'
   */
  trigger: import_prop_types39.default.oneOf(["axis", "item", "none"])
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsLabel/labelClasses.js
function getLabelUtilityClass(slot) {
  return generateUtilityClass("MuiChartsLabel", slot);
}
var labelClasses = generateUtilityClasses("MuiChartsLabel", ["root"]);
var useUtilityClasses9 = (props) => {
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getLabelUtilityClass, props.classes);
};

// node_modules/@mui/x-charts/esm/ChartsLabel/labelGradientClasses.js
function getLabelGradientUtilityClass(slot) {
  return generateUtilityClass("MuiChartsLabelGradient", slot);
}
var labelGradientClasses = generateUtilityClasses("MuiChartsLabelGradient", ["root", "vertical", "horizontal", "mask", "fill"]);
var useUtilityClasses10 = (props) => {
  const {
    direction
  } = props;
  const slots = {
    root: ["root", direction],
    mask: ["mask"],
    fill: ["fill"]
  };
  return composeClasses(slots, getLabelGradientUtilityClass, props.classes);
};

// node_modules/@mui/x-charts/esm/ChartsLegend/ChartsLegend.js
var React78 = __toESM(require_react(), 1);
var import_prop_types41 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/ChartsLegend/onClickContextBuilder.js
var seriesContextBuilder = (context) => ({
  type: "series",
  color: context.color,
  label: context.label,
  seriesId: context.seriesId,
  itemId: context.itemId
});

// node_modules/@mui/x-charts/esm/ChartsLegend/chartsLegendClasses.js
function getLegendUtilityClass(slot) {
  return generateUtilityClass("MuiChartsLegend", slot);
}
var useUtilityClasses11 = (props) => {
  const {
    classes,
    direction
  } = props;
  const slots = {
    root: ["root", direction],
    mark: ["mark"],
    label: ["label"],
    series: ["series"]
  };
  return composeClasses(slots, getLegendUtilityClass, classes);
};
var legendClasses = generateUtilityClasses("MuiChartsLegend", ["root", "series", "mark", "label", "vertical", "horizontal"]);

// node_modules/@mui/x-charts/esm/internals/consumeSlots.js
var React76 = __toESM(require_react(), 1);
var import_jsx_runtime41 = __toESM(require_jsx_runtime(), 1);
var _excluded9 = ["slots", "slotProps"];
var _excluded23 = ["ownerState"];
var consumeSlots = (name, slotPropName, options, InComponent) => {
  function ConsumeSlotsInternal(props, ref) {
    var _a;
    const themedProps = useThemeProps2({
      props,
      // eslint-disable-next-line material-ui/mui-name-matches-component-name
      name
    });
    const defaultProps4 = typeof options.defaultProps === "function" ? options.defaultProps(themedProps) : options.defaultProps ?? {};
    const defaultizedProps = resolveProps(defaultProps4, themedProps);
    const _ref = defaultizedProps, {
      slots,
      slotProps
    } = _ref, other = _objectWithoutPropertiesLoose(_ref, _excluded9);
    const theme = useTheme4();
    const classes = (_a = options.classesResolver) == null ? void 0 : _a.call(options, defaultizedProps, theme);
    const Component = (slots == null ? void 0 : slots[slotPropName]) ?? InComponent;
    const propagateSlots = options.propagateSlots && !(slots == null ? void 0 : slots[slotPropName]);
    const _useSlotProps = useSlotProps_default({
      elementType: Component,
      externalSlotProps: slotProps == null ? void 0 : slotProps[slotPropName],
      additionalProps: _extends({}, other, {
        classes
      }, propagateSlots && {
        slots,
        slotProps
      }),
      ownerState: {}
    }), originalOutProps = _objectWithoutPropertiesLoose(_useSlotProps, _excluded23);
    const outProps = _extends({}, originalOutProps);
    for (const prop of options.omitProps ?? []) {
      delete outProps[prop];
    }
    if (true) {
      Component.displayName = `${name}.slots.${slotPropName}`;
    }
    return (0, import_jsx_runtime41.jsx)(Component, _extends({}, outProps, {
      ref
    }));
  }
  return React76.forwardRef(ConsumeSlotsInternal);
};

// node_modules/@mui/x-charts/esm/ChartsLabel/ChartsLabel.js
var React77 = __toESM(require_react(), 1);
var import_prop_types40 = __toESM(require_prop_types(), 1);
var import_jsx_runtime42 = __toESM(require_jsx_runtime(), 1);
var _excluded10 = ["children", "className", "classes"];
var ChartsLabel = consumeThemeProps("MuiChartsLabel", {
  classesResolver: useUtilityClasses9
}, function ChartsLabel2(props, ref) {
  const {
    children: children2,
    className,
    classes
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded10);
  return (0, import_jsx_runtime42.jsx)("span", _extends({
    className: clsx_default(classes == null ? void 0 : classes.root, className),
    ref
  }, other, {
    children: children2
  }));
});
true ? ChartsLabel.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  children: import_prop_types40.default.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types40.default.object
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsLegend/ChartsLegend.js
var import_jsx_runtime43 = __toESM(require_jsx_runtime(), 1);
var _excluded11 = ["direction", "onItemClick", "className", "classes"];
var RootElement = styled_default2("ul", {
  name: "MuiChartsLegend",
  slot: "Root"
})(({
  ownerState,
  theme
}) => _extends({}, theme.typography.caption, {
  color: (theme.vars || theme).palette.text.primary,
  lineHeight: "100%",
  display: "flex",
  flexDirection: ownerState.direction === "vertical" ? "column" : "row",
  alignItems: ownerState.direction === "vertical" ? void 0 : "center",
  flexShrink: 0,
  gap: theme.spacing(2),
  listStyleType: "none",
  paddingInlineStart: 0,
  marginBlock: theme.spacing(1),
  marginInline: theme.spacing(1),
  flexWrap: "wrap",
  li: {
    display: ownerState.direction === "horizontal" ? "inline-flex" : void 0
  },
  [`button.${legendClasses.series}`]: {
    // Reset button styles
    background: "none",
    border: "none",
    padding: 0,
    fontFamily: "inherit",
    fontWeight: "inherit",
    fontSize: "inherit",
    letterSpacing: "inherit",
    color: "inherit"
  },
  [`& .${legendClasses.series}`]: {
    display: ownerState.direction === "vertical" ? "flex" : "inline-flex",
    alignItems: "center",
    gap: theme.spacing(1)
  }
}));
var ChartsLegend = consumeSlots("MuiChartsLegend", "legend", {
  defaultProps: {
    direction: "horizontal"
  },
  // @ts-expect-error position is used only in the slots, but it is passed to the SVG wrapper.
  // We omit it here to avoid passing to slots.
  omitProps: ["position"],
  classesResolver: useUtilityClasses11
}, React78.forwardRef(function ChartsLegend2(props, ref) {
  const data = useLegend();
  const {
    onItemClick,
    className,
    classes
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded11);
  if (data.items.length === 0) {
    return null;
  }
  const Element2 = onItemClick ? "button" : "div";
  return (0, import_jsx_runtime43.jsx)(RootElement, _extends({
    className: clsx_default(classes == null ? void 0 : classes.root, className),
    ref
  }, other, {
    ownerState: props,
    children: data.items.map((item, i2) => {
      return (0, import_jsx_runtime43.jsx)("li", {
        children: (0, import_jsx_runtime43.jsxs)(Element2, {
          className: classes == null ? void 0 : classes.series,
          role: onItemClick ? "button" : void 0,
          type: onItemClick ? "button" : void 0,
          onClick: onItemClick ? (
            // @ts-ignore onClick is only attached to a button
            (event) => onItemClick(event, seriesContextBuilder(item), i2)
          ) : void 0,
          children: [(0, import_jsx_runtime43.jsx)(ChartsLabelMark, {
            className: classes == null ? void 0 : classes.mark,
            color: item.color,
            type: item.markType
          }), (0, import_jsx_runtime43.jsx)(ChartsLabel, {
            className: classes == null ? void 0 : classes.label,
            children: item.label
          })]
        })
      }, item.id);
    })
  }));
}));
true ? ChartsLegend.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types41.default.object,
  className: import_prop_types41.default.string,
  /**
   * The direction of the legend layout.
   * The default depends on the chart.
   */
  direction: import_prop_types41.default.oneOf(["horizontal", "vertical"]),
  /**
   * Callback fired when a legend item is clicked.
   * @param {React.MouseEvent<HTMLButtonElement, MouseEvent>} event The click event.
   * @param {SeriesLegendItemContext} legendItem The legend item data.
   * @param {number} index The index of the clicked legend item.
   */
  onItemClick: import_prop_types41.default.func,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types41.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types41.default.object,
  sx: import_prop_types41.default.oneOfType([import_prop_types41.default.arrayOf(import_prop_types41.default.oneOfType([import_prop_types41.default.func, import_prop_types41.default.object, import_prop_types41.default.bool])), import_prop_types41.default.func, import_prop_types41.default.object])
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsLegend/ContinuousColorLegend.js
var React80 = __toESM(require_react(), 1);
var import_prop_types43 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/ChartsLegend/useAxis.js
function useAxis({
  axisDirection,
  axisId
}) {
  const {
    xAxis,
    xAxisIds
  } = useXAxes();
  const {
    yAxis,
    yAxisIds
  } = useYAxes();
  const {
    zAxis,
    zAxisIds
  } = useZAxes();
  switch (axisDirection) {
    case "x": {
      const id = typeof axisId === "string" ? axisId : xAxisIds[axisId ?? 0];
      return xAxis[id];
    }
    case "y": {
      const id = typeof axisId === "string" ? axisId : yAxisIds[axisId ?? 0];
      return yAxis[id];
    }
    case "z":
    default: {
      const id = typeof axisId === "string" ? axisId : zAxisIds[axisId ?? 0];
      return zAxis[id];
    }
  }
}

// node_modules/@mui/x-charts/esm/ChartsLabel/ChartsLabelGradient.js
var React79 = __toESM(require_react(), 1);
var import_prop_types42 = __toESM(require_prop_types(), 1);
var import_jsx_runtime44 = __toESM(require_jsx_runtime(), 1);
var _excluded12 = ["gradientId", "direction", "classes", "className", "rotate", "reverse", "thickness"];
var getRotation = (direction, reverse2, rotate, isRtl) => {
  const angle = (direction === "vertical" ? -90 : 0) + (rotate ? 90 : 0) + (reverse2 ? 180 : 0);
  if (isRtl && direction !== "vertical") {
    return angle + 180;
  }
  return angle;
};
var Root2 = styled_default2("div", {
  name: "MuiChartsLabelGradient",
  slot: "Root"
})(({
  ownerState
}) => {
  const rotation = getRotation(ownerState.direction, ownerState.reverse, ownerState.rotate, ownerState.isRtl);
  return {
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    [`.${labelGradientClasses.mask}`]: {
      borderRadius: 2,
      overflow: "hidden"
    },
    [`&.${labelGradientClasses.horizontal}`]: {
      width: "100%",
      [`.${labelGradientClasses.mask}`]: {
        height: ownerState.thickness,
        width: "100%"
      }
    },
    [`&.${labelGradientClasses.vertical}`]: {
      height: "100%",
      [`.${labelGradientClasses.mask}`]: {
        width: ownerState.thickness,
        height: "100%",
        "> svg": {
          height: "100%"
        }
      }
    },
    svg: {
      transform: `rotate(${rotation}deg)`,
      display: "block"
    }
  };
});
var ChartsLabelGradient = consumeThemeProps("MuiChartsLabelGradient", {
  defaultProps: {
    direction: "horizontal",
    thickness: 12
  },
  classesResolver: useUtilityClasses10
}, function ChartsLabelGradient2(props, ref) {
  const {
    gradientId,
    classes,
    className
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded12);
  const isRtl = useRtl();
  return (0, import_jsx_runtime44.jsx)(Root2, _extends({
    className: clsx_default(classes == null ? void 0 : classes.root, className),
    ownerState: _extends({}, props, {
      isRtl
    }),
    "aria-hidden": "true",
    ref
  }, other, {
    children: (0, import_jsx_runtime44.jsx)("div", {
      className: classes == null ? void 0 : classes.mask,
      children: (0, import_jsx_runtime44.jsx)("svg", {
        viewBox: "0 0 24 24",
        children: (0, import_jsx_runtime44.jsx)("rect", {
          className: classes == null ? void 0 : classes.fill,
          width: "24",
          height: "24",
          fill: `url(#${gradientId})`
        })
      })
    })
  }));
});
true ? ChartsLabelGradient.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types42.default.object,
  /**
   * The direction of the gradient.
   * @default 'horizontal'
   */
  direction: import_prop_types42.default.oneOf(["vertical", "horizontal"]),
  /**
   * A unique identifier for the gradient.
   * The `gradientId` will be used as `fill="url(#gradientId)"`.
   */
  gradientId: import_prop_types42.default.string.isRequired,
  /**
   * If `true`, the gradient will be reversed.
   */
  reverse: import_prop_types42.default.bool,
  /**
   * If provided, the gradient will be rotated by 90deg.
   * Useful for linear gradients that are not in the correct orientation.
   */
  rotate: import_prop_types42.default.bool,
  /**
   * The thickness of the gradient
   * @default 12
   */
  thickness: import_prop_types42.default.number
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsLegend/continuousColorLegendClasses.js
function getLegendUtilityClass2(slot) {
  return generateUtilityClass("MuiContinuousColorLegend", slot);
}
var useUtilityClasses12 = (props) => {
  const {
    classes,
    direction,
    labelPosition
  } = props;
  const slots = {
    root: ["root", direction, labelPosition],
    minLabel: ["minLabel"],
    maxLabel: ["maxLabel"],
    gradient: ["gradient"],
    mark: ["mark"],
    label: ["label"]
  };
  return composeClasses(slots, getLegendUtilityClass2, classes);
};
var continuousColorLegendClasses = generateUtilityClasses("MuiContinuousColorLegend", ["root", "minLabel", "maxLabel", "gradient", "vertical", "horizontal", "start", "end", "extremes", "label"]);

// node_modules/@mui/x-charts/esm/ChartsLegend/ContinuousColorLegend.js
var import_jsx_runtime45 = __toESM(require_jsx_runtime(), 1);
var _excluded13 = ["minLabel", "maxLabel", "direction", "axisDirection", "axisId", "rotateGradient", "reverse", "classes", "className", "gradientId", "labelPosition", "thickness"];
var templateAreas = (reverse2) => {
  const startLabel = reverse2 ? "max-label" : "min-label";
  const endLabel = reverse2 ? "min-label" : "max-label";
  return {
    row: {
      start: `
    '${startLabel} . ${endLabel}'
    'gradient gradient gradient'
  `,
      end: `
      'gradient gradient gradient'
      '${startLabel} . ${endLabel}'
    `,
      extremes: `
      '${startLabel} gradient ${endLabel}'
    `
    },
    column: {
      start: `
      '${endLabel} gradient'
      '. gradient'
      '${startLabel} gradient'
    `,
      end: `
      'gradient ${endLabel}'
      'gradient .'
      'gradient ${startLabel}'
    `,
      extremes: `
      '${endLabel}'
      'gradient'
      '${startLabel}'
    `
    }
  };
};
var RootElement2 = styled_default2("ul", {
  name: "MuiContinuousColorLegend",
  slot: "Root"
})(({
  theme,
  ownerState
}) => _extends({}, theme.typography.caption, {
  color: (theme.vars || theme).palette.text.primary,
  lineHeight: "100%",
  display: "grid",
  flexShrink: 0,
  gap: theme.spacing(0.5),
  listStyleType: "none",
  paddingInlineStart: 0,
  marginBlock: theme.spacing(1),
  marginInline: theme.spacing(1),
  [`&.${continuousColorLegendClasses.horizontal}`]: {
    gridTemplateRows: "min-content min-content",
    gridTemplateColumns: "min-content auto min-content",
    [`&.${continuousColorLegendClasses.start}`]: {
      gridTemplateAreas: templateAreas(ownerState.reverse).row.start
    },
    [`&.${continuousColorLegendClasses.end}`]: {
      gridTemplateAreas: templateAreas(ownerState.reverse).row.end
    },
    [`&.${continuousColorLegendClasses.extremes}`]: {
      gridTemplateAreas: templateAreas(ownerState.reverse).row.extremes,
      gridTemplateRows: "min-content",
      alignItems: "center"
    }
  },
  [`&.${continuousColorLegendClasses.vertical}`]: {
    gridTemplateRows: "min-content auto min-content",
    gridTemplateColumns: "min-content min-content",
    [`&.${continuousColorLegendClasses.start}`]: {
      gridTemplateAreas: templateAreas(ownerState.reverse).column.start,
      [`.${continuousColorLegendClasses.maxLabel}, .${continuousColorLegendClasses.minLabel}`]: {
        justifySelf: "end"
      }
    },
    [`&.${continuousColorLegendClasses.end}`]: {
      gridTemplateAreas: templateAreas(ownerState.reverse).column.end,
      [`.${continuousColorLegendClasses.maxLabel}, .${continuousColorLegendClasses.minLabel}`]: {
        justifySelf: "start"
      }
    },
    [`&.${continuousColorLegendClasses.extremes}`]: {
      gridTemplateAreas: templateAreas(ownerState.reverse).column.extremes,
      gridTemplateColumns: "min-content",
      [`.${continuousColorLegendClasses.maxLabel}, .${continuousColorLegendClasses.minLabel}`]: {
        justifySelf: "center"
      }
    }
  },
  [`.${continuousColorLegendClasses.gradient}`]: {
    gridArea: "gradient"
  },
  [`.${continuousColorLegendClasses.maxLabel}`]: {
    gridArea: "max-label"
  },
  [`.${continuousColorLegendClasses.minLabel}`]: {
    gridArea: "min-label"
  }
}));
var getText = (label, value, formattedValue) => {
  if (typeof label === "string") {
    return label;
  }
  return (label == null ? void 0 : label({
    value,
    formattedValue
  })) ?? formattedValue;
};
var isZAxis = (axis) => axis.scale === void 0;
var ContinuousColorLegend = consumeThemeProps("MuiContinuousColorLegend", {
  defaultProps: {
    direction: "horizontal",
    labelPosition: "end",
    axisDirection: "z"
  },
  classesResolver: useUtilityClasses12
}, function ContinuousColorLegend2(props, ref) {
  const {
    minLabel,
    maxLabel,
    direction,
    axisDirection,
    axisId,
    rotateGradient,
    reverse: reverse2,
    classes,
    className,
    gradientId,
    thickness
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded13);
  const generateGradientId = useChartGradientIdObjectBoundBuilder();
  const axisItem = useAxis({
    axisDirection,
    axisId
  });
  const colorMap = axisItem == null ? void 0 : axisItem.colorMap;
  if (!colorMap || !colorMap.type || colorMap.type !== "continuous") {
    return null;
  }
  const minValue = colorMap.min ?? 0;
  const maxValue = colorMap.max ?? 100;
  const valueFormatter = isZAxis(axisItem) ? void 0 : axisItem.valueFormatter;
  const formattedMin = valueFormatter ? valueFormatter(minValue, {
    location: "legend"
  }) : minValue.toLocaleString();
  const formattedMax = valueFormatter ? valueFormatter(maxValue, {
    location: "legend"
  }) : maxValue.toLocaleString();
  const minText = getText(minLabel, minValue, formattedMin);
  const maxText = getText(maxLabel, maxValue, formattedMax);
  const minComponent = (0, import_jsx_runtime45.jsx)("li", {
    className: classes == null ? void 0 : classes.minLabel,
    children: (0, import_jsx_runtime45.jsx)(ChartsLabel, {
      className: classes == null ? void 0 : classes.label,
      children: minText
    })
  });
  const maxComponent = (0, import_jsx_runtime45.jsx)("li", {
    className: classes == null ? void 0 : classes.maxLabel,
    children: (0, import_jsx_runtime45.jsx)(ChartsLabel, {
      className: classes == null ? void 0 : classes.label,
      children: maxText
    })
  });
  return (0, import_jsx_runtime45.jsxs)(RootElement2, _extends({
    className: clsx_default(classes == null ? void 0 : classes.root, className),
    ref
  }, other, {
    ownerState: props,
    children: [reverse2 ? maxComponent : minComponent, (0, import_jsx_runtime45.jsx)("li", {
      className: classes == null ? void 0 : classes.gradient,
      children: (0, import_jsx_runtime45.jsx)(ChartsLabelGradient, {
        direction,
        rotate: rotateGradient,
        reverse: reverse2,
        thickness,
        gradientId: gradientId ?? generateGradientId(axisItem.id)
      })
    }), reverse2 ? minComponent : maxComponent]
  }));
});
true ? ContinuousColorLegend.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The axis direction containing the color configuration to represent.
   * @default 'z'
   */
  axisDirection: import_prop_types43.default.oneOf(["x", "y", "z"]),
  /**
   * The id of the axis item with the color configuration to represent.
   * @default The first axis item.
   */
  axisId: import_prop_types43.default.oneOfType([import_prop_types43.default.number, import_prop_types43.default.string]),
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types43.default.object,
  className: import_prop_types43.default.string,
  /**
   * The direction of the legend layout.
   * @default 'horizontal'
   */
  direction: import_prop_types43.default.oneOf(["horizontal", "vertical"]),
  /**
   * The id for the gradient to use.
   * If not provided, it will use the generated gradient from the axis configuration.
   * The `gradientId` will be used as `fill="url(#gradientId)"`.
   * @default auto-generated id
   */
  gradientId: import_prop_types43.default.string,
  /**
   * Where to position the labels relative to the gradient.
   * @default 'end'
   */
  labelPosition: import_prop_types43.default.oneOf(["start", "end", "extremes"]),
  /**
   * The label to display at the maximum side of the gradient.
   * Can either be a string, or a function.
   * If not defined, the formatted maximal value is display.
   * @default formattedValue
   */
  maxLabel: import_prop_types43.default.oneOfType([import_prop_types43.default.func, import_prop_types43.default.string]),
  /**
   * The label to display at the minimum side of the gradient.
   * Can either be a string, or a function.
   * @default formattedValue
   */
  minLabel: import_prop_types43.default.oneOfType([import_prop_types43.default.func, import_prop_types43.default.string]),
  /**
   * If `true`, the gradient and labels will be reversed.
   * @default false
   */
  reverse: import_prop_types43.default.bool,
  /**
   * If provided, the gradient will be rotated by 90deg.
   * Useful for linear gradients that are not in the correct orientation.
   */
  rotateGradient: import_prop_types43.default.bool,
  /**
   * The thickness of the gradient
   * @default 12
   */
  thickness: import_prop_types43.default.number,
  sx: import_prop_types43.default.oneOfType([import_prop_types43.default.arrayOf(import_prop_types43.default.oneOfType([import_prop_types43.default.func, import_prop_types43.default.object, import_prop_types43.default.bool])), import_prop_types43.default.func, import_prop_types43.default.object])
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsLegend/PiecewiseColorLegend.js
var React81 = __toESM(require_react(), 1);
var import_prop_types44 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/ChartsLegend/piecewiseColorLegendClasses.js
function getLegendUtilityClass3(slot) {
  return generateUtilityClass("MuiPiecewiseColorLegendClasses", slot);
}
var useUtilityClasses13 = (props) => {
  const {
    classes,
    direction,
    labelPosition
  } = props;
  const slots = {
    root: ["root", direction, labelPosition],
    minLabel: ["minLabel"],
    maxLabel: ["maxLabel"],
    item: ["item"],
    mark: ["mark"],
    label: ["label"]
  };
  return composeClasses(slots, getLegendUtilityClass3, classes);
};
var piecewiseColorLegendClasses = generateUtilityClasses("MuiPiecewiseColorLegendClasses", ["root", "minLabel", "maxLabel", "item", "vertical", "horizontal", "start", "end", "extremes", "mark", "label"]);

// node_modules/@mui/x-charts/esm/ChartsLegend/piecewiseColorDefaultLabelFormatter.js
function piecewiseColorDefaultLabelFormatter(params) {
  if (params.min === null) {
    return `<${params.formattedMax}`;
  }
  if (params.max === null) {
    return `>${params.formattedMin}`;
  }
  return `${params.formattedMin}-${params.formattedMax}`;
}

// node_modules/@mui/x-charts/esm/ChartsLegend/PiecewiseColorLegend.js
var import_jsx_runtime46 = __toESM(require_jsx_runtime(), 1);
var _excluded14 = ["direction", "classes", "className", "markType", "labelPosition", "axisDirection", "axisId", "labelFormatter", "onItemClick"];
var RootElement3 = styled_default2("ul", {
  name: "MuiPiecewiseColorLegend",
  slot: "Root"
})(({
  theme,
  ownerState
}) => {
  var _a;
  return _extends({}, theme.typography.caption, {
    color: (theme.vars || theme).palette.text.primary,
    lineHeight: "100%",
    display: "flex",
    flexDirection: ownerState.direction === "vertical" ? "column" : "row",
    flexShrink: 0,
    gap: theme.spacing(0.5),
    listStyleType: "none",
    paddingInlineStart: 0,
    marginBlock: theme.spacing(1),
    marginInline: theme.spacing(1),
    width: "max-content",
    [`button.${piecewiseColorLegendClasses.item}`]: {
      // Reset button styles
      background: "none",
      border: "none",
      padding: 0,
      cursor: ownerState.onItemClick ? "pointer" : "unset",
      fontFamily: "inherit",
      fontWeight: "inherit",
      fontSize: "inherit",
      letterSpacing: "inherit",
      color: "inherit"
    },
    [`.${piecewiseColorLegendClasses.item}`]: {
      display: "flex",
      gap: theme.spacing(0.5)
    },
    [`li :not(.${piecewiseColorLegendClasses.minLabel}, .${piecewiseColorLegendClasses.maxLabel}) .${(_a = piecewiseColorLegendClasses) == null ? void 0 : _a.mark}`]: {
      alignSelf: "center"
    },
    [`&.${piecewiseColorLegendClasses.start}`]: {
      alignItems: "end"
    },
    [`&.${piecewiseColorLegendClasses.end}`]: {
      alignItems: "start"
    },
    [`&.${piecewiseColorLegendClasses.horizontal}`]: {
      alignItems: "center",
      [`.${piecewiseColorLegendClasses.item}`]: {
        flexDirection: "column"
      },
      [`&.${piecewiseColorLegendClasses.start}`]: {
        alignItems: "end"
      },
      [`&.${piecewiseColorLegendClasses.end}`]: {
        alignItems: "start"
      },
      [`.${piecewiseColorLegendClasses.minLabel}`]: {
        alignItems: "end"
      },
      [`&.${piecewiseColorLegendClasses.extremes}`]: {
        [`.${piecewiseColorLegendClasses.minLabel}, .${piecewiseColorLegendClasses.maxLabel}`]: {
          alignItems: "center",
          display: "flex",
          flexDirection: "row"
        }
      }
    },
    [`&.${piecewiseColorLegendClasses.vertical}`]: {
      [`.${piecewiseColorLegendClasses.item}`]: {
        flexDirection: "row",
        alignItems: "center"
      },
      [`&.${piecewiseColorLegendClasses.start}`]: {
        alignItems: "end"
      },
      [`&.${piecewiseColorLegendClasses.end}`]: {
        alignItems: "start"
      },
      [`&.${piecewiseColorLegendClasses.extremes}`]: {
        alignItems: "center",
        [`.${piecewiseColorLegendClasses.minLabel}, .${piecewiseColorLegendClasses.maxLabel}`]: {
          alignItems: "center",
          display: "flex",
          flexDirection: "column"
        }
      }
    }
  });
});
var PiecewiseColorLegend = consumeThemeProps("MuiPiecewiseColorLegend", {
  defaultProps: {
    direction: "horizontal",
    labelPosition: "extremes",
    labelFormatter: piecewiseColorDefaultLabelFormatter
  },
  classesResolver: useUtilityClasses13
}, function PiecewiseColorLegend2(props, ref) {
  const {
    direction,
    classes,
    className,
    markType,
    labelPosition,
    axisDirection,
    axisId,
    labelFormatter,
    onItemClick
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded14);
  const isVertical = direction === "vertical";
  const isReverse = isVertical;
  const axisItem = useAxis({
    axisDirection,
    axisId
  });
  const colorMap = axisItem == null ? void 0 : axisItem.colorMap;
  if (!colorMap || !colorMap.type || colorMap.type !== "piecewise") {
    return null;
  }
  const valueFormatter = (v3) => {
    var _a;
    return ((_a = axisItem.valueFormatter) == null ? void 0 : _a.call(axisItem, v3, {
      location: "legend"
    })) ?? v3.toLocaleString();
  };
  const formattedLabels = colorMap.thresholds.map(valueFormatter);
  const startClass = isReverse ? classes == null ? void 0 : classes.maxLabel : classes == null ? void 0 : classes.minLabel;
  const endClass = isReverse ? classes == null ? void 0 : classes.minLabel : classes == null ? void 0 : classes.maxLabel;
  const colors = colorMap.colors.map((color3, colorIndex) => ({
    color: color3,
    colorIndex
  }));
  const orderedColors = isReverse ? colors.reverse() : colors;
  const isStart = labelPosition === "start";
  const isEnd = labelPosition === "end";
  const isExtremes = labelPosition === "extremes";
  return (0, import_jsx_runtime46.jsx)(RootElement3, _extends({
    className: clsx_default(classes == null ? void 0 : classes.root, className),
    ref
  }, other, {
    ownerState: props,
    children: orderedColors.map(({
      color: color3,
      colorIndex
    }, index2) => {
      const isFirst = index2 === 0;
      const isLast = index2 === colorMap.colors.length - 1;
      const isFirstColor = colorIndex === 0;
      const isLastColor = colorIndex === colorMap.colors.length - 1;
      const data = _extends({
        index: colorIndex,
        length: formattedLabels.length
      }, isFirstColor ? {
        min: null,
        formattedMin: null
      } : {
        min: colorMap.thresholds[colorIndex - 1],
        formattedMin: formattedLabels[colorIndex - 1]
      }, isLastColor ? {
        max: null,
        formattedMax: null
      } : {
        max: colorMap.thresholds[colorIndex],
        formattedMax: formattedLabels[colorIndex]
      });
      const label = labelFormatter == null ? void 0 : labelFormatter(data);
      if (label === null || label === void 0) {
        return null;
      }
      const isTextBefore = isStart || isExtremes && isFirst;
      const isTextAfter = isEnd || isExtremes && isLast;
      const clickObject = {
        type: "piecewiseColor",
        color: color3,
        label,
        minValue: data.min,
        maxValue: data.max
      };
      const Element2 = onItemClick ? "button" : "div";
      return (0, import_jsx_runtime46.jsx)("li", {
        children: (0, import_jsx_runtime46.jsxs)(Element2, {
          role: onItemClick ? "button" : void 0,
          type: onItemClick ? "button" : void 0,
          onClick: (
            // @ts-ignore onClick is only attached to a button
            onItemClick ? (event) => onItemClick(event, clickObject, index2) : void 0
          ),
          className: clsx_default(classes == null ? void 0 : classes.item, index2 === 0 && `${startClass}`, index2 === orderedColors.length - 1 && `${endClass}`),
          children: [isTextBefore && (0, import_jsx_runtime46.jsx)(ChartsLabel, {
            className: classes == null ? void 0 : classes.label,
            children: label
          }), (0, import_jsx_runtime46.jsx)(ChartsLabelMark, {
            className: classes == null ? void 0 : classes.mark,
            type: markType,
            color: color3
          }), isTextAfter && (0, import_jsx_runtime46.jsx)(ChartsLabel, {
            className: classes == null ? void 0 : classes.label,
            children: label
          })]
        })
      }, colorIndex);
    })
  }));
});
true ? PiecewiseColorLegend.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The axis direction containing the color configuration to represent.
   * @default 'z'
   */
  axisDirection: import_prop_types44.default.oneOf(["x", "y", "z"]),
  /**
   * The id of the axis item with the color configuration to represent.
   * @default The first axis item.
   */
  axisId: import_prop_types44.default.oneOfType([import_prop_types44.default.number, import_prop_types44.default.string]),
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types44.default.object,
  className: import_prop_types44.default.string,
  /**
   * The direction of the legend layout.
   * @default 'horizontal'
   */
  direction: import_prop_types44.default.oneOf(["horizontal", "vertical"]),
  /**
   * Format the legend labels.
   * @param {PiecewiseLabelFormatterParams} params The bound of the piece to format.
   * @returns {string|null} The displayed label, `''` to skip the label but show the color mark, or `null` to skip it entirely.
   */
  labelFormatter: import_prop_types44.default.func,
  /**
   * Where to position the labels relative to the gradient.
   * @default 'extremes'
   */
  labelPosition: import_prop_types44.default.oneOf(["start", "end", "extremes"]),
  /**
   * The type of the mark.
   * @default 'square'
   */
  markType: import_prop_types44.default.oneOf(["square", "circle", "line"]),
  /**
   * Callback fired when a legend item is clicked.
   * @param {React.MouseEvent<HTMLButtonElement, MouseEvent>} event The click event.
   * @param {PiecewiseColorLegendItemContext} legendItem The legend item data.
   * @param {number} index The index of the clicked legend item.
   */
  onItemClick: import_prop_types44.default.func,
  sx: import_prop_types44.default.oneOfType([import_prop_types44.default.arrayOf(import_prop_types44.default.oneOfType([import_prop_types44.default.func, import_prop_types44.default.object, import_prop_types44.default.bool])), import_prop_types44.default.func, import_prop_types44.default.object])
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsAxisHighlight/ChartsAxisHighlight.js
var React84 = __toESM(require_react(), 1);
var import_prop_types45 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/ChartsAxisHighlight/chartsAxisHighlightClasses.js
function getAxisHighlightUtilityClass(slot) {
  return generateUtilityClass("MuiChartsAxisHighlight", slot);
}
var chartsAxisHighlightClasses = generateUtilityClasses("MuiChartsAxisHighlight", ["root"]);

// node_modules/@mui/x-charts/esm/ChartsAxisHighlight/ChartsYAxisHighlight.js
var React82 = __toESM(require_react(), 1);

// node_modules/@mui/x-charts/esm/ChartsAxisHighlight/ChartsAxisHighlightPath.js
var ChartsAxisHighlightPath = styled_default2("path", {
  name: "MuiChartsAxisHighlight",
  slot: "Root"
})(({
  theme
}) => ({
  pointerEvents: "none",
  variants: [{
    props: {
      axisHighlight: "band"
    },
    style: _extends({
      fill: "white",
      fillOpacity: 0.1
    }, theme.applyStyles("light", {
      fill: "gray"
    }))
  }, {
    props: {
      axisHighlight: "line"
    },
    style: _extends({
      strokeDasharray: "5 2",
      stroke: "#ffffff"
    }, theme.applyStyles("light", {
      stroke: "#000000"
    }))
  }]
}));

// node_modules/@mui/x-charts/esm/ChartsAxisHighlight/ChartsYAxisHighlight.js
var import_jsx_runtime47 = __toESM(require_jsx_runtime(), 1);
function ChartsYHighlight(props) {
  const {
    type,
    classes
  } = props;
  const {
    left: left3,
    width: width2
  } = useDrawingArea();
  const yScale = useYScale();
  const store = useStore();
  const axisYValue = useSelector(store, selectorChartsInteractionYAxisValue);
  const getYPosition = getValueToPositionMapper(yScale);
  const isBandScaleY = type === "band" && axisYValue !== null && isBandScale(yScale);
  if (true) {
    const isError = isBandScaleY && yScale(axisYValue) === void 0;
    if (isError) {
      console.error([`MUI X Charts: The position value provided for the axis is not valid for the current scale.`, `This probably means something is wrong with the data passed to the chart.`, `The ChartsAxisHighlight component will not be displayed.`].join("\n"));
    }
  }
  return (0, import_jsx_runtime47.jsxs)(React82.Fragment, {
    children: [isBandScaleY && yScale(axisYValue) !== void 0 && (0, import_jsx_runtime47.jsx)(ChartsAxisHighlightPath, {
      d: `M ${left3} ${// @ts-expect-error, yScale value is checked in the statement above
      yScale(axisYValue) - (yScale.step() - yScale.bandwidth()) / 2} l 0 ${yScale.step()} l ${width2} 0 l 0 ${-yScale.step()} Z`,
      className: classes.root,
      ownerState: {
        axisHighlight: "band"
      }
    }), type === "line" && axisYValue !== null && (0, import_jsx_runtime47.jsx)(ChartsAxisHighlightPath, {
      d: `M ${left3} ${getYPosition(axisYValue)} L ${left3 + width2} ${getYPosition(axisYValue)}`,
      className: classes.root,
      ownerState: {
        axisHighlight: "line"
      }
    })]
  });
}

// node_modules/@mui/x-charts/esm/ChartsAxisHighlight/ChartsXAxisHighlight.js
var React83 = __toESM(require_react(), 1);
var import_jsx_runtime48 = __toESM(require_jsx_runtime(), 1);
function ChartsXHighlight(props) {
  const {
    type,
    classes
  } = props;
  const {
    top: top3,
    height: height2
  } = useDrawingArea();
  const xScale = useXScale();
  const store = useStore();
  const axisXValue = useSelector(store, selectorChartsInteractionXAxisValue);
  const getXPosition = getValueToPositionMapper(xScale);
  const isBandScaleX = type === "band" && axisXValue !== null && isBandScale(xScale);
  if (true) {
    const isError = isBandScaleX && xScale(axisXValue) === void 0;
    if (isError) {
      console.error([`MUI X Charts: The position value provided for the axis is not valid for the current scale.`, `This probably means something is wrong with the data passed to the chart.`, `The ChartsAxisHighlight component will not be displayed.`].join("\n"));
    }
  }
  return (0, import_jsx_runtime48.jsxs)(React83.Fragment, {
    children: [isBandScaleX && xScale(axisXValue) !== void 0 && (0, import_jsx_runtime48.jsx)(
      ChartsAxisHighlightPath,
      {
        d: `M ${xScale(axisXValue) - (xScale.step() - xScale.bandwidth()) / 2} ${top3} l ${xScale.step()} 0 l 0 ${height2} l ${-xScale.step()} 0 Z`,
        className: classes.root,
        ownerState: {
          axisHighlight: "band"
        }
      }
    ), type === "line" && axisXValue !== null && (0, import_jsx_runtime48.jsx)(ChartsAxisHighlightPath, {
      d: `M ${getXPosition(axisXValue)} ${top3} L ${getXPosition(axisXValue)} ${top3 + height2}`,
      className: classes.root,
      ownerState: {
        axisHighlight: "line"
      }
    })]
  });
}

// node_modules/@mui/x-charts/esm/ChartsAxisHighlight/ChartsAxisHighlight.js
var import_jsx_runtime49 = __toESM(require_jsx_runtime(), 1);
var useUtilityClasses14 = () => {
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getAxisHighlightUtilityClass);
};
function ChartsAxisHighlight(props) {
  const {
    x: xAxisHighlight,
    y: yAxisHighlight
  } = props;
  const classes = useUtilityClasses14();
  return (0, import_jsx_runtime49.jsxs)(React84.Fragment, {
    children: [xAxisHighlight && (0, import_jsx_runtime49.jsx)(ChartsXHighlight, {
      type: xAxisHighlight,
      classes
    }), yAxisHighlight && (0, import_jsx_runtime49.jsx)(ChartsYHighlight, {
      type: yAxisHighlight,
      classes
    })]
  });
}
true ? ChartsAxisHighlight.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  x: import_prop_types45.default.oneOf(["band", "line", "none"]),
  y: import_prop_types45.default.oneOf(["band", "line", "none"])
} : void 0;

// node_modules/@mui/x-charts/esm/BarChart/BarChart.js
var React105 = __toESM(require_react(), 1);
var import_prop_types52 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/BarChart/BarPlot.js
var React92 = __toESM(require_react(), 1);
var import_prop_types49 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/BarChart/barElementClasses.js
function getBarElementUtilityClass(slot) {
  return generateUtilityClass("MuiBarElement", slot);
}
var barElementClasses = generateUtilityClasses("MuiBarElement", ["root", "highlighted", "faded", "series"]);
var useUtilityClasses15 = (ownerState) => {
  const {
    classes,
    id,
    isHighlighted,
    isFaded
  } = ownerState;
  const slots = {
    root: ["root", `series-${id}`, isHighlighted && "highlighted", isFaded && "faded"]
  };
  return composeClasses(slots, getBarElementUtilityClass, classes);
};

// node_modules/@mui/x-charts/esm/BarChart/BarElement.js
var React87 = __toESM(require_react(), 1);
var import_prop_types46 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/hooks/useInteractionItemProps.js
var React85 = __toESM(require_react(), 1);
var onPointerDown = (event) => {
  if ("hasPointerCapture" in event.currentTarget && event.currentTarget.hasPointerCapture(event.pointerId)) {
    event.currentTarget.releasePointerCapture(event.pointerId);
  }
};
var useInteractionItemProps = (data, skip) => {
  const {
    instance
  } = useChartContext();
  const interactionActive = React85.useRef(false);
  const onPointerEnter = React85.useCallback(() => {
    interactionActive.current = true;
    instance.setItemInteraction({
      type: data.type,
      seriesId: data.seriesId,
      dataIndex: data.dataIndex
    });
    instance.setHighlight({
      seriesId: data.seriesId,
      dataIndex: data.dataIndex
    });
  }, [instance, data.type, data.seriesId, data.dataIndex]);
  const onPointerLeave = React85.useCallback(() => {
    interactionActive.current = false;
    instance.removeItemInteraction({
      type: data.type,
      seriesId: data.seriesId,
      dataIndex: data.dataIndex
    });
    instance.clearHighlight();
  }, [instance, data.type, data.seriesId, data.dataIndex]);
  React85.useEffect(() => {
    return () => {
      if (interactionActive.current) {
        onPointerLeave();
      }
    };
  }, [onPointerLeave]);
  if (skip) {
    return {};
  }
  return {
    onPointerEnter,
    onPointerLeave,
    onPointerDown
  };
};
var useInteractionAllItemProps = (data, skip) => {
  const {
    instance
  } = useChartContext();
  const results = React85.useMemo(() => {
    return data.map((item) => {
      if (skip) {
        return {};
      }
      const onPointerEnter = () => {
        if (!item) {
          return;
        }
        instance.setItemInteraction(item);
        instance.setHighlight({
          seriesId: item.seriesId,
          dataIndex: item.dataIndex
        });
      };
      const onPointerLeave = () => {
        if (!item) {
          return;
        }
        instance.removeItemInteraction(item);
        instance.clearHighlight();
      };
      return {
        onPointerEnter,
        onPointerLeave,
        onPointerDown
      };
    });
  }, [data, instance, skip]);
  return results;
};

// node_modules/@mui/x-charts/esm/BarChart/AnimatedBarElement.js
var React86 = __toESM(require_react(), 1);
var import_jsx_runtime50 = __toESM(require_jsx_runtime(), 1);
var _excluded15 = ["ownerState", "skipAnimation", "id", "dataIndex", "xOrigin", "yOrigin"];
function AnimatedBarElement(props) {
  const {
    ownerState
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded15);
  const animatedProps = useAnimateBar(props);
  return (0, import_jsx_runtime50.jsx)("rect", _extends({}, other, {
    filter: ownerState.isHighlighted ? "brightness(120%)" : void 0,
    opacity: ownerState.isFaded ? 0.3 : 1
  }, animatedProps));
}

// node_modules/@mui/x-charts/esm/BarChart/BarElement.js
var import_jsx_runtime51 = __toESM(require_jsx_runtime(), 1);
var _excluded16 = ["id", "dataIndex", "classes", "color", "slots", "slotProps", "style", "onClick", "skipAnimation", "layout", "x", "xOrigin", "y", "yOrigin", "width", "height"];
function BarElement(props) {
  const {
    id,
    dataIndex,
    classes: innerClasses,
    color: color3,
    slots,
    slotProps,
    style: style4,
    onClick,
    skipAnimation,
    layout,
    x: x3,
    xOrigin,
    y: y3,
    yOrigin,
    width: width2,
    height: height2
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded16);
  const interactionProps = useInteractionItemProps({
    type: "bar",
    seriesId: id,
    dataIndex
  });
  const {
    isFaded,
    isHighlighted
  } = useItemHighlighted({
    seriesId: id,
    dataIndex
  });
  const ownerState = {
    id,
    dataIndex,
    classes: innerClasses,
    color: color3,
    isFaded,
    isHighlighted
  };
  const classes = useUtilityClasses15(ownerState);
  const Bar = (slots == null ? void 0 : slots.bar) ?? AnimatedBarElement;
  const barProps = useSlotProps_default({
    elementType: Bar,
    externalSlotProps: slotProps == null ? void 0 : slotProps.bar,
    externalForwardedProps: other,
    additionalProps: _extends({}, interactionProps, {
      id,
      dataIndex,
      color: color3,
      x: x3,
      xOrigin,
      y: y3,
      yOrigin,
      width: width2,
      height: height2,
      style: style4,
      onClick,
      cursor: onClick ? "pointer" : "unset",
      stroke: "none",
      fill: color3,
      skipAnimation,
      layout
    }),
    className: classes.root,
    ownerState
  });
  return (0, import_jsx_runtime51.jsx)(Bar, _extends({}, barProps));
}
true ? BarElement.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  classes: import_prop_types46.default.object,
  dataIndex: import_prop_types46.default.number.isRequired,
  id: import_prop_types46.default.oneOfType([import_prop_types46.default.number, import_prop_types46.default.string]).isRequired,
  layout: import_prop_types46.default.oneOf(["horizontal", "vertical"]).isRequired,
  skipAnimation: import_prop_types46.default.bool.isRequired,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types46.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types46.default.object,
  xOrigin: import_prop_types46.default.number.isRequired,
  yOrigin: import_prop_types46.default.number.isRequired
} : void 0;

// node_modules/@mui/x-charts/esm/BarChart/BarClipPath.js
var React88 = __toESM(require_react(), 1);

// node_modules/@mui/x-charts/esm/BarChart/getRadius.js
var getRadius = (corner, {
  hasNegative,
  hasPositive,
  borderRadius: borderRadius2,
  layout
}) => {
  if (!borderRadius2) {
    return 0;
  }
  const isVertical = layout === "vertical";
  if (corner === "top-left" && (isVertical && hasPositive || !isVertical && hasNegative)) {
    return borderRadius2;
  }
  if (corner === "top-right" && (isVertical && hasPositive || !isVertical && hasPositive)) {
    return borderRadius2;
  }
  if (corner === "bottom-right" && (isVertical && hasNegative || !isVertical && hasPositive)) {
    return borderRadius2;
  }
  if (corner === "bottom-left" && (isVertical && hasNegative || !isVertical && hasNegative)) {
    return borderRadius2;
  }
  return 0;
};

// node_modules/@mui/x-charts/esm/BarChart/BarClipPath.js
var import_jsx_runtime52 = __toESM(require_jsx_runtime(), 1);
var _excluded17 = ["maskId", "x", "y", "width", "height", "skipAnimation"];
function buildClipPath(size, borderRadius2, ownerState) {
  const radiusData = _extends({}, ownerState, {
    borderRadius: borderRadius2
  });
  const topLeft = Math.min(size, getRadius("top-left", radiusData));
  const topRight = Math.min(size, getRadius("top-right", radiusData));
  const bottomRight = Math.min(size, getRadius("bottom-right", radiusData));
  const bottomLeft = Math.min(size, getRadius("bottom-left", radiusData));
  return `inset(0px round ${topLeft}px ${topRight}px ${bottomRight}px ${bottomLeft}px)`;
}
function barClipRectPropsInterpolator(from2, to) {
  const interpolateX = number_default(from2.x, to.x);
  const interpolateY = number_default(from2.y, to.y);
  const interpolateWidth = number_default(from2.width, to.width);
  const interpolateHeight = number_default(from2.height, to.height);
  const interpolateBorderRadius = number_default(from2.borderRadius, to.borderRadius);
  return (t) => {
    return {
      x: interpolateX(t),
      y: interpolateY(t),
      width: interpolateWidth(t),
      height: interpolateHeight(t),
      borderRadius: interpolateBorderRadius(t)
    };
  };
}
function useAnimateBarClipRect(props) {
  const initialProps = {
    x: props.x,
    y: props.y + (props.ownerState.layout === "vertical" ? props.height : 0),
    width: props.ownerState.layout === "vertical" ? props.width : 0,
    height: props.ownerState.layout === "vertical" ? 0 : props.height,
    borderRadius: props.borderRadius
  };
  return useAnimate({
    x: props.x,
    y: props.y,
    width: props.width,
    height: props.height,
    borderRadius: props.borderRadius
  }, {
    createInterpolator: barClipRectPropsInterpolator,
    transformProps: (p2) => ({
      x: p2.x,
      y: p2.y,
      width: p2.width,
      height: p2.height,
      style: {
        clipPath: buildClipPath(props.ownerState.layout === "vertical" ? p2.height : p2.width, p2.borderRadius, props.ownerState)
      }
    }),
    applyProps(element, animatedProps) {
      element.setAttribute("x", animatedProps.x.toString());
      element.setAttribute("y", animatedProps.y.toString());
      element.setAttribute("width", animatedProps.width.toString());
      element.setAttribute("height", animatedProps.height.toString());
      element.style.clipPath = animatedProps.style.clipPath;
    },
    initialProps,
    skip: props.skipAnimation,
    ref: props.ref
  });
}
function BarClipRect(props) {
  const animatedProps = useAnimateBarClipRect(_extends({}, props, {
    borderRadius: props.ownerState.borderRadius ?? 0
  }));
  return (0, import_jsx_runtime52.jsx)("rect", _extends({}, animatedProps));
}
function BarClipPath(props) {
  const {
    maskId,
    x: x3,
    y: y3,
    width: width2,
    height: height2,
    skipAnimation
  } = props, rest = _objectWithoutPropertiesLoose(props, _excluded17);
  if (!props.borderRadius || props.borderRadius <= 0) {
    return null;
  }
  return (0, import_jsx_runtime52.jsx)("clipPath", {
    id: maskId,
    children: (0, import_jsx_runtime52.jsx)(BarClipRect, {
      ownerState: rest,
      x: x3,
      y: y3,
      width: width2,
      height: height2,
      skipAnimation
    })
  });
}

// node_modules/@mui/x-charts/esm/BarChart/BarLabel/BarLabelPlot.js
var React91 = __toESM(require_react(), 1);

// node_modules/@mui/x-charts/esm/BarChart/BarLabel/BarLabelItem.js
var React90 = __toESM(require_react(), 1);
var import_prop_types48 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/BarChart/BarLabel/barLabelClasses.js
function getBarLabelUtilityClass(slot) {
  return generateUtilityClass("MuiBarLabel", slot);
}
var barLabelClasses = generateUtilityClasses("MuiBarLabel", ["root", "highlighted", "faded", "animate"]);
var useUtilityClasses16 = (ownerState) => {
  const {
    classes,
    seriesId,
    isFaded,
    isHighlighted,
    skipAnimation
  } = ownerState;
  const slots = {
    root: ["root", `series-${seriesId}`, isHighlighted && "highlighted", isFaded && "faded", !skipAnimation && "animate"]
  };
  return composeClasses(slots, getBarLabelUtilityClass, classes);
};

// node_modules/@mui/x-charts/esm/BarChart/BarLabel/getBarLabel.js
var getBarLabel = (options) => {
  const {
    barLabel,
    value,
    dataIndex,
    seriesId,
    height: height2,
    width: width2
  } = options;
  if (barLabel === "value") {
    return value ? value == null ? void 0 : value.toString() : null;
  }
  return barLabel({
    seriesId,
    dataIndex,
    value
  }, {
    bar: {
      height: height2,
      width: width2
    }
  });
};

// node_modules/@mui/x-charts/esm/BarChart/BarLabel/BarLabel.js
var React89 = __toESM(require_react(), 1);
var import_prop_types47 = __toESM(require_prop_types(), 1);
var import_jsx_runtime53 = __toESM(require_jsx_runtime(), 1);
var _excluded18 = ["seriesId", "dataIndex", "color", "isFaded", "isHighlighted", "classes", "skipAnimation", "layout", "xOrigin", "yOrigin"];
var BarLabelComponent = styled_default2("text", {
  name: "MuiBarLabel",
  slot: "Root",
  overridesResolver: (_2, styles) => [{
    [`&.${barLabelClasses.faded}`]: styles.faded
  }, {
    [`&.${barLabelClasses.highlighted}`]: styles.highlighted
  }, styles.root]
})(({
  theme
}) => {
  var _a, _b, _c, _d;
  return _extends({}, (_a = theme == null ? void 0 : theme.typography) == null ? void 0 : _a.body2, {
    stroke: "none",
    fill: (_d = (_c = (_b = theme.vars || theme) == null ? void 0 : _b.palette) == null ? void 0 : _c.text) == null ? void 0 : _d.primary,
    transition: "opacity 0.2s ease-in, fill 0.2s ease-in",
    textAnchor: "middle",
    dominantBaseline: "central",
    pointerEvents: "none",
    opacity: 1,
    [`&.${barLabelClasses.faded}`]: {
      opacity: 0.3
    }
  });
});
function BarLabel(inProps) {
  const props = useThemeProps2({
    props: inProps,
    name: "MuiBarLabel"
  });
  const otherProps = _objectWithoutPropertiesLoose(props, _excluded18);
  const animatedProps = useAnimateBarLabel(props);
  return (0, import_jsx_runtime53.jsx)(BarLabelComponent, _extends({}, otherProps, animatedProps));
}
true ? BarLabel.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  classes: import_prop_types47.default.object,
  dataIndex: import_prop_types47.default.number.isRequired,
  /**
   * Height of the bar this label belongs to.
   */
  height: import_prop_types47.default.number.isRequired,
  isFaded: import_prop_types47.default.bool.isRequired,
  isHighlighted: import_prop_types47.default.bool.isRequired,
  layout: import_prop_types47.default.oneOf(["horizontal", "vertical"]).isRequired,
  seriesId: import_prop_types47.default.oneOfType([import_prop_types47.default.number, import_prop_types47.default.string]).isRequired,
  skipAnimation: import_prop_types47.default.bool.isRequired,
  /**
   * Width of the bar this label belongs to.
   */
  width: import_prop_types47.default.number.isRequired,
  /**
   * Position in the x-axis of the bar this label belongs to.
   */
  x: import_prop_types47.default.number.isRequired,
  /**
   * The x-coordinate of the stack this bar label belongs to.
   */
  xOrigin: import_prop_types47.default.number.isRequired,
  /**
   * Position in the y-axis of the bar this label belongs to.
   */
  y: import_prop_types47.default.number.isRequired,
  /**
   * The y-coordinate of the stack this bar label belongs to.
   */
  yOrigin: import_prop_types47.default.number.isRequired
} : void 0;

// node_modules/@mui/x-charts/esm/BarChart/BarLabel/BarLabelItem.js
var import_jsx_runtime54 = __toESM(require_jsx_runtime(), 1);
var _excluded19 = ["seriesId", "classes", "color", "dataIndex", "barLabel", "slots", "slotProps", "xOrigin", "yOrigin", "x", "y", "width", "height", "value", "skipAnimation", "layout"];
var _excluded24 = ["ownerState"];
function BarLabelItem(props) {
  const {
    seriesId,
    classes: innerClasses,
    color: color3,
    dataIndex,
    barLabel,
    slots,
    slotProps,
    xOrigin,
    yOrigin,
    x: x3,
    y: y3,
    width: width2,
    height: height2,
    value,
    skipAnimation,
    layout
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded19);
  const {
    isFaded,
    isHighlighted
  } = useItemHighlighted({
    seriesId,
    dataIndex
  });
  const ownerState = {
    seriesId,
    classes: innerClasses,
    color: color3,
    isFaded,
    isHighlighted,
    dataIndex,
    skipAnimation,
    layout
  };
  const classes = useUtilityClasses16(ownerState);
  const Component = (slots == null ? void 0 : slots.barLabel) ?? BarLabel;
  const _useSlotProps = useSlotProps_default({
    elementType: Component,
    externalSlotProps: slotProps == null ? void 0 : slotProps.barLabel,
    additionalProps: _extends({}, other, {
      xOrigin,
      yOrigin,
      x: x3,
      y: y3,
      width: width2,
      height: height2,
      className: classes.root
    }),
    ownerState
  }), {
    ownerState: barLabelOwnerState
  } = _useSlotProps, barLabelProps = _objectWithoutPropertiesLoose(_useSlotProps, _excluded24);
  if (!barLabel) {
    return null;
  }
  const formattedLabelText = getBarLabel({
    barLabel,
    value,
    dataIndex,
    seriesId,
    height: height2,
    width: width2
  });
  if (!formattedLabelText) {
    return null;
  }
  return (0, import_jsx_runtime54.jsx)(Component, _extends({}, barLabelProps, barLabelOwnerState, {
    children: formattedLabelText
  }));
}
true ? BarLabelItem.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * If provided, the function will be used to format the label of the bar.
   * It can be set to 'value' to display the current value.
   * @param {BarItem} item The item to format.
   * @param {BarLabelContext} context data about the bar.
   * @returns {string} The formatted label.
   */
  barLabel: import_prop_types48.default.oneOfType([import_prop_types48.default.oneOf(["value"]), import_prop_types48.default.func]),
  classes: import_prop_types48.default.object,
  color: import_prop_types48.default.string.isRequired,
  dataIndex: import_prop_types48.default.number.isRequired,
  /**
   * The height of the bar.
   */
  height: import_prop_types48.default.number.isRequired,
  seriesId: import_prop_types48.default.oneOfType([import_prop_types48.default.number, import_prop_types48.default.string]).isRequired,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types48.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types48.default.object,
  /**
   * The value of the data point.
   */
  value: import_prop_types48.default.number,
  /**
   * The width of the bar.
   */
  width: import_prop_types48.default.number.isRequired
} : void 0;

// node_modules/@mui/x-charts/esm/BarChart/BarLabel/BarLabelPlot.js
var import_jsx_runtime55 = __toESM(require_jsx_runtime(), 1);
var _excluded20 = ["bars", "skipAnimation"];
function BarLabelPlot(props) {
  const {
    bars,
    skipAnimation
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded20);
  return (0, import_jsx_runtime55.jsx)(React91.Fragment, {
    children: bars.map(({
      xOrigin,
      yOrigin,
      x: x3,
      y: y3,
      seriesId,
      dataIndex,
      color: color3,
      value,
      width: width2,
      height: height2,
      layout
    }) => (0, import_jsx_runtime55.jsx)(BarLabelItem, _extends({
      seriesId,
      dataIndex,
      value,
      color: color3,
      xOrigin,
      yOrigin,
      x: x3,
      y: y3,
      width: width2,
      height: height2,
      skipAnimation: skipAnimation ?? false,
      layout: layout ?? "vertical"
    }, other), `${seriesId}-${dataIndex}`))
  });
}

// node_modules/@mui/x-charts/esm/BarChart/checkScaleErrors.js
var getAxisMessage = (axisDirection, axisId) => {
  const axisName = `${axisDirection}-axis`;
  const axisIdName = `${axisDirection}Axis`;
  const axisDefaultKey = axisDirection === "x" ? DEFAULT_X_AXIS_KEY : DEFAULT_Y_AXIS_KEY;
  return axisId === axisDefaultKey ? `The first \`${axisIdName}\`` : `The ${axisName} with id "${axisId}"`;
};
function checkScaleErrors(verticalLayout, seriesId, series, xAxisId, xAxis, yAxisId, yAxis) {
  const xAxisConfig = xAxis[xAxisId];
  const yAxisConfig = yAxis[yAxisId];
  const discreteAxisConfig = verticalLayout ? xAxisConfig : yAxisConfig;
  const continuousAxisConfig = verticalLayout ? yAxisConfig : xAxisConfig;
  const discreteAxisId = verticalLayout ? xAxisId : yAxisId;
  const continuousAxisId = verticalLayout ? yAxisId : xAxisId;
  const discreteAxisDirection = verticalLayout ? "x" : "y";
  const continuousAxisDirection = verticalLayout ? "y" : "x";
  if (!isBandScaleConfig(discreteAxisConfig)) {
    throw new Error(`MUI X Charts: ${getAxisMessage(discreteAxisDirection, discreteAxisId)} should be of type "band" to display the bar series of id "${seriesId}".`);
  }
  if (discreteAxisConfig.data === void 0) {
    throw new Error(`MUI X Charts: ${getAxisMessage(discreteAxisDirection, discreteAxisId)} should have data property.`);
  }
  if (isBandScaleConfig(continuousAxisConfig) || isPointScaleConfig(continuousAxisConfig)) {
    throw new Error(`MUI X Charts: ${getAxisMessage(continuousAxisDirection, continuousAxisId)} should be a continuous type to display the bar series of id "${seriesId}".`);
  }
  if (true) {
    if (discreteAxisConfig.data.length < series.stackedData.length) {
      warnOnce([`MUI X Charts: ${getAxisMessage(discreteAxisDirection, discreteAxisId)} has less data (${discreteAxisConfig.data.length} values) than the bar series of id "${seriesId}" (${series.stackedData.length} values).`, "The axis data should have at least the same length than the series using it."], "error");
    }
  }
}

// node_modules/@mui/x-charts/esm/hooks/useSkipAnimation.js
function useSkipAnimation(skipAnimation) {
  const store = useStore();
  const storeSkipAnimation = useSelector(store, selectorChartSkipAnimation);
  return skipAnimation || storeSkipAnimation;
}

// node_modules/@mui/x-charts/esm/internals/plugins/featurePlugins/useChartCartesianAxis/useInternalIsZoomInteracting.js
function useInternalIsZoomInteracting() {
  const store = useStore();
  const isInteracting = useSelector(store, selectorChartZoomIsInteracting);
  return isInteracting;
}

// node_modules/@mui/x-charts/esm/BarChart/BarPlot.js
var import_jsx_runtime56 = __toESM(require_jsx_runtime(), 1);
var _excluded21 = ["skipAnimation", "onItemClick", "borderRadius", "barLabel"];
function getBandSize({
  bandWidth: W2,
  numberOfGroups: N2,
  gapRatio: r3
}) {
  if (r3 === 0) {
    return {
      barWidth: W2 / N2,
      offset: 0
    };
  }
  const barWidth = W2 / (N2 + (N2 - 1) * r3);
  const offset2 = r3 * barWidth;
  return {
    barWidth,
    offset: offset2
  };
}
var useAggregatedData = () => {
  const seriesData = useBarSeriesContext() ?? {
    series: {},
    stackingGroups: [],
    seriesOrder: []
  };
  const drawingArea = useDrawingArea();
  const chartId = useChartId2();
  const {
    series,
    stackingGroups
  } = seriesData;
  const {
    xAxis,
    xAxisIds
  } = useXAxes();
  const {
    yAxis,
    yAxisIds
  } = useYAxes();
  const defaultXAxisId = xAxisIds[0];
  const defaultYAxisId = yAxisIds[0];
  const masks = {};
  const data = stackingGroups.flatMap(({
    ids: groupIds
  }, groupIndex) => {
    const xMin = drawingArea.left;
    const xMax = drawingArea.left + drawingArea.width;
    const yMin = drawingArea.top;
    const yMax = drawingArea.top + drawingArea.height;
    return groupIds.flatMap((seriesId) => {
      const xAxisId = series[seriesId].xAxisId ?? defaultXAxisId;
      const yAxisId = series[seriesId].yAxisId ?? defaultYAxisId;
      const xAxisConfig = xAxis[xAxisId];
      const yAxisConfig = yAxis[yAxisId];
      const verticalLayout = series[seriesId].layout === "vertical";
      checkScaleErrors(verticalLayout, seriesId, series[seriesId], xAxisId, xAxis, yAxisId, yAxis);
      const baseScaleConfig = verticalLayout ? xAxisConfig : yAxisConfig;
      const xScale = xAxisConfig.scale;
      const yScale = yAxisConfig.scale;
      const colorGetter = getColor_default(series[seriesId], xAxis[xAxisId], yAxis[yAxisId]);
      const bandWidth = baseScaleConfig.scale.bandwidth();
      const {
        barWidth,
        offset: offset2
      } = getBandSize({
        bandWidth,
        numberOfGroups: stackingGroups.length,
        gapRatio: baseScaleConfig.barGapRatio
      });
      const barOffset = groupIndex * (barWidth + offset2);
      const {
        stackedData,
        data: currentSeriesData,
        layout
      } = series[seriesId];
      return baseScaleConfig.data.map((baseValue, dataIndex) => {
        if (currentSeriesData[dataIndex] == null) {
          return null;
        }
        const values3 = stackedData[dataIndex];
        const valueCoordinates = values3.map((v3) => verticalLayout ? yScale(v3) : xScale(v3));
        const minValueCoord = Math.round(Math.min(...valueCoordinates));
        const maxValueCoord = Math.round(Math.max(...valueCoordinates));
        const stackId = series[seriesId].stack;
        const result = {
          seriesId,
          dataIndex,
          layout,
          x: verticalLayout ? xScale(baseValue) + barOffset : minValueCoord,
          y: verticalLayout ? minValueCoord : yScale(baseValue) + barOffset,
          xOrigin: xScale(0) ?? 0,
          yOrigin: yScale(0) ?? 0,
          height: verticalLayout ? maxValueCoord - minValueCoord : barWidth,
          width: verticalLayout ? barWidth : maxValueCoord - minValueCoord,
          color: colorGetter(dataIndex),
          value: currentSeriesData[dataIndex],
          maskId: `${chartId}_${stackId || seriesId}_${groupIndex}_${dataIndex}`
        };
        if (result.x > xMax || result.x + result.width < xMin || result.y > yMax || result.y + result.height < yMin) {
          return null;
        }
        if (!masks[result.maskId]) {
          masks[result.maskId] = {
            id: result.maskId,
            width: 0,
            height: 0,
            hasNegative: false,
            hasPositive: false,
            layout: result.layout,
            xOrigin: xScale(0),
            yOrigin: yScale(0),
            x: 0,
            y: 0
          };
        }
        const mask = masks[result.maskId];
        mask.width = result.layout === "vertical" ? result.width : mask.width + result.width;
        mask.height = result.layout === "vertical" ? mask.height + result.height : result.height;
        mask.x = Math.min(mask.x === 0 ? Infinity : mask.x, result.x);
        mask.y = Math.min(mask.y === 0 ? Infinity : mask.y, result.y);
        mask.hasNegative = mask.hasNegative || (result.value ?? 0) < 0;
        mask.hasPositive = mask.hasPositive || (result.value ?? 0) > 0;
        return result;
      }).filter((rectangle) => rectangle !== null);
    });
  });
  return {
    completedData: data,
    masksData: Object.values(masks)
  };
};
var BarPlotRoot = styled_default2("g", {
  name: "MuiBarPlot",
  slot: "Root"
})({
  [`& .${barElementClasses.root}`]: {
    transition: "opacity 0.2s ease-in, fill 0.2s ease-in"
  }
});
function BarPlot(props) {
  const {
    completedData,
    masksData
  } = useAggregatedData();
  const {
    skipAnimation: inSkipAnimation,
    onItemClick,
    borderRadius: borderRadius2,
    barLabel
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded21);
  const isZoomInteracting = useInternalIsZoomInteracting();
  const skipAnimation = useSkipAnimation(isZoomInteracting || inSkipAnimation);
  const withoutBorderRadius = !borderRadius2 || borderRadius2 <= 0;
  return (0, import_jsx_runtime56.jsxs)(BarPlotRoot, {
    children: [!withoutBorderRadius && masksData.map(({
      id,
      x: x3,
      y: y3,
      width: width2,
      height: height2,
      hasPositive,
      hasNegative,
      layout
    }) => {
      return (0, import_jsx_runtime56.jsx)(BarClipPath, {
        maskId: id,
        borderRadius: borderRadius2,
        hasNegative,
        hasPositive,
        layout,
        x: x3,
        y: y3,
        width: width2,
        height: height2,
        skipAnimation: skipAnimation ?? false
      }, id);
    }), completedData.map(({
      seriesId,
      dataIndex,
      color: color3,
      maskId,
      layout,
      x: x3,
      xOrigin,
      y: y3,
      yOrigin,
      width: width2,
      height: height2
    }) => {
      const barElement = (0, import_jsx_runtime56.jsx)(BarElement, _extends({
        id: seriesId,
        dataIndex,
        color: color3,
        skipAnimation: skipAnimation ?? false,
        layout: layout ?? "vertical",
        x: x3,
        xOrigin,
        y: y3,
        yOrigin,
        width: width2,
        height: height2
      }, other, {
        onClick: onItemClick && ((event) => {
          onItemClick(event, {
            type: "bar",
            seriesId,
            dataIndex
          });
        })
      }), `${seriesId}-${dataIndex}`);
      if (withoutBorderRadius) {
        return barElement;
      }
      return (0, import_jsx_runtime56.jsx)("g", {
        clipPath: `url(#${maskId})`,
        children: barElement
      }, `${seriesId}-${dataIndex}`);
    }), barLabel && (0, import_jsx_runtime56.jsx)(BarLabelPlot, _extends({
      bars: completedData,
      skipAnimation,
      barLabel
    }, other))]
  });
}
true ? BarPlot.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * If provided, the function will be used to format the label of the bar.
   * It can be set to 'value' to display the current value.
   * @param {BarItem} item The item to format.
   * @param {BarLabelContext} context data about the bar.
   * @returns {string} The formatted label.
   */
  barLabel: import_prop_types49.default.oneOfType([import_prop_types49.default.oneOf(["value"]), import_prop_types49.default.func]),
  /**
   * Defines the border radius of the bar element.
   */
  borderRadius: import_prop_types49.default.number,
  /**
   * Callback fired when a bar item is clicked.
   * @param {React.MouseEvent<SVGElement, MouseEvent>} event The event source of the callback.
   * @param {BarItemIdentifier} barItemIdentifier The bar item identifier.
   */
  onItemClick: import_prop_types49.default.func,
  /**
   * If `true`, animations are skipped.
   * @default undefined
   */
  skipAnimation: import_prop_types49.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types49.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types49.default.object
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsOverlay/ChartsOverlay.js
var React95 = __toESM(require_react(), 1);

// node_modules/@mui/x-charts/esm/ChartsOverlay/ChartsLoadingOverlay.js
var React93 = __toESM(require_react(), 1);
var import_jsx_runtime57 = __toESM(require_jsx_runtime(), 1);
var _excluded25 = ["message"];
var StyledText = styled_default2("text")(({
  theme
}) => _extends({}, theme.typography.body2, {
  stroke: "none",
  fill: (theme.vars || theme).palette.text.primary,
  shapeRendering: "crispEdges",
  textAnchor: "middle",
  dominantBaseline: "middle"
}));
function ChartsLoadingOverlay(props) {
  const {
    message
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded25);
  const {
    top: top3,
    left: left3,
    height: height2,
    width: width2
  } = useDrawingArea();
  const {
    localeText
  } = useChartsLocalization();
  return (0, import_jsx_runtime57.jsx)(StyledText, _extends({
    x: left3 + width2 / 2,
    y: top3 + height2 / 2
  }, other, {
    children: message ?? localeText.loading
  }));
}

// node_modules/@mui/x-charts/esm/ChartsOverlay/ChartsNoDataOverlay.js
var React94 = __toESM(require_react(), 1);
var import_jsx_runtime58 = __toESM(require_jsx_runtime(), 1);
var _excluded26 = ["message"];
var StyledText2 = styled_default2("text")(({
  theme
}) => _extends({}, theme.typography.body2, {
  stroke: "none",
  fill: (theme.vars || theme).palette.text.primary,
  shapeRendering: "crispEdges",
  textAnchor: "middle",
  dominantBaseline: "middle"
}));
function ChartsNoDataOverlay(props) {
  const {
    message
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded26);
  const {
    top: top3,
    left: left3,
    height: height2,
    width: width2
  } = useDrawingArea();
  const {
    localeText
  } = useChartsLocalization();
  return (0, import_jsx_runtime58.jsx)(StyledText2, _extends({
    x: left3 + width2 / 2,
    y: top3 + height2 / 2
  }, other, {
    children: message ?? localeText.noData
  }));
}

// node_modules/@mui/x-charts/esm/ChartsOverlay/ChartsOverlay.js
var import_jsx_runtime59 = __toESM(require_jsx_runtime(), 1);
function useNoData() {
  const seriesPerType = useSeries();
  return Object.values(seriesPerType).every((seriesOfGivenType) => {
    if (!seriesOfGivenType) {
      return true;
    }
    const {
      series,
      seriesOrder
    } = seriesOfGivenType;
    return seriesOrder.every((seriesId) => series[seriesId].data.length === 0);
  });
}
function ChartsOverlay(props) {
  var _a, _b, _c, _d;
  const noData = useNoData();
  if (props.loading) {
    const LoadingOverlay = ((_a = props.slots) == null ? void 0 : _a.loadingOverlay) ?? ChartsLoadingOverlay;
    return (0, import_jsx_runtime59.jsx)(LoadingOverlay, _extends({}, (_b = props.slotProps) == null ? void 0 : _b.loadingOverlay));
  }
  if (noData) {
    const NoDataOverlay = ((_c = props.slots) == null ? void 0 : _c.noDataOverlay) ?? ChartsNoDataOverlay;
    return (0, import_jsx_runtime59.jsx)(NoDataOverlay, _extends({}, (_d = props.slotProps) == null ? void 0 : _d.noDataOverlay));
  }
  return null;
}

// node_modules/@mui/x-charts/esm/BarChart/useBarChartProps.js
var React96 = __toESM(require_react(), 1);

// node_modules/@mui/x-charts/esm/BarChart/BarChart.plugins.js
var BAR_CHART_PLUGINS = [useChartZAxis, useChartCartesianAxis, useChartInteraction, useChartHighlight];

// node_modules/@mui/x-charts/esm/BarChart/useBarChartProps.js
var _excluded27 = ["xAxis", "yAxis", "series", "width", "height", "margin", "colors", "dataset", "sx", "axisHighlight", "grid", "children", "slots", "slotProps", "skipAnimation", "loading", "layout", "onItemClick", "highlightedItem", "onHighlightChange", "borderRadius", "barLabel", "className", "hideLegend"];
var useBarChartProps = (props) => {
  var _a, _b, _c, _d, _e2;
  const {
    xAxis,
    yAxis,
    series,
    width: width2,
    height: height2,
    margin: margin2,
    colors,
    dataset,
    sx,
    axisHighlight,
    grid: grid2,
    children: children2,
    slots,
    slotProps,
    skipAnimation,
    loading,
    layout,
    onItemClick,
    highlightedItem,
    onHighlightChange,
    borderRadius: borderRadius2,
    barLabel,
    className
  } = props, rest = _objectWithoutPropertiesLoose(props, _excluded27);
  const id = useId();
  const clipPathId = `${id}-clip-path`;
  const hasHorizontalSeries = layout === "horizontal" || layout === void 0 && series.some((item) => item.layout === "horizontal");
  const defaultBandXAxis = React96.useMemo(() => [{
    id: DEFAULT_X_AXIS_KEY,
    scaleType: "band",
    data: Array.from({
      length: Math.max(...series.map((s3) => (s3.data ?? dataset ?? []).length))
    }, (_2, index2) => index2)
  }], [dataset, series]);
  const defaultBandYAxis = React96.useMemo(() => [{
    id: DEFAULT_Y_AXIS_KEY,
    scaleType: "band",
    data: Array.from({
      length: Math.max(...series.map((s3) => (s3.data ?? dataset ?? []).length))
    }, (_2, index2) => index2)
  }], [dataset, series]);
  const seriesWithDefault = React96.useMemo(() => series.map((s3) => _extends({
    type: "bar"
  }, s3, {
    layout: hasHorizontalSeries ? "horizontal" : "vertical"
  })), [hasHorizontalSeries, series]);
  const defaultXAxis = hasHorizontalSeries ? void 0 : defaultBandXAxis;
  const processedXAxis = React96.useMemo(() => {
    if (!xAxis) {
      return defaultXAxis;
    }
    return hasHorizontalSeries ? xAxis : xAxis.map((axis) => _extends({
      scaleType: "band"
    }, axis));
  }, [defaultXAxis, hasHorizontalSeries, xAxis]);
  const defaultYAxis = hasHorizontalSeries ? defaultBandYAxis : void 0;
  const processedYAxis = React96.useMemo(() => {
    if (!yAxis) {
      return defaultYAxis;
    }
    return hasHorizontalSeries ? yAxis.map((axis) => _extends({
      scaleType: "band"
    }, axis)) : yAxis;
  }, [defaultYAxis, hasHorizontalSeries, yAxis]);
  const chartContainerProps = _extends({}, rest, {
    series: seriesWithDefault,
    width: width2,
    height: height2,
    margin: margin2,
    colors,
    dataset,
    xAxis: processedXAxis,
    yAxis: processedYAxis,
    highlightedItem,
    onHighlightChange,
    disableAxisListener: ((_a = slotProps == null ? void 0 : slotProps.tooltip) == null ? void 0 : _a.trigger) !== "axis" && (axisHighlight == null ? void 0 : axisHighlight.x) === "none" && (axisHighlight == null ? void 0 : axisHighlight.y) === "none",
    className,
    skipAnimation,
    plugins: BAR_CHART_PLUGINS
  });
  const barPlotProps = {
    onItemClick,
    slots,
    slotProps,
    borderRadius: borderRadius2,
    barLabel
  };
  const gridProps = {
    vertical: grid2 == null ? void 0 : grid2.vertical,
    horizontal: grid2 == null ? void 0 : grid2.horizontal
  };
  const clipPathGroupProps = {
    clipPath: `url(#${clipPathId})`
  };
  const clipPathProps = {
    id: clipPathId
  };
  const overlayProps = {
    slots,
    slotProps,
    loading
  };
  const chartsAxisProps = {
    slots,
    slotProps
  };
  const axisHighlightProps = _extends({}, hasHorizontalSeries ? {
    y: "band"
  } : {
    x: "band"
  }, axisHighlight);
  const legendProps = {
    slots,
    slotProps
  };
  const chartsWrapperProps = {
    sx,
    legendPosition: (_c = (_b = props.slotProps) == null ? void 0 : _b.legend) == null ? void 0 : _c.position,
    legendDirection: (_e2 = (_d = props.slotProps) == null ? void 0 : _d.legend) == null ? void 0 : _e2.direction
  };
  return {
    chartsWrapperProps,
    chartContainerProps,
    barPlotProps,
    gridProps,
    clipPathProps,
    clipPathGroupProps,
    overlayProps,
    chartsAxisProps,
    axisHighlightProps,
    legendProps,
    children: children2
  };
};

// node_modules/@mui/x-charts/esm/ChartDataProvider/ChartDataProvider.js
var React98 = __toESM(require_react(), 1);
var import_prop_types50 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/internals/plugins/featurePlugins/useChartVoronoi/useChartVoronoi.js
var React97 = __toESM(require_react(), 1);

// node_modules/robust-predicates/esm/util.js
var epsilon4 = 11102230246251565e-32;
var splitter = 134217729;
var resulterrbound = (3 + 8 * epsilon4) * epsilon4;
function sum3(elen, e, flen, f2, h) {
  let Q2, Qnew, hh, bvirt;
  let enow = e[0];
  let fnow = f2[0];
  let eindex = 0;
  let findex = 0;
  if (fnow > enow === fnow > -enow) {
    Q2 = enow;
    enow = e[++eindex];
  } else {
    Q2 = fnow;
    fnow = f2[++findex];
  }
  let hindex = 0;
  if (eindex < elen && findex < flen) {
    if (fnow > enow === fnow > -enow) {
      Qnew = enow + Q2;
      hh = Q2 - (Qnew - enow);
      enow = e[++eindex];
    } else {
      Qnew = fnow + Q2;
      hh = Q2 - (Qnew - fnow);
      fnow = f2[++findex];
    }
    Q2 = Qnew;
    if (hh !== 0) {
      h[hindex++] = hh;
    }
    while (eindex < elen && findex < flen) {
      if (fnow > enow === fnow > -enow) {
        Qnew = Q2 + enow;
        bvirt = Qnew - Q2;
        hh = Q2 - (Qnew - bvirt) + (enow - bvirt);
        enow = e[++eindex];
      } else {
        Qnew = Q2 + fnow;
        bvirt = Qnew - Q2;
        hh = Q2 - (Qnew - bvirt) + (fnow - bvirt);
        fnow = f2[++findex];
      }
      Q2 = Qnew;
      if (hh !== 0) {
        h[hindex++] = hh;
      }
    }
  }
  while (eindex < elen) {
    Qnew = Q2 + enow;
    bvirt = Qnew - Q2;
    hh = Q2 - (Qnew - bvirt) + (enow - bvirt);
    enow = e[++eindex];
    Q2 = Qnew;
    if (hh !== 0) {
      h[hindex++] = hh;
    }
  }
  while (findex < flen) {
    Qnew = Q2 + fnow;
    bvirt = Qnew - Q2;
    hh = Q2 - (Qnew - bvirt) + (fnow - bvirt);
    fnow = f2[++findex];
    Q2 = Qnew;
    if (hh !== 0) {
      h[hindex++] = hh;
    }
  }
  if (Q2 !== 0 || hindex === 0) {
    h[hindex++] = Q2;
  }
  return hindex;
}
function estimate(elen, e) {
  let Q2 = e[0];
  for (let i2 = 1; i2 < elen; i2++) Q2 += e[i2];
  return Q2;
}
function vec(n) {
  return new Float64Array(n);
}

// node_modules/robust-predicates/esm/orient2d.js
var ccwerrboundA = (3 + 16 * epsilon4) * epsilon4;
var ccwerrboundB = (2 + 12 * epsilon4) * epsilon4;
var ccwerrboundC = (9 + 64 * epsilon4) * epsilon4 * epsilon4;
var B3 = vec(4);
var C1 = vec(8);
var C22 = vec(12);
var D3 = vec(16);
var u2 = vec(4);
function orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {
  let acxtail, acytail, bcxtail, bcytail;
  let bvirt, c3, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t13, t03, u32;
  const acx = ax - cx;
  const bcx = bx - cx;
  const acy = ay - cy;
  const bcy = by - cy;
  s1 = acx * bcy;
  c3 = splitter * acx;
  ahi = c3 - (c3 - acx);
  alo = acx - ahi;
  c3 = splitter * bcy;
  bhi = c3 - (c3 - bcy);
  blo = bcy - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t13 = acy * bcx;
  c3 = splitter * acy;
  ahi = c3 - (c3 - acy);
  alo = acy - ahi;
  c3 = splitter * bcx;
  bhi = c3 - (c3 - bcx);
  blo = bcx - bhi;
  t03 = alo * blo - (t13 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t03;
  bvirt = s0 - _i;
  B3[0] = s0 - (_i + bvirt) + (bvirt - t03);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t13;
  bvirt = _0 - _i;
  B3[1] = _0 - (_i + bvirt) + (bvirt - t13);
  u32 = _j + _i;
  bvirt = u32 - _j;
  B3[2] = _j - (u32 - bvirt) + (_i - bvirt);
  B3[3] = u32;
  let det = estimate(4, B3);
  let errbound = ccwerrboundB * detsum;
  if (det >= errbound || -det >= errbound) {
    return det;
  }
  bvirt = ax - acx;
  acxtail = ax - (acx + bvirt) + (bvirt - cx);
  bvirt = bx - bcx;
  bcxtail = bx - (bcx + bvirt) + (bvirt - cx);
  bvirt = ay - acy;
  acytail = ay - (acy + bvirt) + (bvirt - cy);
  bvirt = by - bcy;
  bcytail = by - (bcy + bvirt) + (bvirt - cy);
  if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {
    return det;
  }
  errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);
  det += acx * bcytail + bcy * acxtail - (acy * bcxtail + bcx * acytail);
  if (det >= errbound || -det >= errbound) return det;
  s1 = acxtail * bcy;
  c3 = splitter * acxtail;
  ahi = c3 - (c3 - acxtail);
  alo = acxtail - ahi;
  c3 = splitter * bcy;
  bhi = c3 - (c3 - bcy);
  blo = bcy - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t13 = acytail * bcx;
  c3 = splitter * acytail;
  ahi = c3 - (c3 - acytail);
  alo = acytail - ahi;
  c3 = splitter * bcx;
  bhi = c3 - (c3 - bcx);
  blo = bcx - bhi;
  t03 = alo * blo - (t13 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t03;
  bvirt = s0 - _i;
  u2[0] = s0 - (_i + bvirt) + (bvirt - t03);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t13;
  bvirt = _0 - _i;
  u2[1] = _0 - (_i + bvirt) + (bvirt - t13);
  u32 = _j + _i;
  bvirt = u32 - _j;
  u2[2] = _j - (u32 - bvirt) + (_i - bvirt);
  u2[3] = u32;
  const C1len = sum3(4, B3, 4, u2, C1);
  s1 = acx * bcytail;
  c3 = splitter * acx;
  ahi = c3 - (c3 - acx);
  alo = acx - ahi;
  c3 = splitter * bcytail;
  bhi = c3 - (c3 - bcytail);
  blo = bcytail - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t13 = acy * bcxtail;
  c3 = splitter * acy;
  ahi = c3 - (c3 - acy);
  alo = acy - ahi;
  c3 = splitter * bcxtail;
  bhi = c3 - (c3 - bcxtail);
  blo = bcxtail - bhi;
  t03 = alo * blo - (t13 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t03;
  bvirt = s0 - _i;
  u2[0] = s0 - (_i + bvirt) + (bvirt - t03);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t13;
  bvirt = _0 - _i;
  u2[1] = _0 - (_i + bvirt) + (bvirt - t13);
  u32 = _j + _i;
  bvirt = u32 - _j;
  u2[2] = _j - (u32 - bvirt) + (_i - bvirt);
  u2[3] = u32;
  const C2len = sum3(C1len, C1, 4, u2, C22);
  s1 = acxtail * bcytail;
  c3 = splitter * acxtail;
  ahi = c3 - (c3 - acxtail);
  alo = acxtail - ahi;
  c3 = splitter * bcytail;
  bhi = c3 - (c3 - bcytail);
  blo = bcytail - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t13 = acytail * bcxtail;
  c3 = splitter * acytail;
  ahi = c3 - (c3 - acytail);
  alo = acytail - ahi;
  c3 = splitter * bcxtail;
  bhi = c3 - (c3 - bcxtail);
  blo = bcxtail - bhi;
  t03 = alo * blo - (t13 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t03;
  bvirt = s0 - _i;
  u2[0] = s0 - (_i + bvirt) + (bvirt - t03);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t13;
  bvirt = _0 - _i;
  u2[1] = _0 - (_i + bvirt) + (bvirt - t13);
  u32 = _j + _i;
  bvirt = u32 - _j;
  u2[2] = _j - (u32 - bvirt) + (_i - bvirt);
  u2[3] = u32;
  const Dlen = sum3(C2len, C22, 4, u2, D3);
  return D3[Dlen - 1];
}
function orient2d(ax, ay, bx, by, cx, cy) {
  const detleft = (ay - cy) * (bx - cx);
  const detright = (ax - cx) * (by - cy);
  const det = detleft - detright;
  const detsum = Math.abs(detleft + detright);
  if (Math.abs(det) >= ccwerrboundA * detsum) return det;
  return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);
}

// node_modules/robust-predicates/esm/orient3d.js
var o3derrboundA = (7 + 56 * epsilon4) * epsilon4;
var o3derrboundB = (3 + 28 * epsilon4) * epsilon4;
var o3derrboundC = (26 + 288 * epsilon4) * epsilon4 * epsilon4;
var bc = vec(4);
var ca = vec(4);
var ab = vec(4);
var at_b = vec(4);
var at_c = vec(4);
var bt_c = vec(4);
var bt_a = vec(4);
var ct_a = vec(4);
var ct_b = vec(4);
var bct = vec(8);
var cat = vec(8);
var abt = vec(8);
var u3 = vec(4);
var _8 = vec(8);
var _8b = vec(8);
var _16 = vec(8);
var _12 = vec(12);
var fin = vec(192);
var fin2 = vec(192);

// node_modules/robust-predicates/esm/incircle.js
var iccerrboundA = (10 + 96 * epsilon4) * epsilon4;
var iccerrboundB = (4 + 48 * epsilon4) * epsilon4;
var iccerrboundC = (44 + 576 * epsilon4) * epsilon4 * epsilon4;
var bc2 = vec(4);
var ca2 = vec(4);
var ab2 = vec(4);
var aa = vec(4);
var bb = vec(4);
var cc = vec(4);
var u4 = vec(4);
var v2 = vec(4);
var axtbc = vec(8);
var aytbc = vec(8);
var bxtca = vec(8);
var bytca = vec(8);
var cxtab = vec(8);
var cytab = vec(8);
var abt2 = vec(8);
var bct2 = vec(8);
var cat2 = vec(8);
var abtt = vec(4);
var bctt = vec(4);
var catt = vec(4);
var _82 = vec(8);
var _162 = vec(16);
var _16b = vec(16);
var _16c = vec(16);
var _32 = vec(32);
var _32b = vec(32);
var _48 = vec(48);
var _64 = vec(64);
var fin3 = vec(1152);
var fin22 = vec(1152);

// node_modules/robust-predicates/esm/insphere.js
var isperrboundA = (16 + 224 * epsilon4) * epsilon4;
var isperrboundB = (5 + 72 * epsilon4) * epsilon4;
var isperrboundC = (71 + 1408 * epsilon4) * epsilon4 * epsilon4;
var ab3 = vec(4);
var bc3 = vec(4);
var cd = vec(4);
var de2 = vec(4);
var ea = vec(4);
var ac = vec(4);
var bd = vec(4);
var ce2 = vec(4);
var da = vec(4);
var eb = vec(4);
var abc = vec(24);
var bcd = vec(24);
var cde = vec(24);
var dea = vec(24);
var eab = vec(24);
var abd = vec(24);
var bce = vec(24);
var cda = vec(24);
var deb = vec(24);
var eac = vec(24);
var adet = vec(1152);
var bdet = vec(1152);
var cdet = vec(1152);
var ddet = vec(1152);
var edet = vec(1152);
var abdet = vec(2304);
var cddet = vec(2304);
var cdedet = vec(3456);
var deter = vec(5760);
var _83 = vec(8);
var _8b2 = vec(8);
var _8c = vec(8);
var _163 = vec(16);
var _24 = vec(24);
var _482 = vec(48);
var _48b = vec(48);
var _96 = vec(96);
var _192 = vec(192);
var _384x = vec(384);
var _384y = vec(384);
var _384z = vec(384);
var _768 = vec(768);
var xdet = vec(96);
var ydet = vec(96);
var zdet = vec(96);
var fin4 = vec(1152);

// node_modules/delaunator/index.js
var EPSILON = Math.pow(2, -52);
var EDGE_STACK = new Uint32Array(512);
var Delaunator = class _Delaunator {
  static from(points, getX = defaultGetX, getY = defaultGetY) {
    const n = points.length;
    const coords = new Float64Array(n * 2);
    for (let i2 = 0; i2 < n; i2++) {
      const p2 = points[i2];
      coords[2 * i2] = getX(p2);
      coords[2 * i2 + 1] = getY(p2);
    }
    return new _Delaunator(coords);
  }
  constructor(coords) {
    const n = coords.length >> 1;
    if (n > 0 && typeof coords[0] !== "number") throw new Error("Expected coords to contain numbers.");
    this.coords = coords;
    const maxTriangles = Math.max(2 * n - 5, 0);
    this._triangles = new Uint32Array(maxTriangles * 3);
    this._halfedges = new Int32Array(maxTriangles * 3);
    this._hashSize = Math.ceil(Math.sqrt(n));
    this._hullPrev = new Uint32Array(n);
    this._hullNext = new Uint32Array(n);
    this._hullTri = new Uint32Array(n);
    this._hullHash = new Int32Array(this._hashSize);
    this._ids = new Uint32Array(n);
    this._dists = new Float64Array(n);
    this.update();
  }
  update() {
    const { coords, _hullPrev: hullPrev, _hullNext: hullNext, _hullTri: hullTri, _hullHash: hullHash } = this;
    const n = coords.length >> 1;
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    for (let i3 = 0; i3 < n; i3++) {
      const x3 = coords[2 * i3];
      const y3 = coords[2 * i3 + 1];
      if (x3 < minX) minX = x3;
      if (y3 < minY) minY = y3;
      if (x3 > maxX) maxX = x3;
      if (y3 > maxY) maxY = y3;
      this._ids[i3] = i3;
    }
    const cx = (minX + maxX) / 2;
    const cy = (minY + maxY) / 2;
    let i0, i1, i2;
    for (let i3 = 0, minDist = Infinity; i3 < n; i3++) {
      const d = dist(cx, cy, coords[2 * i3], coords[2 * i3 + 1]);
      if (d < minDist) {
        i0 = i3;
        minDist = d;
      }
    }
    const i0x = coords[2 * i0];
    const i0y = coords[2 * i0 + 1];
    for (let i3 = 0, minDist = Infinity; i3 < n; i3++) {
      if (i3 === i0) continue;
      const d = dist(i0x, i0y, coords[2 * i3], coords[2 * i3 + 1]);
      if (d < minDist && d > 0) {
        i1 = i3;
        minDist = d;
      }
    }
    let i1x = coords[2 * i1];
    let i1y = coords[2 * i1 + 1];
    let minRadius = Infinity;
    for (let i3 = 0; i3 < n; i3++) {
      if (i3 === i0 || i3 === i1) continue;
      const r3 = circumradius(i0x, i0y, i1x, i1y, coords[2 * i3], coords[2 * i3 + 1]);
      if (r3 < minRadius) {
        i2 = i3;
        minRadius = r3;
      }
    }
    let i2x = coords[2 * i2];
    let i2y = coords[2 * i2 + 1];
    if (minRadius === Infinity) {
      for (let i3 = 0; i3 < n; i3++) {
        this._dists[i3] = coords[2 * i3] - coords[0] || coords[2 * i3 + 1] - coords[1];
      }
      quicksort(this._ids, this._dists, 0, n - 1);
      const hull = new Uint32Array(n);
      let j2 = 0;
      for (let i3 = 0, d0 = -Infinity; i3 < n; i3++) {
        const id = this._ids[i3];
        const d = this._dists[id];
        if (d > d0) {
          hull[j2++] = id;
          d0 = d;
        }
      }
      this.hull = hull.subarray(0, j2);
      this.triangles = new Uint32Array(0);
      this.halfedges = new Uint32Array(0);
      return;
    }
    if (orient2d(i0x, i0y, i1x, i1y, i2x, i2y) < 0) {
      const i3 = i1;
      const x3 = i1x;
      const y3 = i1y;
      i1 = i2;
      i1x = i2x;
      i1y = i2y;
      i2 = i3;
      i2x = x3;
      i2y = y3;
    }
    const center = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);
    this._cx = center.x;
    this._cy = center.y;
    for (let i3 = 0; i3 < n; i3++) {
      this._dists[i3] = dist(coords[2 * i3], coords[2 * i3 + 1], center.x, center.y);
    }
    quicksort(this._ids, this._dists, 0, n - 1);
    this._hullStart = i0;
    let hullSize = 3;
    hullNext[i0] = hullPrev[i2] = i1;
    hullNext[i1] = hullPrev[i0] = i2;
    hullNext[i2] = hullPrev[i1] = i0;
    hullTri[i0] = 0;
    hullTri[i1] = 1;
    hullTri[i2] = 2;
    hullHash.fill(-1);
    hullHash[this._hashKey(i0x, i0y)] = i0;
    hullHash[this._hashKey(i1x, i1y)] = i1;
    hullHash[this._hashKey(i2x, i2y)] = i2;
    this.trianglesLen = 0;
    this._addTriangle(i0, i1, i2, -1, -1, -1);
    for (let k3 = 0, xp, yp; k3 < this._ids.length; k3++) {
      const i3 = this._ids[k3];
      const x3 = coords[2 * i3];
      const y3 = coords[2 * i3 + 1];
      if (k3 > 0 && Math.abs(x3 - xp) <= EPSILON && Math.abs(y3 - yp) <= EPSILON) continue;
      xp = x3;
      yp = y3;
      if (i3 === i0 || i3 === i1 || i3 === i2) continue;
      let start2 = 0;
      for (let j2 = 0, key = this._hashKey(x3, y3); j2 < this._hashSize; j2++) {
        start2 = hullHash[(key + j2) % this._hashSize];
        if (start2 !== -1 && start2 !== hullNext[start2]) break;
      }
      start2 = hullPrev[start2];
      let e = start2, q2;
      while (q2 = hullNext[e], orient2d(x3, y3, coords[2 * e], coords[2 * e + 1], coords[2 * q2], coords[2 * q2 + 1]) >= 0) {
        e = q2;
        if (e === start2) {
          e = -1;
          break;
        }
      }
      if (e === -1) continue;
      let t = this._addTriangle(e, i3, hullNext[e], -1, -1, hullTri[e]);
      hullTri[i3] = this._legalize(t + 2);
      hullTri[e] = t;
      hullSize++;
      let n2 = hullNext[e];
      while (q2 = hullNext[n2], orient2d(x3, y3, coords[2 * n2], coords[2 * n2 + 1], coords[2 * q2], coords[2 * q2 + 1]) < 0) {
        t = this._addTriangle(n2, i3, q2, hullTri[i3], -1, hullTri[n2]);
        hullTri[i3] = this._legalize(t + 2);
        hullNext[n2] = n2;
        hullSize--;
        n2 = q2;
      }
      if (e === start2) {
        while (q2 = hullPrev[e], orient2d(x3, y3, coords[2 * q2], coords[2 * q2 + 1], coords[2 * e], coords[2 * e + 1]) < 0) {
          t = this._addTriangle(q2, i3, e, -1, hullTri[e], hullTri[q2]);
          this._legalize(t + 2);
          hullTri[q2] = t;
          hullNext[e] = e;
          hullSize--;
          e = q2;
        }
      }
      this._hullStart = hullPrev[i3] = e;
      hullNext[e] = hullPrev[n2] = i3;
      hullNext[i3] = n2;
      hullHash[this._hashKey(x3, y3)] = i3;
      hullHash[this._hashKey(coords[2 * e], coords[2 * e + 1])] = e;
    }
    this.hull = new Uint32Array(hullSize);
    for (let i3 = 0, e = this._hullStart; i3 < hullSize; i3++) {
      this.hull[i3] = e;
      e = hullNext[e];
    }
    this.triangles = this._triangles.subarray(0, this.trianglesLen);
    this.halfedges = this._halfedges.subarray(0, this.trianglesLen);
  }
  _hashKey(x3, y3) {
    return Math.floor(pseudoAngle(x3 - this._cx, y3 - this._cy) * this._hashSize) % this._hashSize;
  }
  _legalize(a3) {
    const { _triangles: triangles, _halfedges: halfedges, coords } = this;
    let i2 = 0;
    let ar = 0;
    while (true) {
      const b2 = halfedges[a3];
      const a0 = a3 - a3 % 3;
      ar = a0 + (a3 + 2) % 3;
      if (b2 === -1) {
        if (i2 === 0) break;
        a3 = EDGE_STACK[--i2];
        continue;
      }
      const b0 = b2 - b2 % 3;
      const al = a0 + (a3 + 1) % 3;
      const bl = b0 + (b2 + 2) % 3;
      const p0 = triangles[ar];
      const pr = triangles[a3];
      const pl = triangles[al];
      const p1 = triangles[bl];
      const illegal = inCircle(
        coords[2 * p0],
        coords[2 * p0 + 1],
        coords[2 * pr],
        coords[2 * pr + 1],
        coords[2 * pl],
        coords[2 * pl + 1],
        coords[2 * p1],
        coords[2 * p1 + 1]
      );
      if (illegal) {
        triangles[a3] = p1;
        triangles[b2] = p0;
        const hbl = halfedges[bl];
        if (hbl === -1) {
          let e = this._hullStart;
          do {
            if (this._hullTri[e] === bl) {
              this._hullTri[e] = a3;
              break;
            }
            e = this._hullPrev[e];
          } while (e !== this._hullStart);
        }
        this._link(a3, hbl);
        this._link(b2, halfedges[ar]);
        this._link(ar, bl);
        const br = b0 + (b2 + 1) % 3;
        if (i2 < EDGE_STACK.length) {
          EDGE_STACK[i2++] = br;
        }
      } else {
        if (i2 === 0) break;
        a3 = EDGE_STACK[--i2];
      }
    }
    return ar;
  }
  _link(a3, b2) {
    this._halfedges[a3] = b2;
    if (b2 !== -1) this._halfedges[b2] = a3;
  }
  // add a new triangle given vertex indices and adjacent half-edge ids
  _addTriangle(i0, i1, i2, a3, b2, c3) {
    const t = this.trianglesLen;
    this._triangles[t] = i0;
    this._triangles[t + 1] = i1;
    this._triangles[t + 2] = i2;
    this._link(t, a3);
    this._link(t + 1, b2);
    this._link(t + 2, c3);
    this.trianglesLen += 3;
    return t;
  }
};
function pseudoAngle(dx, dy) {
  const p2 = dx / (Math.abs(dx) + Math.abs(dy));
  return (dy > 0 ? 3 - p2 : 1 + p2) / 4;
}
function dist(ax, ay, bx, by) {
  const dx = ax - bx;
  const dy = ay - by;
  return dx * dx + dy * dy;
}
function inCircle(ax, ay, bx, by, cx, cy, px, py) {
  const dx = ax - px;
  const dy = ay - py;
  const ex = bx - px;
  const ey = by - py;
  const fx = cx - px;
  const fy = cy - py;
  const ap = dx * dx + dy * dy;
  const bp = ex * ex + ey * ey;
  const cp = fx * fx + fy * fy;
  return dx * (ey * cp - bp * fy) - dy * (ex * cp - bp * fx) + ap * (ex * fy - ey * fx) < 0;
}
function circumradius(ax, ay, bx, by, cx, cy) {
  const dx = bx - ax;
  const dy = by - ay;
  const ex = cx - ax;
  const ey = cy - ay;
  const bl = dx * dx + dy * dy;
  const cl = ex * ex + ey * ey;
  const d = 0.5 / (dx * ey - dy * ex);
  const x3 = (ey * bl - dy * cl) * d;
  const y3 = (dx * cl - ex * bl) * d;
  return x3 * x3 + y3 * y3;
}
function circumcenter(ax, ay, bx, by, cx, cy) {
  const dx = bx - ax;
  const dy = by - ay;
  const ex = cx - ax;
  const ey = cy - ay;
  const bl = dx * dx + dy * dy;
  const cl = ex * ex + ey * ey;
  const d = 0.5 / (dx * ey - dy * ex);
  const x3 = ax + (ey * bl - dy * cl) * d;
  const y3 = ay + (dx * cl - ex * bl) * d;
  return { x: x3, y: y3 };
}
function quicksort(ids, dists, left3, right3) {
  if (right3 - left3 <= 20) {
    for (let i2 = left3 + 1; i2 <= right3; i2++) {
      const temp = ids[i2];
      const tempDist = dists[temp];
      let j2 = i2 - 1;
      while (j2 >= left3 && dists[ids[j2]] > tempDist) ids[j2 + 1] = ids[j2--];
      ids[j2 + 1] = temp;
    }
  } else {
    const median2 = left3 + right3 >> 1;
    let i2 = left3 + 1;
    let j2 = right3;
    swap(ids, median2, i2);
    if (dists[ids[left3]] > dists[ids[right3]]) swap(ids, left3, right3);
    if (dists[ids[i2]] > dists[ids[right3]]) swap(ids, i2, right3);
    if (dists[ids[left3]] > dists[ids[i2]]) swap(ids, left3, i2);
    const temp = ids[i2];
    const tempDist = dists[temp];
    while (true) {
      do
        i2++;
      while (dists[ids[i2]] < tempDist);
      do
        j2--;
      while (dists[ids[j2]] > tempDist);
      if (j2 < i2) break;
      swap(ids, i2, j2);
    }
    ids[left3 + 1] = ids[j2];
    ids[j2] = temp;
    if (right3 - i2 + 1 >= j2 - left3) {
      quicksort(ids, dists, i2, right3);
      quicksort(ids, dists, left3, j2 - 1);
    } else {
      quicksort(ids, dists, left3, j2 - 1);
      quicksort(ids, dists, i2, right3);
    }
  }
}
function swap(arr, i2, j2) {
  const tmp = arr[i2];
  arr[i2] = arr[j2];
  arr[j2] = tmp;
}
function defaultGetX(p2) {
  return p2[0];
}
function defaultGetY(p2) {
  return p2[1];
}

// node_modules/d3-delaunay/src/path.js
var epsilon5 = 1e-6;
var Path2 = class {
  constructor() {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null;
    this._ = "";
  }
  moveTo(x3, y3) {
    this._ += `M${this._x0 = this._x1 = +x3},${this._y0 = this._y1 = +y3}`;
  }
  closePath() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  }
  lineTo(x3, y3) {
    this._ += `L${this._x1 = +x3},${this._y1 = +y3}`;
  }
  arc(x3, y3, r3) {
    x3 = +x3, y3 = +y3, r3 = +r3;
    const x0 = x3 + r3;
    const y0 = y3;
    if (r3 < 0) throw new Error("negative radius");
    if (this._x1 === null) this._ += `M${x0},${y0}`;
    else if (Math.abs(this._x1 - x0) > epsilon5 || Math.abs(this._y1 - y0) > epsilon5) this._ += "L" + x0 + "," + y0;
    if (!r3) return;
    this._ += `A${r3},${r3},0,1,1,${x3 - r3},${y3}A${r3},${r3},0,1,1,${this._x1 = x0},${this._y1 = y0}`;
  }
  rect(x3, y3, w2, h) {
    this._ += `M${this._x0 = this._x1 = +x3},${this._y0 = this._y1 = +y3}h${+w2}v${+h}h${-w2}Z`;
  }
  value() {
    return this._ || null;
  }
};

// node_modules/d3-delaunay/src/polygon.js
var Polygon = class {
  constructor() {
    this._ = [];
  }
  moveTo(x3, y3) {
    this._.push([x3, y3]);
  }
  closePath() {
    this._.push(this._[0].slice());
  }
  lineTo(x3, y3) {
    this._.push([x3, y3]);
  }
  value() {
    return this._.length ? this._ : null;
  }
};

// node_modules/d3-delaunay/src/voronoi.js
var Voronoi = class {
  constructor(delaunay, [xmin, ymin, xmax, ymax] = [0, 0, 960, 500]) {
    if (!((xmax = +xmax) >= (xmin = +xmin)) || !((ymax = +ymax) >= (ymin = +ymin))) throw new Error("invalid bounds");
    this.delaunay = delaunay;
    this._circumcenters = new Float64Array(delaunay.points.length * 2);
    this.vectors = new Float64Array(delaunay.points.length * 2);
    this.xmax = xmax, this.xmin = xmin;
    this.ymax = ymax, this.ymin = ymin;
    this._init();
  }
  update() {
    this.delaunay.update();
    this._init();
    return this;
  }
  _init() {
    const { delaunay: { points, hull, triangles }, vectors } = this;
    let bx, by;
    const circumcenters = this.circumcenters = this._circumcenters.subarray(0, triangles.length / 3 * 2);
    for (let i2 = 0, j2 = 0, n = triangles.length, x3, y3; i2 < n; i2 += 3, j2 += 2) {
      const t13 = triangles[i2] * 2;
      const t22 = triangles[i2 + 1] * 2;
      const t32 = triangles[i2 + 2] * 2;
      const x12 = points[t13];
      const y12 = points[t13 + 1];
      const x22 = points[t22];
      const y22 = points[t22 + 1];
      const x32 = points[t32];
      const y32 = points[t32 + 1];
      const dx = x22 - x12;
      const dy = y22 - y12;
      const ex = x32 - x12;
      const ey = y32 - y12;
      const ab4 = (dx * ey - dy * ex) * 2;
      if (Math.abs(ab4) < 1e-9) {
        if (bx === void 0) {
          bx = by = 0;
          for (const i3 of hull) bx += points[i3 * 2], by += points[i3 * 2 + 1];
          bx /= hull.length, by /= hull.length;
        }
        const a3 = 1e9 * Math.sign((bx - x12) * ey - (by - y12) * ex);
        x3 = (x12 + x32) / 2 - a3 * ey;
        y3 = (y12 + y32) / 2 + a3 * ex;
      } else {
        const d = 1 / ab4;
        const bl = dx * dx + dy * dy;
        const cl = ex * ex + ey * ey;
        x3 = x12 + (ey * bl - dy * cl) * d;
        y3 = y12 + (dx * cl - ex * bl) * d;
      }
      circumcenters[j2] = x3;
      circumcenters[j2 + 1] = y3;
    }
    let h = hull[hull.length - 1];
    let p0, p1 = h * 4;
    let x0, x1 = points[2 * h];
    let y0, y1 = points[2 * h + 1];
    vectors.fill(0);
    for (let i2 = 0; i2 < hull.length; ++i2) {
      h = hull[i2];
      p0 = p1, x0 = x1, y0 = y1;
      p1 = h * 4, x1 = points[2 * h], y1 = points[2 * h + 1];
      vectors[p0 + 2] = vectors[p1] = y0 - y1;
      vectors[p0 + 3] = vectors[p1 + 1] = x1 - x0;
    }
  }
  render(context) {
    const buffer = context == null ? context = new Path2() : void 0;
    const { delaunay: { halfedges, inedges, hull }, circumcenters, vectors } = this;
    if (hull.length <= 1) return null;
    for (let i2 = 0, n = halfedges.length; i2 < n; ++i2) {
      const j2 = halfedges[i2];
      if (j2 < i2) continue;
      const ti = Math.floor(i2 / 3) * 2;
      const tj = Math.floor(j2 / 3) * 2;
      const xi = circumcenters[ti];
      const yi = circumcenters[ti + 1];
      const xj = circumcenters[tj];
      const yj = circumcenters[tj + 1];
      this._renderSegment(xi, yi, xj, yj, context);
    }
    let h0, h1 = hull[hull.length - 1];
    for (let i2 = 0; i2 < hull.length; ++i2) {
      h0 = h1, h1 = hull[i2];
      const t = Math.floor(inedges[h1] / 3) * 2;
      const x3 = circumcenters[t];
      const y3 = circumcenters[t + 1];
      const v3 = h0 * 4;
      const p2 = this._project(x3, y3, vectors[v3 + 2], vectors[v3 + 3]);
      if (p2) this._renderSegment(x3, y3, p2[0], p2[1], context);
    }
    return buffer && buffer.value();
  }
  renderBounds(context) {
    const buffer = context == null ? context = new Path2() : void 0;
    context.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin);
    return buffer && buffer.value();
  }
  renderCell(i2, context) {
    const buffer = context == null ? context = new Path2() : void 0;
    const points = this._clip(i2);
    if (points === null || !points.length) return;
    context.moveTo(points[0], points[1]);
    let n = points.length;
    while (points[0] === points[n - 2] && points[1] === points[n - 1] && n > 1) n -= 2;
    for (let i3 = 2; i3 < n; i3 += 2) {
      if (points[i3] !== points[i3 - 2] || points[i3 + 1] !== points[i3 - 1])
        context.lineTo(points[i3], points[i3 + 1]);
    }
    context.closePath();
    return buffer && buffer.value();
  }
  *cellPolygons() {
    const { delaunay: { points } } = this;
    for (let i2 = 0, n = points.length / 2; i2 < n; ++i2) {
      const cell = this.cellPolygon(i2);
      if (cell) cell.index = i2, yield cell;
    }
  }
  cellPolygon(i2) {
    const polygon = new Polygon();
    this.renderCell(i2, polygon);
    return polygon.value();
  }
  _renderSegment(x0, y0, x1, y1, context) {
    let S2;
    const c0 = this._regioncode(x0, y0);
    const c1 = this._regioncode(x1, y1);
    if (c0 === 0 && c1 === 0) {
      context.moveTo(x0, y0);
      context.lineTo(x1, y1);
    } else if (S2 = this._clipSegment(x0, y0, x1, y1, c0, c1)) {
      context.moveTo(S2[0], S2[1]);
      context.lineTo(S2[2], S2[3]);
    }
  }
  contains(i2, x3, y3) {
    if ((x3 = +x3, x3 !== x3) || (y3 = +y3, y3 !== y3)) return false;
    return this.delaunay._step(i2, x3, y3) === i2;
  }
  *neighbors(i2) {
    const ci = this._clip(i2);
    if (ci) for (const j2 of this.delaunay.neighbors(i2)) {
      const cj = this._clip(j2);
      if (cj) loop: for (let ai = 0, li = ci.length; ai < li; ai += 2) {
        for (let aj = 0, lj = cj.length; aj < lj; aj += 2) {
          if (ci[ai] === cj[aj] && ci[ai + 1] === cj[aj + 1] && ci[(ai + 2) % li] === cj[(aj + lj - 2) % lj] && ci[(ai + 3) % li] === cj[(aj + lj - 1) % lj]) {
            yield j2;
            break loop;
          }
        }
      }
    }
  }
  _cell(i2) {
    const { circumcenters, delaunay: { inedges, halfedges, triangles } } = this;
    const e0 = inedges[i2];
    if (e0 === -1) return null;
    const points = [];
    let e = e0;
    do {
      const t = Math.floor(e / 3);
      points.push(circumcenters[t * 2], circumcenters[t * 2 + 1]);
      e = e % 3 === 2 ? e - 2 : e + 1;
      if (triangles[e] !== i2) break;
      e = halfedges[e];
    } while (e !== e0 && e !== -1);
    return points;
  }
  _clip(i2) {
    if (i2 === 0 && this.delaunay.hull.length === 1) {
      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
    }
    const points = this._cell(i2);
    if (points === null) return null;
    const { vectors: V2 } = this;
    const v3 = i2 * 4;
    return this._simplify(V2[v3] || V2[v3 + 1] ? this._clipInfinite(i2, points, V2[v3], V2[v3 + 1], V2[v3 + 2], V2[v3 + 3]) : this._clipFinite(i2, points));
  }
  _clipFinite(i2, points) {
    const n = points.length;
    let P2 = null;
    let x0, y0, x1 = points[n - 2], y1 = points[n - 1];
    let c0, c1 = this._regioncode(x1, y1);
    let e0, e1 = 0;
    for (let j2 = 0; j2 < n; j2 += 2) {
      x0 = x1, y0 = y1, x1 = points[j2], y1 = points[j2 + 1];
      c0 = c1, c1 = this._regioncode(x1, y1);
      if (c0 === 0 && c1 === 0) {
        e0 = e1, e1 = 0;
        if (P2) P2.push(x1, y1);
        else P2 = [x1, y1];
      } else {
        let S2, sx0, sy0, sx1, sy1;
        if (c0 === 0) {
          if ((S2 = this._clipSegment(x0, y0, x1, y1, c0, c1)) === null) continue;
          [sx0, sy0, sx1, sy1] = S2;
        } else {
          if ((S2 = this._clipSegment(x1, y1, x0, y0, c1, c0)) === null) continue;
          [sx1, sy1, sx0, sy0] = S2;
          e0 = e1, e1 = this._edgecode(sx0, sy0);
          if (e0 && e1) this._edge(i2, e0, e1, P2, P2.length);
          if (P2) P2.push(sx0, sy0);
          else P2 = [sx0, sy0];
        }
        e0 = e1, e1 = this._edgecode(sx1, sy1);
        if (e0 && e1) this._edge(i2, e0, e1, P2, P2.length);
        if (P2) P2.push(sx1, sy1);
        else P2 = [sx1, sy1];
      }
    }
    if (P2) {
      e0 = e1, e1 = this._edgecode(P2[0], P2[1]);
      if (e0 && e1) this._edge(i2, e0, e1, P2, P2.length);
    } else if (this.contains(i2, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
    }
    return P2;
  }
  _clipSegment(x0, y0, x1, y1, c0, c1) {
    const flip2 = c0 < c1;
    if (flip2) [x0, y0, x1, y1, c0, c1] = [x1, y1, x0, y0, c1, c0];
    while (true) {
      if (c0 === 0 && c1 === 0) return flip2 ? [x1, y1, x0, y0] : [x0, y0, x1, y1];
      if (c0 & c1) return null;
      let x3, y3, c3 = c0 || c1;
      if (c3 & 8) x3 = x0 + (x1 - x0) * (this.ymax - y0) / (y1 - y0), y3 = this.ymax;
      else if (c3 & 4) x3 = x0 + (x1 - x0) * (this.ymin - y0) / (y1 - y0), y3 = this.ymin;
      else if (c3 & 2) y3 = y0 + (y1 - y0) * (this.xmax - x0) / (x1 - x0), x3 = this.xmax;
      else y3 = y0 + (y1 - y0) * (this.xmin - x0) / (x1 - x0), x3 = this.xmin;
      if (c0) x0 = x3, y0 = y3, c0 = this._regioncode(x0, y0);
      else x1 = x3, y1 = y3, c1 = this._regioncode(x1, y1);
    }
  }
  _clipInfinite(i2, points, vx0, vy0, vxn, vyn) {
    let P2 = Array.from(points), p2;
    if (p2 = this._project(P2[0], P2[1], vx0, vy0)) P2.unshift(p2[0], p2[1]);
    if (p2 = this._project(P2[P2.length - 2], P2[P2.length - 1], vxn, vyn)) P2.push(p2[0], p2[1]);
    if (P2 = this._clipFinite(i2, P2)) {
      for (let j2 = 0, n = P2.length, c0, c1 = this._edgecode(P2[n - 2], P2[n - 1]); j2 < n; j2 += 2) {
        c0 = c1, c1 = this._edgecode(P2[j2], P2[j2 + 1]);
        if (c0 && c1) j2 = this._edge(i2, c0, c1, P2, j2), n = P2.length;
      }
    } else if (this.contains(i2, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
      P2 = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax];
    }
    return P2;
  }
  _edge(i2, e0, e1, P2, j2) {
    while (e0 !== e1) {
      let x3, y3;
      switch (e0) {
        case 5:
          e0 = 4;
          continue;
        // top-left
        case 4:
          e0 = 6, x3 = this.xmax, y3 = this.ymin;
          break;
        // top
        case 6:
          e0 = 2;
          continue;
        // top-right
        case 2:
          e0 = 10, x3 = this.xmax, y3 = this.ymax;
          break;
        // right
        case 10:
          e0 = 8;
          continue;
        // bottom-right
        case 8:
          e0 = 9, x3 = this.xmin, y3 = this.ymax;
          break;
        // bottom
        case 9:
          e0 = 1;
          continue;
        // bottom-left
        case 1:
          e0 = 5, x3 = this.xmin, y3 = this.ymin;
          break;
      }
      if ((P2[j2] !== x3 || P2[j2 + 1] !== y3) && this.contains(i2, x3, y3)) {
        P2.splice(j2, 0, x3, y3), j2 += 2;
      }
    }
    return j2;
  }
  _project(x0, y0, vx, vy) {
    let t = Infinity, c3, x3, y3;
    if (vy < 0) {
      if (y0 <= this.ymin) return null;
      if ((c3 = (this.ymin - y0) / vy) < t) y3 = this.ymin, x3 = x0 + (t = c3) * vx;
    } else if (vy > 0) {
      if (y0 >= this.ymax) return null;
      if ((c3 = (this.ymax - y0) / vy) < t) y3 = this.ymax, x3 = x0 + (t = c3) * vx;
    }
    if (vx > 0) {
      if (x0 >= this.xmax) return null;
      if ((c3 = (this.xmax - x0) / vx) < t) x3 = this.xmax, y3 = y0 + (t = c3) * vy;
    } else if (vx < 0) {
      if (x0 <= this.xmin) return null;
      if ((c3 = (this.xmin - x0) / vx) < t) x3 = this.xmin, y3 = y0 + (t = c3) * vy;
    }
    return [x3, y3];
  }
  _edgecode(x3, y3) {
    return (x3 === this.xmin ? 1 : x3 === this.xmax ? 2 : 0) | (y3 === this.ymin ? 4 : y3 === this.ymax ? 8 : 0);
  }
  _regioncode(x3, y3) {
    return (x3 < this.xmin ? 1 : x3 > this.xmax ? 2 : 0) | (y3 < this.ymin ? 4 : y3 > this.ymax ? 8 : 0);
  }
  _simplify(P2) {
    if (P2 && P2.length > 4) {
      for (let i2 = 0; i2 < P2.length; i2 += 2) {
        const j2 = (i2 + 2) % P2.length, k3 = (i2 + 4) % P2.length;
        if (P2[i2] === P2[j2] && P2[j2] === P2[k3] || P2[i2 + 1] === P2[j2 + 1] && P2[j2 + 1] === P2[k3 + 1]) {
          P2.splice(j2, 2), i2 -= 2;
        }
      }
      if (!P2.length) P2 = null;
    }
    return P2;
  }
};

// node_modules/d3-delaunay/src/delaunay.js
var tau3 = 2 * Math.PI;
var pow2 = Math.pow;
function pointX(p2) {
  return p2[0];
}
function pointY(p2) {
  return p2[1];
}
function collinear(d) {
  const { triangles, coords } = d;
  for (let i2 = 0; i2 < triangles.length; i2 += 3) {
    const a3 = 2 * triangles[i2], b2 = 2 * triangles[i2 + 1], c3 = 2 * triangles[i2 + 2], cross2 = (coords[c3] - coords[a3]) * (coords[b2 + 1] - coords[a3 + 1]) - (coords[b2] - coords[a3]) * (coords[c3 + 1] - coords[a3 + 1]);
    if (cross2 > 1e-10) return false;
  }
  return true;
}
function jitter(x3, y3, r3) {
  return [x3 + Math.sin(x3 + y3) * r3, y3 + Math.cos(x3 - y3) * r3];
}
var Delaunay = class _Delaunay {
  static from(points, fx = pointX, fy = pointY, that) {
    return new _Delaunay("length" in points ? flatArray(points, fx, fy, that) : Float64Array.from(flatIterable(points, fx, fy, that)));
  }
  constructor(points) {
    this._delaunator = new Delaunator(points);
    this.inedges = new Int32Array(points.length / 2);
    this._hullIndex = new Int32Array(points.length / 2);
    this.points = this._delaunator.coords;
    this._init();
  }
  update() {
    this._delaunator.update();
    this._init();
    return this;
  }
  _init() {
    const d = this._delaunator, points = this.points;
    if (d.hull && d.hull.length > 2 && collinear(d)) {
      this.collinear = Int32Array.from({ length: points.length / 2 }, (_2, i2) => i2).sort((i2, j2) => points[2 * i2] - points[2 * j2] || points[2 * i2 + 1] - points[2 * j2 + 1]);
      const e = this.collinear[0], f2 = this.collinear[this.collinear.length - 1], bounds = [points[2 * e], points[2 * e + 1], points[2 * f2], points[2 * f2 + 1]], r3 = 1e-8 * Math.hypot(bounds[3] - bounds[1], bounds[2] - bounds[0]);
      for (let i2 = 0, n = points.length / 2; i2 < n; ++i2) {
        const p2 = jitter(points[2 * i2], points[2 * i2 + 1], r3);
        points[2 * i2] = p2[0];
        points[2 * i2 + 1] = p2[1];
      }
      this._delaunator = new Delaunator(points);
    } else {
      delete this.collinear;
    }
    const halfedges = this.halfedges = this._delaunator.halfedges;
    const hull = this.hull = this._delaunator.hull;
    const triangles = this.triangles = this._delaunator.triangles;
    const inedges = this.inedges.fill(-1);
    const hullIndex = this._hullIndex.fill(-1);
    for (let e = 0, n = halfedges.length; e < n; ++e) {
      const p2 = triangles[e % 3 === 2 ? e - 2 : e + 1];
      if (halfedges[e] === -1 || inedges[p2] === -1) inedges[p2] = e;
    }
    for (let i2 = 0, n = hull.length; i2 < n; ++i2) {
      hullIndex[hull[i2]] = i2;
    }
    if (hull.length <= 2 && hull.length > 0) {
      this.triangles = new Int32Array(3).fill(-1);
      this.halfedges = new Int32Array(3).fill(-1);
      this.triangles[0] = hull[0];
      inedges[hull[0]] = 1;
      if (hull.length === 2) {
        inedges[hull[1]] = 0;
        this.triangles[1] = hull[1];
        this.triangles[2] = hull[1];
      }
    }
  }
  voronoi(bounds) {
    return new Voronoi(this, bounds);
  }
  *neighbors(i2) {
    const { inedges, hull, _hullIndex, halfedges, triangles, collinear: collinear2 } = this;
    if (collinear2) {
      const l2 = collinear2.indexOf(i2);
      if (l2 > 0) yield collinear2[l2 - 1];
      if (l2 < collinear2.length - 1) yield collinear2[l2 + 1];
      return;
    }
    const e0 = inedges[i2];
    if (e0 === -1) return;
    let e = e0, p0 = -1;
    do {
      yield p0 = triangles[e];
      e = e % 3 === 2 ? e - 2 : e + 1;
      if (triangles[e] !== i2) return;
      e = halfedges[e];
      if (e === -1) {
        const p2 = hull[(_hullIndex[i2] + 1) % hull.length];
        if (p2 !== p0) yield p2;
        return;
      }
    } while (e !== e0);
  }
  find(x3, y3, i2 = 0) {
    if ((x3 = +x3, x3 !== x3) || (y3 = +y3, y3 !== y3)) return -1;
    const i0 = i2;
    let c3;
    while ((c3 = this._step(i2, x3, y3)) >= 0 && c3 !== i2 && c3 !== i0) i2 = c3;
    return c3;
  }
  _step(i2, x3, y3) {
    const { inedges, hull, _hullIndex, halfedges, triangles, points } = this;
    if (inedges[i2] === -1 || !points.length) return (i2 + 1) % (points.length >> 1);
    let c3 = i2;
    let dc = pow2(x3 - points[i2 * 2], 2) + pow2(y3 - points[i2 * 2 + 1], 2);
    const e0 = inedges[i2];
    let e = e0;
    do {
      let t = triangles[e];
      const dt2 = pow2(x3 - points[t * 2], 2) + pow2(y3 - points[t * 2 + 1], 2);
      if (dt2 < dc) dc = dt2, c3 = t;
      e = e % 3 === 2 ? e - 2 : e + 1;
      if (triangles[e] !== i2) break;
      e = halfedges[e];
      if (e === -1) {
        e = hull[(_hullIndex[i2] + 1) % hull.length];
        if (e !== t) {
          if (pow2(x3 - points[e * 2], 2) + pow2(y3 - points[e * 2 + 1], 2) < dc) return e;
        }
        break;
      }
    } while (e !== e0);
    return c3;
  }
  render(context) {
    const buffer = context == null ? context = new Path2() : void 0;
    const { points, halfedges, triangles } = this;
    for (let i2 = 0, n = halfedges.length; i2 < n; ++i2) {
      const j2 = halfedges[i2];
      if (j2 < i2) continue;
      const ti = triangles[i2] * 2;
      const tj = triangles[j2] * 2;
      context.moveTo(points[ti], points[ti + 1]);
      context.lineTo(points[tj], points[tj + 1]);
    }
    this.renderHull(context);
    return buffer && buffer.value();
  }
  renderPoints(context, r3) {
    if (r3 === void 0 && (!context || typeof context.moveTo !== "function")) r3 = context, context = null;
    r3 = r3 == void 0 ? 2 : +r3;
    const buffer = context == null ? context = new Path2() : void 0;
    const { points } = this;
    for (let i2 = 0, n = points.length; i2 < n; i2 += 2) {
      const x3 = points[i2], y3 = points[i2 + 1];
      context.moveTo(x3 + r3, y3);
      context.arc(x3, y3, r3, 0, tau3);
    }
    return buffer && buffer.value();
  }
  renderHull(context) {
    const buffer = context == null ? context = new Path2() : void 0;
    const { hull, points } = this;
    const h = hull[0] * 2, n = hull.length;
    context.moveTo(points[h], points[h + 1]);
    for (let i2 = 1; i2 < n; ++i2) {
      const h2 = 2 * hull[i2];
      context.lineTo(points[h2], points[h2 + 1]);
    }
    context.closePath();
    return buffer && buffer.value();
  }
  hullPolygon() {
    const polygon = new Polygon();
    this.renderHull(polygon);
    return polygon.value();
  }
  renderTriangle(i2, context) {
    const buffer = context == null ? context = new Path2() : void 0;
    const { points, triangles } = this;
    const t03 = triangles[i2 *= 3] * 2;
    const t13 = triangles[i2 + 1] * 2;
    const t22 = triangles[i2 + 2] * 2;
    context.moveTo(points[t03], points[t03 + 1]);
    context.lineTo(points[t13], points[t13 + 1]);
    context.lineTo(points[t22], points[t22 + 1]);
    context.closePath();
    return buffer && buffer.value();
  }
  *trianglePolygons() {
    const { triangles } = this;
    for (let i2 = 0, n = triangles.length / 3; i2 < n; ++i2) {
      yield this.trianglePolygon(i2);
    }
  }
  trianglePolygon(i2) {
    const polygon = new Polygon();
    this.renderTriangle(i2, polygon);
    return polygon.value();
  }
};
function flatArray(points, fx, fy, that) {
  const n = points.length;
  const array2 = new Float64Array(n * 2);
  for (let i2 = 0; i2 < n; ++i2) {
    const p2 = points[i2];
    array2[i2 * 2] = fx.call(that, p2, i2, points);
    array2[i2 * 2 + 1] = fy.call(that, p2, i2, points);
  }
  return array2;
}
function* flatIterable(points, fx, fy, that) {
  let i2 = 0;
  for (const p2 of points) {
    yield fx.call(that, p2, i2, points);
    yield fy.call(that, p2, i2, points);
    ++i2;
  }
}

// node_modules/@mui/x-charts/esm/internals/plugins/featurePlugins/useChartVoronoi/useChartVoronoi.js
var useChartVoronoi = ({
  svgRef,
  params,
  store,
  instance
}) => {
  var _a;
  const {
    disableVoronoi,
    voronoiMaxRadius,
    onItemClick
  } = params;
  const drawingArea = useSelector(store, selectorChartDrawingArea);
  const {
    axis: xAxis,
    axisIds: xAxisIds
  } = useSelector(store, selectorChartXAxis);
  const {
    axis: yAxis,
    axisIds: yAxisIds
  } = useSelector(store, selectorChartYAxis);
  const zoomIsInteracting = useSelector(store, selectorChartZoomIsInteracting);
  const {
    series,
    seriesOrder
  } = ((_a = useSelector(store, selectorChartSeriesProcessed)) == null ? void 0 : _a.scatter) ?? {};
  const voronoiRef = React97.useRef({});
  const delauneyRef = React97.useRef(void 0);
  const lastFind = React97.useRef(void 0);
  const defaultXAxisId = xAxisIds[0];
  const defaultYAxisId = yAxisIds[0];
  useEnhancedEffect_default(() => {
    store.update((prev2) => prev2.voronoi.isVoronoiEnabled === !disableVoronoi ? prev2 : _extends({}, prev2, {
      voronoi: {
        isVoronoiEnabled: !disableVoronoi
      }
    }));
  }, [store, disableVoronoi]);
  useEnhancedEffect_default(() => {
    if (zoomIsInteracting || seriesOrder === void 0 || series === void 0 || disableVoronoi) {
      return;
    }
    voronoiRef.current = {};
    let points = [];
    seriesOrder.forEach((seriesId) => {
      const {
        data,
        xAxisId,
        yAxisId
      } = series[seriesId];
      const xScale = xAxis[xAxisId ?? defaultXAxisId].scale;
      const yScale = yAxis[yAxisId ?? defaultYAxisId].scale;
      const getXPosition = getValueToPositionMapper(xScale);
      const getYPosition = getValueToPositionMapper(yScale);
      const seriesPoints = data.flatMap(({
        x: x3,
        y: y3
      }) => {
        const pointX2 = getXPosition(x3);
        const pointY2 = getYPosition(y3);
        if (!instance.isPointInside({
          x: pointX2,
          y: pointY2
        })) {
          return [-drawingArea.width, -drawingArea.height];
        }
        return [pointX2, pointY2];
      });
      voronoiRef.current[seriesId] = {
        seriesId,
        startIndex: points.length,
        endIndex: points.length + seriesPoints.length
      };
      points = points.concat(seriesPoints);
    });
    delauneyRef.current = new Delaunay(points);
    lastFind.current = void 0;
  }, [zoomIsInteracting, defaultXAxisId, defaultYAxisId, series, seriesOrder, xAxis, yAxis, drawingArea, instance, disableVoronoi]);
  React97.useEffect(() => {
    if (svgRef.current === null || disableVoronoi) {
      return void 0;
    }
    const element = svgRef.current;
    function getClosestPoint(event) {
      const svgPoint = getSVGPoint(element, event);
      if (!instance.isPointInside(svgPoint)) {
        lastFind.current = void 0;
        return "outside-chart";
      }
      if (!delauneyRef.current) {
        return "no-point-found";
      }
      const closestPointIndex = delauneyRef.current.find(svgPoint.x, svgPoint.y, lastFind.current);
      if (closestPointIndex === void 0) {
        return "no-point-found";
      }
      lastFind.current = closestPointIndex;
      const closestSeries = Object.values(voronoiRef.current).find((value) => {
        return 2 * closestPointIndex >= value.startIndex && 2 * closestPointIndex < value.endIndex;
      });
      if (closestSeries === void 0) {
        return "no-point-found";
      }
      const dataIndex = (2 * closestPointIndex - voronoiRef.current[closestSeries.seriesId].startIndex) / 2;
      if (voronoiMaxRadius !== void 0) {
        const pointX2 = delauneyRef.current.points[2 * closestPointIndex];
        const pointY2 = delauneyRef.current.points[2 * closestPointIndex + 1];
        const dist2 = (pointX2 - svgPoint.x) ** 2 + (pointY2 - svgPoint.y) ** 2;
        if (dist2 > voronoiMaxRadius ** 2) {
          return "outside-voronoi-max-radius";
        }
      }
      return {
        seriesId: closestSeries.seriesId,
        dataIndex
      };
    }
    const handleMouseLeave = () => {
      var _a2, _b;
      (_a2 = instance.cleanInteraction) == null ? void 0 : _a2.call(instance);
      (_b = instance.clearHighlight) == null ? void 0 : _b.call(instance);
    };
    const handleMouseMove = (event) => {
      var _a2, _b, _c, _d, _e2, _f;
      const closestPoint = getClosestPoint(event);
      if (closestPoint === "outside-chart") {
        (_a2 = instance.cleanInteraction) == null ? void 0 : _a2.call(instance);
        (_b = instance.clearHighlight) == null ? void 0 : _b.call(instance);
        return;
      }
      if (closestPoint === "outside-voronoi-max-radius" || closestPoint === "no-point-found") {
        (_c = instance.removeItemInteraction) == null ? void 0 : _c.call(instance);
        (_d = instance.clearHighlight) == null ? void 0 : _d.call(instance);
        return;
      }
      const {
        seriesId,
        dataIndex
      } = closestPoint;
      (_e2 = instance.setItemInteraction) == null ? void 0 : _e2.call(instance, {
        type: "scatter",
        seriesId,
        dataIndex
      });
      (_f = instance.setHighlight) == null ? void 0 : _f.call(instance, {
        seriesId,
        dataIndex
      });
    };
    const handleMouseClick = (event) => {
      if (!onItemClick) {
        return;
      }
      const closestPoint = getClosestPoint(event);
      if (typeof closestPoint === "string") {
        return;
      }
      const {
        seriesId,
        dataIndex
      } = closestPoint;
      onItemClick(event, {
        type: "scatter",
        seriesId,
        dataIndex
      });
    };
    element.addEventListener("pointerleave", handleMouseLeave);
    element.addEventListener("pointermove", handleMouseMove);
    element.addEventListener("click", handleMouseClick);
    return () => {
      element.removeEventListener("pointerleave", handleMouseLeave);
      element.removeEventListener("pointermove", handleMouseMove);
      element.removeEventListener("click", handleMouseClick);
    };
  }, [svgRef, yAxis, xAxis, voronoiMaxRadius, onItemClick, disableVoronoi, drawingArea, instance]);
  const enableVoronoiCallback = useEventCallback_default(() => {
    store.update((prev2) => _extends({}, prev2, {
      voronoi: _extends({}, prev2.voronoi, {
        isVoronoiEnabled: true
      })
    }));
  });
  const disableVoronoiCallback = useEventCallback_default(() => {
    store.update((prev2) => _extends({}, prev2, {
      voronoi: _extends({}, prev2.voronoi, {
        isVoronoiEnabled: false
      })
    }));
  });
  return {
    instance: {
      enableVoronoi: enableVoronoiCallback,
      disableVoronoi: disableVoronoiCallback
    }
  };
};
useChartVoronoi.getDefaultizedParams = ({
  params
}) => _extends({}, params, {
  disableVoronoi: params.disableVoronoi ?? !params.series.some((item) => item.type === "scatter")
});
useChartVoronoi.getInitialState = (params) => ({
  voronoi: {
    isVoronoiEnabled: !params.disableVoronoi
  }
});
useChartVoronoi.params = {
  disableVoronoi: true,
  voronoiMaxRadius: true,
  onItemClick: true
};

// node_modules/@mui/x-charts/esm/internals/plugins/featurePlugins/useChartVoronoi/useChartVoronoi.selectors.js
var selectVoronoi = (state) => state.voronoi;
var selectorChartsVoronoiIsVoronoiEnabled = createSelector2(selectVoronoi, (voronoi) => voronoi == null ? void 0 : voronoi.isVoronoiEnabled);

// node_modules/@mui/x-charts/esm/internals/plugins/allPlugins.js
var DEFAULT_PLUGINS = [useChartZAxis, useChartCartesianAxis, useChartInteraction, useChartHighlight, useChartVoronoi];

// node_modules/@mui/x-charts/esm/ChartDataProvider/useChartDataProviderProps.js
var _excluded28 = ["children", "localeText", "plugins", "seriesConfig"];
var useChartDataProviderProps = (props) => {
  const {
    children: children2,
    localeText,
    plugins = DEFAULT_PLUGINS,
    seriesConfig: seriesConfig5
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded28);
  const theme = useTheme4();
  const chartProviderProps = {
    plugins,
    seriesConfig: seriesConfig5,
    pluginParams: _extends({
      theme: theme.palette.mode
    }, other)
  };
  return {
    children: children2,
    localeText,
    chartProviderProps
  };
};

// node_modules/@mui/x-charts/esm/ChartDataProvider/ChartDataProvider.js
var import_jsx_runtime60 = __toESM(require_jsx_runtime(), 1);
function ChartDataProvider(props) {
  const {
    children: children2,
    localeText,
    chartProviderProps
  } = useChartDataProviderProps(props);
  return (0, import_jsx_runtime60.jsx)(ChartProvider, _extends({}, chartProviderProps, {
    children: (0, import_jsx_runtime60.jsx)(ChartsLocalizationProvider, {
      localeText,
      children: children2
    })
  }));
}
true ? ChartDataProvider.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  apiRef: import_prop_types50.default.shape({
    current: import_prop_types50.default.any
  }),
  /**
   * Color palette used to colorize multiple series.
   * @default rainbowSurgePalette
   */
  colors: import_prop_types50.default.oneOfType([import_prop_types50.default.arrayOf(import_prop_types50.default.string), import_prop_types50.default.func]),
  /**
   * An array of objects that can be used to populate series and axes data using their `dataKey` property.
   */
  dataset: import_prop_types50.default.arrayOf(import_prop_types50.default.object),
  /**
   * The height of the chart in px. If not defined, it takes the height of the parent element.
   */
  height: import_prop_types50.default.number,
  /**
   * This prop is used to help implement the accessibility logic.
   * If you don't provide this prop. It falls back to a randomly generated id.
   */
  id: import_prop_types50.default.string,
  /**
   * Localized text for chart components.
   */
  localeText: import_prop_types50.default.object,
  /**
   * The margin between the SVG and the drawing area.
   * It's used for leaving some space for extra information such as the x- and y-axis or legend.
   *
   * Accepts a `number` to be used on all sides or an object with the optional properties: `top`, `bottom`, `left`, and `right`.
   */
  margin: import_prop_types50.default.oneOfType([import_prop_types50.default.number, import_prop_types50.default.shape({
    bottom: import_prop_types50.default.number,
    left: import_prop_types50.default.number,
    right: import_prop_types50.default.number,
    top: import_prop_types50.default.number
  })]),
  /**
   * The array of series to display.
   * Each type of series has its own specificity.
   * Please refer to the appropriate docs page to learn more about it.
   */
  series: import_prop_types50.default.arrayOf(import_prop_types50.default.object),
  /**
   * If `true`, animations are skipped.
   * If unset or `false`, the animations respects the user's `prefers-reduced-motion` setting.
   */
  skipAnimation: import_prop_types50.default.bool,
  theme: import_prop_types50.default.oneOf(["dark", "light"]),
  /**
   * The width of the chart in px. If not defined, it takes the width of the parent element.
   */
  width: import_prop_types50.default.number
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsSurface/ChartsSurface.js
var import_prop_types51 = __toESM(require_prop_types(), 1);
var React103 = __toESM(require_react(), 1);

// node_modules/@mui/x-charts/esm/internals/components/ChartsAxesGradients/ChartsAxesGradients.js
var React102 = __toESM(require_react(), 1);

// node_modules/@mui/x-charts/esm/internals/components/ChartsAxesGradients/ChartsPiecewiseGradient.js
var React99 = __toESM(require_react(), 1);
var import_jsx_runtime61 = __toESM(require_jsx_runtime(), 1);
function ChartsPiecewiseGradient(props) {
  const {
    isReversed,
    gradientId,
    size,
    direction,
    scale: scale2,
    colorMap
  } = props;
  if (size <= 0) {
    return null;
  }
  return (0, import_jsx_runtime61.jsx)("linearGradient", {
    id: gradientId,
    x1: "0",
    x2: "0",
    y1: "0",
    y2: "0",
    [`${direction}${isReversed ? 1 : 2}`]: `${size}px`,
    gradientUnits: "userSpaceOnUse",
    children: colorMap.thresholds.map((threshold2, index2) => {
      const x3 = scale2(threshold2);
      if (x3 === void 0) {
        return null;
      }
      const offset2 = isReversed ? 1 - x3 / size : x3 / size;
      if (Number.isNaN(offset2)) {
        return null;
      }
      return (0, import_jsx_runtime61.jsxs)(React99.Fragment, {
        children: [(0, import_jsx_runtime61.jsx)("stop", {
          offset: offset2,
          stopColor: colorMap.colors[index2],
          stopOpacity: 1
        }), (0, import_jsx_runtime61.jsx)("stop", {
          offset: offset2,
          stopColor: colorMap.colors[index2 + 1],
          stopOpacity: 1
        })]
      }, threshold2.toString() + index2);
    })
  });
}

// node_modules/@mui/x-charts/esm/internals/components/ChartsAxesGradients/ChartsContinuousGradient.js
var React100 = __toESM(require_react(), 1);
var import_jsx_runtime62 = __toESM(require_jsx_runtime(), 1);
var PX_PRECISION = 10;
function ChartsContinuousGradient(props) {
  const {
    gradientUnits,
    isReversed,
    gradientId,
    size,
    direction,
    scale: scale2,
    colorScale,
    colorMap
  } = props;
  const extremumValues = [colorMap.min ?? 0, colorMap.max ?? 100];
  const extremumPositions = extremumValues.map(scale2).filter((p2) => p2 !== void 0);
  if (extremumPositions.length !== 2) {
    return null;
  }
  const interpolator = typeof extremumValues[0] === "number" ? number_default(extremumValues[0], extremumValues[1]) : date_default(extremumValues[0], extremumValues[1]);
  const numberOfPoints = Math.round((Math.max(...extremumPositions) - Math.min(...extremumPositions)) / PX_PRECISION);
  const keyPrefix = `${extremumValues[0]}-${extremumValues[1]}-`;
  return (0, import_jsx_runtime62.jsx)("linearGradient", {
    id: gradientId,
    x1: "0",
    x2: "0",
    y1: "0",
    y2: "0",
    [`${direction}${isReversed ? 1 : 2}`]: gradientUnits === "objectBoundingBox" ? 1 : `${size}px`,
    gradientUnits: gradientUnits ?? "userSpaceOnUse",
    children: Array.from({
      length: numberOfPoints + 1
    }, (_2, index2) => {
      const value = interpolator(index2 / numberOfPoints);
      if (value === void 0) {
        return null;
      }
      const x3 = scale2(value);
      if (x3 === void 0) {
        return null;
      }
      const offset2 = isReversed ? 1 - x3 / size : x3 / size;
      const color3 = colorScale(value);
      if (color3 === null) {
        return null;
      }
      return (0, import_jsx_runtime62.jsx)("stop", {
        offset: offset2,
        stopColor: color3,
        stopOpacity: 1
      }, keyPrefix + index2);
    })
  });
}

// node_modules/@mui/x-charts/esm/internals/components/ChartsAxesGradients/ChartsContinuousGradientObjectBound.js
var React101 = __toESM(require_react(), 1);
var import_jsx_runtime63 = __toESM(require_jsx_runtime(), 1);
var PX_PRECISION2 = 10;
var getDirection = (isReversed) => {
  if (isReversed) {
    return {
      x1: "1",
      x2: "0",
      y1: "0",
      y2: "0"
    };
  }
  return {
    x1: "0",
    x2: "1",
    y1: "0",
    y2: "0"
  };
};
function ChartsContinuousGradientObjectBound(props) {
  const {
    isReversed,
    gradientId,
    colorScale,
    colorMap
  } = props;
  const extremumValues = [colorMap.min ?? 0, colorMap.max ?? 100];
  const interpolator = typeof extremumValues[0] === "number" ? number_default(extremumValues[0], extremumValues[1]) : date_default(extremumValues[0], extremumValues[1]);
  const numberOfPoints = PX_PRECISION2;
  const keyPrefix = `${extremumValues[0]}-${extremumValues[1]}-`;
  return (0, import_jsx_runtime63.jsx)("linearGradient", _extends({
    id: gradientId
  }, getDirection(isReversed), {
    gradientUnits: "objectBoundingBox",
    children: Array.from({
      length: numberOfPoints + 1
    }, (_2, index2) => {
      const offset2 = index2 / numberOfPoints;
      const value = interpolator(offset2);
      if (value === void 0) {
        return null;
      }
      const color3 = colorScale(value);
      if (color3 === null) {
        return null;
      }
      return (0, import_jsx_runtime63.jsx)("stop", {
        offset: offset2,
        stopColor: color3,
        stopOpacity: 1
      }, keyPrefix + index2);
    })
  }));
}

// node_modules/@mui/x-charts/esm/internals/components/ChartsAxesGradients/ChartsAxesGradients.js
var import_jsx_runtime64 = __toESM(require_jsx_runtime(), 1);
function ChartsAxesGradients() {
  const {
    top: top3,
    height: height2,
    bottom: bottom3,
    left: left3,
    width: width2,
    right: right3
  } = useDrawingArea();
  const svgHeight = top3 + height2 + bottom3;
  const svgWidth = left3 + width2 + right3;
  const getGradientId = useChartGradientIdBuilder();
  const getObjectBoundGradientId = useChartGradientIdObjectBoundBuilder();
  const {
    xAxis,
    xAxisIds
  } = useXAxes();
  const {
    yAxis,
    yAxisIds
  } = useYAxes();
  const {
    zAxis,
    zAxisIds
  } = useZAxes();
  const filteredYAxisIds = yAxisIds.filter((axisId) => yAxis[axisId].colorMap !== void 0);
  const filteredXAxisIds = xAxisIds.filter((axisId) => xAxis[axisId].colorMap !== void 0);
  const filteredZAxisIds = zAxisIds.filter((axisId) => zAxis[axisId].colorMap !== void 0);
  if (filteredYAxisIds.length === 0 && filteredXAxisIds.length === 0 && filteredZAxisIds.length === 0) {
    return null;
  }
  return (0, import_jsx_runtime64.jsxs)("defs", {
    children: [filteredYAxisIds.map((axisId) => {
      const gradientId = getGradientId(axisId);
      const objectBoundGradientId = getObjectBoundGradientId(axisId);
      const {
        colorMap,
        scale: scale2,
        colorScale,
        reverse: reverse2
      } = yAxis[axisId];
      if ((colorMap == null ? void 0 : colorMap.type) === "piecewise") {
        return (0, import_jsx_runtime64.jsx)(ChartsPiecewiseGradient, {
          isReversed: !reverse2,
          scale: scale2,
          colorMap,
          size: svgHeight,
          gradientId,
          direction: "y"
        }, gradientId);
      }
      if ((colorMap == null ? void 0 : colorMap.type) === "continuous") {
        return (0, import_jsx_runtime64.jsxs)(React102.Fragment, {
          children: [(0, import_jsx_runtime64.jsx)(ChartsContinuousGradient, {
            isReversed: !reverse2,
            scale: scale2,
            colorScale,
            colorMap,
            size: svgHeight,
            gradientId,
            direction: "y"
          }), (0, import_jsx_runtime64.jsx)(ChartsContinuousGradientObjectBound, {
            isReversed: reverse2,
            colorScale,
            colorMap,
            gradientId: objectBoundGradientId
          })]
        }, gradientId);
      }
      return null;
    }), filteredXAxisIds.map((axisId) => {
      const gradientId = getGradientId(axisId);
      const objectBoundGradientId = getObjectBoundGradientId(axisId);
      const {
        colorMap,
        scale: scale2,
        reverse: reverse2,
        colorScale
      } = xAxis[axisId];
      if ((colorMap == null ? void 0 : colorMap.type) === "piecewise") {
        return (0, import_jsx_runtime64.jsx)(ChartsPiecewiseGradient, {
          isReversed: reverse2,
          scale: scale2,
          colorMap,
          size: svgWidth,
          gradientId,
          direction: "x"
        }, gradientId);
      }
      if ((colorMap == null ? void 0 : colorMap.type) === "continuous") {
        return (0, import_jsx_runtime64.jsxs)(React102.Fragment, {
          children: [(0, import_jsx_runtime64.jsx)(ChartsContinuousGradient, {
            isReversed: reverse2,
            scale: scale2,
            colorScale,
            colorMap,
            size: svgWidth,
            gradientId,
            direction: "x"
          }), (0, import_jsx_runtime64.jsx)(ChartsContinuousGradientObjectBound, {
            isReversed: reverse2,
            colorScale,
            colorMap,
            gradientId: objectBoundGradientId
          })]
        }, gradientId);
      }
      return null;
    }), filteredZAxisIds.map((axisId) => {
      const objectBoundGradientId = getObjectBoundGradientId(axisId);
      const {
        colorMap,
        colorScale
      } = zAxis[axisId];
      if ((colorMap == null ? void 0 : colorMap.type) === "continuous") {
        return (0, import_jsx_runtime64.jsx)(ChartsContinuousGradientObjectBound, {
          colorScale,
          colorMap,
          gradientId: objectBoundGradientId
        }, objectBoundGradientId);
      }
      return null;
    })]
  });
}

// node_modules/@mui/x-charts/esm/ChartsSurface/ChartsSurface.js
var import_jsx_runtime65 = __toESM(require_jsx_runtime(), 1);
var _excluded29 = ["children", "className", "title", "desc"];
var ChartsSurfaceStyles = styled_default2("svg", {
  name: "MuiChartsSurface",
  slot: "Root"
})(({
  ownerState
}) => ({
  width: ownerState.width ?? "100%",
  height: ownerState.height ?? "100%",
  display: "flex",
  position: "relative",
  flexDirection: "column",
  alignItems: "center",
  justifyContent: "center",
  overflow: "hidden",
  // This prevents default touch actions when using the svg on mobile devices.
  // For example, prevent page scroll & zoom.
  touchAction: "none"
}));
var ChartsSurface = React103.forwardRef(function ChartsSurface2(inProps, ref) {
  const store = useStore();
  const {
    width: svgWidth,
    height: svgHeight
  } = useSelector(store, selectorChartContainerSize);
  const {
    width: propsWidth,
    height: propsHeight
  } = useSelector(store, selectorChartPropsSize);
  const svgRef = useSvgRef();
  const handleRef = useForkRef(svgRef, ref);
  const themeProps = useThemeProps2({
    props: inProps,
    name: "MuiChartsSurface"
  });
  const {
    children: children2,
    className,
    title,
    desc
  } = themeProps, other = _objectWithoutPropertiesLoose(themeProps, _excluded29);
  const hasIntrinsicSize = svgHeight > 0 && svgWidth > 0;
  return (0, import_jsx_runtime65.jsxs)(ChartsSurfaceStyles, _extends({
    ownerState: {
      width: propsWidth,
      height: propsHeight
    },
    viewBox: `${0} ${0} ${svgWidth} ${svgHeight}`,
    className
  }, other, {
    ref: handleRef,
    children: [title && (0, import_jsx_runtime65.jsx)("title", {
      children: title
    }), desc && (0, import_jsx_runtime65.jsx)("desc", {
      children: desc
    }), (0, import_jsx_runtime65.jsx)(ChartsAxesGradients, {}), hasIntrinsicSize && children2]
  }));
});
true ? ChartsSurface.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  children: import_prop_types51.default.node,
  className: import_prop_types51.default.string,
  desc: import_prop_types51.default.string,
  sx: import_prop_types51.default.oneOfType([import_prop_types51.default.arrayOf(import_prop_types51.default.oneOfType([import_prop_types51.default.func, import_prop_types51.default.object, import_prop_types51.default.bool])), import_prop_types51.default.func, import_prop_types51.default.object]),
  title: import_prop_types51.default.string
} : void 0;

// node_modules/@mui/x-charts/esm/ChartContainer/useChartContainerProps.js
var _excluded30 = ["width", "height", "margin", "children", "series", "colors", "dataset", "desc", "onAxisClick", "disableVoronoi", "voronoiMaxRadius", "onItemClick", "disableAxisListener", "highlightedItem", "onHighlightChange", "sx", "title", "xAxis", "yAxis", "zAxis", "rotationAxis", "radiusAxis", "skipAnimation", "seriesConfig", "plugins", "localeText"];
var useChartContainerProps = (props, ref) => {
  const _ref = props, {
    width: width2,
    height: height2,
    margin: margin2,
    children: children2,
    series,
    colors,
    dataset,
    desc,
    onAxisClick,
    disableVoronoi,
    voronoiMaxRadius,
    onItemClick,
    disableAxisListener,
    highlightedItem,
    onHighlightChange,
    sx,
    title,
    xAxis,
    yAxis,
    zAxis,
    rotationAxis,
    radiusAxis,
    skipAnimation,
    seriesConfig: seriesConfig5,
    plugins,
    localeText
  } = _ref, other = _objectWithoutPropertiesLoose(_ref, _excluded30);
  const chartsSurfaceProps = _extends({
    title,
    desc,
    sx,
    ref
  }, other);
  const chartDataProviderProps = {
    margin: margin2,
    series,
    colors,
    dataset,
    disableAxisListener,
    highlightedItem,
    onHighlightChange,
    onAxisClick,
    disableVoronoi,
    voronoiMaxRadius,
    onItemClick,
    xAxis,
    yAxis,
    zAxis,
    rotationAxis,
    radiusAxis,
    skipAnimation,
    width: width2,
    height: height2,
    localeText,
    seriesConfig: seriesConfig5,
    plugins: plugins ?? DEFAULT_PLUGINS
  };
  return {
    chartDataProviderProps,
    chartsSurfaceProps,
    children: children2
  };
};

// node_modules/@mui/x-charts/esm/internals/components/ChartsWrapper/ChartsWrapper.js
var React104 = __toESM(require_react(), 1);
var import_jsx_runtime66 = __toESM(require_jsx_runtime(), 1);
var getDirection2 = (direction, position3) => {
  if (direction === "vertical") {
    if ((position3 == null ? void 0 : position3.horizontal) === "start") {
      return "row";
    }
    return "row-reverse";
  }
  if ((position3 == null ? void 0 : position3.vertical) === "bottom") {
    return "column-reverse";
  }
  return "column";
};
var getAlign = (direction, position3) => {
  if (direction === "vertical") {
    if ((position3 == null ? void 0 : position3.vertical) === "top") {
      return "flex-start";
    }
    if ((position3 == null ? void 0 : position3.vertical) === "bottom") {
      return "flex-end";
    }
  }
  if (direction === "horizontal") {
    if ((position3 == null ? void 0 : position3.horizontal) === "start") {
      return "flex-start";
    }
    if ((position3 == null ? void 0 : position3.horizontal) === "end") {
      return "flex-end";
    }
  }
  return "center";
};
var Root3 = styled_default2("div", {
  name: "MuiChartsWrapper",
  slot: "Root"
})(({
  ownerState
}) => ({
  display: "flex",
  flexDirection: getDirection2(ownerState.legendDirection, ownerState.legendPosition),
  flex: 1,
  justifyContent: "center",
  alignItems: getAlign(ownerState.legendDirection, ownerState.legendPosition)
}));
function ChartsWrapper(props) {
  const {
    children: children2,
    sx
  } = props;
  const chartRootRef = useChartRootRef();
  return (0, import_jsx_runtime66.jsx)(Root3, {
    ref: chartRootRef,
    ownerState: props,
    sx,
    children: children2
  });
}

// node_modules/@mui/x-charts/esm/BarChart/BarChart.js
var import_jsx_runtime67 = __toESM(require_jsx_runtime(), 1);
var BarChart = React105.forwardRef(function BarChart2(inProps, ref) {
  var _a, _b;
  const props = useThemeProps2({
    props: inProps,
    name: "MuiBarChart"
  });
  const {
    chartsWrapperProps,
    chartContainerProps,
    barPlotProps,
    gridProps,
    clipPathProps,
    clipPathGroupProps,
    overlayProps,
    chartsAxisProps,
    axisHighlightProps,
    legendProps,
    children: children2
  } = useBarChartProps(props);
  const {
    chartDataProviderProps,
    chartsSurfaceProps
  } = useChartContainerProps(chartContainerProps, ref);
  const Tooltip = ((_a = props.slots) == null ? void 0 : _a.tooltip) ?? ChartsTooltip;
  return (0, import_jsx_runtime67.jsx)(ChartDataProvider, _extends({}, chartDataProviderProps, {
    children: (0, import_jsx_runtime67.jsxs)(ChartsWrapper, _extends({}, chartsWrapperProps, {
      children: [!props.hideLegend && (0, import_jsx_runtime67.jsx)(ChartsLegend, _extends({}, legendProps)), (0, import_jsx_runtime67.jsxs)(ChartsSurface, _extends({}, chartsSurfaceProps, {
        children: [(0, import_jsx_runtime67.jsx)(ChartsGrid, _extends({}, gridProps)), (0, import_jsx_runtime67.jsxs)("g", _extends({}, clipPathGroupProps, {
          children: [(0, import_jsx_runtime67.jsx)(BarPlot, _extends({}, barPlotProps)), (0, import_jsx_runtime67.jsx)(ChartsOverlay, _extends({}, overlayProps)), (0, import_jsx_runtime67.jsx)(ChartsAxisHighlight, _extends({}, axisHighlightProps))]
        })), (0, import_jsx_runtime67.jsx)(ChartsAxis, _extends({}, chartsAxisProps)), !props.loading && (0, import_jsx_runtime67.jsx)(Tooltip, _extends({}, (_b = props.slotProps) == null ? void 0 : _b.tooltip)), (0, import_jsx_runtime67.jsx)(ChartsClipPath, _extends({}, clipPathProps)), children2]
      }))]
    }))
  }));
});
true ? BarChart.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  apiRef: import_prop_types52.default.shape({
    current: import_prop_types52.default.object
  }),
  /**
   * The configuration of axes highlight.
   * Default is set to 'band' in the bar direction.
   * Depends on `layout` prop.
   * @see See {@link https://mui.com/x/react-charts/highlighting/ highlighting docs} for more details.
   */
  axisHighlight: import_prop_types52.default.shape({
    x: import_prop_types52.default.oneOf(["band", "line", "none"]),
    y: import_prop_types52.default.oneOf(["band", "line", "none"])
  }),
  /**
   * If provided, the function will be used to format the label of the bar.
   * It can be set to 'value' to display the current value.
   * @param {BarItem} item The item to format.
   * @param {BarLabelContext} context data about the bar.
   * @returns {string} The formatted label.
   */
  barLabel: import_prop_types52.default.oneOfType([import_prop_types52.default.oneOf(["value"]), import_prop_types52.default.func]),
  /**
   * Defines the border radius of the bar element.
   */
  borderRadius: import_prop_types52.default.number,
  children: import_prop_types52.default.node,
  className: import_prop_types52.default.string,
  /**
   * Color palette used to colorize multiple series.
   * @default rainbowSurgePalette
   */
  colors: import_prop_types52.default.oneOfType([import_prop_types52.default.arrayOf(import_prop_types52.default.string), import_prop_types52.default.func]),
  /**
   * An array of objects that can be used to populate series and axes data using their `dataKey` property.
   */
  dataset: import_prop_types52.default.arrayOf(import_prop_types52.default.object),
  desc: import_prop_types52.default.string,
  /**
   * If `true`, the charts will not listen to the mouse move event.
   * It might break interactive features, but will improve performance.
   * @default false
   */
  disableAxisListener: import_prop_types52.default.bool,
  /**
   * Option to display a cartesian grid in the background.
   */
  grid: import_prop_types52.default.shape({
    horizontal: import_prop_types52.default.bool,
    vertical: import_prop_types52.default.bool
  }),
  /**
   * The height of the chart in px. If not defined, it takes the height of the parent element.
   */
  height: import_prop_types52.default.number,
  /**
   * If `true`, the legend is not rendered.
   */
  hideLegend: import_prop_types52.default.bool,
  /**
   * The highlighted item.
   * Used when the highlight is controlled.
   */
  highlightedItem: import_prop_types52.default.shape({
    dataIndex: import_prop_types52.default.number,
    seriesId: import_prop_types52.default.oneOfType([import_prop_types52.default.number, import_prop_types52.default.string]).isRequired
  }),
  /**
   * This prop is used to help implement the accessibility logic.
   * If you don't provide this prop. It falls back to a randomly generated id.
   */
  id: import_prop_types52.default.string,
  /**
   * The direction of the bar elements.
   * @default 'vertical'
   */
  layout: import_prop_types52.default.oneOf(["horizontal", "vertical"]),
  /**
   * If `true`, a loading overlay is displayed.
   * @default false
   */
  loading: import_prop_types52.default.bool,
  /**
   * Localized text for chart components.
   */
  localeText: import_prop_types52.default.object,
  /**
   * The margin between the SVG and the drawing area.
   * It's used for leaving some space for extra information such as the x- and y-axis or legend.
   *
   * Accepts a `number` to be used on all sides or an object with the optional properties: `top`, `bottom`, `left`, and `right`.
   */
  margin: import_prop_types52.default.oneOfType([import_prop_types52.default.number, import_prop_types52.default.shape({
    bottom: import_prop_types52.default.number,
    left: import_prop_types52.default.number,
    right: import_prop_types52.default.number,
    top: import_prop_types52.default.number
  })]),
  /**
   * The function called for onClick events.
   * The second argument contains information about all line/bar elements at the current mouse position.
   * @param {MouseEvent} event The mouse event recorded on the `<svg/>` element.
   * @param {null | ChartsAxisData} data The data about the clicked axis and items associated with it.
   */
  onAxisClick: import_prop_types52.default.func,
  /**
   * The callback fired when the highlighted item changes.
   *
   * @param {HighlightItemData | null} highlightedItem  The newly highlighted item.
   */
  onHighlightChange: import_prop_types52.default.func,
  /**
   * Callback fired when a bar item is clicked.
   * @param {React.MouseEvent<SVGElement, MouseEvent>} event The event source of the callback.
   * @param {BarItemIdentifier} barItemIdentifier The bar item identifier.
   */
  onItemClick: import_prop_types52.default.func,
  /**
   * The series to display in the bar chart.
   * An array of [[BarSeriesType]] objects.
   */
  series: import_prop_types52.default.arrayOf(import_prop_types52.default.object).isRequired,
  /**
   * If `true`, animations are skipped.
   * If unset or `false`, the animations respects the user's `prefers-reduced-motion` setting.
   */
  skipAnimation: import_prop_types52.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types52.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types52.default.object,
  sx: import_prop_types52.default.oneOfType([import_prop_types52.default.arrayOf(import_prop_types52.default.oneOfType([import_prop_types52.default.func, import_prop_types52.default.object, import_prop_types52.default.bool])), import_prop_types52.default.func, import_prop_types52.default.object]),
  theme: import_prop_types52.default.oneOf(["dark", "light"]),
  title: import_prop_types52.default.string,
  /**
   * The width of the chart in px. If not defined, it takes the width of the parent element.
   */
  width: import_prop_types52.default.number,
  /**
   * The configuration of the x-axes.
   * If not provided, a default axis config is used.
   * An array of [[AxisConfig]] objects.
   */
  xAxis: import_prop_types52.default.arrayOf(import_prop_types52.default.oneOfType([import_prop_types52.default.shape({
    axis: import_prop_types52.default.oneOf(["x"]),
    barGapRatio: import_prop_types52.default.number,
    categoryGapRatio: import_prop_types52.default.number,
    classes: import_prop_types52.default.object,
    colorMap: import_prop_types52.default.oneOfType([import_prop_types52.default.shape({
      colors: import_prop_types52.default.arrayOf(import_prop_types52.default.string).isRequired,
      type: import_prop_types52.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types52.default.string,
      values: import_prop_types52.default.arrayOf(import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number, import_prop_types52.default.string]).isRequired)
    }), import_prop_types52.default.shape({
      color: import_prop_types52.default.oneOfType([import_prop_types52.default.arrayOf(import_prop_types52.default.string.isRequired), import_prop_types52.default.func]).isRequired,
      max: import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]),
      min: import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]),
      type: import_prop_types52.default.oneOf(["continuous"]).isRequired
    }), import_prop_types52.default.shape({
      colors: import_prop_types52.default.arrayOf(import_prop_types52.default.string).isRequired,
      thresholds: import_prop_types52.default.arrayOf(import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]).isRequired).isRequired,
      type: import_prop_types52.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types52.default.array,
    dataKey: import_prop_types52.default.string,
    disableLine: import_prop_types52.default.bool,
    disableTicks: import_prop_types52.default.bool,
    domainLimit: import_prop_types52.default.oneOfType([import_prop_types52.default.oneOf(["nice", "strict"]), import_prop_types52.default.func]),
    fill: import_prop_types52.default.string,
    height: import_prop_types52.default.number,
    hideTooltip: import_prop_types52.default.bool,
    id: import_prop_types52.default.oneOfType([import_prop_types52.default.number, import_prop_types52.default.string]),
    ignoreTooltip: import_prop_types52.default.bool,
    label: import_prop_types52.default.string,
    labelStyle: import_prop_types52.default.object,
    max: import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]),
    min: import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]),
    offset: import_prop_types52.default.number,
    position: import_prop_types52.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types52.default.bool,
    scaleType: import_prop_types52.default.oneOf(["band"]),
    slotProps: import_prop_types52.default.object,
    slots: import_prop_types52.default.object,
    stroke: import_prop_types52.default.string,
    sx: import_prop_types52.default.oneOfType([import_prop_types52.default.arrayOf(import_prop_types52.default.oneOfType([import_prop_types52.default.func, import_prop_types52.default.object, import_prop_types52.default.bool])), import_prop_types52.default.func, import_prop_types52.default.object]),
    tickInterval: import_prop_types52.default.oneOfType([import_prop_types52.default.oneOf(["auto"]), import_prop_types52.default.array, import_prop_types52.default.func]),
    tickLabelInterval: import_prop_types52.default.oneOfType([import_prop_types52.default.oneOf(["auto"]), import_prop_types52.default.func]),
    tickLabelMinGap: import_prop_types52.default.number,
    tickLabelPlacement: import_prop_types52.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types52.default.object,
    tickMaxStep: import_prop_types52.default.number,
    tickMinStep: import_prop_types52.default.number,
    tickNumber: import_prop_types52.default.number,
    tickPlacement: import_prop_types52.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types52.default.number,
    valueFormatter: import_prop_types52.default.func
  }), import_prop_types52.default.shape({
    axis: import_prop_types52.default.oneOf(["x"]),
    classes: import_prop_types52.default.object,
    colorMap: import_prop_types52.default.oneOfType([import_prop_types52.default.shape({
      colors: import_prop_types52.default.arrayOf(import_prop_types52.default.string).isRequired,
      type: import_prop_types52.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types52.default.string,
      values: import_prop_types52.default.arrayOf(import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number, import_prop_types52.default.string]).isRequired)
    }), import_prop_types52.default.shape({
      color: import_prop_types52.default.oneOfType([import_prop_types52.default.arrayOf(import_prop_types52.default.string.isRequired), import_prop_types52.default.func]).isRequired,
      max: import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]),
      min: import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]),
      type: import_prop_types52.default.oneOf(["continuous"]).isRequired
    }), import_prop_types52.default.shape({
      colors: import_prop_types52.default.arrayOf(import_prop_types52.default.string).isRequired,
      thresholds: import_prop_types52.default.arrayOf(import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]).isRequired).isRequired,
      type: import_prop_types52.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types52.default.array,
    dataKey: import_prop_types52.default.string,
    disableLine: import_prop_types52.default.bool,
    disableTicks: import_prop_types52.default.bool,
    domainLimit: import_prop_types52.default.oneOfType([import_prop_types52.default.oneOf(["nice", "strict"]), import_prop_types52.default.func]),
    fill: import_prop_types52.default.string,
    height: import_prop_types52.default.number,
    hideTooltip: import_prop_types52.default.bool,
    id: import_prop_types52.default.oneOfType([import_prop_types52.default.number, import_prop_types52.default.string]),
    ignoreTooltip: import_prop_types52.default.bool,
    label: import_prop_types52.default.string,
    labelStyle: import_prop_types52.default.object,
    max: import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]),
    min: import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]),
    offset: import_prop_types52.default.number,
    position: import_prop_types52.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types52.default.bool,
    scaleType: import_prop_types52.default.oneOf(["point"]),
    slotProps: import_prop_types52.default.object,
    slots: import_prop_types52.default.object,
    stroke: import_prop_types52.default.string,
    sx: import_prop_types52.default.oneOfType([import_prop_types52.default.arrayOf(import_prop_types52.default.oneOfType([import_prop_types52.default.func, import_prop_types52.default.object, import_prop_types52.default.bool])), import_prop_types52.default.func, import_prop_types52.default.object]),
    tickInterval: import_prop_types52.default.oneOfType([import_prop_types52.default.oneOf(["auto"]), import_prop_types52.default.array, import_prop_types52.default.func]),
    tickLabelInterval: import_prop_types52.default.oneOfType([import_prop_types52.default.oneOf(["auto"]), import_prop_types52.default.func]),
    tickLabelMinGap: import_prop_types52.default.number,
    tickLabelPlacement: import_prop_types52.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types52.default.object,
    tickMaxStep: import_prop_types52.default.number,
    tickMinStep: import_prop_types52.default.number,
    tickNumber: import_prop_types52.default.number,
    tickPlacement: import_prop_types52.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types52.default.number,
    valueFormatter: import_prop_types52.default.func
  }), import_prop_types52.default.shape({
    axis: import_prop_types52.default.oneOf(["x"]),
    classes: import_prop_types52.default.object,
    colorMap: import_prop_types52.default.oneOfType([import_prop_types52.default.shape({
      color: import_prop_types52.default.oneOfType([import_prop_types52.default.arrayOf(import_prop_types52.default.string.isRequired), import_prop_types52.default.func]).isRequired,
      max: import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]),
      min: import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]),
      type: import_prop_types52.default.oneOf(["continuous"]).isRequired
    }), import_prop_types52.default.shape({
      colors: import_prop_types52.default.arrayOf(import_prop_types52.default.string).isRequired,
      thresholds: import_prop_types52.default.arrayOf(import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]).isRequired).isRequired,
      type: import_prop_types52.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types52.default.array,
    dataKey: import_prop_types52.default.string,
    disableLine: import_prop_types52.default.bool,
    disableTicks: import_prop_types52.default.bool,
    domainLimit: import_prop_types52.default.oneOfType([import_prop_types52.default.oneOf(["nice", "strict"]), import_prop_types52.default.func]),
    fill: import_prop_types52.default.string,
    height: import_prop_types52.default.number,
    hideTooltip: import_prop_types52.default.bool,
    id: import_prop_types52.default.oneOfType([import_prop_types52.default.number, import_prop_types52.default.string]),
    ignoreTooltip: import_prop_types52.default.bool,
    label: import_prop_types52.default.string,
    labelStyle: import_prop_types52.default.object,
    max: import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]),
    min: import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]),
    offset: import_prop_types52.default.number,
    position: import_prop_types52.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types52.default.bool,
    scaleType: import_prop_types52.default.oneOf(["log"]),
    slotProps: import_prop_types52.default.object,
    slots: import_prop_types52.default.object,
    stroke: import_prop_types52.default.string,
    sx: import_prop_types52.default.oneOfType([import_prop_types52.default.arrayOf(import_prop_types52.default.oneOfType([import_prop_types52.default.func, import_prop_types52.default.object, import_prop_types52.default.bool])), import_prop_types52.default.func, import_prop_types52.default.object]),
    tickInterval: import_prop_types52.default.oneOfType([import_prop_types52.default.oneOf(["auto"]), import_prop_types52.default.array, import_prop_types52.default.func]),
    tickLabelInterval: import_prop_types52.default.oneOfType([import_prop_types52.default.oneOf(["auto"]), import_prop_types52.default.func]),
    tickLabelMinGap: import_prop_types52.default.number,
    tickLabelPlacement: import_prop_types52.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types52.default.object,
    tickMaxStep: import_prop_types52.default.number,
    tickMinStep: import_prop_types52.default.number,
    tickNumber: import_prop_types52.default.number,
    tickPlacement: import_prop_types52.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types52.default.number,
    valueFormatter: import_prop_types52.default.func
  }), import_prop_types52.default.shape({
    axis: import_prop_types52.default.oneOf(["x"]),
    classes: import_prop_types52.default.object,
    colorMap: import_prop_types52.default.oneOfType([import_prop_types52.default.shape({
      color: import_prop_types52.default.oneOfType([import_prop_types52.default.arrayOf(import_prop_types52.default.string.isRequired), import_prop_types52.default.func]).isRequired,
      max: import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]),
      min: import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]),
      type: import_prop_types52.default.oneOf(["continuous"]).isRequired
    }), import_prop_types52.default.shape({
      colors: import_prop_types52.default.arrayOf(import_prop_types52.default.string).isRequired,
      thresholds: import_prop_types52.default.arrayOf(import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]).isRequired).isRequired,
      type: import_prop_types52.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types52.default.array,
    dataKey: import_prop_types52.default.string,
    disableLine: import_prop_types52.default.bool,
    disableTicks: import_prop_types52.default.bool,
    domainLimit: import_prop_types52.default.oneOfType([import_prop_types52.default.oneOf(["nice", "strict"]), import_prop_types52.default.func]),
    fill: import_prop_types52.default.string,
    height: import_prop_types52.default.number,
    hideTooltip: import_prop_types52.default.bool,
    id: import_prop_types52.default.oneOfType([import_prop_types52.default.number, import_prop_types52.default.string]),
    ignoreTooltip: import_prop_types52.default.bool,
    label: import_prop_types52.default.string,
    labelStyle: import_prop_types52.default.object,
    max: import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]),
    min: import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]),
    offset: import_prop_types52.default.number,
    position: import_prop_types52.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types52.default.bool,
    scaleType: import_prop_types52.default.oneOf(["pow"]),
    slotProps: import_prop_types52.default.object,
    slots: import_prop_types52.default.object,
    stroke: import_prop_types52.default.string,
    sx: import_prop_types52.default.oneOfType([import_prop_types52.default.arrayOf(import_prop_types52.default.oneOfType([import_prop_types52.default.func, import_prop_types52.default.object, import_prop_types52.default.bool])), import_prop_types52.default.func, import_prop_types52.default.object]),
    tickInterval: import_prop_types52.default.oneOfType([import_prop_types52.default.oneOf(["auto"]), import_prop_types52.default.array, import_prop_types52.default.func]),
    tickLabelInterval: import_prop_types52.default.oneOfType([import_prop_types52.default.oneOf(["auto"]), import_prop_types52.default.func]),
    tickLabelMinGap: import_prop_types52.default.number,
    tickLabelPlacement: import_prop_types52.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types52.default.object,
    tickMaxStep: import_prop_types52.default.number,
    tickMinStep: import_prop_types52.default.number,
    tickNumber: import_prop_types52.default.number,
    tickPlacement: import_prop_types52.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types52.default.number,
    valueFormatter: import_prop_types52.default.func
  }), import_prop_types52.default.shape({
    axis: import_prop_types52.default.oneOf(["x"]),
    classes: import_prop_types52.default.object,
    colorMap: import_prop_types52.default.oneOfType([import_prop_types52.default.shape({
      color: import_prop_types52.default.oneOfType([import_prop_types52.default.arrayOf(import_prop_types52.default.string.isRequired), import_prop_types52.default.func]).isRequired,
      max: import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]),
      min: import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]),
      type: import_prop_types52.default.oneOf(["continuous"]).isRequired
    }), import_prop_types52.default.shape({
      colors: import_prop_types52.default.arrayOf(import_prop_types52.default.string).isRequired,
      thresholds: import_prop_types52.default.arrayOf(import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]).isRequired).isRequired,
      type: import_prop_types52.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types52.default.array,
    dataKey: import_prop_types52.default.string,
    disableLine: import_prop_types52.default.bool,
    disableTicks: import_prop_types52.default.bool,
    domainLimit: import_prop_types52.default.oneOfType([import_prop_types52.default.oneOf(["nice", "strict"]), import_prop_types52.default.func]),
    fill: import_prop_types52.default.string,
    height: import_prop_types52.default.number,
    hideTooltip: import_prop_types52.default.bool,
    id: import_prop_types52.default.oneOfType([import_prop_types52.default.number, import_prop_types52.default.string]),
    ignoreTooltip: import_prop_types52.default.bool,
    label: import_prop_types52.default.string,
    labelStyle: import_prop_types52.default.object,
    max: import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]),
    min: import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]),
    offset: import_prop_types52.default.number,
    position: import_prop_types52.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types52.default.bool,
    scaleType: import_prop_types52.default.oneOf(["sqrt"]),
    slotProps: import_prop_types52.default.object,
    slots: import_prop_types52.default.object,
    stroke: import_prop_types52.default.string,
    sx: import_prop_types52.default.oneOfType([import_prop_types52.default.arrayOf(import_prop_types52.default.oneOfType([import_prop_types52.default.func, import_prop_types52.default.object, import_prop_types52.default.bool])), import_prop_types52.default.func, import_prop_types52.default.object]),
    tickInterval: import_prop_types52.default.oneOfType([import_prop_types52.default.oneOf(["auto"]), import_prop_types52.default.array, import_prop_types52.default.func]),
    tickLabelInterval: import_prop_types52.default.oneOfType([import_prop_types52.default.oneOf(["auto"]), import_prop_types52.default.func]),
    tickLabelMinGap: import_prop_types52.default.number,
    tickLabelPlacement: import_prop_types52.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types52.default.object,
    tickMaxStep: import_prop_types52.default.number,
    tickMinStep: import_prop_types52.default.number,
    tickNumber: import_prop_types52.default.number,
    tickPlacement: import_prop_types52.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types52.default.number,
    valueFormatter: import_prop_types52.default.func
  }), import_prop_types52.default.shape({
    axis: import_prop_types52.default.oneOf(["x"]),
    classes: import_prop_types52.default.object,
    colorMap: import_prop_types52.default.oneOfType([import_prop_types52.default.shape({
      color: import_prop_types52.default.oneOfType([import_prop_types52.default.arrayOf(import_prop_types52.default.string.isRequired), import_prop_types52.default.func]).isRequired,
      max: import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]),
      min: import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]),
      type: import_prop_types52.default.oneOf(["continuous"]).isRequired
    }), import_prop_types52.default.shape({
      colors: import_prop_types52.default.arrayOf(import_prop_types52.default.string).isRequired,
      thresholds: import_prop_types52.default.arrayOf(import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]).isRequired).isRequired,
      type: import_prop_types52.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types52.default.array,
    dataKey: import_prop_types52.default.string,
    disableLine: import_prop_types52.default.bool,
    disableTicks: import_prop_types52.default.bool,
    domainLimit: import_prop_types52.default.oneOfType([import_prop_types52.default.oneOf(["nice", "strict"]), import_prop_types52.default.func]),
    fill: import_prop_types52.default.string,
    height: import_prop_types52.default.number,
    hideTooltip: import_prop_types52.default.bool,
    id: import_prop_types52.default.oneOfType([import_prop_types52.default.number, import_prop_types52.default.string]),
    ignoreTooltip: import_prop_types52.default.bool,
    label: import_prop_types52.default.string,
    labelStyle: import_prop_types52.default.object,
    max: import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]),
    min: import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]),
    offset: import_prop_types52.default.number,
    position: import_prop_types52.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types52.default.bool,
    scaleType: import_prop_types52.default.oneOf(["time"]),
    slotProps: import_prop_types52.default.object,
    slots: import_prop_types52.default.object,
    stroke: import_prop_types52.default.string,
    sx: import_prop_types52.default.oneOfType([import_prop_types52.default.arrayOf(import_prop_types52.default.oneOfType([import_prop_types52.default.func, import_prop_types52.default.object, import_prop_types52.default.bool])), import_prop_types52.default.func, import_prop_types52.default.object]),
    tickInterval: import_prop_types52.default.oneOfType([import_prop_types52.default.oneOf(["auto"]), import_prop_types52.default.array, import_prop_types52.default.func]),
    tickLabelInterval: import_prop_types52.default.oneOfType([import_prop_types52.default.oneOf(["auto"]), import_prop_types52.default.func]),
    tickLabelMinGap: import_prop_types52.default.number,
    tickLabelPlacement: import_prop_types52.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types52.default.object,
    tickMaxStep: import_prop_types52.default.number,
    tickMinStep: import_prop_types52.default.number,
    tickNumber: import_prop_types52.default.number,
    tickPlacement: import_prop_types52.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types52.default.number,
    valueFormatter: import_prop_types52.default.func
  }), import_prop_types52.default.shape({
    axis: import_prop_types52.default.oneOf(["x"]),
    classes: import_prop_types52.default.object,
    colorMap: import_prop_types52.default.oneOfType([import_prop_types52.default.shape({
      color: import_prop_types52.default.oneOfType([import_prop_types52.default.arrayOf(import_prop_types52.default.string.isRequired), import_prop_types52.default.func]).isRequired,
      max: import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]),
      min: import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]),
      type: import_prop_types52.default.oneOf(["continuous"]).isRequired
    }), import_prop_types52.default.shape({
      colors: import_prop_types52.default.arrayOf(import_prop_types52.default.string).isRequired,
      thresholds: import_prop_types52.default.arrayOf(import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]).isRequired).isRequired,
      type: import_prop_types52.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types52.default.array,
    dataKey: import_prop_types52.default.string,
    disableLine: import_prop_types52.default.bool,
    disableTicks: import_prop_types52.default.bool,
    domainLimit: import_prop_types52.default.oneOfType([import_prop_types52.default.oneOf(["nice", "strict"]), import_prop_types52.default.func]),
    fill: import_prop_types52.default.string,
    height: import_prop_types52.default.number,
    hideTooltip: import_prop_types52.default.bool,
    id: import_prop_types52.default.oneOfType([import_prop_types52.default.number, import_prop_types52.default.string]),
    ignoreTooltip: import_prop_types52.default.bool,
    label: import_prop_types52.default.string,
    labelStyle: import_prop_types52.default.object,
    max: import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]),
    min: import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]),
    offset: import_prop_types52.default.number,
    position: import_prop_types52.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types52.default.bool,
    scaleType: import_prop_types52.default.oneOf(["utc"]),
    slotProps: import_prop_types52.default.object,
    slots: import_prop_types52.default.object,
    stroke: import_prop_types52.default.string,
    sx: import_prop_types52.default.oneOfType([import_prop_types52.default.arrayOf(import_prop_types52.default.oneOfType([import_prop_types52.default.func, import_prop_types52.default.object, import_prop_types52.default.bool])), import_prop_types52.default.func, import_prop_types52.default.object]),
    tickInterval: import_prop_types52.default.oneOfType([import_prop_types52.default.oneOf(["auto"]), import_prop_types52.default.array, import_prop_types52.default.func]),
    tickLabelInterval: import_prop_types52.default.oneOfType([import_prop_types52.default.oneOf(["auto"]), import_prop_types52.default.func]),
    tickLabelMinGap: import_prop_types52.default.number,
    tickLabelPlacement: import_prop_types52.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types52.default.object,
    tickMaxStep: import_prop_types52.default.number,
    tickMinStep: import_prop_types52.default.number,
    tickNumber: import_prop_types52.default.number,
    tickPlacement: import_prop_types52.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types52.default.number,
    valueFormatter: import_prop_types52.default.func
  }), import_prop_types52.default.shape({
    axis: import_prop_types52.default.oneOf(["x"]),
    classes: import_prop_types52.default.object,
    colorMap: import_prop_types52.default.oneOfType([import_prop_types52.default.shape({
      color: import_prop_types52.default.oneOfType([import_prop_types52.default.arrayOf(import_prop_types52.default.string.isRequired), import_prop_types52.default.func]).isRequired,
      max: import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]),
      min: import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]),
      type: import_prop_types52.default.oneOf(["continuous"]).isRequired
    }), import_prop_types52.default.shape({
      colors: import_prop_types52.default.arrayOf(import_prop_types52.default.string).isRequired,
      thresholds: import_prop_types52.default.arrayOf(import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]).isRequired).isRequired,
      type: import_prop_types52.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types52.default.array,
    dataKey: import_prop_types52.default.string,
    disableLine: import_prop_types52.default.bool,
    disableTicks: import_prop_types52.default.bool,
    domainLimit: import_prop_types52.default.oneOfType([import_prop_types52.default.oneOf(["nice", "strict"]), import_prop_types52.default.func]),
    fill: import_prop_types52.default.string,
    height: import_prop_types52.default.number,
    hideTooltip: import_prop_types52.default.bool,
    id: import_prop_types52.default.oneOfType([import_prop_types52.default.number, import_prop_types52.default.string]),
    ignoreTooltip: import_prop_types52.default.bool,
    label: import_prop_types52.default.string,
    labelStyle: import_prop_types52.default.object,
    max: import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]),
    min: import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]),
    offset: import_prop_types52.default.number,
    position: import_prop_types52.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types52.default.bool,
    scaleType: import_prop_types52.default.oneOf(["linear"]),
    slotProps: import_prop_types52.default.object,
    slots: import_prop_types52.default.object,
    stroke: import_prop_types52.default.string,
    sx: import_prop_types52.default.oneOfType([import_prop_types52.default.arrayOf(import_prop_types52.default.oneOfType([import_prop_types52.default.func, import_prop_types52.default.object, import_prop_types52.default.bool])), import_prop_types52.default.func, import_prop_types52.default.object]),
    tickInterval: import_prop_types52.default.oneOfType([import_prop_types52.default.oneOf(["auto"]), import_prop_types52.default.array, import_prop_types52.default.func]),
    tickLabelInterval: import_prop_types52.default.oneOfType([import_prop_types52.default.oneOf(["auto"]), import_prop_types52.default.func]),
    tickLabelMinGap: import_prop_types52.default.number,
    tickLabelPlacement: import_prop_types52.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types52.default.object,
    tickMaxStep: import_prop_types52.default.number,
    tickMinStep: import_prop_types52.default.number,
    tickNumber: import_prop_types52.default.number,
    tickPlacement: import_prop_types52.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types52.default.number,
    valueFormatter: import_prop_types52.default.func
  })]).isRequired),
  /**
   * The configuration of the y-axes.
   * If not provided, a default axis config is used.
   * An array of [[AxisConfig]] objects.
   */
  yAxis: import_prop_types52.default.arrayOf(import_prop_types52.default.oneOfType([import_prop_types52.default.shape({
    axis: import_prop_types52.default.oneOf(["y"]),
    barGapRatio: import_prop_types52.default.number,
    categoryGapRatio: import_prop_types52.default.number,
    classes: import_prop_types52.default.object,
    colorMap: import_prop_types52.default.oneOfType([import_prop_types52.default.shape({
      colors: import_prop_types52.default.arrayOf(import_prop_types52.default.string).isRequired,
      type: import_prop_types52.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types52.default.string,
      values: import_prop_types52.default.arrayOf(import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number, import_prop_types52.default.string]).isRequired)
    }), import_prop_types52.default.shape({
      color: import_prop_types52.default.oneOfType([import_prop_types52.default.arrayOf(import_prop_types52.default.string.isRequired), import_prop_types52.default.func]).isRequired,
      max: import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]),
      min: import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]),
      type: import_prop_types52.default.oneOf(["continuous"]).isRequired
    }), import_prop_types52.default.shape({
      colors: import_prop_types52.default.arrayOf(import_prop_types52.default.string).isRequired,
      thresholds: import_prop_types52.default.arrayOf(import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]).isRequired).isRequired,
      type: import_prop_types52.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types52.default.array,
    dataKey: import_prop_types52.default.string,
    disableLine: import_prop_types52.default.bool,
    disableTicks: import_prop_types52.default.bool,
    domainLimit: import_prop_types52.default.oneOfType([import_prop_types52.default.oneOf(["nice", "strict"]), import_prop_types52.default.func]),
    fill: import_prop_types52.default.string,
    hideTooltip: import_prop_types52.default.bool,
    id: import_prop_types52.default.oneOfType([import_prop_types52.default.number, import_prop_types52.default.string]),
    ignoreTooltip: import_prop_types52.default.bool,
    label: import_prop_types52.default.string,
    labelStyle: import_prop_types52.default.object,
    max: import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]),
    min: import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]),
    offset: import_prop_types52.default.number,
    position: import_prop_types52.default.oneOf(["left", "none", "right"]),
    reverse: import_prop_types52.default.bool,
    scaleType: import_prop_types52.default.oneOf(["band"]),
    slotProps: import_prop_types52.default.object,
    slots: import_prop_types52.default.object,
    stroke: import_prop_types52.default.string,
    sx: import_prop_types52.default.oneOfType([import_prop_types52.default.arrayOf(import_prop_types52.default.oneOfType([import_prop_types52.default.func, import_prop_types52.default.object, import_prop_types52.default.bool])), import_prop_types52.default.func, import_prop_types52.default.object]),
    tickInterval: import_prop_types52.default.oneOfType([import_prop_types52.default.oneOf(["auto"]), import_prop_types52.default.array, import_prop_types52.default.func]),
    tickLabelInterval: import_prop_types52.default.oneOfType([import_prop_types52.default.oneOf(["auto"]), import_prop_types52.default.func]),
    tickLabelPlacement: import_prop_types52.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types52.default.object,
    tickMaxStep: import_prop_types52.default.number,
    tickMinStep: import_prop_types52.default.number,
    tickNumber: import_prop_types52.default.number,
    tickPlacement: import_prop_types52.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types52.default.number,
    valueFormatter: import_prop_types52.default.func,
    width: import_prop_types52.default.number
  }), import_prop_types52.default.shape({
    axis: import_prop_types52.default.oneOf(["y"]),
    classes: import_prop_types52.default.object,
    colorMap: import_prop_types52.default.oneOfType([import_prop_types52.default.shape({
      colors: import_prop_types52.default.arrayOf(import_prop_types52.default.string).isRequired,
      type: import_prop_types52.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types52.default.string,
      values: import_prop_types52.default.arrayOf(import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number, import_prop_types52.default.string]).isRequired)
    }), import_prop_types52.default.shape({
      color: import_prop_types52.default.oneOfType([import_prop_types52.default.arrayOf(import_prop_types52.default.string.isRequired), import_prop_types52.default.func]).isRequired,
      max: import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]),
      min: import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]),
      type: import_prop_types52.default.oneOf(["continuous"]).isRequired
    }), import_prop_types52.default.shape({
      colors: import_prop_types52.default.arrayOf(import_prop_types52.default.string).isRequired,
      thresholds: import_prop_types52.default.arrayOf(import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]).isRequired).isRequired,
      type: import_prop_types52.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types52.default.array,
    dataKey: import_prop_types52.default.string,
    disableLine: import_prop_types52.default.bool,
    disableTicks: import_prop_types52.default.bool,
    domainLimit: import_prop_types52.default.oneOfType([import_prop_types52.default.oneOf(["nice", "strict"]), import_prop_types52.default.func]),
    fill: import_prop_types52.default.string,
    hideTooltip: import_prop_types52.default.bool,
    id: import_prop_types52.default.oneOfType([import_prop_types52.default.number, import_prop_types52.default.string]),
    ignoreTooltip: import_prop_types52.default.bool,
    label: import_prop_types52.default.string,
    labelStyle: import_prop_types52.default.object,
    max: import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]),
    min: import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]),
    offset: import_prop_types52.default.number,
    position: import_prop_types52.default.oneOf(["left", "none", "right"]),
    reverse: import_prop_types52.default.bool,
    scaleType: import_prop_types52.default.oneOf(["point"]),
    slotProps: import_prop_types52.default.object,
    slots: import_prop_types52.default.object,
    stroke: import_prop_types52.default.string,
    sx: import_prop_types52.default.oneOfType([import_prop_types52.default.arrayOf(import_prop_types52.default.oneOfType([import_prop_types52.default.func, import_prop_types52.default.object, import_prop_types52.default.bool])), import_prop_types52.default.func, import_prop_types52.default.object]),
    tickInterval: import_prop_types52.default.oneOfType([import_prop_types52.default.oneOf(["auto"]), import_prop_types52.default.array, import_prop_types52.default.func]),
    tickLabelInterval: import_prop_types52.default.oneOfType([import_prop_types52.default.oneOf(["auto"]), import_prop_types52.default.func]),
    tickLabelPlacement: import_prop_types52.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types52.default.object,
    tickMaxStep: import_prop_types52.default.number,
    tickMinStep: import_prop_types52.default.number,
    tickNumber: import_prop_types52.default.number,
    tickPlacement: import_prop_types52.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types52.default.number,
    valueFormatter: import_prop_types52.default.func,
    width: import_prop_types52.default.number
  }), import_prop_types52.default.shape({
    axis: import_prop_types52.default.oneOf(["y"]),
    classes: import_prop_types52.default.object,
    colorMap: import_prop_types52.default.oneOfType([import_prop_types52.default.shape({
      color: import_prop_types52.default.oneOfType([import_prop_types52.default.arrayOf(import_prop_types52.default.string.isRequired), import_prop_types52.default.func]).isRequired,
      max: import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]),
      min: import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]),
      type: import_prop_types52.default.oneOf(["continuous"]).isRequired
    }), import_prop_types52.default.shape({
      colors: import_prop_types52.default.arrayOf(import_prop_types52.default.string).isRequired,
      thresholds: import_prop_types52.default.arrayOf(import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]).isRequired).isRequired,
      type: import_prop_types52.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types52.default.array,
    dataKey: import_prop_types52.default.string,
    disableLine: import_prop_types52.default.bool,
    disableTicks: import_prop_types52.default.bool,
    domainLimit: import_prop_types52.default.oneOfType([import_prop_types52.default.oneOf(["nice", "strict"]), import_prop_types52.default.func]),
    fill: import_prop_types52.default.string,
    hideTooltip: import_prop_types52.default.bool,
    id: import_prop_types52.default.oneOfType([import_prop_types52.default.number, import_prop_types52.default.string]),
    ignoreTooltip: import_prop_types52.default.bool,
    label: import_prop_types52.default.string,
    labelStyle: import_prop_types52.default.object,
    max: import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]),
    min: import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]),
    offset: import_prop_types52.default.number,
    position: import_prop_types52.default.oneOf(["left", "none", "right"]),
    reverse: import_prop_types52.default.bool,
    scaleType: import_prop_types52.default.oneOf(["log"]),
    slotProps: import_prop_types52.default.object,
    slots: import_prop_types52.default.object,
    stroke: import_prop_types52.default.string,
    sx: import_prop_types52.default.oneOfType([import_prop_types52.default.arrayOf(import_prop_types52.default.oneOfType([import_prop_types52.default.func, import_prop_types52.default.object, import_prop_types52.default.bool])), import_prop_types52.default.func, import_prop_types52.default.object]),
    tickInterval: import_prop_types52.default.oneOfType([import_prop_types52.default.oneOf(["auto"]), import_prop_types52.default.array, import_prop_types52.default.func]),
    tickLabelInterval: import_prop_types52.default.oneOfType([import_prop_types52.default.oneOf(["auto"]), import_prop_types52.default.func]),
    tickLabelPlacement: import_prop_types52.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types52.default.object,
    tickMaxStep: import_prop_types52.default.number,
    tickMinStep: import_prop_types52.default.number,
    tickNumber: import_prop_types52.default.number,
    tickPlacement: import_prop_types52.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types52.default.number,
    valueFormatter: import_prop_types52.default.func,
    width: import_prop_types52.default.number
  }), import_prop_types52.default.shape({
    axis: import_prop_types52.default.oneOf(["y"]),
    classes: import_prop_types52.default.object,
    colorMap: import_prop_types52.default.oneOfType([import_prop_types52.default.shape({
      color: import_prop_types52.default.oneOfType([import_prop_types52.default.arrayOf(import_prop_types52.default.string.isRequired), import_prop_types52.default.func]).isRequired,
      max: import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]),
      min: import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]),
      type: import_prop_types52.default.oneOf(["continuous"]).isRequired
    }), import_prop_types52.default.shape({
      colors: import_prop_types52.default.arrayOf(import_prop_types52.default.string).isRequired,
      thresholds: import_prop_types52.default.arrayOf(import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]).isRequired).isRequired,
      type: import_prop_types52.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types52.default.array,
    dataKey: import_prop_types52.default.string,
    disableLine: import_prop_types52.default.bool,
    disableTicks: import_prop_types52.default.bool,
    domainLimit: import_prop_types52.default.oneOfType([import_prop_types52.default.oneOf(["nice", "strict"]), import_prop_types52.default.func]),
    fill: import_prop_types52.default.string,
    hideTooltip: import_prop_types52.default.bool,
    id: import_prop_types52.default.oneOfType([import_prop_types52.default.number, import_prop_types52.default.string]),
    ignoreTooltip: import_prop_types52.default.bool,
    label: import_prop_types52.default.string,
    labelStyle: import_prop_types52.default.object,
    max: import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]),
    min: import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]),
    offset: import_prop_types52.default.number,
    position: import_prop_types52.default.oneOf(["left", "none", "right"]),
    reverse: import_prop_types52.default.bool,
    scaleType: import_prop_types52.default.oneOf(["pow"]),
    slotProps: import_prop_types52.default.object,
    slots: import_prop_types52.default.object,
    stroke: import_prop_types52.default.string,
    sx: import_prop_types52.default.oneOfType([import_prop_types52.default.arrayOf(import_prop_types52.default.oneOfType([import_prop_types52.default.func, import_prop_types52.default.object, import_prop_types52.default.bool])), import_prop_types52.default.func, import_prop_types52.default.object]),
    tickInterval: import_prop_types52.default.oneOfType([import_prop_types52.default.oneOf(["auto"]), import_prop_types52.default.array, import_prop_types52.default.func]),
    tickLabelInterval: import_prop_types52.default.oneOfType([import_prop_types52.default.oneOf(["auto"]), import_prop_types52.default.func]),
    tickLabelPlacement: import_prop_types52.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types52.default.object,
    tickMaxStep: import_prop_types52.default.number,
    tickMinStep: import_prop_types52.default.number,
    tickNumber: import_prop_types52.default.number,
    tickPlacement: import_prop_types52.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types52.default.number,
    valueFormatter: import_prop_types52.default.func,
    width: import_prop_types52.default.number
  }), import_prop_types52.default.shape({
    axis: import_prop_types52.default.oneOf(["y"]),
    classes: import_prop_types52.default.object,
    colorMap: import_prop_types52.default.oneOfType([import_prop_types52.default.shape({
      color: import_prop_types52.default.oneOfType([import_prop_types52.default.arrayOf(import_prop_types52.default.string.isRequired), import_prop_types52.default.func]).isRequired,
      max: import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]),
      min: import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]),
      type: import_prop_types52.default.oneOf(["continuous"]).isRequired
    }), import_prop_types52.default.shape({
      colors: import_prop_types52.default.arrayOf(import_prop_types52.default.string).isRequired,
      thresholds: import_prop_types52.default.arrayOf(import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]).isRequired).isRequired,
      type: import_prop_types52.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types52.default.array,
    dataKey: import_prop_types52.default.string,
    disableLine: import_prop_types52.default.bool,
    disableTicks: import_prop_types52.default.bool,
    domainLimit: import_prop_types52.default.oneOfType([import_prop_types52.default.oneOf(["nice", "strict"]), import_prop_types52.default.func]),
    fill: import_prop_types52.default.string,
    hideTooltip: import_prop_types52.default.bool,
    id: import_prop_types52.default.oneOfType([import_prop_types52.default.number, import_prop_types52.default.string]),
    ignoreTooltip: import_prop_types52.default.bool,
    label: import_prop_types52.default.string,
    labelStyle: import_prop_types52.default.object,
    max: import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]),
    min: import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]),
    offset: import_prop_types52.default.number,
    position: import_prop_types52.default.oneOf(["left", "none", "right"]),
    reverse: import_prop_types52.default.bool,
    scaleType: import_prop_types52.default.oneOf(["sqrt"]),
    slotProps: import_prop_types52.default.object,
    slots: import_prop_types52.default.object,
    stroke: import_prop_types52.default.string,
    sx: import_prop_types52.default.oneOfType([import_prop_types52.default.arrayOf(import_prop_types52.default.oneOfType([import_prop_types52.default.func, import_prop_types52.default.object, import_prop_types52.default.bool])), import_prop_types52.default.func, import_prop_types52.default.object]),
    tickInterval: import_prop_types52.default.oneOfType([import_prop_types52.default.oneOf(["auto"]), import_prop_types52.default.array, import_prop_types52.default.func]),
    tickLabelInterval: import_prop_types52.default.oneOfType([import_prop_types52.default.oneOf(["auto"]), import_prop_types52.default.func]),
    tickLabelPlacement: import_prop_types52.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types52.default.object,
    tickMaxStep: import_prop_types52.default.number,
    tickMinStep: import_prop_types52.default.number,
    tickNumber: import_prop_types52.default.number,
    tickPlacement: import_prop_types52.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types52.default.number,
    valueFormatter: import_prop_types52.default.func,
    width: import_prop_types52.default.number
  }), import_prop_types52.default.shape({
    axis: import_prop_types52.default.oneOf(["y"]),
    classes: import_prop_types52.default.object,
    colorMap: import_prop_types52.default.oneOfType([import_prop_types52.default.shape({
      color: import_prop_types52.default.oneOfType([import_prop_types52.default.arrayOf(import_prop_types52.default.string.isRequired), import_prop_types52.default.func]).isRequired,
      max: import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]),
      min: import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]),
      type: import_prop_types52.default.oneOf(["continuous"]).isRequired
    }), import_prop_types52.default.shape({
      colors: import_prop_types52.default.arrayOf(import_prop_types52.default.string).isRequired,
      thresholds: import_prop_types52.default.arrayOf(import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]).isRequired).isRequired,
      type: import_prop_types52.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types52.default.array,
    dataKey: import_prop_types52.default.string,
    disableLine: import_prop_types52.default.bool,
    disableTicks: import_prop_types52.default.bool,
    domainLimit: import_prop_types52.default.oneOfType([import_prop_types52.default.oneOf(["nice", "strict"]), import_prop_types52.default.func]),
    fill: import_prop_types52.default.string,
    hideTooltip: import_prop_types52.default.bool,
    id: import_prop_types52.default.oneOfType([import_prop_types52.default.number, import_prop_types52.default.string]),
    ignoreTooltip: import_prop_types52.default.bool,
    label: import_prop_types52.default.string,
    labelStyle: import_prop_types52.default.object,
    max: import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]),
    min: import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]),
    offset: import_prop_types52.default.number,
    position: import_prop_types52.default.oneOf(["left", "none", "right"]),
    reverse: import_prop_types52.default.bool,
    scaleType: import_prop_types52.default.oneOf(["time"]),
    slotProps: import_prop_types52.default.object,
    slots: import_prop_types52.default.object,
    stroke: import_prop_types52.default.string,
    sx: import_prop_types52.default.oneOfType([import_prop_types52.default.arrayOf(import_prop_types52.default.oneOfType([import_prop_types52.default.func, import_prop_types52.default.object, import_prop_types52.default.bool])), import_prop_types52.default.func, import_prop_types52.default.object]),
    tickInterval: import_prop_types52.default.oneOfType([import_prop_types52.default.oneOf(["auto"]), import_prop_types52.default.array, import_prop_types52.default.func]),
    tickLabelInterval: import_prop_types52.default.oneOfType([import_prop_types52.default.oneOf(["auto"]), import_prop_types52.default.func]),
    tickLabelPlacement: import_prop_types52.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types52.default.object,
    tickMaxStep: import_prop_types52.default.number,
    tickMinStep: import_prop_types52.default.number,
    tickNumber: import_prop_types52.default.number,
    tickPlacement: import_prop_types52.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types52.default.number,
    valueFormatter: import_prop_types52.default.func,
    width: import_prop_types52.default.number
  }), import_prop_types52.default.shape({
    axis: import_prop_types52.default.oneOf(["y"]),
    classes: import_prop_types52.default.object,
    colorMap: import_prop_types52.default.oneOfType([import_prop_types52.default.shape({
      color: import_prop_types52.default.oneOfType([import_prop_types52.default.arrayOf(import_prop_types52.default.string.isRequired), import_prop_types52.default.func]).isRequired,
      max: import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]),
      min: import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]),
      type: import_prop_types52.default.oneOf(["continuous"]).isRequired
    }), import_prop_types52.default.shape({
      colors: import_prop_types52.default.arrayOf(import_prop_types52.default.string).isRequired,
      thresholds: import_prop_types52.default.arrayOf(import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]).isRequired).isRequired,
      type: import_prop_types52.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types52.default.array,
    dataKey: import_prop_types52.default.string,
    disableLine: import_prop_types52.default.bool,
    disableTicks: import_prop_types52.default.bool,
    domainLimit: import_prop_types52.default.oneOfType([import_prop_types52.default.oneOf(["nice", "strict"]), import_prop_types52.default.func]),
    fill: import_prop_types52.default.string,
    hideTooltip: import_prop_types52.default.bool,
    id: import_prop_types52.default.oneOfType([import_prop_types52.default.number, import_prop_types52.default.string]),
    ignoreTooltip: import_prop_types52.default.bool,
    label: import_prop_types52.default.string,
    labelStyle: import_prop_types52.default.object,
    max: import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]),
    min: import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]),
    offset: import_prop_types52.default.number,
    position: import_prop_types52.default.oneOf(["left", "none", "right"]),
    reverse: import_prop_types52.default.bool,
    scaleType: import_prop_types52.default.oneOf(["utc"]),
    slotProps: import_prop_types52.default.object,
    slots: import_prop_types52.default.object,
    stroke: import_prop_types52.default.string,
    sx: import_prop_types52.default.oneOfType([import_prop_types52.default.arrayOf(import_prop_types52.default.oneOfType([import_prop_types52.default.func, import_prop_types52.default.object, import_prop_types52.default.bool])), import_prop_types52.default.func, import_prop_types52.default.object]),
    tickInterval: import_prop_types52.default.oneOfType([import_prop_types52.default.oneOf(["auto"]), import_prop_types52.default.array, import_prop_types52.default.func]),
    tickLabelInterval: import_prop_types52.default.oneOfType([import_prop_types52.default.oneOf(["auto"]), import_prop_types52.default.func]),
    tickLabelPlacement: import_prop_types52.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types52.default.object,
    tickMaxStep: import_prop_types52.default.number,
    tickMinStep: import_prop_types52.default.number,
    tickNumber: import_prop_types52.default.number,
    tickPlacement: import_prop_types52.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types52.default.number,
    valueFormatter: import_prop_types52.default.func,
    width: import_prop_types52.default.number
  }), import_prop_types52.default.shape({
    axis: import_prop_types52.default.oneOf(["y"]),
    classes: import_prop_types52.default.object,
    colorMap: import_prop_types52.default.oneOfType([import_prop_types52.default.shape({
      color: import_prop_types52.default.oneOfType([import_prop_types52.default.arrayOf(import_prop_types52.default.string.isRequired), import_prop_types52.default.func]).isRequired,
      max: import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]),
      min: import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]),
      type: import_prop_types52.default.oneOf(["continuous"]).isRequired
    }), import_prop_types52.default.shape({
      colors: import_prop_types52.default.arrayOf(import_prop_types52.default.string).isRequired,
      thresholds: import_prop_types52.default.arrayOf(import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]).isRequired).isRequired,
      type: import_prop_types52.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types52.default.array,
    dataKey: import_prop_types52.default.string,
    disableLine: import_prop_types52.default.bool,
    disableTicks: import_prop_types52.default.bool,
    domainLimit: import_prop_types52.default.oneOfType([import_prop_types52.default.oneOf(["nice", "strict"]), import_prop_types52.default.func]),
    fill: import_prop_types52.default.string,
    hideTooltip: import_prop_types52.default.bool,
    id: import_prop_types52.default.oneOfType([import_prop_types52.default.number, import_prop_types52.default.string]),
    ignoreTooltip: import_prop_types52.default.bool,
    label: import_prop_types52.default.string,
    labelStyle: import_prop_types52.default.object,
    max: import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]),
    min: import_prop_types52.default.oneOfType([import_prop_types52.default.instanceOf(Date), import_prop_types52.default.number]),
    offset: import_prop_types52.default.number,
    position: import_prop_types52.default.oneOf(["left", "none", "right"]),
    reverse: import_prop_types52.default.bool,
    scaleType: import_prop_types52.default.oneOf(["linear"]),
    slotProps: import_prop_types52.default.object,
    slots: import_prop_types52.default.object,
    stroke: import_prop_types52.default.string,
    sx: import_prop_types52.default.oneOfType([import_prop_types52.default.arrayOf(import_prop_types52.default.oneOfType([import_prop_types52.default.func, import_prop_types52.default.object, import_prop_types52.default.bool])), import_prop_types52.default.func, import_prop_types52.default.object]),
    tickInterval: import_prop_types52.default.oneOfType([import_prop_types52.default.oneOf(["auto"]), import_prop_types52.default.array, import_prop_types52.default.func]),
    tickLabelInterval: import_prop_types52.default.oneOfType([import_prop_types52.default.oneOf(["auto"]), import_prop_types52.default.func]),
    tickLabelPlacement: import_prop_types52.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types52.default.object,
    tickMaxStep: import_prop_types52.default.number,
    tickMinStep: import_prop_types52.default.number,
    tickNumber: import_prop_types52.default.number,
    tickPlacement: import_prop_types52.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types52.default.number,
    valueFormatter: import_prop_types52.default.func,
    width: import_prop_types52.default.number
  })]).isRequired)
} : void 0;

// node_modules/@mui/x-charts/esm/LineChart/LineChart.js
var React120 = __toESM(require_react(), 1);
var import_prop_types64 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/LineChart/AreaPlot.js
var React109 = __toESM(require_react(), 1);
var import_prop_types55 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/LineChart/AreaElement.js
var React108 = __toESM(require_react(), 1);
var import_prop_types54 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/LineChart/AnimatedArea.js
var React107 = __toESM(require_react(), 1);
var import_prop_types53 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/LineChart/AppearingMask.js
var React106 = __toESM(require_react(), 1);

// node_modules/@mui/x-charts/esm/internals/cleanId.js
function cleanId(id) {
  return id.replace(" ", "_");
}

// node_modules/@mui/x-charts/esm/LineChart/AppearingMask.js
var import_jsx_runtime68 = __toESM(require_jsx_runtime(), 1);
var appearingMaskClasses = generateUtilityClasses("MuiAppearingMask", ["animate"]);
var AnimatedRect = styled_default2("rect")({
  animationName: "animate-width",
  animationTimingFunction: ANIMATION_TIMING_FUNCTION,
  animationDuration: "0s",
  [`&.${appearingMaskClasses.animate}`]: {
    animationDuration: `${ANIMATION_DURATION_MS}ms`
  },
  "@keyframes animate-width": {
    from: {
      width: 0
    }
  }
});
function AppearingMask(props) {
  const drawingArea = useDrawingArea();
  const chartId = useChartId2();
  const clipId = cleanId(`${chartId}-${props.id}`);
  return (0, import_jsx_runtime68.jsxs)(React106.Fragment, {
    children: [(0, import_jsx_runtime68.jsx)("clipPath", {
      id: clipId,
      children: (0, import_jsx_runtime68.jsx)(AnimatedRect, {
        className: props.skipAnimation ? "" : appearingMaskClasses.animate,
        x: 0,
        y: 0,
        width: drawingArea.left + drawingArea.width + drawingArea.right,
        height: drawingArea.top + drawingArea.height + drawingArea.bottom
      })
    }), (0, import_jsx_runtime68.jsx)("g", {
      clipPath: `url(#${clipId})`,
      children: props.children
    })]
  });
}

// node_modules/@mui/x-charts/esm/LineChart/AnimatedArea.js
var import_jsx_runtime69 = __toESM(require_jsx_runtime(), 1);
var _excluded31 = ["skipAnimation", "ownerState"];
function AnimatedArea(props) {
  const {
    skipAnimation,
    ownerState
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded31);
  const animatedProps = useAnimateArea(props);
  return (0, import_jsx_runtime69.jsx)(AppearingMask, {
    skipAnimation,
    id: `${ownerState.id}-area-clip`,
    children: (0, import_jsx_runtime69.jsx)("path", _extends({
      fill: ownerState.gradientId ? `url(#${ownerState.gradientId})` : ownerState.color,
      filter: (
        // eslint-disable-next-line no-nested-ternary
        ownerState.isHighlighted ? "brightness(140%)" : ownerState.gradientId ? void 0 : "brightness(120%)"
      ),
      opacity: ownerState.isFaded ? 0.3 : 1,
      stroke: "none"
    }, other, animatedProps))
  });
}
true ? AnimatedArea.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  d: import_prop_types53.default.string.isRequired,
  ownerState: import_prop_types53.default.shape({
    classes: import_prop_types53.default.object,
    color: import_prop_types53.default.string.isRequired,
    gradientId: import_prop_types53.default.string,
    id: import_prop_types53.default.oneOfType([import_prop_types53.default.number, import_prop_types53.default.string]).isRequired,
    isFaded: import_prop_types53.default.bool.isRequired,
    isHighlighted: import_prop_types53.default.bool.isRequired
  }).isRequired,
  /**
   * If `true`, animations are skipped.
   * @default false
   */
  skipAnimation: import_prop_types53.default.bool
} : void 0;

// node_modules/@mui/x-charts/esm/LineChart/AreaElement.js
var import_jsx_runtime70 = __toESM(require_jsx_runtime(), 1);
var _excluded32 = ["id", "classes", "color", "gradientId", "slots", "slotProps", "onClick"];
function getAreaElementUtilityClass(slot) {
  return generateUtilityClass("MuiAreaElement", slot);
}
var areaElementClasses = generateUtilityClasses("MuiAreaElement", ["root", "highlighted", "faded", "series"]);
var useUtilityClasses17 = (ownerState) => {
  const {
    classes,
    id,
    isFaded,
    isHighlighted
  } = ownerState;
  const slots = {
    root: ["root", `series-${id}`, isHighlighted && "highlighted", isFaded && "faded"]
  };
  return composeClasses(slots, getAreaElementUtilityClass, classes);
};
function AreaElement(props) {
  const {
    id,
    classes: innerClasses,
    color: color3,
    gradientId,
    slots,
    slotProps,
    onClick
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded32);
  const interactionProps = useInteractionItemProps({
    type: "line",
    seriesId: id
  });
  const {
    isFaded,
    isHighlighted
  } = useItemHighlighted({
    seriesId: id
  });
  const ownerState = {
    id,
    classes: innerClasses,
    color: color3,
    gradientId,
    isFaded,
    isHighlighted
  };
  const classes = useUtilityClasses17(ownerState);
  const Area = (slots == null ? void 0 : slots.area) ?? AnimatedArea;
  const areaProps = useSlotProps_default({
    elementType: Area,
    externalSlotProps: slotProps == null ? void 0 : slotProps.area,
    additionalProps: _extends({}, interactionProps, {
      onClick,
      cursor: onClick ? "pointer" : "unset"
    }),
    className: classes.root,
    ownerState
  });
  return (0, import_jsx_runtime70.jsx)(Area, _extends({}, other, areaProps));
}
true ? AreaElement.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  classes: import_prop_types54.default.object,
  color: import_prop_types54.default.string.isRequired,
  d: import_prop_types54.default.string.isRequired,
  gradientId: import_prop_types54.default.string,
  id: import_prop_types54.default.oneOfType([import_prop_types54.default.number, import_prop_types54.default.string]).isRequired,
  /**
   * If `true`, animations are skipped.
   * @default false
   */
  skipAnimation: import_prop_types54.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types54.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types54.default.object
} : void 0;

// node_modules/@mui/x-charts/esm/internals/getCurve.js
function getCurveFactory(curveType) {
  switch (curveType) {
    case "catmullRom":
      return catmullRom_default.alpha(0.5);
    case "linear":
      return linear_default;
    case "monotoneX":
      return monotoneX;
    case "monotoneY":
      return monotoneY;
    case "natural":
      return natural_default;
    case "step":
      return step_default;
    case "stepBefore":
      return stepBefore;
    case "stepAfter":
      return stepAfter;
    case "bumpY":
      return bumpY;
    case "bumpX":
      return bumpX;
    default:
      return monotoneX;
  }
}

// node_modules/@mui/x-charts/esm/LineChart/AreaPlot.js
var import_jsx_runtime71 = __toESM(require_jsx_runtime(), 1);
var _excluded33 = ["slots", "slotProps", "onItemClick", "skipAnimation"];
var AreaPlotRoot = styled_default2("g", {
  name: "MuiAreaPlot",
  slot: "Root"
})({
  [`& .${areaElementClasses.root}`]: {
    transition: "opacity 0.2s ease-in, fill 0.2s ease-in"
  }
});
var useAggregatedData2 = () => {
  const seriesData = useLineSeriesContext();
  const {
    xAxis,
    xAxisIds
  } = useXAxes();
  const {
    yAxis,
    yAxisIds
  } = useYAxes();
  const getGradientId = useChartGradientIdBuilder();
  const allData = React109.useMemo(() => {
    if (seriesData === void 0) {
      return [];
    }
    const {
      series,
      stackingGroups
    } = seriesData;
    const defaultXAxisId = xAxisIds[0];
    const defaultYAxisId = yAxisIds[0];
    return stackingGroups.flatMap(({
      ids: groupIds
    }) => {
      return [...groupIds].reverse().map((seriesId) => {
        const {
          xAxisId = defaultXAxisId,
          yAxisId = defaultYAxisId,
          stackedData,
          data,
          connectNulls,
          baseline,
          curve,
          strictStepCurve
        } = series[seriesId];
        const xScale = xAxis[xAxisId].scale;
        const xPosition = getValueToPositionMapper(xScale);
        const yScale = yAxis[yAxisId].scale;
        const xData = xAxis[xAxisId].data;
        const gradientId = yAxis[yAxisId].colorScale && getGradientId(yAxisId) || xAxis[xAxisId].colorScale && getGradientId(xAxisId) || void 0;
        if (true) {
          if (xData === void 0) {
            throw new Error(`MUI X Charts: ${xAxisId === DEFAULT_X_AXIS_KEY ? "The first `xAxis`" : `The x-axis with id "${xAxisId}"`} should have data property to be able to display a line plot.`);
          }
          if (xData.length < stackedData.length) {
            throw new Error(`MUI X Charts: The data length of the x axis (${xData.length} items) is lower than the length of series (${stackedData.length} items).`);
          }
        }
        const shouldExpand = (curve == null ? void 0 : curve.includes("step")) && !strictStepCurve && isBandScale(xScale);
        const formattedData = (xData == null ? void 0 : xData.flatMap((x3, index2) => {
          const nullData = data[index2] == null;
          if (shouldExpand) {
            const rep = [{
              x: x3,
              y: stackedData[index2],
              nullData,
              isExtension: false
            }];
            if (!nullData && (index2 === 0 || data[index2 - 1] == null)) {
              rep.unshift({
                x: (xScale(x3) ?? 0) - (xScale.step() - xScale.bandwidth()) / 2,
                y: stackedData[index2],
                nullData,
                isExtension: true
              });
            }
            if (!nullData && (index2 === data.length - 1 || data[index2 + 1] == null)) {
              rep.push({
                x: (xScale(x3) ?? 0) + (xScale.step() + xScale.bandwidth()) / 2,
                y: stackedData[index2],
                nullData,
                isExtension: true
              });
            }
            return rep;
          }
          return {
            x: x3,
            y: stackedData[index2],
            nullData
          };
        })) ?? [];
        const d3Data = connectNulls ? formattedData.filter((d2) => !d2.nullData) : formattedData;
        const areaPath = area_default().x((d2) => d2.isExtension ? d2.x : xPosition(d2.x)).defined((d2) => connectNulls || !d2.nullData || !!d2.isExtension).y0((d2) => {
          if (typeof baseline === "number") {
            return yScale(baseline);
          }
          if (baseline === "max") {
            return yScale.range()[1];
          }
          if (baseline === "min") {
            return yScale.range()[0];
          }
          const value = d2.y && yScale(d2.y[0]);
          if (Number.isNaN(value)) {
            return yScale.range()[0];
          }
          return value;
        }).y1((d2) => d2.y && yScale(d2.y[1]));
        const d = areaPath.curve(getCurveFactory(curve))(d3Data) || "";
        return _extends({}, series[seriesId], {
          gradientId,
          d,
          seriesId
        });
      });
    });
  }, [seriesData, xAxisIds, yAxisIds, xAxis, yAxis, getGradientId]);
  return allData;
};
function AreaPlot(props) {
  const {
    slots,
    slotProps,
    onItemClick,
    skipAnimation: inSkipAnimation
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded33);
  const isZoomInteracting = useInternalIsZoomInteracting();
  const skipAnimation = useSkipAnimation(isZoomInteracting || inSkipAnimation);
  const completedData = useAggregatedData2();
  return (0, import_jsx_runtime71.jsx)(AreaPlotRoot, _extends({}, other, {
    children: completedData.map(({
      d,
      seriesId,
      color: color3,
      area,
      gradientId
    }) => !!area && (0, import_jsx_runtime71.jsx)(AreaElement, {
      id: seriesId,
      d,
      color: color3,
      gradientId,
      slots,
      slotProps,
      onClick: onItemClick && ((event) => onItemClick(event, {
        type: "line",
        seriesId
      })),
      skipAnimation
    }, seriesId))
  }));
}
true ? AreaPlot.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Callback fired when a line area item is clicked.
   * @param {React.MouseEvent<SVGPathElement, MouseEvent>} event The event source of the callback.
   * @param {LineItemIdentifier} lineItemIdentifier The line item identifier.
   */
  onItemClick: import_prop_types55.default.func,
  /**
   * If `true`, animations are skipped.
   * @default false
   */
  skipAnimation: import_prop_types55.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types55.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types55.default.object
} : void 0;

// node_modules/@mui/x-charts/esm/LineChart/LinePlot.js
var React112 = __toESM(require_react(), 1);
var import_prop_types58 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/LineChart/LineElement.js
var React111 = __toESM(require_react(), 1);
var import_prop_types57 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/LineChart/AnimatedLine.js
var React110 = __toESM(require_react(), 1);
var import_prop_types56 = __toESM(require_prop_types(), 1);
var import_jsx_runtime72 = __toESM(require_jsx_runtime(), 1);
var _excluded34 = ["skipAnimation", "ownerState"];
var AnimatedLine = React110.forwardRef(function AnimatedLine2(props, ref) {
  const {
    skipAnimation,
    ownerState
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded34);
  const animateProps = useAnimateLine(_extends({}, props, {
    ref
  }));
  return (0, import_jsx_runtime72.jsx)(AppearingMask, {
    skipAnimation,
    id: `${ownerState.id}-line-clip`,
    children: (0, import_jsx_runtime72.jsx)("path", _extends({
      stroke: ownerState.gradientId ? `url(#${ownerState.gradientId})` : ownerState.color,
      strokeWidth: 2,
      strokeLinejoin: "round",
      fill: "none",
      filter: ownerState.isHighlighted ? "brightness(120%)" : void 0,
      opacity: ownerState.isFaded ? 0.3 : 1
    }, other, animateProps))
  });
});
true ? AnimatedLine.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  d: import_prop_types56.default.string.isRequired,
  ownerState: import_prop_types56.default.shape({
    classes: import_prop_types56.default.object,
    color: import_prop_types56.default.string.isRequired,
    gradientId: import_prop_types56.default.string,
    id: import_prop_types56.default.oneOfType([import_prop_types56.default.number, import_prop_types56.default.string]).isRequired,
    isFaded: import_prop_types56.default.bool.isRequired,
    isHighlighted: import_prop_types56.default.bool.isRequired
  }).isRequired,
  /**
   * If `true`, animations are skipped.
   * @default false
   */
  skipAnimation: import_prop_types56.default.bool
} : void 0;

// node_modules/@mui/x-charts/esm/LineChart/LineElement.js
var import_jsx_runtime73 = __toESM(require_jsx_runtime(), 1);
var _excluded35 = ["id", "classes", "color", "gradientId", "slots", "slotProps", "onClick"];
function getLineElementUtilityClass(slot) {
  return generateUtilityClass("MuiLineElement", slot);
}
var lineElementClasses = generateUtilityClasses("MuiLineElement", ["root", "highlighted", "faded", "series"]);
var useUtilityClasses18 = (ownerState) => {
  const {
    classes,
    id,
    isFaded,
    isHighlighted
  } = ownerState;
  const slots = {
    root: ["root", `series-${id}`, isHighlighted && "highlighted", isFaded && "faded"]
  };
  return composeClasses(slots, getLineElementUtilityClass, classes);
};
function LineElement(props) {
  const {
    id,
    classes: innerClasses,
    color: color3,
    gradientId,
    slots,
    slotProps,
    onClick
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded35);
  const interactionProps = useInteractionItemProps({
    type: "line",
    seriesId: id
  });
  const {
    isFaded,
    isHighlighted
  } = useItemHighlighted({
    seriesId: id
  });
  const ownerState = {
    id,
    classes: innerClasses,
    color: color3,
    gradientId,
    isFaded,
    isHighlighted
  };
  const classes = useUtilityClasses18(ownerState);
  const Line = (slots == null ? void 0 : slots.line) ?? AnimatedLine;
  const lineProps = useSlotProps_default({
    elementType: Line,
    externalSlotProps: slotProps == null ? void 0 : slotProps.line,
    additionalProps: _extends({}, interactionProps, {
      onClick,
      cursor: onClick ? "pointer" : "unset"
    }),
    className: classes.root,
    ownerState
  });
  return (0, import_jsx_runtime73.jsx)(Line, _extends({}, other, lineProps));
}
true ? LineElement.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  classes: import_prop_types57.default.object,
  color: import_prop_types57.default.string.isRequired,
  d: import_prop_types57.default.string.isRequired,
  gradientId: import_prop_types57.default.string,
  id: import_prop_types57.default.oneOfType([import_prop_types57.default.number, import_prop_types57.default.string]).isRequired,
  /**
   * If `true`, animations are skipped.
   * @default false
   */
  skipAnimation: import_prop_types57.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types57.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types57.default.object
} : void 0;

// node_modules/@mui/x-charts/esm/LineChart/LinePlot.js
var import_jsx_runtime74 = __toESM(require_jsx_runtime(), 1);
var _excluded36 = ["slots", "slotProps", "skipAnimation", "onItemClick"];
var LinePlotRoot = styled_default2("g", {
  name: "MuiAreaPlot",
  slot: "Root"
})({
  [`& .${lineElementClasses.root}`]: {
    transition: "opacity 0.2s ease-in, fill 0.2s ease-in"
  }
});
var useAggregatedData3 = () => {
  const seriesData = useLineSeriesContext();
  const {
    xAxis,
    xAxisIds
  } = useXAxes();
  const {
    yAxis,
    yAxisIds
  } = useYAxes();
  const getGradientId = useChartGradientIdBuilder();
  const allData = React112.useMemo(() => {
    if (seriesData === void 0) {
      return [];
    }
    const {
      series,
      stackingGroups
    } = seriesData;
    const defaultXAxisId = xAxisIds[0];
    const defaultYAxisId = yAxisIds[0];
    return stackingGroups.flatMap(({
      ids: groupIds
    }) => {
      return groupIds.flatMap((seriesId) => {
        const {
          xAxisId = defaultXAxisId,
          yAxisId = defaultYAxisId,
          stackedData,
          data,
          connectNulls,
          curve,
          strictStepCurve
        } = series[seriesId];
        const xScale = xAxis[xAxisId].scale;
        const xPosition = getValueToPositionMapper(xScale);
        const yScale = yAxis[yAxisId].scale;
        const xData = xAxis[xAxisId].data;
        const gradientId = yAxis[yAxisId].colorScale && getGradientId(yAxisId) || xAxis[xAxisId].colorScale && getGradientId(xAxisId) || void 0;
        if (true) {
          if (xData === void 0) {
            throw new Error(`MUI X Charts: ${xAxisId === DEFAULT_X_AXIS_KEY ? "The first `xAxis`" : `The x-axis with id "${xAxisId}"`} should have data property to be able to display a line plot.`);
          }
          if (xData.length < stackedData.length) {
            warnOnce(`MUI X Charts: The data length of the x axis (${xData.length} items) is lower than the length of series (${stackedData.length} items).`, "error");
          }
        }
        const shouldExpand = (curve == null ? void 0 : curve.includes("step")) && !strictStepCurve && isBandScale(xScale);
        const formattedData = (xData == null ? void 0 : xData.flatMap((x3, index2) => {
          const nullData = data[index2] == null;
          if (shouldExpand) {
            const rep = [{
              x: x3,
              y: stackedData[index2],
              nullData,
              isExtension: false
            }];
            if (!nullData && (index2 === 0 || data[index2 - 1] == null)) {
              rep.unshift({
                x: (xScale(x3) ?? 0) - (xScale.step() - xScale.bandwidth()) / 2,
                y: stackedData[index2],
                nullData,
                isExtension: true
              });
            }
            if (!nullData && (index2 === data.length - 1 || data[index2 + 1] == null)) {
              rep.push({
                x: (xScale(x3) ?? 0) + (xScale.step() + xScale.bandwidth()) / 2,
                y: stackedData[index2],
                nullData,
                isExtension: true
              });
            }
            return rep;
          }
          return {
            x: x3,
            y: stackedData[index2],
            nullData
          };
        })) ?? [];
        const d3Data = connectNulls ? formattedData.filter((d2) => !d2.nullData) : formattedData;
        const linePath = line_default().x((d2) => d2.isExtension ? d2.x : xPosition(d2.x)).defined((d2) => connectNulls || !d2.nullData || !!d2.isExtension).y((d2) => yScale(d2.y[1]));
        const d = linePath.curve(getCurveFactory(curve))(d3Data) || "";
        return _extends({}, series[seriesId], {
          gradientId,
          d,
          seriesId
        });
      });
    });
  }, [seriesData, xAxisIds, yAxisIds, xAxis, yAxis, getGradientId]);
  return allData;
};
function LinePlot(props) {
  const {
    slots,
    slotProps,
    skipAnimation: inSkipAnimation,
    onItemClick
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded36);
  const isZoomInteracting = useInternalIsZoomInteracting();
  const skipAnimation = useSkipAnimation(isZoomInteracting || inSkipAnimation);
  const completedData = useAggregatedData3();
  return (0, import_jsx_runtime74.jsx)(LinePlotRoot, _extends({}, other, {
    children: completedData.map(({
      d,
      seriesId,
      color: color3,
      gradientId
    }) => {
      return (0, import_jsx_runtime74.jsx)(LineElement, {
        id: seriesId,
        d,
        color: color3,
        gradientId,
        skipAnimation,
        slots,
        slotProps,
        onClick: onItemClick && ((event) => onItemClick(event, {
          type: "line",
          seriesId
        }))
      }, seriesId);
    })
  }));
}
true ? LinePlot.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Callback fired when a line item is clicked.
   * @param {React.MouseEvent<SVGPathElement, MouseEvent>} event The event source of the callback.
   * @param {LineItemIdentifier} lineItemIdentifier The line item identifier.
   */
  onItemClick: import_prop_types58.default.func,
  /**
   * If `true`, animations are skipped.
   * @default false
   */
  skipAnimation: import_prop_types58.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types58.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types58.default.object
} : void 0;

// node_modules/@mui/x-charts/esm/LineChart/MarkPlot.js
var import_prop_types61 = __toESM(require_prop_types(), 1);
var React115 = __toESM(require_react(), 1);

// node_modules/@mui/x-charts/esm/LineChart/CircleMarkElement.js
var React113 = __toESM(require_react(), 1);
var import_prop_types59 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/LineChart/markElementClasses.js
function getMarkElementUtilityClass(slot) {
  return generateUtilityClass("MuiMarkElement", slot);
}
var markElementClasses = generateUtilityClasses("MuiMarkElement", ["root", "highlighted", "faded", "animate", "series"]);
var useUtilityClasses19 = (ownerState) => {
  const {
    classes,
    id,
    isFaded,
    isHighlighted,
    skipAnimation
  } = ownerState;
  const slots = {
    root: ["root", `series-${id}`, isHighlighted && "highlighted", isFaded && "faded", skipAnimation ? void 0 : "animate"]
  };
  return composeClasses(slots, getMarkElementUtilityClass, classes);
};

// node_modules/@mui/x-charts/esm/LineChart/CircleMarkElement.js
var import_jsx_runtime75 = __toESM(require_jsx_runtime(), 1);
var _excluded37 = ["x", "y", "id", "classes", "color", "dataIndex", "onClick", "skipAnimation", "isFaded", "isHighlighted"];
var Circle = styled_default2("circle")({
  [`&.${markElementClasses.animate}`]: {
    transitionDuration: `${ANIMATION_DURATION_MS}ms`,
    transitionProperty: "cx, cy",
    transitionTimingFunction: ANIMATION_TIMING_FUNCTION
  }
});
function CircleMarkElement(props) {
  const {
    x: x3,
    y: y3,
    id,
    classes: innerClasses,
    color: color3,
    dataIndex,
    onClick,
    skipAnimation,
    isFaded = false,
    isHighlighted = false
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded37);
  const theme = useTheme4();
  const interactionProps = useInteractionItemProps({
    type: "line",
    seriesId: id,
    dataIndex
  });
  const ownerState = {
    id,
    classes: innerClasses,
    isHighlighted,
    isFaded,
    color: color3,
    skipAnimation
  };
  const classes = useUtilityClasses19(ownerState);
  return (0, import_jsx_runtime75.jsx)(Circle, _extends({}, other, {
    cx: x3,
    cy: y3,
    r: 5,
    fill: (theme.vars || theme).palette.background.paper,
    stroke: color3,
    strokeWidth: 2,
    className: classes.root,
    onClick,
    cursor: onClick ? "pointer" : "unset"
  }, interactionProps));
}
true ? CircleMarkElement.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  classes: import_prop_types59.default.object,
  /**
   * The index to the element in the series' data array.
   */
  dataIndex: import_prop_types59.default.number.isRequired,
  id: import_prop_types59.default.oneOfType([import_prop_types59.default.number, import_prop_types59.default.string]).isRequired,
  /**
   * The shape of the marker.
   */
  shape: import_prop_types59.default.oneOf(["circle", "cross", "diamond", "square", "star", "triangle", "wye"]).isRequired,
  /**
   * If `true`, animations are skipped.
   * @default false
   */
  skipAnimation: import_prop_types59.default.bool
} : void 0;

// node_modules/@mui/x-charts/esm/LineChart/MarkElement.js
var React114 = __toESM(require_react(), 1);
var import_prop_types60 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/internals/getSymbol.js
function getSymbol(shape2) {
  switch (shape2) {
    case "circle":
      return 0;
    case "cross":
      return 1;
    case "diamond":
      return 2;
    case "square":
      return 3;
    case "star":
      return 4;
    case "triangle":
      return 5;
    case "wye":
      return 6;
    default:
      return 0;
  }
}

// node_modules/@mui/x-charts/esm/LineChart/MarkElement.js
var import_jsx_runtime76 = __toESM(require_jsx_runtime(), 1);
var _excluded38 = ["x", "y", "id", "classes", "color", "shape", "dataIndex", "onClick", "skipAnimation", "isFaded", "isHighlighted"];
var MarkElementPath = styled_default2("path", {
  name: "MuiMarkElement",
  slot: "Root"
})(({
  ownerState,
  theme
}) => ({
  fill: (theme.vars || theme).palette.background.paper,
  stroke: ownerState.color,
  strokeWidth: 2,
  [`&.${markElementClasses.animate}`]: {
    transitionDuration: `${ANIMATION_DURATION_MS}ms`,
    transitionProperty: "transform, transform-origin",
    transitionTimingFunction: ANIMATION_TIMING_FUNCTION
  }
}));
function MarkElement(props) {
  const {
    x: x3,
    y: y3,
    id,
    classes: innerClasses,
    color: color3,
    shape: shape2,
    dataIndex,
    onClick,
    skipAnimation,
    isFaded = false,
    isHighlighted = false
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded38);
  const interactionProps = useInteractionItemProps({
    type: "line",
    seriesId: id,
    dataIndex
  });
  const ownerState = {
    id,
    classes: innerClasses,
    isHighlighted,
    isFaded,
    color: color3,
    skipAnimation
  };
  const classes = useUtilityClasses19(ownerState);
  return (0, import_jsx_runtime76.jsx)(MarkElementPath, _extends({}, other, {
    style: {
      transform: `translate(${x3}px, ${y3}px)`,
      transformOrigin: `${x3}px ${y3}px`
    },
    ownerState,
    className: classes.root,
    d: Symbol2(symbolsFill[getSymbol(shape2)])(),
    onClick,
    cursor: onClick ? "pointer" : "unset"
  }, interactionProps));
}
true ? MarkElement.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  classes: import_prop_types60.default.object,
  /**
   * The index to the element in the series' data array.
   */
  dataIndex: import_prop_types60.default.number.isRequired,
  id: import_prop_types60.default.oneOfType([import_prop_types60.default.number, import_prop_types60.default.string]).isRequired,
  /**
   * If `true`, the marker is faded.
   * @default false
   */
  isFaded: import_prop_types60.default.bool,
  /**
   * If `true`, the marker is highlighted.
   * @default false
   */
  isHighlighted: import_prop_types60.default.bool,
  /**
   * The shape of the marker.
   */
  shape: import_prop_types60.default.oneOf(["circle", "cross", "diamond", "square", "star", "triangle", "wye"]).isRequired,
  /**
   * If `true`, animations are skipped.
   */
  skipAnimation: import_prop_types60.default.bool
} : void 0;

// node_modules/@mui/x-charts/esm/LineChart/MarkPlot.js
var import_jsx_runtime77 = __toESM(require_jsx_runtime(), 1);
var _excluded39 = ["slots", "slotProps", "skipAnimation", "onItemClick"];
function MarkPlot(props) {
  const {
    slots,
    slotProps,
    skipAnimation: inSkipAnimation,
    onItemClick
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded39);
  const isZoomInteracting = useInternalIsZoomInteracting();
  const skipAnimation = useSkipAnimation(isZoomInteracting || inSkipAnimation);
  const seriesData = useLineSeriesContext();
  const {
    xAxis,
    xAxisIds
  } = useXAxes();
  const {
    yAxis,
    yAxisIds
  } = useYAxes();
  const chartId = useChartId2();
  const {
    instance,
    store
  } = useChartContext();
  const {
    isFaded,
    isHighlighted
  } = useItemHighlightedGetter();
  const xAxisInteractionIndex = useSelector(store, selectorChartsInteractionXAxisIndex);
  if (seriesData === void 0) {
    return null;
  }
  const {
    series,
    stackingGroups
  } = seriesData;
  const defaultXAxisId = xAxisIds[0];
  const defaultYAxisId = yAxisIds[0];
  return (0, import_jsx_runtime77.jsx)("g", _extends({}, other, {
    children: stackingGroups.flatMap(({
      ids: groupIds
    }) => {
      return groupIds.map((seriesId) => {
        const {
          xAxisId = defaultXAxisId,
          yAxisId = defaultYAxisId,
          stackedData,
          data,
          showMark = true,
          shape: shape2 = "circle"
        } = series[seriesId];
        if (showMark === false) {
          return null;
        }
        const xScale = getValueToPositionMapper(xAxis[xAxisId].scale);
        const yScale = yAxis[yAxisId].scale;
        const xData = xAxis[xAxisId].data;
        if (xData === void 0) {
          throw new Error(`MUI X Charts: ${xAxisId === DEFAULT_X_AXIS_KEY ? "The first `xAxis`" : `The x-axis with id "${xAxisId}"`} should have data property to be able to display a line plot.`);
        }
        const clipId = cleanId(`${chartId}-${seriesId}-line-clip`);
        const colorGetter = getColor_default3(series[seriesId], xAxis[xAxisId], yAxis[yAxisId]);
        const Mark = (slots == null ? void 0 : slots.mark) ?? (shape2 === "circle" ? CircleMarkElement : MarkElement);
        const isSeriesHighlighted = isHighlighted({
          seriesId
        });
        const isSeriesFaded = !isSeriesHighlighted && isFaded({
          seriesId
        });
        return (0, import_jsx_runtime77.jsx)("g", {
          clipPath: `url(#${clipId})`,
          children: xData == null ? void 0 : xData.map((x3, index2) => {
            const value = data[index2] == null ? null : stackedData[index2][1];
            return {
              x: xScale(x3),
              y: value === null ? null : yScale(value),
              position: x3,
              value,
              index: index2
            };
          }).filter(({
            x: x3,
            y: y3,
            index: index2,
            position: position3,
            value
          }) => {
            if (value === null || y3 === null) {
              return false;
            }
            if (!instance.isPointInside({
              x: x3,
              y: y3
            })) {
              return false;
            }
            if (showMark === true) {
              return true;
            }
            return showMark({
              x: x3,
              y: y3,
              index: index2,
              position: position3,
              value
            });
          }).map(({
            x: x3,
            y: y3,
            index: index2
          }) => {
            return (0, import_jsx_runtime77.jsx)(Mark, _extends({
              id: seriesId,
              dataIndex: index2,
              shape: shape2,
              color: colorGetter(index2),
              x: x3,
              y: y3,
              skipAnimation,
              onClick: onItemClick && ((event) => onItemClick(event, {
                type: "line",
                seriesId,
                dataIndex: index2
              })),
              isHighlighted: xAxisInteractionIndex === index2 || isSeriesHighlighted,
              isFaded: isSeriesFaded
            }, slotProps == null ? void 0 : slotProps.mark), `${seriesId}-${index2}`);
          })
        }, seriesId);
      });
    })
  }));
}
true ? MarkPlot.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Callback fired when a line mark item is clicked.
   * @param {React.MouseEvent<SVGPathElement, MouseEvent>} event The event source of the callback.
   * @param {LineItemIdentifier} lineItemIdentifier The line mark item identifier.
   */
  onItemClick: import_prop_types61.default.func,
  /**
   * If `true`, animations are skipped.
   */
  skipAnimation: import_prop_types61.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types61.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types61.default.object
} : void 0;

// node_modules/@mui/x-charts/esm/LineChart/LineHighlightPlot.js
var React118 = __toESM(require_react(), 1);
var import_prop_types63 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/LineChart/LineHighlightElement.js
var React117 = __toESM(require_react(), 1);
var import_prop_types62 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-internals/esm/reactMajor/index.js
var React116 = __toESM(require_react());
var reactMajor_default = parseInt(React116.version, 10);

// node_modules/@mui/x-charts/esm/LineChart/LineHighlightElement.js
var import_jsx_runtime78 = __toESM(require_jsx_runtime(), 1);
var _excluded40 = ["x", "y", "id", "classes", "color", "shape"];
function getHighlightElementUtilityClass(slot) {
  return generateUtilityClass("MuiHighlightElement", slot);
}
var lineHighlightElementClasses = generateUtilityClasses("MuiHighlightElement", ["root"]);
var useUtilityClasses20 = (ownerState) => {
  const {
    classes,
    id
  } = ownerState;
  const slots = {
    root: ["root", `series-${id}`]
  };
  return composeClasses(slots, getHighlightElementUtilityClass, classes);
};
function LineHighlightElement(props) {
  const {
    x: x3,
    y: y3,
    color: color3,
    shape: shape2
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded40);
  const classes = useUtilityClasses20(props);
  const Element2 = shape2 === "circle" ? "circle" : "path";
  const additionalProps = shape2 === "circle" ? {
    cx: 0,
    cy: 0,
    r: other.r === void 0 ? 5 : other.r
  } : {
    d: Symbol2(symbolsFill[getSymbol(shape2)])()
  };
  const transformOrigin = reactMajor_default > 18 ? {
    transformOrigin: `${x3} ${y3}`
  } : {
    "transform-origin": `${x3} ${y3}`
  };
  return (0, import_jsx_runtime78.jsx)(Element2, _extends({
    pointerEvents: "none",
    className: classes.root,
    transform: `translate(${x3} ${y3})`,
    fill: color3
  }, transformOrigin, additionalProps, other));
}
true ? LineHighlightElement.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  classes: import_prop_types62.default.object,
  id: import_prop_types62.default.oneOfType([import_prop_types62.default.number, import_prop_types62.default.string]).isRequired,
  shape: import_prop_types62.default.oneOf(["circle", "cross", "diamond", "square", "star", "triangle", "wye"]).isRequired
} : void 0;

// node_modules/@mui/x-charts/esm/LineChart/LineHighlightPlot.js
var import_jsx_runtime79 = __toESM(require_jsx_runtime(), 1);
var _excluded41 = ["slots", "slotProps"];
function LineHighlightPlot(props) {
  const {
    slots,
    slotProps
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded41);
  const seriesData = useLineSeriesContext();
  const {
    xAxis,
    xAxisIds
  } = useXAxes();
  const {
    yAxis,
    yAxisIds
  } = useYAxes();
  const {
    instance
  } = useChartContext();
  const store = useStore();
  const highlightedIndex = useSelector(store, selectorChartsInteractionXAxisIndex);
  if (highlightedIndex === null) {
    return null;
  }
  if (seriesData === void 0) {
    return null;
  }
  const {
    series,
    stackingGroups
  } = seriesData;
  const defaultXAxisId = xAxisIds[0];
  const defaultYAxisId = yAxisIds[0];
  const Element2 = (slots == null ? void 0 : slots.lineHighlight) ?? LineHighlightElement;
  return (0, import_jsx_runtime79.jsx)("g", _extends({}, other, {
    children: stackingGroups.flatMap(({
      ids: groupIds
    }) => {
      return groupIds.flatMap((seriesId) => {
        const {
          xAxisId = defaultXAxisId,
          yAxisId = defaultYAxisId,
          stackedData,
          data,
          disableHighlight,
          shape: shape2 = "circle"
        } = series[seriesId];
        if (disableHighlight || data[highlightedIndex] == null) {
          return null;
        }
        const xScale = getValueToPositionMapper(xAxis[xAxisId].scale);
        const yScale = yAxis[yAxisId].scale;
        const xData = xAxis[xAxisId].data;
        if (xData === void 0) {
          throw new Error(`MUI X Charts: ${xAxisId === DEFAULT_X_AXIS_KEY ? "The first `xAxis`" : `The x-axis with id "${xAxisId}"`} should have data property to be able to display a line plot.`);
        }
        const x3 = xScale(xData[highlightedIndex]);
        const y3 = yScale(stackedData[highlightedIndex][1]);
        if (!instance.isPointInside({
          x: x3,
          y: y3
        })) {
          return null;
        }
        const colorGetter = getColor_default3(series[seriesId], xAxis[xAxisId], yAxis[yAxisId]);
        return (0, import_jsx_runtime79.jsx)(Element2, _extends({
          id: seriesId,
          color: colorGetter(highlightedIndex),
          x: x3,
          y: y3,
          shape: shape2
        }, slotProps == null ? void 0 : slotProps.lineHighlight), `${seriesId}`);
      });
    })
  }));
}
true ? LineHighlightPlot.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types63.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types63.default.object
} : void 0;

// node_modules/@mui/x-charts/esm/LineChart/useLineChartProps.js
var React119 = __toESM(require_react(), 1);

// node_modules/@mui/x-charts/esm/LineChart/LineChart.plugins.js
var LINE_CHART_PLUGINS = [useChartZAxis, useChartCartesianAxis, useChartInteraction, useChartHighlight];

// node_modules/@mui/x-charts/esm/LineChart/useLineChartProps.js
var _excluded42 = ["xAxis", "yAxis", "series", "width", "height", "margin", "colors", "dataset", "sx", "onAreaClick", "onLineClick", "onMarkClick", "axisHighlight", "disableLineItemHighlight", "hideLegend", "grid", "children", "slots", "slotProps", "skipAnimation", "loading", "highlightedItem", "onHighlightChange", "className"];
var useLineChartProps = (props) => {
  var _a, _b, _c, _d, _e2;
  const {
    xAxis,
    yAxis,
    series,
    width: width2,
    height: height2,
    margin: margin2,
    colors,
    dataset,
    sx,
    onAreaClick,
    onLineClick,
    onMarkClick,
    axisHighlight,
    disableLineItemHighlight,
    grid: grid2,
    children: children2,
    slots,
    slotProps,
    skipAnimation,
    loading,
    highlightedItem,
    onHighlightChange,
    className
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded42);
  const id = useId();
  const clipPathId = `${id}-clip-path`;
  const seriesWithDefault = React119.useMemo(() => series.map((s3) => _extends({
    disableHighlight: !!disableLineItemHighlight,
    type: "line"
  }, s3)), [disableLineItemHighlight, series]);
  const chartContainerProps = _extends({}, other, {
    series: seriesWithDefault,
    width: width2,
    height: height2,
    margin: margin2,
    colors,
    dataset,
    xAxis: xAxis ?? [{
      id: DEFAULT_X_AXIS_KEY,
      scaleType: "point",
      data: Array.from({
        length: Math.max(...series.map((s3) => (s3.data ?? dataset ?? []).length))
      }, (_2, index2) => index2)
    }],
    yAxis,
    highlightedItem,
    onHighlightChange,
    disableAxisListener: ((_a = slotProps == null ? void 0 : slotProps.tooltip) == null ? void 0 : _a.trigger) !== "axis" && (axisHighlight == null ? void 0 : axisHighlight.x) === "none" && (axisHighlight == null ? void 0 : axisHighlight.y) === "none",
    className,
    skipAnimation,
    plugins: LINE_CHART_PLUGINS
  });
  const gridProps = {
    vertical: grid2 == null ? void 0 : grid2.vertical,
    horizontal: grid2 == null ? void 0 : grid2.horizontal
  };
  const clipPathGroupProps = {
    clipPath: `url(#${clipPathId})`
  };
  const clipPathProps = {
    id: clipPathId
  };
  const areaPlotProps = {
    slots,
    slotProps,
    onItemClick: onAreaClick
  };
  const linePlotProps = {
    slots,
    slotProps,
    onItemClick: onLineClick
  };
  const markPlotProps = {
    slots,
    slotProps,
    onItemClick: onMarkClick,
    skipAnimation
  };
  const overlayProps = {
    slots,
    slotProps,
    loading
  };
  const chartsAxisProps = {
    slots,
    slotProps
  };
  const axisHighlightProps = _extends({
    x: "line"
  }, axisHighlight);
  const lineHighlightPlotProps = {
    slots,
    slotProps
  };
  const legendProps = {
    slots,
    slotProps
  };
  const chartsWrapperProps = {
    sx,
    legendPosition: (_c = (_b = props.slotProps) == null ? void 0 : _b.legend) == null ? void 0 : _c.position,
    legendDirection: (_e2 = (_d = props.slotProps) == null ? void 0 : _d.legend) == null ? void 0 : _e2.direction
  };
  return {
    chartsWrapperProps,
    chartContainerProps,
    gridProps,
    clipPathProps,
    clipPathGroupProps,
    areaPlotProps,
    linePlotProps,
    markPlotProps,
    overlayProps,
    chartsAxisProps,
    axisHighlightProps,
    lineHighlightPlotProps,
    legendProps,
    children: children2
  };
};

// node_modules/@mui/x-charts/esm/LineChart/LineChart.js
var import_jsx_runtime80 = __toESM(require_jsx_runtime(), 1);
var LineChart = React120.forwardRef(function LineChart2(inProps, ref) {
  var _a, _b;
  const props = useThemeProps2({
    props: inProps,
    name: "MuiLineChart"
  });
  const {
    chartsWrapperProps,
    chartContainerProps,
    gridProps,
    clipPathProps,
    clipPathGroupProps,
    areaPlotProps,
    linePlotProps,
    markPlotProps,
    overlayProps,
    chartsAxisProps,
    axisHighlightProps,
    lineHighlightPlotProps,
    legendProps,
    children: children2
  } = useLineChartProps(props);
  const {
    chartDataProviderProps,
    chartsSurfaceProps
  } = useChartContainerProps(chartContainerProps, ref);
  const Tooltip = ((_a = props.slots) == null ? void 0 : _a.tooltip) ?? ChartsTooltip;
  return (0, import_jsx_runtime80.jsx)(ChartDataProvider, _extends({}, chartDataProviderProps, {
    children: (0, import_jsx_runtime80.jsxs)(ChartsWrapper, _extends({}, chartsWrapperProps, {
      children: [!props.hideLegend && (0, import_jsx_runtime80.jsx)(ChartsLegend, _extends({}, legendProps)), (0, import_jsx_runtime80.jsxs)(ChartsSurface, _extends({}, chartsSurfaceProps, {
        children: [(0, import_jsx_runtime80.jsx)(ChartsGrid, _extends({}, gridProps)), (0, import_jsx_runtime80.jsxs)("g", _extends({}, clipPathGroupProps, {
          children: [(0, import_jsx_runtime80.jsx)(AreaPlot, _extends({}, areaPlotProps)), (0, import_jsx_runtime80.jsx)(LinePlot, _extends({}, linePlotProps)), (0, import_jsx_runtime80.jsx)(ChartsOverlay, _extends({}, overlayProps)), (0, import_jsx_runtime80.jsx)(ChartsAxisHighlight, _extends({}, axisHighlightProps))]
        })), (0, import_jsx_runtime80.jsx)(ChartsAxis, _extends({}, chartsAxisProps)), (0, import_jsx_runtime80.jsx)("g", {
          "data-drawing-container": true,
          children: (0, import_jsx_runtime80.jsx)(MarkPlot, _extends({}, markPlotProps))
        }), (0, import_jsx_runtime80.jsx)(LineHighlightPlot, _extends({}, lineHighlightPlotProps)), !props.loading && (0, import_jsx_runtime80.jsx)(Tooltip, _extends({}, (_b = props.slotProps) == null ? void 0 : _b.tooltip)), (0, import_jsx_runtime80.jsx)(ChartsClipPath, _extends({}, clipPathProps)), children2]
      }))]
    }))
  }));
});
true ? LineChart.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  apiRef: import_prop_types64.default.shape({
    current: import_prop_types64.default.object
  }),
  /**
   * The configuration of axes highlight.
   * @see See {@link https://mui.com/x/react-charts/highlighting/ highlighting docs} for more details.
   * @default { x: 'line' }
   */
  axisHighlight: import_prop_types64.default.shape({
    x: import_prop_types64.default.oneOf(["band", "line", "none"]),
    y: import_prop_types64.default.oneOf(["band", "line", "none"])
  }),
  children: import_prop_types64.default.node,
  className: import_prop_types64.default.string,
  /**
   * Color palette used to colorize multiple series.
   * @default rainbowSurgePalette
   */
  colors: import_prop_types64.default.oneOfType([import_prop_types64.default.arrayOf(import_prop_types64.default.string), import_prop_types64.default.func]),
  /**
   * An array of objects that can be used to populate series and axes data using their `dataKey` property.
   */
  dataset: import_prop_types64.default.arrayOf(import_prop_types64.default.object),
  desc: import_prop_types64.default.string,
  /**
   * If `true`, the charts will not listen to the mouse move event.
   * It might break interactive features, but will improve performance.
   * @default false
   */
  disableAxisListener: import_prop_types64.default.bool,
  /**
   * If `true`, render the line highlight item.
   */
  disableLineItemHighlight: import_prop_types64.default.bool,
  /**
   * Option to display a cartesian grid in the background.
   */
  grid: import_prop_types64.default.shape({
    horizontal: import_prop_types64.default.bool,
    vertical: import_prop_types64.default.bool
  }),
  /**
   * The height of the chart in px. If not defined, it takes the height of the parent element.
   */
  height: import_prop_types64.default.number,
  /**
   * If `true`, the legend is not rendered.
   */
  hideLegend: import_prop_types64.default.bool,
  /**
   * The highlighted item.
   * Used when the highlight is controlled.
   */
  highlightedItem: import_prop_types64.default.shape({
    dataIndex: import_prop_types64.default.number,
    seriesId: import_prop_types64.default.oneOfType([import_prop_types64.default.number, import_prop_types64.default.string]).isRequired
  }),
  /**
   * This prop is used to help implement the accessibility logic.
   * If you don't provide this prop. It falls back to a randomly generated id.
   */
  id: import_prop_types64.default.string,
  /**
   * If `true`, a loading overlay is displayed.
   * @default false
   */
  loading: import_prop_types64.default.bool,
  /**
   * Localized text for chart components.
   */
  localeText: import_prop_types64.default.object,
  /**
   * The margin between the SVG and the drawing area.
   * It's used for leaving some space for extra information such as the x- and y-axis or legend.
   *
   * Accepts a `number` to be used on all sides or an object with the optional properties: `top`, `bottom`, `left`, and `right`.
   */
  margin: import_prop_types64.default.oneOfType([import_prop_types64.default.number, import_prop_types64.default.shape({
    bottom: import_prop_types64.default.number,
    left: import_prop_types64.default.number,
    right: import_prop_types64.default.number,
    top: import_prop_types64.default.number
  })]),
  /**
   * Callback fired when an area element is clicked.
   */
  onAreaClick: import_prop_types64.default.func,
  /**
   * The function called for onClick events.
   * The second argument contains information about all line/bar elements at the current mouse position.
   * @param {MouseEvent} event The mouse event recorded on the `<svg/>` element.
   * @param {null | ChartsAxisData} data The data about the clicked axis and items associated with it.
   */
  onAxisClick: import_prop_types64.default.func,
  /**
   * The callback fired when the highlighted item changes.
   *
   * @param {HighlightItemData | null} highlightedItem  The newly highlighted item.
   */
  onHighlightChange: import_prop_types64.default.func,
  /**
   * Callback fired when a line element is clicked.
   */
  onLineClick: import_prop_types64.default.func,
  /**
   * Callback fired when a mark element is clicked.
   */
  onMarkClick: import_prop_types64.default.func,
  /**
   * The series to display in the line chart.
   * An array of [[LineSeriesType]] objects.
   */
  series: import_prop_types64.default.arrayOf(import_prop_types64.default.object).isRequired,
  /**
   * If `true`, animations are skipped.
   * @default false
   */
  skipAnimation: import_prop_types64.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types64.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types64.default.object,
  sx: import_prop_types64.default.oneOfType([import_prop_types64.default.arrayOf(import_prop_types64.default.oneOfType([import_prop_types64.default.func, import_prop_types64.default.object, import_prop_types64.default.bool])), import_prop_types64.default.func, import_prop_types64.default.object]),
  theme: import_prop_types64.default.oneOf(["dark", "light"]),
  title: import_prop_types64.default.string,
  /**
   * The width of the chart in px. If not defined, it takes the width of the parent element.
   */
  width: import_prop_types64.default.number,
  /**
   * The configuration of the x-axes.
   * If not provided, a default axis config is used.
   * An array of [[AxisConfig]] objects.
   */
  xAxis: import_prop_types64.default.arrayOf(import_prop_types64.default.oneOfType([import_prop_types64.default.shape({
    axis: import_prop_types64.default.oneOf(["x"]),
    barGapRatio: import_prop_types64.default.number,
    categoryGapRatio: import_prop_types64.default.number,
    classes: import_prop_types64.default.object,
    colorMap: import_prop_types64.default.oneOfType([import_prop_types64.default.shape({
      colors: import_prop_types64.default.arrayOf(import_prop_types64.default.string).isRequired,
      type: import_prop_types64.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types64.default.string,
      values: import_prop_types64.default.arrayOf(import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number, import_prop_types64.default.string]).isRequired)
    }), import_prop_types64.default.shape({
      color: import_prop_types64.default.oneOfType([import_prop_types64.default.arrayOf(import_prop_types64.default.string.isRequired), import_prop_types64.default.func]).isRequired,
      max: import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]),
      min: import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]),
      type: import_prop_types64.default.oneOf(["continuous"]).isRequired
    }), import_prop_types64.default.shape({
      colors: import_prop_types64.default.arrayOf(import_prop_types64.default.string).isRequired,
      thresholds: import_prop_types64.default.arrayOf(import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]).isRequired).isRequired,
      type: import_prop_types64.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types64.default.array,
    dataKey: import_prop_types64.default.string,
    disableLine: import_prop_types64.default.bool,
    disableTicks: import_prop_types64.default.bool,
    domainLimit: import_prop_types64.default.oneOfType([import_prop_types64.default.oneOf(["nice", "strict"]), import_prop_types64.default.func]),
    fill: import_prop_types64.default.string,
    height: import_prop_types64.default.number,
    hideTooltip: import_prop_types64.default.bool,
    id: import_prop_types64.default.oneOfType([import_prop_types64.default.number, import_prop_types64.default.string]),
    ignoreTooltip: import_prop_types64.default.bool,
    label: import_prop_types64.default.string,
    labelStyle: import_prop_types64.default.object,
    max: import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]),
    min: import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]),
    offset: import_prop_types64.default.number,
    position: import_prop_types64.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types64.default.bool,
    scaleType: import_prop_types64.default.oneOf(["band"]),
    slotProps: import_prop_types64.default.object,
    slots: import_prop_types64.default.object,
    stroke: import_prop_types64.default.string,
    sx: import_prop_types64.default.oneOfType([import_prop_types64.default.arrayOf(import_prop_types64.default.oneOfType([import_prop_types64.default.func, import_prop_types64.default.object, import_prop_types64.default.bool])), import_prop_types64.default.func, import_prop_types64.default.object]),
    tickInterval: import_prop_types64.default.oneOfType([import_prop_types64.default.oneOf(["auto"]), import_prop_types64.default.array, import_prop_types64.default.func]),
    tickLabelInterval: import_prop_types64.default.oneOfType([import_prop_types64.default.oneOf(["auto"]), import_prop_types64.default.func]),
    tickLabelMinGap: import_prop_types64.default.number,
    tickLabelPlacement: import_prop_types64.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types64.default.object,
    tickMaxStep: import_prop_types64.default.number,
    tickMinStep: import_prop_types64.default.number,
    tickNumber: import_prop_types64.default.number,
    tickPlacement: import_prop_types64.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types64.default.number,
    valueFormatter: import_prop_types64.default.func
  }), import_prop_types64.default.shape({
    axis: import_prop_types64.default.oneOf(["x"]),
    classes: import_prop_types64.default.object,
    colorMap: import_prop_types64.default.oneOfType([import_prop_types64.default.shape({
      colors: import_prop_types64.default.arrayOf(import_prop_types64.default.string).isRequired,
      type: import_prop_types64.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types64.default.string,
      values: import_prop_types64.default.arrayOf(import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number, import_prop_types64.default.string]).isRequired)
    }), import_prop_types64.default.shape({
      color: import_prop_types64.default.oneOfType([import_prop_types64.default.arrayOf(import_prop_types64.default.string.isRequired), import_prop_types64.default.func]).isRequired,
      max: import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]),
      min: import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]),
      type: import_prop_types64.default.oneOf(["continuous"]).isRequired
    }), import_prop_types64.default.shape({
      colors: import_prop_types64.default.arrayOf(import_prop_types64.default.string).isRequired,
      thresholds: import_prop_types64.default.arrayOf(import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]).isRequired).isRequired,
      type: import_prop_types64.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types64.default.array,
    dataKey: import_prop_types64.default.string,
    disableLine: import_prop_types64.default.bool,
    disableTicks: import_prop_types64.default.bool,
    domainLimit: import_prop_types64.default.oneOfType([import_prop_types64.default.oneOf(["nice", "strict"]), import_prop_types64.default.func]),
    fill: import_prop_types64.default.string,
    height: import_prop_types64.default.number,
    hideTooltip: import_prop_types64.default.bool,
    id: import_prop_types64.default.oneOfType([import_prop_types64.default.number, import_prop_types64.default.string]),
    ignoreTooltip: import_prop_types64.default.bool,
    label: import_prop_types64.default.string,
    labelStyle: import_prop_types64.default.object,
    max: import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]),
    min: import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]),
    offset: import_prop_types64.default.number,
    position: import_prop_types64.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types64.default.bool,
    scaleType: import_prop_types64.default.oneOf(["point"]),
    slotProps: import_prop_types64.default.object,
    slots: import_prop_types64.default.object,
    stroke: import_prop_types64.default.string,
    sx: import_prop_types64.default.oneOfType([import_prop_types64.default.arrayOf(import_prop_types64.default.oneOfType([import_prop_types64.default.func, import_prop_types64.default.object, import_prop_types64.default.bool])), import_prop_types64.default.func, import_prop_types64.default.object]),
    tickInterval: import_prop_types64.default.oneOfType([import_prop_types64.default.oneOf(["auto"]), import_prop_types64.default.array, import_prop_types64.default.func]),
    tickLabelInterval: import_prop_types64.default.oneOfType([import_prop_types64.default.oneOf(["auto"]), import_prop_types64.default.func]),
    tickLabelMinGap: import_prop_types64.default.number,
    tickLabelPlacement: import_prop_types64.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types64.default.object,
    tickMaxStep: import_prop_types64.default.number,
    tickMinStep: import_prop_types64.default.number,
    tickNumber: import_prop_types64.default.number,
    tickPlacement: import_prop_types64.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types64.default.number,
    valueFormatter: import_prop_types64.default.func
  }), import_prop_types64.default.shape({
    axis: import_prop_types64.default.oneOf(["x"]),
    classes: import_prop_types64.default.object,
    colorMap: import_prop_types64.default.oneOfType([import_prop_types64.default.shape({
      color: import_prop_types64.default.oneOfType([import_prop_types64.default.arrayOf(import_prop_types64.default.string.isRequired), import_prop_types64.default.func]).isRequired,
      max: import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]),
      min: import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]),
      type: import_prop_types64.default.oneOf(["continuous"]).isRequired
    }), import_prop_types64.default.shape({
      colors: import_prop_types64.default.arrayOf(import_prop_types64.default.string).isRequired,
      thresholds: import_prop_types64.default.arrayOf(import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]).isRequired).isRequired,
      type: import_prop_types64.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types64.default.array,
    dataKey: import_prop_types64.default.string,
    disableLine: import_prop_types64.default.bool,
    disableTicks: import_prop_types64.default.bool,
    domainLimit: import_prop_types64.default.oneOfType([import_prop_types64.default.oneOf(["nice", "strict"]), import_prop_types64.default.func]),
    fill: import_prop_types64.default.string,
    height: import_prop_types64.default.number,
    hideTooltip: import_prop_types64.default.bool,
    id: import_prop_types64.default.oneOfType([import_prop_types64.default.number, import_prop_types64.default.string]),
    ignoreTooltip: import_prop_types64.default.bool,
    label: import_prop_types64.default.string,
    labelStyle: import_prop_types64.default.object,
    max: import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]),
    min: import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]),
    offset: import_prop_types64.default.number,
    position: import_prop_types64.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types64.default.bool,
    scaleType: import_prop_types64.default.oneOf(["log"]),
    slotProps: import_prop_types64.default.object,
    slots: import_prop_types64.default.object,
    stroke: import_prop_types64.default.string,
    sx: import_prop_types64.default.oneOfType([import_prop_types64.default.arrayOf(import_prop_types64.default.oneOfType([import_prop_types64.default.func, import_prop_types64.default.object, import_prop_types64.default.bool])), import_prop_types64.default.func, import_prop_types64.default.object]),
    tickInterval: import_prop_types64.default.oneOfType([import_prop_types64.default.oneOf(["auto"]), import_prop_types64.default.array, import_prop_types64.default.func]),
    tickLabelInterval: import_prop_types64.default.oneOfType([import_prop_types64.default.oneOf(["auto"]), import_prop_types64.default.func]),
    tickLabelMinGap: import_prop_types64.default.number,
    tickLabelPlacement: import_prop_types64.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types64.default.object,
    tickMaxStep: import_prop_types64.default.number,
    tickMinStep: import_prop_types64.default.number,
    tickNumber: import_prop_types64.default.number,
    tickPlacement: import_prop_types64.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types64.default.number,
    valueFormatter: import_prop_types64.default.func
  }), import_prop_types64.default.shape({
    axis: import_prop_types64.default.oneOf(["x"]),
    classes: import_prop_types64.default.object,
    colorMap: import_prop_types64.default.oneOfType([import_prop_types64.default.shape({
      color: import_prop_types64.default.oneOfType([import_prop_types64.default.arrayOf(import_prop_types64.default.string.isRequired), import_prop_types64.default.func]).isRequired,
      max: import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]),
      min: import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]),
      type: import_prop_types64.default.oneOf(["continuous"]).isRequired
    }), import_prop_types64.default.shape({
      colors: import_prop_types64.default.arrayOf(import_prop_types64.default.string).isRequired,
      thresholds: import_prop_types64.default.arrayOf(import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]).isRequired).isRequired,
      type: import_prop_types64.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types64.default.array,
    dataKey: import_prop_types64.default.string,
    disableLine: import_prop_types64.default.bool,
    disableTicks: import_prop_types64.default.bool,
    domainLimit: import_prop_types64.default.oneOfType([import_prop_types64.default.oneOf(["nice", "strict"]), import_prop_types64.default.func]),
    fill: import_prop_types64.default.string,
    height: import_prop_types64.default.number,
    hideTooltip: import_prop_types64.default.bool,
    id: import_prop_types64.default.oneOfType([import_prop_types64.default.number, import_prop_types64.default.string]),
    ignoreTooltip: import_prop_types64.default.bool,
    label: import_prop_types64.default.string,
    labelStyle: import_prop_types64.default.object,
    max: import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]),
    min: import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]),
    offset: import_prop_types64.default.number,
    position: import_prop_types64.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types64.default.bool,
    scaleType: import_prop_types64.default.oneOf(["pow"]),
    slotProps: import_prop_types64.default.object,
    slots: import_prop_types64.default.object,
    stroke: import_prop_types64.default.string,
    sx: import_prop_types64.default.oneOfType([import_prop_types64.default.arrayOf(import_prop_types64.default.oneOfType([import_prop_types64.default.func, import_prop_types64.default.object, import_prop_types64.default.bool])), import_prop_types64.default.func, import_prop_types64.default.object]),
    tickInterval: import_prop_types64.default.oneOfType([import_prop_types64.default.oneOf(["auto"]), import_prop_types64.default.array, import_prop_types64.default.func]),
    tickLabelInterval: import_prop_types64.default.oneOfType([import_prop_types64.default.oneOf(["auto"]), import_prop_types64.default.func]),
    tickLabelMinGap: import_prop_types64.default.number,
    tickLabelPlacement: import_prop_types64.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types64.default.object,
    tickMaxStep: import_prop_types64.default.number,
    tickMinStep: import_prop_types64.default.number,
    tickNumber: import_prop_types64.default.number,
    tickPlacement: import_prop_types64.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types64.default.number,
    valueFormatter: import_prop_types64.default.func
  }), import_prop_types64.default.shape({
    axis: import_prop_types64.default.oneOf(["x"]),
    classes: import_prop_types64.default.object,
    colorMap: import_prop_types64.default.oneOfType([import_prop_types64.default.shape({
      color: import_prop_types64.default.oneOfType([import_prop_types64.default.arrayOf(import_prop_types64.default.string.isRequired), import_prop_types64.default.func]).isRequired,
      max: import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]),
      min: import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]),
      type: import_prop_types64.default.oneOf(["continuous"]).isRequired
    }), import_prop_types64.default.shape({
      colors: import_prop_types64.default.arrayOf(import_prop_types64.default.string).isRequired,
      thresholds: import_prop_types64.default.arrayOf(import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]).isRequired).isRequired,
      type: import_prop_types64.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types64.default.array,
    dataKey: import_prop_types64.default.string,
    disableLine: import_prop_types64.default.bool,
    disableTicks: import_prop_types64.default.bool,
    domainLimit: import_prop_types64.default.oneOfType([import_prop_types64.default.oneOf(["nice", "strict"]), import_prop_types64.default.func]),
    fill: import_prop_types64.default.string,
    height: import_prop_types64.default.number,
    hideTooltip: import_prop_types64.default.bool,
    id: import_prop_types64.default.oneOfType([import_prop_types64.default.number, import_prop_types64.default.string]),
    ignoreTooltip: import_prop_types64.default.bool,
    label: import_prop_types64.default.string,
    labelStyle: import_prop_types64.default.object,
    max: import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]),
    min: import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]),
    offset: import_prop_types64.default.number,
    position: import_prop_types64.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types64.default.bool,
    scaleType: import_prop_types64.default.oneOf(["sqrt"]),
    slotProps: import_prop_types64.default.object,
    slots: import_prop_types64.default.object,
    stroke: import_prop_types64.default.string,
    sx: import_prop_types64.default.oneOfType([import_prop_types64.default.arrayOf(import_prop_types64.default.oneOfType([import_prop_types64.default.func, import_prop_types64.default.object, import_prop_types64.default.bool])), import_prop_types64.default.func, import_prop_types64.default.object]),
    tickInterval: import_prop_types64.default.oneOfType([import_prop_types64.default.oneOf(["auto"]), import_prop_types64.default.array, import_prop_types64.default.func]),
    tickLabelInterval: import_prop_types64.default.oneOfType([import_prop_types64.default.oneOf(["auto"]), import_prop_types64.default.func]),
    tickLabelMinGap: import_prop_types64.default.number,
    tickLabelPlacement: import_prop_types64.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types64.default.object,
    tickMaxStep: import_prop_types64.default.number,
    tickMinStep: import_prop_types64.default.number,
    tickNumber: import_prop_types64.default.number,
    tickPlacement: import_prop_types64.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types64.default.number,
    valueFormatter: import_prop_types64.default.func
  }), import_prop_types64.default.shape({
    axis: import_prop_types64.default.oneOf(["x"]),
    classes: import_prop_types64.default.object,
    colorMap: import_prop_types64.default.oneOfType([import_prop_types64.default.shape({
      color: import_prop_types64.default.oneOfType([import_prop_types64.default.arrayOf(import_prop_types64.default.string.isRequired), import_prop_types64.default.func]).isRequired,
      max: import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]),
      min: import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]),
      type: import_prop_types64.default.oneOf(["continuous"]).isRequired
    }), import_prop_types64.default.shape({
      colors: import_prop_types64.default.arrayOf(import_prop_types64.default.string).isRequired,
      thresholds: import_prop_types64.default.arrayOf(import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]).isRequired).isRequired,
      type: import_prop_types64.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types64.default.array,
    dataKey: import_prop_types64.default.string,
    disableLine: import_prop_types64.default.bool,
    disableTicks: import_prop_types64.default.bool,
    domainLimit: import_prop_types64.default.oneOfType([import_prop_types64.default.oneOf(["nice", "strict"]), import_prop_types64.default.func]),
    fill: import_prop_types64.default.string,
    height: import_prop_types64.default.number,
    hideTooltip: import_prop_types64.default.bool,
    id: import_prop_types64.default.oneOfType([import_prop_types64.default.number, import_prop_types64.default.string]),
    ignoreTooltip: import_prop_types64.default.bool,
    label: import_prop_types64.default.string,
    labelStyle: import_prop_types64.default.object,
    max: import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]),
    min: import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]),
    offset: import_prop_types64.default.number,
    position: import_prop_types64.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types64.default.bool,
    scaleType: import_prop_types64.default.oneOf(["time"]),
    slotProps: import_prop_types64.default.object,
    slots: import_prop_types64.default.object,
    stroke: import_prop_types64.default.string,
    sx: import_prop_types64.default.oneOfType([import_prop_types64.default.arrayOf(import_prop_types64.default.oneOfType([import_prop_types64.default.func, import_prop_types64.default.object, import_prop_types64.default.bool])), import_prop_types64.default.func, import_prop_types64.default.object]),
    tickInterval: import_prop_types64.default.oneOfType([import_prop_types64.default.oneOf(["auto"]), import_prop_types64.default.array, import_prop_types64.default.func]),
    tickLabelInterval: import_prop_types64.default.oneOfType([import_prop_types64.default.oneOf(["auto"]), import_prop_types64.default.func]),
    tickLabelMinGap: import_prop_types64.default.number,
    tickLabelPlacement: import_prop_types64.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types64.default.object,
    tickMaxStep: import_prop_types64.default.number,
    tickMinStep: import_prop_types64.default.number,
    tickNumber: import_prop_types64.default.number,
    tickPlacement: import_prop_types64.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types64.default.number,
    valueFormatter: import_prop_types64.default.func
  }), import_prop_types64.default.shape({
    axis: import_prop_types64.default.oneOf(["x"]),
    classes: import_prop_types64.default.object,
    colorMap: import_prop_types64.default.oneOfType([import_prop_types64.default.shape({
      color: import_prop_types64.default.oneOfType([import_prop_types64.default.arrayOf(import_prop_types64.default.string.isRequired), import_prop_types64.default.func]).isRequired,
      max: import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]),
      min: import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]),
      type: import_prop_types64.default.oneOf(["continuous"]).isRequired
    }), import_prop_types64.default.shape({
      colors: import_prop_types64.default.arrayOf(import_prop_types64.default.string).isRequired,
      thresholds: import_prop_types64.default.arrayOf(import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]).isRequired).isRequired,
      type: import_prop_types64.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types64.default.array,
    dataKey: import_prop_types64.default.string,
    disableLine: import_prop_types64.default.bool,
    disableTicks: import_prop_types64.default.bool,
    domainLimit: import_prop_types64.default.oneOfType([import_prop_types64.default.oneOf(["nice", "strict"]), import_prop_types64.default.func]),
    fill: import_prop_types64.default.string,
    height: import_prop_types64.default.number,
    hideTooltip: import_prop_types64.default.bool,
    id: import_prop_types64.default.oneOfType([import_prop_types64.default.number, import_prop_types64.default.string]),
    ignoreTooltip: import_prop_types64.default.bool,
    label: import_prop_types64.default.string,
    labelStyle: import_prop_types64.default.object,
    max: import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]),
    min: import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]),
    offset: import_prop_types64.default.number,
    position: import_prop_types64.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types64.default.bool,
    scaleType: import_prop_types64.default.oneOf(["utc"]),
    slotProps: import_prop_types64.default.object,
    slots: import_prop_types64.default.object,
    stroke: import_prop_types64.default.string,
    sx: import_prop_types64.default.oneOfType([import_prop_types64.default.arrayOf(import_prop_types64.default.oneOfType([import_prop_types64.default.func, import_prop_types64.default.object, import_prop_types64.default.bool])), import_prop_types64.default.func, import_prop_types64.default.object]),
    tickInterval: import_prop_types64.default.oneOfType([import_prop_types64.default.oneOf(["auto"]), import_prop_types64.default.array, import_prop_types64.default.func]),
    tickLabelInterval: import_prop_types64.default.oneOfType([import_prop_types64.default.oneOf(["auto"]), import_prop_types64.default.func]),
    tickLabelMinGap: import_prop_types64.default.number,
    tickLabelPlacement: import_prop_types64.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types64.default.object,
    tickMaxStep: import_prop_types64.default.number,
    tickMinStep: import_prop_types64.default.number,
    tickNumber: import_prop_types64.default.number,
    tickPlacement: import_prop_types64.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types64.default.number,
    valueFormatter: import_prop_types64.default.func
  }), import_prop_types64.default.shape({
    axis: import_prop_types64.default.oneOf(["x"]),
    classes: import_prop_types64.default.object,
    colorMap: import_prop_types64.default.oneOfType([import_prop_types64.default.shape({
      color: import_prop_types64.default.oneOfType([import_prop_types64.default.arrayOf(import_prop_types64.default.string.isRequired), import_prop_types64.default.func]).isRequired,
      max: import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]),
      min: import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]),
      type: import_prop_types64.default.oneOf(["continuous"]).isRequired
    }), import_prop_types64.default.shape({
      colors: import_prop_types64.default.arrayOf(import_prop_types64.default.string).isRequired,
      thresholds: import_prop_types64.default.arrayOf(import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]).isRequired).isRequired,
      type: import_prop_types64.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types64.default.array,
    dataKey: import_prop_types64.default.string,
    disableLine: import_prop_types64.default.bool,
    disableTicks: import_prop_types64.default.bool,
    domainLimit: import_prop_types64.default.oneOfType([import_prop_types64.default.oneOf(["nice", "strict"]), import_prop_types64.default.func]),
    fill: import_prop_types64.default.string,
    height: import_prop_types64.default.number,
    hideTooltip: import_prop_types64.default.bool,
    id: import_prop_types64.default.oneOfType([import_prop_types64.default.number, import_prop_types64.default.string]),
    ignoreTooltip: import_prop_types64.default.bool,
    label: import_prop_types64.default.string,
    labelStyle: import_prop_types64.default.object,
    max: import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]),
    min: import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]),
    offset: import_prop_types64.default.number,
    position: import_prop_types64.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types64.default.bool,
    scaleType: import_prop_types64.default.oneOf(["linear"]),
    slotProps: import_prop_types64.default.object,
    slots: import_prop_types64.default.object,
    stroke: import_prop_types64.default.string,
    sx: import_prop_types64.default.oneOfType([import_prop_types64.default.arrayOf(import_prop_types64.default.oneOfType([import_prop_types64.default.func, import_prop_types64.default.object, import_prop_types64.default.bool])), import_prop_types64.default.func, import_prop_types64.default.object]),
    tickInterval: import_prop_types64.default.oneOfType([import_prop_types64.default.oneOf(["auto"]), import_prop_types64.default.array, import_prop_types64.default.func]),
    tickLabelInterval: import_prop_types64.default.oneOfType([import_prop_types64.default.oneOf(["auto"]), import_prop_types64.default.func]),
    tickLabelMinGap: import_prop_types64.default.number,
    tickLabelPlacement: import_prop_types64.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types64.default.object,
    tickMaxStep: import_prop_types64.default.number,
    tickMinStep: import_prop_types64.default.number,
    tickNumber: import_prop_types64.default.number,
    tickPlacement: import_prop_types64.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types64.default.number,
    valueFormatter: import_prop_types64.default.func
  })]).isRequired),
  /**
   * The configuration of the y-axes.
   * If not provided, a default axis config is used.
   * An array of [[AxisConfig]] objects.
   */
  yAxis: import_prop_types64.default.arrayOf(import_prop_types64.default.oneOfType([import_prop_types64.default.shape({
    axis: import_prop_types64.default.oneOf(["y"]),
    barGapRatio: import_prop_types64.default.number,
    categoryGapRatio: import_prop_types64.default.number,
    classes: import_prop_types64.default.object,
    colorMap: import_prop_types64.default.oneOfType([import_prop_types64.default.shape({
      colors: import_prop_types64.default.arrayOf(import_prop_types64.default.string).isRequired,
      type: import_prop_types64.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types64.default.string,
      values: import_prop_types64.default.arrayOf(import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number, import_prop_types64.default.string]).isRequired)
    }), import_prop_types64.default.shape({
      color: import_prop_types64.default.oneOfType([import_prop_types64.default.arrayOf(import_prop_types64.default.string.isRequired), import_prop_types64.default.func]).isRequired,
      max: import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]),
      min: import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]),
      type: import_prop_types64.default.oneOf(["continuous"]).isRequired
    }), import_prop_types64.default.shape({
      colors: import_prop_types64.default.arrayOf(import_prop_types64.default.string).isRequired,
      thresholds: import_prop_types64.default.arrayOf(import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]).isRequired).isRequired,
      type: import_prop_types64.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types64.default.array,
    dataKey: import_prop_types64.default.string,
    disableLine: import_prop_types64.default.bool,
    disableTicks: import_prop_types64.default.bool,
    domainLimit: import_prop_types64.default.oneOfType([import_prop_types64.default.oneOf(["nice", "strict"]), import_prop_types64.default.func]),
    fill: import_prop_types64.default.string,
    hideTooltip: import_prop_types64.default.bool,
    id: import_prop_types64.default.oneOfType([import_prop_types64.default.number, import_prop_types64.default.string]),
    ignoreTooltip: import_prop_types64.default.bool,
    label: import_prop_types64.default.string,
    labelStyle: import_prop_types64.default.object,
    max: import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]),
    min: import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]),
    offset: import_prop_types64.default.number,
    position: import_prop_types64.default.oneOf(["left", "none", "right"]),
    reverse: import_prop_types64.default.bool,
    scaleType: import_prop_types64.default.oneOf(["band"]),
    slotProps: import_prop_types64.default.object,
    slots: import_prop_types64.default.object,
    stroke: import_prop_types64.default.string,
    sx: import_prop_types64.default.oneOfType([import_prop_types64.default.arrayOf(import_prop_types64.default.oneOfType([import_prop_types64.default.func, import_prop_types64.default.object, import_prop_types64.default.bool])), import_prop_types64.default.func, import_prop_types64.default.object]),
    tickInterval: import_prop_types64.default.oneOfType([import_prop_types64.default.oneOf(["auto"]), import_prop_types64.default.array, import_prop_types64.default.func]),
    tickLabelInterval: import_prop_types64.default.oneOfType([import_prop_types64.default.oneOf(["auto"]), import_prop_types64.default.func]),
    tickLabelPlacement: import_prop_types64.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types64.default.object,
    tickMaxStep: import_prop_types64.default.number,
    tickMinStep: import_prop_types64.default.number,
    tickNumber: import_prop_types64.default.number,
    tickPlacement: import_prop_types64.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types64.default.number,
    valueFormatter: import_prop_types64.default.func,
    width: import_prop_types64.default.number
  }), import_prop_types64.default.shape({
    axis: import_prop_types64.default.oneOf(["y"]),
    classes: import_prop_types64.default.object,
    colorMap: import_prop_types64.default.oneOfType([import_prop_types64.default.shape({
      colors: import_prop_types64.default.arrayOf(import_prop_types64.default.string).isRequired,
      type: import_prop_types64.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types64.default.string,
      values: import_prop_types64.default.arrayOf(import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number, import_prop_types64.default.string]).isRequired)
    }), import_prop_types64.default.shape({
      color: import_prop_types64.default.oneOfType([import_prop_types64.default.arrayOf(import_prop_types64.default.string.isRequired), import_prop_types64.default.func]).isRequired,
      max: import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]),
      min: import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]),
      type: import_prop_types64.default.oneOf(["continuous"]).isRequired
    }), import_prop_types64.default.shape({
      colors: import_prop_types64.default.arrayOf(import_prop_types64.default.string).isRequired,
      thresholds: import_prop_types64.default.arrayOf(import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]).isRequired).isRequired,
      type: import_prop_types64.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types64.default.array,
    dataKey: import_prop_types64.default.string,
    disableLine: import_prop_types64.default.bool,
    disableTicks: import_prop_types64.default.bool,
    domainLimit: import_prop_types64.default.oneOfType([import_prop_types64.default.oneOf(["nice", "strict"]), import_prop_types64.default.func]),
    fill: import_prop_types64.default.string,
    hideTooltip: import_prop_types64.default.bool,
    id: import_prop_types64.default.oneOfType([import_prop_types64.default.number, import_prop_types64.default.string]),
    ignoreTooltip: import_prop_types64.default.bool,
    label: import_prop_types64.default.string,
    labelStyle: import_prop_types64.default.object,
    max: import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]),
    min: import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]),
    offset: import_prop_types64.default.number,
    position: import_prop_types64.default.oneOf(["left", "none", "right"]),
    reverse: import_prop_types64.default.bool,
    scaleType: import_prop_types64.default.oneOf(["point"]),
    slotProps: import_prop_types64.default.object,
    slots: import_prop_types64.default.object,
    stroke: import_prop_types64.default.string,
    sx: import_prop_types64.default.oneOfType([import_prop_types64.default.arrayOf(import_prop_types64.default.oneOfType([import_prop_types64.default.func, import_prop_types64.default.object, import_prop_types64.default.bool])), import_prop_types64.default.func, import_prop_types64.default.object]),
    tickInterval: import_prop_types64.default.oneOfType([import_prop_types64.default.oneOf(["auto"]), import_prop_types64.default.array, import_prop_types64.default.func]),
    tickLabelInterval: import_prop_types64.default.oneOfType([import_prop_types64.default.oneOf(["auto"]), import_prop_types64.default.func]),
    tickLabelPlacement: import_prop_types64.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types64.default.object,
    tickMaxStep: import_prop_types64.default.number,
    tickMinStep: import_prop_types64.default.number,
    tickNumber: import_prop_types64.default.number,
    tickPlacement: import_prop_types64.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types64.default.number,
    valueFormatter: import_prop_types64.default.func,
    width: import_prop_types64.default.number
  }), import_prop_types64.default.shape({
    axis: import_prop_types64.default.oneOf(["y"]),
    classes: import_prop_types64.default.object,
    colorMap: import_prop_types64.default.oneOfType([import_prop_types64.default.shape({
      color: import_prop_types64.default.oneOfType([import_prop_types64.default.arrayOf(import_prop_types64.default.string.isRequired), import_prop_types64.default.func]).isRequired,
      max: import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]),
      min: import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]),
      type: import_prop_types64.default.oneOf(["continuous"]).isRequired
    }), import_prop_types64.default.shape({
      colors: import_prop_types64.default.arrayOf(import_prop_types64.default.string).isRequired,
      thresholds: import_prop_types64.default.arrayOf(import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]).isRequired).isRequired,
      type: import_prop_types64.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types64.default.array,
    dataKey: import_prop_types64.default.string,
    disableLine: import_prop_types64.default.bool,
    disableTicks: import_prop_types64.default.bool,
    domainLimit: import_prop_types64.default.oneOfType([import_prop_types64.default.oneOf(["nice", "strict"]), import_prop_types64.default.func]),
    fill: import_prop_types64.default.string,
    hideTooltip: import_prop_types64.default.bool,
    id: import_prop_types64.default.oneOfType([import_prop_types64.default.number, import_prop_types64.default.string]),
    ignoreTooltip: import_prop_types64.default.bool,
    label: import_prop_types64.default.string,
    labelStyle: import_prop_types64.default.object,
    max: import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]),
    min: import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]),
    offset: import_prop_types64.default.number,
    position: import_prop_types64.default.oneOf(["left", "none", "right"]),
    reverse: import_prop_types64.default.bool,
    scaleType: import_prop_types64.default.oneOf(["log"]),
    slotProps: import_prop_types64.default.object,
    slots: import_prop_types64.default.object,
    stroke: import_prop_types64.default.string,
    sx: import_prop_types64.default.oneOfType([import_prop_types64.default.arrayOf(import_prop_types64.default.oneOfType([import_prop_types64.default.func, import_prop_types64.default.object, import_prop_types64.default.bool])), import_prop_types64.default.func, import_prop_types64.default.object]),
    tickInterval: import_prop_types64.default.oneOfType([import_prop_types64.default.oneOf(["auto"]), import_prop_types64.default.array, import_prop_types64.default.func]),
    tickLabelInterval: import_prop_types64.default.oneOfType([import_prop_types64.default.oneOf(["auto"]), import_prop_types64.default.func]),
    tickLabelPlacement: import_prop_types64.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types64.default.object,
    tickMaxStep: import_prop_types64.default.number,
    tickMinStep: import_prop_types64.default.number,
    tickNumber: import_prop_types64.default.number,
    tickPlacement: import_prop_types64.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types64.default.number,
    valueFormatter: import_prop_types64.default.func,
    width: import_prop_types64.default.number
  }), import_prop_types64.default.shape({
    axis: import_prop_types64.default.oneOf(["y"]),
    classes: import_prop_types64.default.object,
    colorMap: import_prop_types64.default.oneOfType([import_prop_types64.default.shape({
      color: import_prop_types64.default.oneOfType([import_prop_types64.default.arrayOf(import_prop_types64.default.string.isRequired), import_prop_types64.default.func]).isRequired,
      max: import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]),
      min: import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]),
      type: import_prop_types64.default.oneOf(["continuous"]).isRequired
    }), import_prop_types64.default.shape({
      colors: import_prop_types64.default.arrayOf(import_prop_types64.default.string).isRequired,
      thresholds: import_prop_types64.default.arrayOf(import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]).isRequired).isRequired,
      type: import_prop_types64.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types64.default.array,
    dataKey: import_prop_types64.default.string,
    disableLine: import_prop_types64.default.bool,
    disableTicks: import_prop_types64.default.bool,
    domainLimit: import_prop_types64.default.oneOfType([import_prop_types64.default.oneOf(["nice", "strict"]), import_prop_types64.default.func]),
    fill: import_prop_types64.default.string,
    hideTooltip: import_prop_types64.default.bool,
    id: import_prop_types64.default.oneOfType([import_prop_types64.default.number, import_prop_types64.default.string]),
    ignoreTooltip: import_prop_types64.default.bool,
    label: import_prop_types64.default.string,
    labelStyle: import_prop_types64.default.object,
    max: import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]),
    min: import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]),
    offset: import_prop_types64.default.number,
    position: import_prop_types64.default.oneOf(["left", "none", "right"]),
    reverse: import_prop_types64.default.bool,
    scaleType: import_prop_types64.default.oneOf(["pow"]),
    slotProps: import_prop_types64.default.object,
    slots: import_prop_types64.default.object,
    stroke: import_prop_types64.default.string,
    sx: import_prop_types64.default.oneOfType([import_prop_types64.default.arrayOf(import_prop_types64.default.oneOfType([import_prop_types64.default.func, import_prop_types64.default.object, import_prop_types64.default.bool])), import_prop_types64.default.func, import_prop_types64.default.object]),
    tickInterval: import_prop_types64.default.oneOfType([import_prop_types64.default.oneOf(["auto"]), import_prop_types64.default.array, import_prop_types64.default.func]),
    tickLabelInterval: import_prop_types64.default.oneOfType([import_prop_types64.default.oneOf(["auto"]), import_prop_types64.default.func]),
    tickLabelPlacement: import_prop_types64.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types64.default.object,
    tickMaxStep: import_prop_types64.default.number,
    tickMinStep: import_prop_types64.default.number,
    tickNumber: import_prop_types64.default.number,
    tickPlacement: import_prop_types64.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types64.default.number,
    valueFormatter: import_prop_types64.default.func,
    width: import_prop_types64.default.number
  }), import_prop_types64.default.shape({
    axis: import_prop_types64.default.oneOf(["y"]),
    classes: import_prop_types64.default.object,
    colorMap: import_prop_types64.default.oneOfType([import_prop_types64.default.shape({
      color: import_prop_types64.default.oneOfType([import_prop_types64.default.arrayOf(import_prop_types64.default.string.isRequired), import_prop_types64.default.func]).isRequired,
      max: import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]),
      min: import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]),
      type: import_prop_types64.default.oneOf(["continuous"]).isRequired
    }), import_prop_types64.default.shape({
      colors: import_prop_types64.default.arrayOf(import_prop_types64.default.string).isRequired,
      thresholds: import_prop_types64.default.arrayOf(import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]).isRequired).isRequired,
      type: import_prop_types64.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types64.default.array,
    dataKey: import_prop_types64.default.string,
    disableLine: import_prop_types64.default.bool,
    disableTicks: import_prop_types64.default.bool,
    domainLimit: import_prop_types64.default.oneOfType([import_prop_types64.default.oneOf(["nice", "strict"]), import_prop_types64.default.func]),
    fill: import_prop_types64.default.string,
    hideTooltip: import_prop_types64.default.bool,
    id: import_prop_types64.default.oneOfType([import_prop_types64.default.number, import_prop_types64.default.string]),
    ignoreTooltip: import_prop_types64.default.bool,
    label: import_prop_types64.default.string,
    labelStyle: import_prop_types64.default.object,
    max: import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]),
    min: import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]),
    offset: import_prop_types64.default.number,
    position: import_prop_types64.default.oneOf(["left", "none", "right"]),
    reverse: import_prop_types64.default.bool,
    scaleType: import_prop_types64.default.oneOf(["sqrt"]),
    slotProps: import_prop_types64.default.object,
    slots: import_prop_types64.default.object,
    stroke: import_prop_types64.default.string,
    sx: import_prop_types64.default.oneOfType([import_prop_types64.default.arrayOf(import_prop_types64.default.oneOfType([import_prop_types64.default.func, import_prop_types64.default.object, import_prop_types64.default.bool])), import_prop_types64.default.func, import_prop_types64.default.object]),
    tickInterval: import_prop_types64.default.oneOfType([import_prop_types64.default.oneOf(["auto"]), import_prop_types64.default.array, import_prop_types64.default.func]),
    tickLabelInterval: import_prop_types64.default.oneOfType([import_prop_types64.default.oneOf(["auto"]), import_prop_types64.default.func]),
    tickLabelPlacement: import_prop_types64.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types64.default.object,
    tickMaxStep: import_prop_types64.default.number,
    tickMinStep: import_prop_types64.default.number,
    tickNumber: import_prop_types64.default.number,
    tickPlacement: import_prop_types64.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types64.default.number,
    valueFormatter: import_prop_types64.default.func,
    width: import_prop_types64.default.number
  }), import_prop_types64.default.shape({
    axis: import_prop_types64.default.oneOf(["y"]),
    classes: import_prop_types64.default.object,
    colorMap: import_prop_types64.default.oneOfType([import_prop_types64.default.shape({
      color: import_prop_types64.default.oneOfType([import_prop_types64.default.arrayOf(import_prop_types64.default.string.isRequired), import_prop_types64.default.func]).isRequired,
      max: import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]),
      min: import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]),
      type: import_prop_types64.default.oneOf(["continuous"]).isRequired
    }), import_prop_types64.default.shape({
      colors: import_prop_types64.default.arrayOf(import_prop_types64.default.string).isRequired,
      thresholds: import_prop_types64.default.arrayOf(import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]).isRequired).isRequired,
      type: import_prop_types64.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types64.default.array,
    dataKey: import_prop_types64.default.string,
    disableLine: import_prop_types64.default.bool,
    disableTicks: import_prop_types64.default.bool,
    domainLimit: import_prop_types64.default.oneOfType([import_prop_types64.default.oneOf(["nice", "strict"]), import_prop_types64.default.func]),
    fill: import_prop_types64.default.string,
    hideTooltip: import_prop_types64.default.bool,
    id: import_prop_types64.default.oneOfType([import_prop_types64.default.number, import_prop_types64.default.string]),
    ignoreTooltip: import_prop_types64.default.bool,
    label: import_prop_types64.default.string,
    labelStyle: import_prop_types64.default.object,
    max: import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]),
    min: import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]),
    offset: import_prop_types64.default.number,
    position: import_prop_types64.default.oneOf(["left", "none", "right"]),
    reverse: import_prop_types64.default.bool,
    scaleType: import_prop_types64.default.oneOf(["time"]),
    slotProps: import_prop_types64.default.object,
    slots: import_prop_types64.default.object,
    stroke: import_prop_types64.default.string,
    sx: import_prop_types64.default.oneOfType([import_prop_types64.default.arrayOf(import_prop_types64.default.oneOfType([import_prop_types64.default.func, import_prop_types64.default.object, import_prop_types64.default.bool])), import_prop_types64.default.func, import_prop_types64.default.object]),
    tickInterval: import_prop_types64.default.oneOfType([import_prop_types64.default.oneOf(["auto"]), import_prop_types64.default.array, import_prop_types64.default.func]),
    tickLabelInterval: import_prop_types64.default.oneOfType([import_prop_types64.default.oneOf(["auto"]), import_prop_types64.default.func]),
    tickLabelPlacement: import_prop_types64.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types64.default.object,
    tickMaxStep: import_prop_types64.default.number,
    tickMinStep: import_prop_types64.default.number,
    tickNumber: import_prop_types64.default.number,
    tickPlacement: import_prop_types64.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types64.default.number,
    valueFormatter: import_prop_types64.default.func,
    width: import_prop_types64.default.number
  }), import_prop_types64.default.shape({
    axis: import_prop_types64.default.oneOf(["y"]),
    classes: import_prop_types64.default.object,
    colorMap: import_prop_types64.default.oneOfType([import_prop_types64.default.shape({
      color: import_prop_types64.default.oneOfType([import_prop_types64.default.arrayOf(import_prop_types64.default.string.isRequired), import_prop_types64.default.func]).isRequired,
      max: import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]),
      min: import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]),
      type: import_prop_types64.default.oneOf(["continuous"]).isRequired
    }), import_prop_types64.default.shape({
      colors: import_prop_types64.default.arrayOf(import_prop_types64.default.string).isRequired,
      thresholds: import_prop_types64.default.arrayOf(import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]).isRequired).isRequired,
      type: import_prop_types64.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types64.default.array,
    dataKey: import_prop_types64.default.string,
    disableLine: import_prop_types64.default.bool,
    disableTicks: import_prop_types64.default.bool,
    domainLimit: import_prop_types64.default.oneOfType([import_prop_types64.default.oneOf(["nice", "strict"]), import_prop_types64.default.func]),
    fill: import_prop_types64.default.string,
    hideTooltip: import_prop_types64.default.bool,
    id: import_prop_types64.default.oneOfType([import_prop_types64.default.number, import_prop_types64.default.string]),
    ignoreTooltip: import_prop_types64.default.bool,
    label: import_prop_types64.default.string,
    labelStyle: import_prop_types64.default.object,
    max: import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]),
    min: import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]),
    offset: import_prop_types64.default.number,
    position: import_prop_types64.default.oneOf(["left", "none", "right"]),
    reverse: import_prop_types64.default.bool,
    scaleType: import_prop_types64.default.oneOf(["utc"]),
    slotProps: import_prop_types64.default.object,
    slots: import_prop_types64.default.object,
    stroke: import_prop_types64.default.string,
    sx: import_prop_types64.default.oneOfType([import_prop_types64.default.arrayOf(import_prop_types64.default.oneOfType([import_prop_types64.default.func, import_prop_types64.default.object, import_prop_types64.default.bool])), import_prop_types64.default.func, import_prop_types64.default.object]),
    tickInterval: import_prop_types64.default.oneOfType([import_prop_types64.default.oneOf(["auto"]), import_prop_types64.default.array, import_prop_types64.default.func]),
    tickLabelInterval: import_prop_types64.default.oneOfType([import_prop_types64.default.oneOf(["auto"]), import_prop_types64.default.func]),
    tickLabelPlacement: import_prop_types64.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types64.default.object,
    tickMaxStep: import_prop_types64.default.number,
    tickMinStep: import_prop_types64.default.number,
    tickNumber: import_prop_types64.default.number,
    tickPlacement: import_prop_types64.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types64.default.number,
    valueFormatter: import_prop_types64.default.func,
    width: import_prop_types64.default.number
  }), import_prop_types64.default.shape({
    axis: import_prop_types64.default.oneOf(["y"]),
    classes: import_prop_types64.default.object,
    colorMap: import_prop_types64.default.oneOfType([import_prop_types64.default.shape({
      color: import_prop_types64.default.oneOfType([import_prop_types64.default.arrayOf(import_prop_types64.default.string.isRequired), import_prop_types64.default.func]).isRequired,
      max: import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]),
      min: import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]),
      type: import_prop_types64.default.oneOf(["continuous"]).isRequired
    }), import_prop_types64.default.shape({
      colors: import_prop_types64.default.arrayOf(import_prop_types64.default.string).isRequired,
      thresholds: import_prop_types64.default.arrayOf(import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]).isRequired).isRequired,
      type: import_prop_types64.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types64.default.array,
    dataKey: import_prop_types64.default.string,
    disableLine: import_prop_types64.default.bool,
    disableTicks: import_prop_types64.default.bool,
    domainLimit: import_prop_types64.default.oneOfType([import_prop_types64.default.oneOf(["nice", "strict"]), import_prop_types64.default.func]),
    fill: import_prop_types64.default.string,
    hideTooltip: import_prop_types64.default.bool,
    id: import_prop_types64.default.oneOfType([import_prop_types64.default.number, import_prop_types64.default.string]),
    ignoreTooltip: import_prop_types64.default.bool,
    label: import_prop_types64.default.string,
    labelStyle: import_prop_types64.default.object,
    max: import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]),
    min: import_prop_types64.default.oneOfType([import_prop_types64.default.instanceOf(Date), import_prop_types64.default.number]),
    offset: import_prop_types64.default.number,
    position: import_prop_types64.default.oneOf(["left", "none", "right"]),
    reverse: import_prop_types64.default.bool,
    scaleType: import_prop_types64.default.oneOf(["linear"]),
    slotProps: import_prop_types64.default.object,
    slots: import_prop_types64.default.object,
    stroke: import_prop_types64.default.string,
    sx: import_prop_types64.default.oneOfType([import_prop_types64.default.arrayOf(import_prop_types64.default.oneOfType([import_prop_types64.default.func, import_prop_types64.default.object, import_prop_types64.default.bool])), import_prop_types64.default.func, import_prop_types64.default.object]),
    tickInterval: import_prop_types64.default.oneOfType([import_prop_types64.default.oneOf(["auto"]), import_prop_types64.default.array, import_prop_types64.default.func]),
    tickLabelInterval: import_prop_types64.default.oneOfType([import_prop_types64.default.oneOf(["auto"]), import_prop_types64.default.func]),
    tickLabelPlacement: import_prop_types64.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types64.default.object,
    tickMaxStep: import_prop_types64.default.number,
    tickMinStep: import_prop_types64.default.number,
    tickNumber: import_prop_types64.default.number,
    tickPlacement: import_prop_types64.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types64.default.number,
    valueFormatter: import_prop_types64.default.func,
    width: import_prop_types64.default.number
  })]).isRequired)
} : void 0;

// node_modules/@mui/x-charts/esm/PieChart/PieChart.js
var React127 = __toESM(require_react(), 1);
var import_prop_types70 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/PieChart/PiePlot.js
var React126 = __toESM(require_react(), 1);
var import_prop_types69 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/PieChart/PieArcPlot.js
var React123 = __toESM(require_react(), 1);
var import_prop_types66 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/PieChart/PieArc.js
var React121 = __toESM(require_react(), 1);
var import_prop_types65 = __toESM(require_prop_types(), 1);
var import_jsx_runtime81 = __toESM(require_jsx_runtime(), 1);
var _excluded43 = ["classes", "color", "dataIndex", "id", "isFaded", "isHighlighted", "onClick", "cornerRadius", "startAngle", "endAngle", "innerRadius", "outerRadius", "paddingAngle", "skipAnimation"];
function getPieArcUtilityClass(slot) {
  return generateUtilityClass("MuiPieArc", slot);
}
var pieArcClasses = generateUtilityClasses("MuiPieArc", ["root", "highlighted", "faded", "series"]);
var useUtilityClasses21 = (ownerState) => {
  const {
    classes,
    id,
    isFaded,
    isHighlighted,
    dataIndex
  } = ownerState;
  const slots = {
    root: ["root", `series-${id}`, `data-index-${dataIndex}`, isHighlighted && "highlighted", isFaded && "faded"]
  };
  return composeClasses(slots, getPieArcUtilityClass, classes);
};
var PieArcRoot = styled_default2("path", {
  name: "MuiPieArc",
  slot: "Root",
  overridesResolver: (_2, styles) => styles.arc
  // FIXME: Inconsistent naming with slot
})(({
  theme
}) => ({
  // Got to move stroke to an element prop instead of style.
  stroke: (theme.vars || theme).palette.background.paper,
  transitionProperty: "opacity, fill, filter",
  transitionDuration: `${ANIMATION_DURATION_MS}ms`,
  transitionTimingFunction: ANIMATION_TIMING_FUNCTION
}));
var PieArc = React121.forwardRef(function PieArc2(props, ref) {
  const {
    classes: innerClasses,
    color: color3,
    dataIndex,
    id,
    isFaded,
    isHighlighted,
    onClick,
    cornerRadius,
    startAngle,
    endAngle,
    innerRadius,
    outerRadius,
    paddingAngle,
    skipAnimation
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded43);
  const ownerState = {
    id,
    dataIndex,
    classes: innerClasses,
    color: color3,
    isFaded,
    isHighlighted
  };
  const classes = useUtilityClasses21(ownerState);
  const interactionProps = useInteractionItemProps({
    type: "pie",
    seriesId: id,
    dataIndex
  });
  const animatedProps = useAnimatePieArc({
    cornerRadius,
    startAngle,
    endAngle,
    innerRadius,
    outerRadius,
    paddingAngle,
    skipAnimation,
    ref
  });
  return (0, import_jsx_runtime81.jsx)(PieArcRoot, _extends({
    onClick,
    cursor: onClick ? "pointer" : "unset",
    ownerState,
    className: classes.root,
    fill: ownerState.color,
    opacity: ownerState.isFaded ? 0.3 : 1,
    filter: ownerState.isHighlighted ? "brightness(120%)" : "none",
    strokeWidth: 1,
    strokeLinejoin: "round"
  }, other, interactionProps, animatedProps));
});
true ? PieArc.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  classes: import_prop_types65.default.object,
  cornerRadius: import_prop_types65.default.number.isRequired,
  dataIndex: import_prop_types65.default.number.isRequired,
  endAngle: import_prop_types65.default.number.isRequired,
  id: import_prop_types65.default.oneOfType([import_prop_types65.default.number, import_prop_types65.default.string]).isRequired,
  innerRadius: import_prop_types65.default.number.isRequired,
  isFaded: import_prop_types65.default.bool.isRequired,
  isHighlighted: import_prop_types65.default.bool.isRequired,
  outerRadius: import_prop_types65.default.number.isRequired,
  paddingAngle: import_prop_types65.default.number.isRequired,
  /**
   * @default false
   */
  skipAnimation: import_prop_types65.default.bool.isRequired,
  startAngle: import_prop_types65.default.number.isRequired
} : void 0;

// node_modules/@mui/x-charts/esm/PieChart/dataTransform/useTransformData.js
var React122 = __toESM(require_react(), 1);
function useTransformData(series) {
  const {
    id: seriesId,
    data,
    faded,
    highlighted,
    paddingAngle: basePaddingAngle = 0,
    innerRadius: baseInnerRadius = 0,
    arcLabelRadius: baseArcLabelRadius,
    outerRadius: baseOuterRadius,
    cornerRadius: baseCornerRadius = 0
  } = series;
  const {
    isFaded: isItemFaded,
    isHighlighted: isItemHighlighted
  } = useItemHighlightedGetter();
  const dataWithHighlight = React122.useMemo(() => data.map((item, itemIndex) => {
    const currentItem = {
      seriesId,
      dataIndex: itemIndex
    };
    const isHighlighted = isItemHighlighted(currentItem);
    const isFaded = !isHighlighted && isItemFaded(currentItem);
    const attributesOverride = _extends({
      additionalRadius: 0
    }, isFaded && faded || isHighlighted && highlighted || {});
    const paddingAngle = Math.max(0, deg2rad(attributesOverride.paddingAngle ?? basePaddingAngle));
    const innerRadius = Math.max(0, attributesOverride.innerRadius ?? baseInnerRadius);
    const outerRadius = Math.max(0, attributesOverride.outerRadius ?? baseOuterRadius + attributesOverride.additionalRadius);
    const cornerRadius = attributesOverride.cornerRadius ?? baseCornerRadius;
    const arcLabelRadius = attributesOverride.arcLabelRadius ?? baseArcLabelRadius ?? (innerRadius + outerRadius) / 2;
    return _extends({}, item, attributesOverride, {
      dataIndex: itemIndex,
      isFaded,
      isHighlighted,
      paddingAngle,
      innerRadius,
      outerRadius,
      cornerRadius,
      arcLabelRadius
    });
  }), [baseCornerRadius, baseInnerRadius, baseOuterRadius, basePaddingAngle, baseArcLabelRadius, data, faded, highlighted, isItemFaded, isItemHighlighted, seriesId]);
  return dataWithHighlight;
}

// node_modules/@mui/x-charts/esm/PieChart/PieArcPlot.js
var import_jsx_runtime82 = __toESM(require_jsx_runtime(), 1);
var _excluded44 = ["slots", "slotProps", "innerRadius", "outerRadius", "cornerRadius", "paddingAngle", "id", "highlighted", "faded", "data", "onItemClick", "skipAnimation"];
function PieArcPlot(props) {
  const {
    slots,
    slotProps,
    innerRadius = 0,
    outerRadius,
    cornerRadius = 0,
    paddingAngle = 0,
    id,
    highlighted,
    faded = {
      additionalRadius: -5
    },
    data,
    onItemClick,
    skipAnimation
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded44);
  const transformedData = useTransformData({
    innerRadius,
    outerRadius,
    cornerRadius,
    paddingAngle,
    id,
    highlighted,
    faded,
    data
  });
  if (data.length === 0) {
    return null;
  }
  const Arc = (slots == null ? void 0 : slots.pieArc) ?? PieArc;
  return (0, import_jsx_runtime82.jsx)("g", _extends({}, other, {
    children: transformedData.map((item, index2) => (0, import_jsx_runtime82.jsx)(Arc, _extends({
      startAngle: item.startAngle,
      endAngle: item.endAngle,
      paddingAngle: item.paddingAngle,
      innerRadius: item.innerRadius,
      outerRadius: item.outerRadius,
      cornerRadius: item.cornerRadius,
      skipAnimation: skipAnimation ?? false,
      id,
      color: item.color,
      dataIndex: index2,
      isFaded: item.isFaded,
      isHighlighted: item.isHighlighted,
      onClick: onItemClick && ((event) => {
        onItemClick(event, {
          type: "pie",
          seriesId: id,
          dataIndex: index2
        }, item);
      })
    }, slotProps == null ? void 0 : slotProps.pieArc), item.dataIndex))
  }));
}
true ? PieArcPlot.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The radius between circle center and the arc label in px.
   * @default (innerRadius - outerRadius) / 2
   */
  arcLabelRadius: import_prop_types66.default.number,
  /**
   * The radius applied to arc corners (similar to border radius).
   * @default 0
   */
  cornerRadius: import_prop_types66.default.number,
  data: import_prop_types66.default.arrayOf(import_prop_types66.default.shape({
    color: import_prop_types66.default.string.isRequired,
    endAngle: import_prop_types66.default.number.isRequired,
    formattedValue: import_prop_types66.default.string.isRequired,
    id: import_prop_types66.default.oneOfType([import_prop_types66.default.number, import_prop_types66.default.string]),
    index: import_prop_types66.default.number.isRequired,
    label: import_prop_types66.default.oneOfType([import_prop_types66.default.func, import_prop_types66.default.string]),
    labelMarkType: import_prop_types66.default.oneOfType([import_prop_types66.default.oneOf(["circle", "line", "square"]), import_prop_types66.default.func]),
    padAngle: import_prop_types66.default.number.isRequired,
    startAngle: import_prop_types66.default.number.isRequired,
    value: import_prop_types66.default.number.isRequired
  })).isRequired,
  /**
   * Override the arc attributes when it is faded.
   * @default { additionalRadius: -5 }
   */
  faded: import_prop_types66.default.shape({
    additionalRadius: import_prop_types66.default.number,
    arcLabelRadius: import_prop_types66.default.number,
    color: import_prop_types66.default.string,
    cornerRadius: import_prop_types66.default.number,
    innerRadius: import_prop_types66.default.number,
    outerRadius: import_prop_types66.default.number,
    paddingAngle: import_prop_types66.default.number
  }),
  /**
   * Override the arc attributes when it is highlighted.
   */
  highlighted: import_prop_types66.default.shape({
    additionalRadius: import_prop_types66.default.number,
    arcLabelRadius: import_prop_types66.default.number,
    color: import_prop_types66.default.string,
    cornerRadius: import_prop_types66.default.number,
    innerRadius: import_prop_types66.default.number,
    outerRadius: import_prop_types66.default.number,
    paddingAngle: import_prop_types66.default.number
  }),
  id: import_prop_types66.default.oneOfType([import_prop_types66.default.number, import_prop_types66.default.string]).isRequired,
  /**
   * The radius between circle center and the beginning of the arc.
   * @default 0
   */
  innerRadius: import_prop_types66.default.number,
  /**
   * Callback fired when a pie item is clicked.
   * @param {React.MouseEvent<SVGPathElement, MouseEvent>} event The event source of the callback.
   * @param {PieItemIdentifier} pieItemIdentifier The pie item identifier.
   * @param {DefaultizedPieValueType} item The pie item.
   */
  onItemClick: import_prop_types66.default.func,
  /**
   * The radius between circle center and the end of the arc.
   */
  outerRadius: import_prop_types66.default.number.isRequired,
  /**
   * The padding angle (deg) between two arcs.
   * @default 0
   */
  paddingAngle: import_prop_types66.default.number,
  /**
   * If `true`, animations are skipped.
   * @default false
   */
  skipAnimation: import_prop_types66.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types66.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types66.default.object
} : void 0;

// node_modules/@mui/x-charts/esm/PieChart/PieArcLabelPlot.js
var React125 = __toESM(require_react(), 1);
var import_prop_types68 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/PieChart/PieArcLabel.js
var React124 = __toESM(require_react(), 1);
var import_prop_types67 = __toESM(require_prop_types(), 1);
var import_jsx_runtime83 = __toESM(require_jsx_runtime(), 1);
var _excluded45 = ["id", "classes", "color", "startAngle", "endAngle", "paddingAngle", "arcLabelRadius", "innerRadius", "outerRadius", "cornerRadius", "formattedArcLabel", "isHighlighted", "isFaded", "style", "skipAnimation"];
function getPieArcLabelUtilityClass(slot) {
  return generateUtilityClass("MuiPieArcLabel", slot);
}
var pieArcLabelClasses = generateUtilityClasses("MuiPieArcLabel", ["root", "highlighted", "faded", "animate", "series"]);
var useUtilityClasses22 = (ownerState) => {
  const {
    classes,
    id,
    isFaded,
    isHighlighted,
    skipAnimation
  } = ownerState;
  const slots = {
    root: ["root", `series-${id}`, isHighlighted && "highlighted", isFaded && "faded", !skipAnimation && "animate"]
  };
  return composeClasses(slots, getPieArcLabelUtilityClass, classes);
};
var PieArcLabelRoot = styled_default2("text", {
  name: "MuiPieArcLabel",
  slot: "Root"
})(({
  theme
}) => ({
  fill: (theme.vars || theme).palette.text.primary,
  textAnchor: "middle",
  dominantBaseline: "middle",
  pointerEvents: "none",
  animationName: "animate-opacity",
  animationDuration: "0s",
  animationTimingFunction: ANIMATION_TIMING_FUNCTION,
  [`&.${pieArcLabelClasses.animate}`]: {
    animationDuration: `${ANIMATION_DURATION_MS}ms`
  },
  "@keyframes animate-opacity": {
    from: {
      opacity: 0
    }
  }
}));
var PieArcLabel = React124.forwardRef(function PieArcLabel2(props, ref) {
  const {
    id,
    classes: innerClasses,
    color: color3,
    startAngle,
    endAngle,
    paddingAngle,
    arcLabelRadius,
    cornerRadius,
    formattedArcLabel,
    isHighlighted,
    isFaded,
    skipAnimation
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded45);
  const ownerState = {
    id,
    classes: innerClasses,
    color: color3,
    isFaded,
    isHighlighted,
    skipAnimation
  };
  const classes = useUtilityClasses22(ownerState);
  const animatedProps = useAnimatePieArcLabel({
    cornerRadius,
    startAngle,
    endAngle,
    innerRadius: arcLabelRadius,
    outerRadius: arcLabelRadius,
    paddingAngle,
    skipAnimation,
    ref
  });
  return (0, import_jsx_runtime83.jsx)(PieArcLabelRoot, _extends({
    className: classes.root
  }, other, animatedProps, {
    children: formattedArcLabel
  }));
});
true ? PieArcLabel.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  arcLabelRadius: import_prop_types67.default.number.isRequired,
  classes: import_prop_types67.default.object,
  color: import_prop_types67.default.string.isRequired,
  cornerRadius: import_prop_types67.default.number.isRequired,
  endAngle: import_prop_types67.default.number.isRequired,
  formattedArcLabel: import_prop_types67.default.string,
  id: import_prop_types67.default.oneOfType([import_prop_types67.default.number, import_prop_types67.default.string]).isRequired,
  innerRadius: import_prop_types67.default.number.isRequired,
  isFaded: import_prop_types67.default.bool.isRequired,
  isHighlighted: import_prop_types67.default.bool.isRequired,
  outerRadius: import_prop_types67.default.number.isRequired,
  paddingAngle: import_prop_types67.default.number.isRequired,
  skipAnimation: import_prop_types67.default.bool.isRequired,
  startAngle: import_prop_types67.default.number.isRequired
} : void 0;

// node_modules/@mui/x-charts/esm/PieChart/PieArcLabelPlot.js
var import_jsx_runtime84 = __toESM(require_jsx_runtime(), 1);
var _excluded46 = ["arcLabel", "arcLabelMinAngle", "arcLabelRadius", "cornerRadius", "data", "faded", "highlighted", "id", "innerRadius", "outerRadius", "paddingAngle", "skipAnimation", "slotProps", "slots"];
var RATIO = 180 / Math.PI;
function getItemLabel(arcLabel, arcLabelMinAngle, item) {
  var _a;
  if (!arcLabel) {
    return null;
  }
  const angle = (item.endAngle - item.startAngle) * RATIO;
  if (angle < arcLabelMinAngle) {
    return null;
  }
  switch (arcLabel) {
    case "label":
      return getLabel(item.label, "arc");
    case "value":
      return (_a = item.value) == null ? void 0 : _a.toString();
    case "formattedValue":
      return item.formattedValue;
    default:
      return arcLabel(_extends({}, item, {
        label: getLabel(item.label, "arc")
      }));
  }
}
function PieArcLabelPlot(props) {
  const {
    arcLabel,
    arcLabelMinAngle = 0,
    arcLabelRadius,
    cornerRadius = 0,
    data,
    faded = {
      additionalRadius: -5
    },
    highlighted,
    id,
    innerRadius,
    outerRadius,
    paddingAngle = 0,
    skipAnimation,
    slotProps,
    slots
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded46);
  const transformedData = useTransformData({
    innerRadius,
    outerRadius,
    arcLabelRadius,
    cornerRadius,
    paddingAngle,
    id,
    highlighted,
    faded,
    data
  });
  if (data.length === 0) {
    return null;
  }
  const ArcLabel = (slots == null ? void 0 : slots.pieArcLabel) ?? PieArcLabel;
  return (0, import_jsx_runtime84.jsx)("g", _extends({}, other, {
    children: transformedData.map((item) => (0, import_jsx_runtime84.jsx)(ArcLabel, _extends({
      startAngle: item.startAngle,
      endAngle: item.endAngle,
      paddingAngle: item.paddingAngle,
      innerRadius: item.innerRadius,
      outerRadius: item.outerRadius,
      arcLabelRadius: item.arcLabelRadius,
      cornerRadius: item.cornerRadius,
      id,
      color: item.color,
      isFaded: item.isFaded,
      isHighlighted: item.isHighlighted,
      formattedArcLabel: getItemLabel(arcLabel, arcLabelMinAngle, item),
      skipAnimation: skipAnimation ?? false
    }, slotProps == null ? void 0 : slotProps.pieArcLabel), item.id ?? item.dataIndex))
  }));
}
true ? PieArcLabelPlot.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The label displayed into the arc.
   */
  arcLabel: import_prop_types68.default.oneOfType([import_prop_types68.default.oneOf(["formattedValue", "label", "value"]), import_prop_types68.default.func]),
  /**
   * The minimal angle required to display the arc label.
   * @default 0
   */
  arcLabelMinAngle: import_prop_types68.default.number,
  /**
   * The radius between circle center and the arc label in px.
   * @default (innerRadius - outerRadius) / 2
   */
  arcLabelRadius: import_prop_types68.default.number,
  /**
   * The radius applied to arc corners (similar to border radius).
   * @default 0
   */
  cornerRadius: import_prop_types68.default.number,
  data: import_prop_types68.default.arrayOf(import_prop_types68.default.shape({
    color: import_prop_types68.default.string.isRequired,
    endAngle: import_prop_types68.default.number.isRequired,
    formattedValue: import_prop_types68.default.string.isRequired,
    id: import_prop_types68.default.oneOfType([import_prop_types68.default.number, import_prop_types68.default.string]),
    index: import_prop_types68.default.number.isRequired,
    label: import_prop_types68.default.oneOfType([import_prop_types68.default.func, import_prop_types68.default.string]),
    labelMarkType: import_prop_types68.default.oneOfType([import_prop_types68.default.oneOf(["circle", "line", "square"]), import_prop_types68.default.func]),
    padAngle: import_prop_types68.default.number.isRequired,
    startAngle: import_prop_types68.default.number.isRequired,
    value: import_prop_types68.default.number.isRequired
  })).isRequired,
  /**
   * Override the arc attributes when it is faded.
   * @default { additionalRadius: -5 }
   */
  faded: import_prop_types68.default.shape({
    additionalRadius: import_prop_types68.default.number,
    arcLabelRadius: import_prop_types68.default.number,
    color: import_prop_types68.default.string,
    cornerRadius: import_prop_types68.default.number,
    innerRadius: import_prop_types68.default.number,
    outerRadius: import_prop_types68.default.number,
    paddingAngle: import_prop_types68.default.number
  }),
  /**
   * Override the arc attributes when it is highlighted.
   */
  highlighted: import_prop_types68.default.shape({
    additionalRadius: import_prop_types68.default.number,
    arcLabelRadius: import_prop_types68.default.number,
    color: import_prop_types68.default.string,
    cornerRadius: import_prop_types68.default.number,
    innerRadius: import_prop_types68.default.number,
    outerRadius: import_prop_types68.default.number,
    paddingAngle: import_prop_types68.default.number
  }),
  id: import_prop_types68.default.oneOfType([import_prop_types68.default.number, import_prop_types68.default.string]).isRequired,
  /**
   * The radius between circle center and the beginning of the arc.
   * @default 0
   */
  innerRadius: import_prop_types68.default.number,
  /**
   * The radius between circle center and the end of the arc.
   */
  outerRadius: import_prop_types68.default.number.isRequired,
  /**
   * The padding angle (deg) between two arcs.
   * @default 0
   */
  paddingAngle: import_prop_types68.default.number,
  /**
   * If `true`, animations are skipped.
   * @default false
   */
  skipAnimation: import_prop_types68.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types68.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types68.default.object
} : void 0;

// node_modules/@mui/x-charts/esm/internals/getPercentageValue.js
function getPercentageValue(value, refValue) {
  if (typeof value === "number") {
    return value;
  }
  if (value === "100%") {
    return refValue;
  }
  if (value.endsWith("%")) {
    const percentage = Number.parseFloat(value.slice(0, value.length - 1));
    if (!Number.isNaN(percentage)) {
      return percentage * refValue / 100;
    }
  }
  if (value.endsWith("px")) {
    const val = Number.parseFloat(value.slice(0, value.length - 2));
    if (!Number.isNaN(val)) {
      return val;
    }
  }
  throw new Error(`MUI X Charts: Received an unknown value "${value}". It should be a number, or a string with a percentage value.`);
}

// node_modules/@mui/x-charts/esm/PieChart/getPieCoordinates.js
function getPieCoordinates(series, drawing) {
  const {
    height: height2,
    width: width2
  } = drawing;
  const {
    cx: cxParam,
    cy: cyParam
  } = series;
  const availableRadius = Math.min(width2, height2) / 2;
  const cx = getPercentageValue(cxParam ?? "50%", width2);
  const cy = getPercentageValue(cyParam ?? "50%", height2);
  return {
    cx,
    cy,
    availableRadius
  };
}

// node_modules/@mui/x-charts/esm/PieChart/PiePlot.js
var import_jsx_runtime85 = __toESM(require_jsx_runtime(), 1);
function PiePlot(props) {
  const {
    skipAnimation: inSkipAnimation,
    slots,
    slotProps,
    onItemClick
  } = props;
  const seriesData = usePieSeriesContext();
  const {
    left: left3,
    top: top3,
    width: width2,
    height: height2
  } = useDrawingArea();
  const skipAnimation = useSkipAnimation(inSkipAnimation);
  if (seriesData === void 0) {
    return null;
  }
  const {
    series,
    seriesOrder
  } = seriesData;
  return (0, import_jsx_runtime85.jsxs)("g", {
    children: [seriesOrder.map((seriesId) => {
      const {
        innerRadius: innerRadiusParam,
        outerRadius: outerRadiusParam,
        cornerRadius,
        paddingAngle,
        data,
        cx: cxParam,
        cy: cyParam,
        highlighted,
        faded
      } = series[seriesId];
      const {
        cx,
        cy,
        availableRadius
      } = getPieCoordinates({
        cx: cxParam,
        cy: cyParam
      }, {
        width: width2,
        height: height2
      });
      const outerRadius = getPercentageValue(outerRadiusParam ?? availableRadius, availableRadius);
      const innerRadius = getPercentageValue(innerRadiusParam ?? 0, availableRadius);
      return (0, import_jsx_runtime85.jsx)("g", {
        transform: `translate(${left3 + cx}, ${top3 + cy})`,
        children: (0, import_jsx_runtime85.jsx)(PieArcPlot, {
          innerRadius,
          outerRadius,
          cornerRadius,
          paddingAngle,
          id: seriesId,
          data,
          skipAnimation,
          highlighted,
          faded,
          onItemClick,
          slots,
          slotProps
        })
      }, seriesId);
    }), seriesOrder.map((seriesId) => {
      const {
        innerRadius: innerRadiusParam,
        outerRadius: outerRadiusParam,
        arcLabelRadius: arcLabelRadiusParam,
        cornerRadius,
        paddingAngle,
        arcLabel,
        arcLabelMinAngle,
        data,
        cx: cxParam,
        cy: cyParam
      } = series[seriesId];
      const {
        cx,
        cy,
        availableRadius
      } = getPieCoordinates({
        cx: cxParam,
        cy: cyParam
      }, {
        width: width2,
        height: height2
      });
      const outerRadius = getPercentageValue(outerRadiusParam ?? availableRadius, availableRadius);
      const innerRadius = getPercentageValue(innerRadiusParam ?? 0, availableRadius);
      const arcLabelRadius = arcLabelRadiusParam === void 0 ? (outerRadius + innerRadius) / 2 : getPercentageValue(arcLabelRadiusParam, availableRadius);
      return (0, import_jsx_runtime85.jsx)("g", {
        transform: `translate(${left3 + cx}, ${top3 + cy})`,
        children: (0, import_jsx_runtime85.jsx)(PieArcLabelPlot, {
          innerRadius,
          outerRadius: outerRadius ?? availableRadius,
          arcLabelRadius,
          cornerRadius,
          paddingAngle,
          id: seriesId,
          data,
          skipAnimation,
          arcLabel,
          arcLabelMinAngle,
          slots,
          slotProps
        })
      }, seriesId);
    })]
  });
}
true ? PiePlot.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Callback fired when a pie item is clicked.
   * @param {React.MouseEvent<SVGPathElement, MouseEvent>} event The event source of the callback.
   * @param {PieItemIdentifier} pieItemIdentifier The pie item identifier.
   * @param {DefaultizedPieValueType} item The pie item.
   */
  onItemClick: import_prop_types69.default.func,
  /**
   * If `true`, animations are skipped.
   * @default false
   */
  skipAnimation: import_prop_types69.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types69.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types69.default.object
} : void 0;

// node_modules/@mui/x-charts/esm/PieChart/PieChart.plugins.js
var PIE_CHART_PLUGINS = [useChartInteraction, useChartHighlight];

// node_modules/@mui/x-charts/esm/PieChart/PieChart.js
var import_jsx_runtime86 = __toESM(require_jsx_runtime(), 1);
var _excluded47 = ["series", "width", "height", "margin", "colors", "sx", "skipAnimation", "hideLegend", "children", "slots", "slotProps", "onItemClick", "loading", "highlightedItem", "onHighlightChange", "className"];
var defaultMargin = {
  top: 5,
  bottom: 5,
  left: 5,
  right: 5
};
var PieChart = React127.forwardRef(function PieChart2(inProps, ref) {
  var _a, _b, _c, _d, _e2, _f;
  const props = useThemeProps2({
    props: inProps,
    name: "MuiPieChart"
  });
  const {
    series,
    width: width2,
    height: height2,
    margin: marginProps,
    colors,
    sx,
    skipAnimation,
    hideLegend,
    children: children2,
    slots,
    slotProps,
    onItemClick,
    loading,
    highlightedItem,
    onHighlightChange,
    className
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded47);
  const margin2 = defaultizeMargin(marginProps, defaultMargin);
  const {
    chartDataProviderProps,
    chartsSurfaceProps
  } = useChartContainerProps(_extends({}, other, {
    series: series.map((s3) => _extends({
      type: "pie"
    }, s3)),
    width: width2,
    height: height2,
    margin: margin2,
    colors,
    highlightedItem,
    onHighlightChange,
    className,
    skipAnimation,
    plugins: PIE_CHART_PLUGINS
  }), ref);
  const Tooltip = (slots == null ? void 0 : slots.tooltip) ?? ChartsTooltip;
  return (0, import_jsx_runtime86.jsx)(ChartDataProvider, _extends({}, chartDataProviderProps, {
    children: (0, import_jsx_runtime86.jsxs)(ChartsWrapper, {
      legendPosition: (_b = (_a = props.slotProps) == null ? void 0 : _a.legend) == null ? void 0 : _b.position,
      legendDirection: ((_d = (_c = props == null ? void 0 : props.slotProps) == null ? void 0 : _c.legend) == null ? void 0 : _d.direction) ?? "vertical",
      sx,
      children: [!hideLegend && (0, import_jsx_runtime86.jsx)(ChartsLegend, {
        direction: ((_f = (_e2 = props == null ? void 0 : props.slotProps) == null ? void 0 : _e2.legend) == null ? void 0 : _f.direction) ?? "vertical",
        slots,
        slotProps
      }), (0, import_jsx_runtime86.jsxs)(ChartsSurface, _extends({}, chartsSurfaceProps, {
        children: [(0, import_jsx_runtime86.jsx)(PiePlot, {
          slots,
          slotProps,
          onItemClick
        }), (0, import_jsx_runtime86.jsx)(ChartsOverlay, {
          loading,
          slots,
          slotProps
        }), !loading && (0, import_jsx_runtime86.jsx)(Tooltip, _extends({
          trigger: "item"
        }, slotProps == null ? void 0 : slotProps.tooltip)), children2]
      }))]
    })
  }));
});
true ? PieChart.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  apiRef: import_prop_types70.default.shape({
    current: import_prop_types70.default.object
  }),
  children: import_prop_types70.default.node,
  className: import_prop_types70.default.string,
  /**
   * Color palette used to colorize multiple series.
   * @default rainbowSurgePalette
   */
  colors: import_prop_types70.default.oneOfType([import_prop_types70.default.arrayOf(import_prop_types70.default.string), import_prop_types70.default.func]),
  /**
   * An array of objects that can be used to populate series and axes data using their `dataKey` property.
   */
  dataset: import_prop_types70.default.arrayOf(import_prop_types70.default.object),
  desc: import_prop_types70.default.string,
  /**
   * The height of the chart in px. If not defined, it takes the height of the parent element.
   */
  height: import_prop_types70.default.number,
  /**
   * If `true`, the legend is not rendered.
   */
  hideLegend: import_prop_types70.default.bool,
  /**
   * The highlighted item.
   * Used when the highlight is controlled.
   */
  highlightedItem: import_prop_types70.default.shape({
    dataIndex: import_prop_types70.default.number,
    seriesId: import_prop_types70.default.oneOfType([import_prop_types70.default.number, import_prop_types70.default.string]).isRequired
  }),
  /**
   * This prop is used to help implement the accessibility logic.
   * If you don't provide this prop. It falls back to a randomly generated id.
   */
  id: import_prop_types70.default.string,
  /**
   * If `true`, a loading overlay is displayed.
   * @default false
   */
  loading: import_prop_types70.default.bool,
  /**
   * Localized text for chart components.
   */
  localeText: import_prop_types70.default.object,
  /**
   * The margin between the SVG and the drawing area.
   * It's used for leaving some space for extra information such as the x- and y-axis or legend.
   *
   * Accepts a `number` to be used on all sides or an object with the optional properties: `top`, `bottom`, `left`, and `right`.
   */
  margin: import_prop_types70.default.oneOfType([import_prop_types70.default.number, import_prop_types70.default.shape({
    bottom: import_prop_types70.default.number,
    left: import_prop_types70.default.number,
    right: import_prop_types70.default.number,
    top: import_prop_types70.default.number
  })]),
  /**
   * The callback fired when the highlighted item changes.
   *
   * @param {HighlightItemData | null} highlightedItem  The newly highlighted item.
   */
  onHighlightChange: import_prop_types70.default.func,
  /**
   * Callback fired when a pie arc is clicked.
   */
  onItemClick: import_prop_types70.default.func,
  /**
   * The series to display in the pie chart.
   * An array of [[PieSeriesType]] objects.
   */
  series: import_prop_types70.default.arrayOf(import_prop_types70.default.object).isRequired,
  /**
   * If `true`, animations are skipped.
   * If unset or `false`, the animations respects the user's `prefers-reduced-motion` setting.
   */
  skipAnimation: import_prop_types70.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types70.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types70.default.object,
  sx: import_prop_types70.default.oneOfType([import_prop_types70.default.arrayOf(import_prop_types70.default.oneOfType([import_prop_types70.default.func, import_prop_types70.default.object, import_prop_types70.default.bool])), import_prop_types70.default.func, import_prop_types70.default.object]),
  theme: import_prop_types70.default.oneOf(["dark", "light"]),
  title: import_prop_types70.default.string,
  /**
   * The width of the chart in px. If not defined, it takes the width of the parent element.
   */
  width: import_prop_types70.default.number
} : void 0;

// node_modules/@mui/x-charts/esm/ScatterChart/ScatterChart.js
var React132 = __toESM(require_react(), 1);
var import_prop_types74 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/ScatterChart/ScatterPlot.js
var React130 = __toESM(require_react(), 1);
var import_prop_types73 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/ScatterChart/Scatter.js
var React129 = __toESM(require_react(), 1);
var import_prop_types72 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/ScatterChart/ScatterMarker.js
var React128 = __toESM(require_react(), 1);
var import_prop_types71 = __toESM(require_prop_types(), 1);
var import_jsx_runtime87 = __toESM(require_jsx_runtime(), 1);
var _excluded48 = ["seriesId", "isFaded", "isHighlighted", "x", "y", "color", "size", "dataIndex"];
function ScatterMarker(props) {
  const {
    isFaded,
    isHighlighted,
    x: x3,
    y: y3,
    color: color3,
    size
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded48);
  return (0, import_jsx_runtime87.jsx)("circle", _extends({
    cx: 0,
    cy: 0,
    r: (isHighlighted ? 1.2 : 1) * size,
    transform: `translate(${x3}, ${y3})`,
    fill: color3,
    opacity: isFaded ? 0.3 : 1,
    cursor: other.onClick ? "pointer" : "unset"
  }, other));
}
true ? ScatterMarker.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The fill color of the marker.
   */
  color: import_prop_types71.default.string.isRequired,
  /**
   * The index of the data point.
   */
  dataIndex: import_prop_types71.default.number.isRequired,
  /**
   * If `true`, the marker is faded.
   */
  isFaded: import_prop_types71.default.bool.isRequired,
  /**
   * If `true`, the marker is highlighted.
   */
  isHighlighted: import_prop_types71.default.bool.isRequired,
  /**
   * Callback fired when clicking on a scatter item.
   * @param {MouseEvent} event Mouse event recorded on the `<svg/>` element.
   */
  onClick: import_prop_types71.default.func,
  /**
   * The series ID.
   */
  seriesId: import_prop_types71.default.oneOfType([import_prop_types71.default.number, import_prop_types71.default.string]).isRequired,
  /**
   * The size of the marker.
   */
  size: import_prop_types71.default.number.isRequired,
  /**
   * The x coordinate of the data point.
   */
  x: import_prop_types71.default.number.isRequired,
  /**
   * The y coordinate of the data point.
   */
  y: import_prop_types71.default.number.isRequired
} : void 0;

// node_modules/@mui/x-charts/esm/ScatterChart/Scatter.js
var import_jsx_runtime88 = __toESM(require_jsx_runtime(), 1);
var _excluded49 = ["ownerState"];
function Scatter(props) {
  const {
    series,
    xScale,
    yScale,
    color: color3,
    colorGetter,
    onItemClick,
    slots,
    slotProps
  } = props;
  const {
    instance
  } = useChartContext();
  const store = useStore();
  const isVoronoiEnabled = useSelector(store, selectorChartsVoronoiIsVoronoiEnabled);
  const skipInteractionHandlers = isVoronoiEnabled || series.disableHover;
  const {
    isFaded,
    isHighlighted
  } = useItemHighlightedGetter();
  const cleanData = React129.useMemo(() => {
    const getXPosition = getValueToPositionMapper(xScale);
    const getYPosition = getValueToPositionMapper(yScale);
    const temp = [];
    for (let i2 = 0; i2 < series.data.length; i2 += 1) {
      const scatterPoint = series.data[i2];
      const x3 = getXPosition(scatterPoint.x);
      const y3 = getYPosition(scatterPoint.y);
      const isInRange = instance.isPointInside({
        x: x3,
        y: y3
      });
      const pointCtx = {
        type: "scatter",
        seriesId: series.id,
        dataIndex: i2
      };
      if (isInRange) {
        const currentItem = {
          seriesId: pointCtx.seriesId,
          dataIndex: pointCtx.dataIndex
        };
        const isItemHighlighted = isHighlighted(currentItem);
        temp.push({
          x: x3,
          y: y3,
          isHighlighted: isItemHighlighted,
          isFaded: !isItemHighlighted && isFaded(currentItem),
          id: scatterPoint.id,
          seriesId: series.id,
          type: "scatter",
          dataIndex: i2,
          color: colorGetter ? colorGetter(i2) : color3
        });
      }
    }
    return temp;
  }, [xScale, yScale, series.data, series.id, isHighlighted, isFaded, colorGetter, color3, instance]);
  const interactionItemProps = useInteractionAllItemProps(cleanData, skipInteractionHandlers);
  const Marker = (slots == null ? void 0 : slots.marker) ?? ScatterMarker;
  const _useSlotProps = useSlotProps_default({
    elementType: Marker,
    externalSlotProps: slotProps == null ? void 0 : slotProps.marker,
    additionalProps: {
      seriesId: series.id,
      size: series.markerSize
    },
    ownerState: {}
  }), markerProps = _objectWithoutPropertiesLoose(_useSlotProps, _excluded49);
  return (0, import_jsx_runtime88.jsx)("g", {
    children: cleanData.map((dataPoint, i2) => (0, import_jsx_runtime88.jsx)(Marker, _extends({
      dataIndex: dataPoint.dataIndex,
      color: dataPoint.color,
      isHighlighted: dataPoint.isHighlighted,
      isFaded: dataPoint.isFaded,
      x: dataPoint.x,
      y: dataPoint.y,
      onClick: onItemClick && ((event) => onItemClick(event, {
        type: "scatter",
        seriesId: series.id,
        dataIndex: dataPoint.dataIndex
      }))
    }, interactionItemProps[i2], markerProps), dataPoint.id ?? dataPoint.dataIndex))
  });
}
true ? Scatter.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  color: import_prop_types72.default.string.isRequired,
  colorGetter: import_prop_types72.default.func,
  /**
   * Callback fired when clicking on a scatter item.
   * @param {MouseEvent} event Mouse event recorded on the `<svg/>` element.
   * @param {ScatterItemIdentifier} scatterItemIdentifier The scatter item identifier.
   */
  onItemClick: import_prop_types72.default.func,
  series: import_prop_types72.default.object.isRequired,
  slotProps: import_prop_types72.default.object,
  slots: import_prop_types72.default.object,
  xScale: import_prop_types72.default.func.isRequired,
  yScale: import_prop_types72.default.func.isRequired
} : void 0;

// node_modules/@mui/x-charts/esm/ScatterChart/ScatterPlot.js
var import_jsx_runtime89 = __toESM(require_jsx_runtime(), 1);
function ScatterPlot(props) {
  const {
    slots,
    slotProps,
    onItemClick
  } = props;
  const seriesData = useScatterSeriesContext();
  const {
    xAxis,
    xAxisIds
  } = useXAxes();
  const {
    yAxis,
    yAxisIds
  } = useYAxes();
  const {
    zAxis,
    zAxisIds
  } = useZAxes();
  if (seriesData === void 0) {
    return null;
  }
  const {
    series,
    seriesOrder
  } = seriesData;
  const defaultXAxisId = xAxisIds[0];
  const defaultYAxisId = yAxisIds[0];
  const defaultZAxisId = zAxisIds[0];
  const ScatterItems = (slots == null ? void 0 : slots.scatter) ?? Scatter;
  return (0, import_jsx_runtime89.jsx)(React130.Fragment, {
    children: seriesOrder.map((seriesId) => {
      const {
        id,
        xAxisId,
        yAxisId,
        zAxisId,
        color: color3
      } = series[seriesId];
      const colorGetter = getColor_default2(series[seriesId], xAxis[xAxisId ?? defaultXAxisId], yAxis[yAxisId ?? defaultYAxisId], zAxis[zAxisId ?? defaultZAxisId]);
      const xScale = xAxis[xAxisId ?? defaultXAxisId].scale;
      const yScale = yAxis[yAxisId ?? defaultYAxisId].scale;
      return (0, import_jsx_runtime89.jsx)(ScatterItems, _extends({
        xScale,
        yScale,
        color: color3,
        colorGetter,
        series: series[seriesId],
        onItemClick,
        slots,
        slotProps
      }, slotProps == null ? void 0 : slotProps.scatter), id);
    })
  });
}
true ? ScatterPlot.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Callback fired when clicking on a scatter item.
   * @param {MouseEvent} event Mouse event recorded on the `<svg/>` element.
   * @param {ScatterItemIdentifier} scatterItemIdentifier The scatter item identifier.
   */
  onItemClick: import_prop_types73.default.func,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types73.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types73.default.object
} : void 0;

// node_modules/@mui/x-charts/esm/ScatterChart/useScatterChartProps.js
var React131 = __toESM(require_react(), 1);

// node_modules/@mui/x-charts/esm/ScatterChart/ScatterChart.plugins.js
var SCATTER_CHART_PLUGINS = [useChartZAxis, useChartCartesianAxis, useChartInteraction, useChartHighlight, useChartVoronoi];

// node_modules/@mui/x-charts/esm/ScatterChart/useScatterChartProps.js
var _excluded50 = ["xAxis", "yAxis", "zAxis", "series", "axisHighlight", "voronoiMaxRadius", "disableVoronoi", "hideLegend", "width", "height", "margin", "colors", "sx", "grid", "onItemClick", "children", "slots", "slotProps", "loading", "highlightedItem", "onHighlightChange", "className"];
var useScatterChartProps = (props) => {
  var _a, _b, _c, _d;
  const {
    xAxis,
    yAxis,
    zAxis,
    series,
    axisHighlight,
    voronoiMaxRadius,
    disableVoronoi,
    width: width2,
    height: height2,
    margin: margin2,
    colors,
    sx,
    grid: grid2,
    onItemClick,
    children: children2,
    slots,
    slotProps,
    loading,
    highlightedItem,
    onHighlightChange,
    className
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded50);
  const seriesWithDefault = React131.useMemo(() => series.map((s3) => _extends({
    type: "scatter"
  }, s3)), [series]);
  const chartContainerProps = _extends({}, other, {
    series: seriesWithDefault,
    width: width2,
    height: height2,
    margin: margin2,
    colors,
    xAxis,
    yAxis,
    zAxis,
    highlightedItem,
    onHighlightChange,
    disableVoronoi,
    voronoiMaxRadius,
    onItemClick: disableVoronoi ? void 0 : onItemClick,
    className,
    plugins: SCATTER_CHART_PLUGINS
  });
  const chartsAxisProps = {
    slots,
    slotProps
  };
  const gridProps = {
    vertical: grid2 == null ? void 0 : grid2.vertical,
    horizontal: grid2 == null ? void 0 : grid2.horizontal
  };
  const scatterPlotProps = {
    onItemClick: disableVoronoi ? onItemClick : void 0,
    slots,
    slotProps
  };
  const overlayProps = {
    loading,
    slots,
    slotProps
  };
  const legendProps = {
    slots,
    slotProps
  };
  const axisHighlightProps = _extends({
    y: "none",
    x: "none"
  }, axisHighlight);
  const chartsWrapperProps = {
    sx,
    legendPosition: (_b = (_a = props.slotProps) == null ? void 0 : _a.legend) == null ? void 0 : _b.position,
    legendDirection: (_d = (_c = props.slotProps) == null ? void 0 : _c.legend) == null ? void 0 : _d.direction
  };
  return {
    chartsWrapperProps,
    chartContainerProps,
    chartsAxisProps,
    gridProps,
    scatterPlotProps,
    overlayProps,
    legendProps,
    axisHighlightProps,
    children: children2
  };
};

// node_modules/@mui/x-charts/esm/ScatterChart/ScatterChart.js
var import_jsx_runtime90 = __toESM(require_jsx_runtime(), 1);
var ScatterChart = React132.forwardRef(function ScatterChart2(inProps, ref) {
  var _a, _b;
  const props = useThemeProps2({
    props: inProps,
    name: "MuiScatterChart"
  });
  const {
    chartsWrapperProps,
    chartContainerProps,
    chartsAxisProps,
    gridProps,
    scatterPlotProps,
    overlayProps,
    legendProps,
    axisHighlightProps,
    children: children2
  } = useScatterChartProps(props);
  const {
    chartDataProviderProps,
    chartsSurfaceProps
  } = useChartContainerProps(chartContainerProps, ref);
  const Tooltip = ((_a = props.slots) == null ? void 0 : _a.tooltip) ?? ChartsTooltip;
  return (0, import_jsx_runtime90.jsx)(ChartDataProvider, _extends({}, chartDataProviderProps, {
    children: (0, import_jsx_runtime90.jsxs)(ChartsWrapper, _extends({}, chartsWrapperProps, {
      children: [!props.hideLegend && (0, import_jsx_runtime90.jsx)(ChartsLegend, _extends({}, legendProps)), (0, import_jsx_runtime90.jsxs)(ChartsSurface, _extends({}, chartsSurfaceProps, {
        children: [(0, import_jsx_runtime90.jsx)(ChartsAxis, _extends({}, chartsAxisProps)), (0, import_jsx_runtime90.jsx)(ChartsGrid, _extends({}, gridProps)), (0, import_jsx_runtime90.jsx)("g", {
          "data-drawing-container": true,
          children: (0, import_jsx_runtime90.jsx)(ScatterPlot, _extends({}, scatterPlotProps))
        }), (0, import_jsx_runtime90.jsx)(ChartsOverlay, _extends({}, overlayProps)), (0, import_jsx_runtime90.jsx)(ChartsAxisHighlight, _extends({}, axisHighlightProps)), !props.loading && (0, import_jsx_runtime90.jsx)(Tooltip, _extends({
          trigger: "item"
        }, (_b = props.slotProps) == null ? void 0 : _b.tooltip)), children2]
      }))]
    }))
  }));
});
true ? ScatterChart.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  apiRef: import_prop_types74.default.shape({
    current: import_prop_types74.default.object
  }),
  /**
   * The configuration of axes highlight.
   * @see See {@link https://mui.com/x/react-charts/highlighting/ highlighting docs} for more details.
   * @default { x: 'none', y: 'none' }
   */
  axisHighlight: import_prop_types74.default.shape({
    x: import_prop_types74.default.oneOf(["band", "line", "none"]),
    y: import_prop_types74.default.oneOf(["band", "line", "none"])
  }),
  children: import_prop_types74.default.node,
  className: import_prop_types74.default.string,
  /**
   * Color palette used to colorize multiple series.
   * @default rainbowSurgePalette
   */
  colors: import_prop_types74.default.oneOfType([import_prop_types74.default.arrayOf(import_prop_types74.default.string), import_prop_types74.default.func]),
  /**
   * An array of objects that can be used to populate series and axes data using their `dataKey` property.
   */
  dataset: import_prop_types74.default.arrayOf(import_prop_types74.default.object),
  desc: import_prop_types74.default.string,
  /**
   * If `true`, the charts will not listen to the mouse move event.
   * It might break interactive features, but will improve performance.
   * @default false
   */
  disableAxisListener: import_prop_types74.default.bool,
  /**
   * If true, the interaction will not use the Voronoi cell and fall back to hover events.
   * @default false
   */
  disableVoronoi: import_prop_types74.default.bool,
  /**
   * Option to display a cartesian grid in the background.
   */
  grid: import_prop_types74.default.shape({
    horizontal: import_prop_types74.default.bool,
    vertical: import_prop_types74.default.bool
  }),
  /**
   * The height of the chart in px. If not defined, it takes the height of the parent element.
   */
  height: import_prop_types74.default.number,
  /**
   * If `true`, the legend is not rendered.
   */
  hideLegend: import_prop_types74.default.bool,
  /**
   * The highlighted item.
   * Used when the highlight is controlled.
   */
  highlightedItem: import_prop_types74.default.shape({
    dataIndex: import_prop_types74.default.number,
    seriesId: import_prop_types74.default.oneOfType([import_prop_types74.default.number, import_prop_types74.default.string]).isRequired
  }),
  /**
   * This prop is used to help implement the accessibility logic.
   * If you don't provide this prop. It falls back to a randomly generated id.
   */
  id: import_prop_types74.default.string,
  /**
   * If `true`, a loading overlay is displayed.
   * @default false
   */
  loading: import_prop_types74.default.bool,
  /**
   * Localized text for chart components.
   */
  localeText: import_prop_types74.default.object,
  /**
   * The margin between the SVG and the drawing area.
   * It's used for leaving some space for extra information such as the x- and y-axis or legend.
   *
   * Accepts a `number` to be used on all sides or an object with the optional properties: `top`, `bottom`, `left`, and `right`.
   */
  margin: import_prop_types74.default.oneOfType([import_prop_types74.default.number, import_prop_types74.default.shape({
    bottom: import_prop_types74.default.number,
    left: import_prop_types74.default.number,
    right: import_prop_types74.default.number,
    top: import_prop_types74.default.number
  })]),
  /**
   * The function called for onClick events.
   * The second argument contains information about all line/bar elements at the current mouse position.
   * @param {MouseEvent} event The mouse event recorded on the `<svg/>` element.
   * @param {null | ChartsAxisData} data The data about the clicked axis and items associated with it.
   */
  onAxisClick: import_prop_types74.default.func,
  /**
   * The callback fired when the highlighted item changes.
   *
   * @param {HighlightItemData | null} highlightedItem  The newly highlighted item.
   */
  onHighlightChange: import_prop_types74.default.func,
  /**
   * Callback fired when clicking on a scatter item.
   * @param {MouseEvent} event The mouse event recorded on the `<svg/>` element if using Voronoi cells. Or the Mouse event from the scatter element, when `disableVoronoi=true`.
   * @param {ScatterItemIdentifier} scatterItemIdentifier The scatter item identifier.
   */
  onItemClick: import_prop_types74.default.func,
  /**
   * The series to display in the scatter chart.
   * An array of [[ScatterSeriesType]] objects.
   */
  series: import_prop_types74.default.arrayOf(import_prop_types74.default.object).isRequired,
  /**
   * If `true`, animations are skipped.
   * If unset or `false`, the animations respects the user's `prefers-reduced-motion` setting.
   */
  skipAnimation: import_prop_types74.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types74.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types74.default.object,
  sx: import_prop_types74.default.oneOfType([import_prop_types74.default.arrayOf(import_prop_types74.default.oneOfType([import_prop_types74.default.func, import_prop_types74.default.object, import_prop_types74.default.bool])), import_prop_types74.default.func, import_prop_types74.default.object]),
  theme: import_prop_types74.default.oneOf(["dark", "light"]),
  title: import_prop_types74.default.string,
  /**
   * Defines the maximal distance between a scatter point and the pointer that triggers the interaction.
   * If `undefined`, the radius is assumed to be infinite.
   */
  voronoiMaxRadius: import_prop_types74.default.number,
  /**
   * The width of the chart in px. If not defined, it takes the width of the parent element.
   */
  width: import_prop_types74.default.number,
  /**
   * The configuration of the x-axes.
   * If not provided, a default axis config is used.
   * An array of [[AxisConfig]] objects.
   */
  xAxis: import_prop_types74.default.arrayOf(import_prop_types74.default.oneOfType([import_prop_types74.default.shape({
    axis: import_prop_types74.default.oneOf(["x"]),
    barGapRatio: import_prop_types74.default.number,
    categoryGapRatio: import_prop_types74.default.number,
    classes: import_prop_types74.default.object,
    colorMap: import_prop_types74.default.oneOfType([import_prop_types74.default.shape({
      colors: import_prop_types74.default.arrayOf(import_prop_types74.default.string).isRequired,
      type: import_prop_types74.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types74.default.string,
      values: import_prop_types74.default.arrayOf(import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number, import_prop_types74.default.string]).isRequired)
    }), import_prop_types74.default.shape({
      color: import_prop_types74.default.oneOfType([import_prop_types74.default.arrayOf(import_prop_types74.default.string.isRequired), import_prop_types74.default.func]).isRequired,
      max: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
      min: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
      type: import_prop_types74.default.oneOf(["continuous"]).isRequired
    }), import_prop_types74.default.shape({
      colors: import_prop_types74.default.arrayOf(import_prop_types74.default.string).isRequired,
      thresholds: import_prop_types74.default.arrayOf(import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]).isRequired).isRequired,
      type: import_prop_types74.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types74.default.array,
    dataKey: import_prop_types74.default.string,
    disableLine: import_prop_types74.default.bool,
    disableTicks: import_prop_types74.default.bool,
    domainLimit: import_prop_types74.default.oneOfType([import_prop_types74.default.oneOf(["nice", "strict"]), import_prop_types74.default.func]),
    fill: import_prop_types74.default.string,
    height: import_prop_types74.default.number,
    hideTooltip: import_prop_types74.default.bool,
    id: import_prop_types74.default.oneOfType([import_prop_types74.default.number, import_prop_types74.default.string]),
    ignoreTooltip: import_prop_types74.default.bool,
    label: import_prop_types74.default.string,
    labelStyle: import_prop_types74.default.object,
    max: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
    min: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
    offset: import_prop_types74.default.number,
    position: import_prop_types74.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types74.default.bool,
    scaleType: import_prop_types74.default.oneOf(["band"]),
    slotProps: import_prop_types74.default.object,
    slots: import_prop_types74.default.object,
    stroke: import_prop_types74.default.string,
    sx: import_prop_types74.default.oneOfType([import_prop_types74.default.arrayOf(import_prop_types74.default.oneOfType([import_prop_types74.default.func, import_prop_types74.default.object, import_prop_types74.default.bool])), import_prop_types74.default.func, import_prop_types74.default.object]),
    tickInterval: import_prop_types74.default.oneOfType([import_prop_types74.default.oneOf(["auto"]), import_prop_types74.default.array, import_prop_types74.default.func]),
    tickLabelInterval: import_prop_types74.default.oneOfType([import_prop_types74.default.oneOf(["auto"]), import_prop_types74.default.func]),
    tickLabelMinGap: import_prop_types74.default.number,
    tickLabelPlacement: import_prop_types74.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types74.default.object,
    tickMaxStep: import_prop_types74.default.number,
    tickMinStep: import_prop_types74.default.number,
    tickNumber: import_prop_types74.default.number,
    tickPlacement: import_prop_types74.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types74.default.number,
    valueFormatter: import_prop_types74.default.func
  }), import_prop_types74.default.shape({
    axis: import_prop_types74.default.oneOf(["x"]),
    classes: import_prop_types74.default.object,
    colorMap: import_prop_types74.default.oneOfType([import_prop_types74.default.shape({
      colors: import_prop_types74.default.arrayOf(import_prop_types74.default.string).isRequired,
      type: import_prop_types74.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types74.default.string,
      values: import_prop_types74.default.arrayOf(import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number, import_prop_types74.default.string]).isRequired)
    }), import_prop_types74.default.shape({
      color: import_prop_types74.default.oneOfType([import_prop_types74.default.arrayOf(import_prop_types74.default.string.isRequired), import_prop_types74.default.func]).isRequired,
      max: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
      min: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
      type: import_prop_types74.default.oneOf(["continuous"]).isRequired
    }), import_prop_types74.default.shape({
      colors: import_prop_types74.default.arrayOf(import_prop_types74.default.string).isRequired,
      thresholds: import_prop_types74.default.arrayOf(import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]).isRequired).isRequired,
      type: import_prop_types74.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types74.default.array,
    dataKey: import_prop_types74.default.string,
    disableLine: import_prop_types74.default.bool,
    disableTicks: import_prop_types74.default.bool,
    domainLimit: import_prop_types74.default.oneOfType([import_prop_types74.default.oneOf(["nice", "strict"]), import_prop_types74.default.func]),
    fill: import_prop_types74.default.string,
    height: import_prop_types74.default.number,
    hideTooltip: import_prop_types74.default.bool,
    id: import_prop_types74.default.oneOfType([import_prop_types74.default.number, import_prop_types74.default.string]),
    ignoreTooltip: import_prop_types74.default.bool,
    label: import_prop_types74.default.string,
    labelStyle: import_prop_types74.default.object,
    max: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
    min: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
    offset: import_prop_types74.default.number,
    position: import_prop_types74.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types74.default.bool,
    scaleType: import_prop_types74.default.oneOf(["point"]),
    slotProps: import_prop_types74.default.object,
    slots: import_prop_types74.default.object,
    stroke: import_prop_types74.default.string,
    sx: import_prop_types74.default.oneOfType([import_prop_types74.default.arrayOf(import_prop_types74.default.oneOfType([import_prop_types74.default.func, import_prop_types74.default.object, import_prop_types74.default.bool])), import_prop_types74.default.func, import_prop_types74.default.object]),
    tickInterval: import_prop_types74.default.oneOfType([import_prop_types74.default.oneOf(["auto"]), import_prop_types74.default.array, import_prop_types74.default.func]),
    tickLabelInterval: import_prop_types74.default.oneOfType([import_prop_types74.default.oneOf(["auto"]), import_prop_types74.default.func]),
    tickLabelMinGap: import_prop_types74.default.number,
    tickLabelPlacement: import_prop_types74.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types74.default.object,
    tickMaxStep: import_prop_types74.default.number,
    tickMinStep: import_prop_types74.default.number,
    tickNumber: import_prop_types74.default.number,
    tickPlacement: import_prop_types74.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types74.default.number,
    valueFormatter: import_prop_types74.default.func
  }), import_prop_types74.default.shape({
    axis: import_prop_types74.default.oneOf(["x"]),
    classes: import_prop_types74.default.object,
    colorMap: import_prop_types74.default.oneOfType([import_prop_types74.default.shape({
      color: import_prop_types74.default.oneOfType([import_prop_types74.default.arrayOf(import_prop_types74.default.string.isRequired), import_prop_types74.default.func]).isRequired,
      max: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
      min: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
      type: import_prop_types74.default.oneOf(["continuous"]).isRequired
    }), import_prop_types74.default.shape({
      colors: import_prop_types74.default.arrayOf(import_prop_types74.default.string).isRequired,
      thresholds: import_prop_types74.default.arrayOf(import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]).isRequired).isRequired,
      type: import_prop_types74.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types74.default.array,
    dataKey: import_prop_types74.default.string,
    disableLine: import_prop_types74.default.bool,
    disableTicks: import_prop_types74.default.bool,
    domainLimit: import_prop_types74.default.oneOfType([import_prop_types74.default.oneOf(["nice", "strict"]), import_prop_types74.default.func]),
    fill: import_prop_types74.default.string,
    height: import_prop_types74.default.number,
    hideTooltip: import_prop_types74.default.bool,
    id: import_prop_types74.default.oneOfType([import_prop_types74.default.number, import_prop_types74.default.string]),
    ignoreTooltip: import_prop_types74.default.bool,
    label: import_prop_types74.default.string,
    labelStyle: import_prop_types74.default.object,
    max: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
    min: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
    offset: import_prop_types74.default.number,
    position: import_prop_types74.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types74.default.bool,
    scaleType: import_prop_types74.default.oneOf(["log"]),
    slotProps: import_prop_types74.default.object,
    slots: import_prop_types74.default.object,
    stroke: import_prop_types74.default.string,
    sx: import_prop_types74.default.oneOfType([import_prop_types74.default.arrayOf(import_prop_types74.default.oneOfType([import_prop_types74.default.func, import_prop_types74.default.object, import_prop_types74.default.bool])), import_prop_types74.default.func, import_prop_types74.default.object]),
    tickInterval: import_prop_types74.default.oneOfType([import_prop_types74.default.oneOf(["auto"]), import_prop_types74.default.array, import_prop_types74.default.func]),
    tickLabelInterval: import_prop_types74.default.oneOfType([import_prop_types74.default.oneOf(["auto"]), import_prop_types74.default.func]),
    tickLabelMinGap: import_prop_types74.default.number,
    tickLabelPlacement: import_prop_types74.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types74.default.object,
    tickMaxStep: import_prop_types74.default.number,
    tickMinStep: import_prop_types74.default.number,
    tickNumber: import_prop_types74.default.number,
    tickPlacement: import_prop_types74.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types74.default.number,
    valueFormatter: import_prop_types74.default.func
  }), import_prop_types74.default.shape({
    axis: import_prop_types74.default.oneOf(["x"]),
    classes: import_prop_types74.default.object,
    colorMap: import_prop_types74.default.oneOfType([import_prop_types74.default.shape({
      color: import_prop_types74.default.oneOfType([import_prop_types74.default.arrayOf(import_prop_types74.default.string.isRequired), import_prop_types74.default.func]).isRequired,
      max: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
      min: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
      type: import_prop_types74.default.oneOf(["continuous"]).isRequired
    }), import_prop_types74.default.shape({
      colors: import_prop_types74.default.arrayOf(import_prop_types74.default.string).isRequired,
      thresholds: import_prop_types74.default.arrayOf(import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]).isRequired).isRequired,
      type: import_prop_types74.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types74.default.array,
    dataKey: import_prop_types74.default.string,
    disableLine: import_prop_types74.default.bool,
    disableTicks: import_prop_types74.default.bool,
    domainLimit: import_prop_types74.default.oneOfType([import_prop_types74.default.oneOf(["nice", "strict"]), import_prop_types74.default.func]),
    fill: import_prop_types74.default.string,
    height: import_prop_types74.default.number,
    hideTooltip: import_prop_types74.default.bool,
    id: import_prop_types74.default.oneOfType([import_prop_types74.default.number, import_prop_types74.default.string]),
    ignoreTooltip: import_prop_types74.default.bool,
    label: import_prop_types74.default.string,
    labelStyle: import_prop_types74.default.object,
    max: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
    min: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
    offset: import_prop_types74.default.number,
    position: import_prop_types74.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types74.default.bool,
    scaleType: import_prop_types74.default.oneOf(["pow"]),
    slotProps: import_prop_types74.default.object,
    slots: import_prop_types74.default.object,
    stroke: import_prop_types74.default.string,
    sx: import_prop_types74.default.oneOfType([import_prop_types74.default.arrayOf(import_prop_types74.default.oneOfType([import_prop_types74.default.func, import_prop_types74.default.object, import_prop_types74.default.bool])), import_prop_types74.default.func, import_prop_types74.default.object]),
    tickInterval: import_prop_types74.default.oneOfType([import_prop_types74.default.oneOf(["auto"]), import_prop_types74.default.array, import_prop_types74.default.func]),
    tickLabelInterval: import_prop_types74.default.oneOfType([import_prop_types74.default.oneOf(["auto"]), import_prop_types74.default.func]),
    tickLabelMinGap: import_prop_types74.default.number,
    tickLabelPlacement: import_prop_types74.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types74.default.object,
    tickMaxStep: import_prop_types74.default.number,
    tickMinStep: import_prop_types74.default.number,
    tickNumber: import_prop_types74.default.number,
    tickPlacement: import_prop_types74.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types74.default.number,
    valueFormatter: import_prop_types74.default.func
  }), import_prop_types74.default.shape({
    axis: import_prop_types74.default.oneOf(["x"]),
    classes: import_prop_types74.default.object,
    colorMap: import_prop_types74.default.oneOfType([import_prop_types74.default.shape({
      color: import_prop_types74.default.oneOfType([import_prop_types74.default.arrayOf(import_prop_types74.default.string.isRequired), import_prop_types74.default.func]).isRequired,
      max: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
      min: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
      type: import_prop_types74.default.oneOf(["continuous"]).isRequired
    }), import_prop_types74.default.shape({
      colors: import_prop_types74.default.arrayOf(import_prop_types74.default.string).isRequired,
      thresholds: import_prop_types74.default.arrayOf(import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]).isRequired).isRequired,
      type: import_prop_types74.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types74.default.array,
    dataKey: import_prop_types74.default.string,
    disableLine: import_prop_types74.default.bool,
    disableTicks: import_prop_types74.default.bool,
    domainLimit: import_prop_types74.default.oneOfType([import_prop_types74.default.oneOf(["nice", "strict"]), import_prop_types74.default.func]),
    fill: import_prop_types74.default.string,
    height: import_prop_types74.default.number,
    hideTooltip: import_prop_types74.default.bool,
    id: import_prop_types74.default.oneOfType([import_prop_types74.default.number, import_prop_types74.default.string]),
    ignoreTooltip: import_prop_types74.default.bool,
    label: import_prop_types74.default.string,
    labelStyle: import_prop_types74.default.object,
    max: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
    min: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
    offset: import_prop_types74.default.number,
    position: import_prop_types74.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types74.default.bool,
    scaleType: import_prop_types74.default.oneOf(["sqrt"]),
    slotProps: import_prop_types74.default.object,
    slots: import_prop_types74.default.object,
    stroke: import_prop_types74.default.string,
    sx: import_prop_types74.default.oneOfType([import_prop_types74.default.arrayOf(import_prop_types74.default.oneOfType([import_prop_types74.default.func, import_prop_types74.default.object, import_prop_types74.default.bool])), import_prop_types74.default.func, import_prop_types74.default.object]),
    tickInterval: import_prop_types74.default.oneOfType([import_prop_types74.default.oneOf(["auto"]), import_prop_types74.default.array, import_prop_types74.default.func]),
    tickLabelInterval: import_prop_types74.default.oneOfType([import_prop_types74.default.oneOf(["auto"]), import_prop_types74.default.func]),
    tickLabelMinGap: import_prop_types74.default.number,
    tickLabelPlacement: import_prop_types74.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types74.default.object,
    tickMaxStep: import_prop_types74.default.number,
    tickMinStep: import_prop_types74.default.number,
    tickNumber: import_prop_types74.default.number,
    tickPlacement: import_prop_types74.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types74.default.number,
    valueFormatter: import_prop_types74.default.func
  }), import_prop_types74.default.shape({
    axis: import_prop_types74.default.oneOf(["x"]),
    classes: import_prop_types74.default.object,
    colorMap: import_prop_types74.default.oneOfType([import_prop_types74.default.shape({
      color: import_prop_types74.default.oneOfType([import_prop_types74.default.arrayOf(import_prop_types74.default.string.isRequired), import_prop_types74.default.func]).isRequired,
      max: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
      min: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
      type: import_prop_types74.default.oneOf(["continuous"]).isRequired
    }), import_prop_types74.default.shape({
      colors: import_prop_types74.default.arrayOf(import_prop_types74.default.string).isRequired,
      thresholds: import_prop_types74.default.arrayOf(import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]).isRequired).isRequired,
      type: import_prop_types74.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types74.default.array,
    dataKey: import_prop_types74.default.string,
    disableLine: import_prop_types74.default.bool,
    disableTicks: import_prop_types74.default.bool,
    domainLimit: import_prop_types74.default.oneOfType([import_prop_types74.default.oneOf(["nice", "strict"]), import_prop_types74.default.func]),
    fill: import_prop_types74.default.string,
    height: import_prop_types74.default.number,
    hideTooltip: import_prop_types74.default.bool,
    id: import_prop_types74.default.oneOfType([import_prop_types74.default.number, import_prop_types74.default.string]),
    ignoreTooltip: import_prop_types74.default.bool,
    label: import_prop_types74.default.string,
    labelStyle: import_prop_types74.default.object,
    max: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
    min: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
    offset: import_prop_types74.default.number,
    position: import_prop_types74.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types74.default.bool,
    scaleType: import_prop_types74.default.oneOf(["time"]),
    slotProps: import_prop_types74.default.object,
    slots: import_prop_types74.default.object,
    stroke: import_prop_types74.default.string,
    sx: import_prop_types74.default.oneOfType([import_prop_types74.default.arrayOf(import_prop_types74.default.oneOfType([import_prop_types74.default.func, import_prop_types74.default.object, import_prop_types74.default.bool])), import_prop_types74.default.func, import_prop_types74.default.object]),
    tickInterval: import_prop_types74.default.oneOfType([import_prop_types74.default.oneOf(["auto"]), import_prop_types74.default.array, import_prop_types74.default.func]),
    tickLabelInterval: import_prop_types74.default.oneOfType([import_prop_types74.default.oneOf(["auto"]), import_prop_types74.default.func]),
    tickLabelMinGap: import_prop_types74.default.number,
    tickLabelPlacement: import_prop_types74.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types74.default.object,
    tickMaxStep: import_prop_types74.default.number,
    tickMinStep: import_prop_types74.default.number,
    tickNumber: import_prop_types74.default.number,
    tickPlacement: import_prop_types74.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types74.default.number,
    valueFormatter: import_prop_types74.default.func
  }), import_prop_types74.default.shape({
    axis: import_prop_types74.default.oneOf(["x"]),
    classes: import_prop_types74.default.object,
    colorMap: import_prop_types74.default.oneOfType([import_prop_types74.default.shape({
      color: import_prop_types74.default.oneOfType([import_prop_types74.default.arrayOf(import_prop_types74.default.string.isRequired), import_prop_types74.default.func]).isRequired,
      max: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
      min: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
      type: import_prop_types74.default.oneOf(["continuous"]).isRequired
    }), import_prop_types74.default.shape({
      colors: import_prop_types74.default.arrayOf(import_prop_types74.default.string).isRequired,
      thresholds: import_prop_types74.default.arrayOf(import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]).isRequired).isRequired,
      type: import_prop_types74.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types74.default.array,
    dataKey: import_prop_types74.default.string,
    disableLine: import_prop_types74.default.bool,
    disableTicks: import_prop_types74.default.bool,
    domainLimit: import_prop_types74.default.oneOfType([import_prop_types74.default.oneOf(["nice", "strict"]), import_prop_types74.default.func]),
    fill: import_prop_types74.default.string,
    height: import_prop_types74.default.number,
    hideTooltip: import_prop_types74.default.bool,
    id: import_prop_types74.default.oneOfType([import_prop_types74.default.number, import_prop_types74.default.string]),
    ignoreTooltip: import_prop_types74.default.bool,
    label: import_prop_types74.default.string,
    labelStyle: import_prop_types74.default.object,
    max: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
    min: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
    offset: import_prop_types74.default.number,
    position: import_prop_types74.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types74.default.bool,
    scaleType: import_prop_types74.default.oneOf(["utc"]),
    slotProps: import_prop_types74.default.object,
    slots: import_prop_types74.default.object,
    stroke: import_prop_types74.default.string,
    sx: import_prop_types74.default.oneOfType([import_prop_types74.default.arrayOf(import_prop_types74.default.oneOfType([import_prop_types74.default.func, import_prop_types74.default.object, import_prop_types74.default.bool])), import_prop_types74.default.func, import_prop_types74.default.object]),
    tickInterval: import_prop_types74.default.oneOfType([import_prop_types74.default.oneOf(["auto"]), import_prop_types74.default.array, import_prop_types74.default.func]),
    tickLabelInterval: import_prop_types74.default.oneOfType([import_prop_types74.default.oneOf(["auto"]), import_prop_types74.default.func]),
    tickLabelMinGap: import_prop_types74.default.number,
    tickLabelPlacement: import_prop_types74.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types74.default.object,
    tickMaxStep: import_prop_types74.default.number,
    tickMinStep: import_prop_types74.default.number,
    tickNumber: import_prop_types74.default.number,
    tickPlacement: import_prop_types74.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types74.default.number,
    valueFormatter: import_prop_types74.default.func
  }), import_prop_types74.default.shape({
    axis: import_prop_types74.default.oneOf(["x"]),
    classes: import_prop_types74.default.object,
    colorMap: import_prop_types74.default.oneOfType([import_prop_types74.default.shape({
      color: import_prop_types74.default.oneOfType([import_prop_types74.default.arrayOf(import_prop_types74.default.string.isRequired), import_prop_types74.default.func]).isRequired,
      max: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
      min: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
      type: import_prop_types74.default.oneOf(["continuous"]).isRequired
    }), import_prop_types74.default.shape({
      colors: import_prop_types74.default.arrayOf(import_prop_types74.default.string).isRequired,
      thresholds: import_prop_types74.default.arrayOf(import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]).isRequired).isRequired,
      type: import_prop_types74.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types74.default.array,
    dataKey: import_prop_types74.default.string,
    disableLine: import_prop_types74.default.bool,
    disableTicks: import_prop_types74.default.bool,
    domainLimit: import_prop_types74.default.oneOfType([import_prop_types74.default.oneOf(["nice", "strict"]), import_prop_types74.default.func]),
    fill: import_prop_types74.default.string,
    height: import_prop_types74.default.number,
    hideTooltip: import_prop_types74.default.bool,
    id: import_prop_types74.default.oneOfType([import_prop_types74.default.number, import_prop_types74.default.string]),
    ignoreTooltip: import_prop_types74.default.bool,
    label: import_prop_types74.default.string,
    labelStyle: import_prop_types74.default.object,
    max: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
    min: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
    offset: import_prop_types74.default.number,
    position: import_prop_types74.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types74.default.bool,
    scaleType: import_prop_types74.default.oneOf(["linear"]),
    slotProps: import_prop_types74.default.object,
    slots: import_prop_types74.default.object,
    stroke: import_prop_types74.default.string,
    sx: import_prop_types74.default.oneOfType([import_prop_types74.default.arrayOf(import_prop_types74.default.oneOfType([import_prop_types74.default.func, import_prop_types74.default.object, import_prop_types74.default.bool])), import_prop_types74.default.func, import_prop_types74.default.object]),
    tickInterval: import_prop_types74.default.oneOfType([import_prop_types74.default.oneOf(["auto"]), import_prop_types74.default.array, import_prop_types74.default.func]),
    tickLabelInterval: import_prop_types74.default.oneOfType([import_prop_types74.default.oneOf(["auto"]), import_prop_types74.default.func]),
    tickLabelMinGap: import_prop_types74.default.number,
    tickLabelPlacement: import_prop_types74.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types74.default.object,
    tickMaxStep: import_prop_types74.default.number,
    tickMinStep: import_prop_types74.default.number,
    tickNumber: import_prop_types74.default.number,
    tickPlacement: import_prop_types74.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types74.default.number,
    valueFormatter: import_prop_types74.default.func
  })]).isRequired),
  /**
   * The configuration of the y-axes.
   * If not provided, a default axis config is used.
   * An array of [[AxisConfig]] objects.
   */
  yAxis: import_prop_types74.default.arrayOf(import_prop_types74.default.oneOfType([import_prop_types74.default.shape({
    axis: import_prop_types74.default.oneOf(["y"]),
    barGapRatio: import_prop_types74.default.number,
    categoryGapRatio: import_prop_types74.default.number,
    classes: import_prop_types74.default.object,
    colorMap: import_prop_types74.default.oneOfType([import_prop_types74.default.shape({
      colors: import_prop_types74.default.arrayOf(import_prop_types74.default.string).isRequired,
      type: import_prop_types74.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types74.default.string,
      values: import_prop_types74.default.arrayOf(import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number, import_prop_types74.default.string]).isRequired)
    }), import_prop_types74.default.shape({
      color: import_prop_types74.default.oneOfType([import_prop_types74.default.arrayOf(import_prop_types74.default.string.isRequired), import_prop_types74.default.func]).isRequired,
      max: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
      min: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
      type: import_prop_types74.default.oneOf(["continuous"]).isRequired
    }), import_prop_types74.default.shape({
      colors: import_prop_types74.default.arrayOf(import_prop_types74.default.string).isRequired,
      thresholds: import_prop_types74.default.arrayOf(import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]).isRequired).isRequired,
      type: import_prop_types74.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types74.default.array,
    dataKey: import_prop_types74.default.string,
    disableLine: import_prop_types74.default.bool,
    disableTicks: import_prop_types74.default.bool,
    domainLimit: import_prop_types74.default.oneOfType([import_prop_types74.default.oneOf(["nice", "strict"]), import_prop_types74.default.func]),
    fill: import_prop_types74.default.string,
    hideTooltip: import_prop_types74.default.bool,
    id: import_prop_types74.default.oneOfType([import_prop_types74.default.number, import_prop_types74.default.string]),
    ignoreTooltip: import_prop_types74.default.bool,
    label: import_prop_types74.default.string,
    labelStyle: import_prop_types74.default.object,
    max: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
    min: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
    offset: import_prop_types74.default.number,
    position: import_prop_types74.default.oneOf(["left", "none", "right"]),
    reverse: import_prop_types74.default.bool,
    scaleType: import_prop_types74.default.oneOf(["band"]),
    slotProps: import_prop_types74.default.object,
    slots: import_prop_types74.default.object,
    stroke: import_prop_types74.default.string,
    sx: import_prop_types74.default.oneOfType([import_prop_types74.default.arrayOf(import_prop_types74.default.oneOfType([import_prop_types74.default.func, import_prop_types74.default.object, import_prop_types74.default.bool])), import_prop_types74.default.func, import_prop_types74.default.object]),
    tickInterval: import_prop_types74.default.oneOfType([import_prop_types74.default.oneOf(["auto"]), import_prop_types74.default.array, import_prop_types74.default.func]),
    tickLabelInterval: import_prop_types74.default.oneOfType([import_prop_types74.default.oneOf(["auto"]), import_prop_types74.default.func]),
    tickLabelPlacement: import_prop_types74.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types74.default.object,
    tickMaxStep: import_prop_types74.default.number,
    tickMinStep: import_prop_types74.default.number,
    tickNumber: import_prop_types74.default.number,
    tickPlacement: import_prop_types74.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types74.default.number,
    valueFormatter: import_prop_types74.default.func,
    width: import_prop_types74.default.number
  }), import_prop_types74.default.shape({
    axis: import_prop_types74.default.oneOf(["y"]),
    classes: import_prop_types74.default.object,
    colorMap: import_prop_types74.default.oneOfType([import_prop_types74.default.shape({
      colors: import_prop_types74.default.arrayOf(import_prop_types74.default.string).isRequired,
      type: import_prop_types74.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types74.default.string,
      values: import_prop_types74.default.arrayOf(import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number, import_prop_types74.default.string]).isRequired)
    }), import_prop_types74.default.shape({
      color: import_prop_types74.default.oneOfType([import_prop_types74.default.arrayOf(import_prop_types74.default.string.isRequired), import_prop_types74.default.func]).isRequired,
      max: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
      min: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
      type: import_prop_types74.default.oneOf(["continuous"]).isRequired
    }), import_prop_types74.default.shape({
      colors: import_prop_types74.default.arrayOf(import_prop_types74.default.string).isRequired,
      thresholds: import_prop_types74.default.arrayOf(import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]).isRequired).isRequired,
      type: import_prop_types74.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types74.default.array,
    dataKey: import_prop_types74.default.string,
    disableLine: import_prop_types74.default.bool,
    disableTicks: import_prop_types74.default.bool,
    domainLimit: import_prop_types74.default.oneOfType([import_prop_types74.default.oneOf(["nice", "strict"]), import_prop_types74.default.func]),
    fill: import_prop_types74.default.string,
    hideTooltip: import_prop_types74.default.bool,
    id: import_prop_types74.default.oneOfType([import_prop_types74.default.number, import_prop_types74.default.string]),
    ignoreTooltip: import_prop_types74.default.bool,
    label: import_prop_types74.default.string,
    labelStyle: import_prop_types74.default.object,
    max: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
    min: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
    offset: import_prop_types74.default.number,
    position: import_prop_types74.default.oneOf(["left", "none", "right"]),
    reverse: import_prop_types74.default.bool,
    scaleType: import_prop_types74.default.oneOf(["point"]),
    slotProps: import_prop_types74.default.object,
    slots: import_prop_types74.default.object,
    stroke: import_prop_types74.default.string,
    sx: import_prop_types74.default.oneOfType([import_prop_types74.default.arrayOf(import_prop_types74.default.oneOfType([import_prop_types74.default.func, import_prop_types74.default.object, import_prop_types74.default.bool])), import_prop_types74.default.func, import_prop_types74.default.object]),
    tickInterval: import_prop_types74.default.oneOfType([import_prop_types74.default.oneOf(["auto"]), import_prop_types74.default.array, import_prop_types74.default.func]),
    tickLabelInterval: import_prop_types74.default.oneOfType([import_prop_types74.default.oneOf(["auto"]), import_prop_types74.default.func]),
    tickLabelPlacement: import_prop_types74.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types74.default.object,
    tickMaxStep: import_prop_types74.default.number,
    tickMinStep: import_prop_types74.default.number,
    tickNumber: import_prop_types74.default.number,
    tickPlacement: import_prop_types74.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types74.default.number,
    valueFormatter: import_prop_types74.default.func,
    width: import_prop_types74.default.number
  }), import_prop_types74.default.shape({
    axis: import_prop_types74.default.oneOf(["y"]),
    classes: import_prop_types74.default.object,
    colorMap: import_prop_types74.default.oneOfType([import_prop_types74.default.shape({
      color: import_prop_types74.default.oneOfType([import_prop_types74.default.arrayOf(import_prop_types74.default.string.isRequired), import_prop_types74.default.func]).isRequired,
      max: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
      min: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
      type: import_prop_types74.default.oneOf(["continuous"]).isRequired
    }), import_prop_types74.default.shape({
      colors: import_prop_types74.default.arrayOf(import_prop_types74.default.string).isRequired,
      thresholds: import_prop_types74.default.arrayOf(import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]).isRequired).isRequired,
      type: import_prop_types74.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types74.default.array,
    dataKey: import_prop_types74.default.string,
    disableLine: import_prop_types74.default.bool,
    disableTicks: import_prop_types74.default.bool,
    domainLimit: import_prop_types74.default.oneOfType([import_prop_types74.default.oneOf(["nice", "strict"]), import_prop_types74.default.func]),
    fill: import_prop_types74.default.string,
    hideTooltip: import_prop_types74.default.bool,
    id: import_prop_types74.default.oneOfType([import_prop_types74.default.number, import_prop_types74.default.string]),
    ignoreTooltip: import_prop_types74.default.bool,
    label: import_prop_types74.default.string,
    labelStyle: import_prop_types74.default.object,
    max: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
    min: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
    offset: import_prop_types74.default.number,
    position: import_prop_types74.default.oneOf(["left", "none", "right"]),
    reverse: import_prop_types74.default.bool,
    scaleType: import_prop_types74.default.oneOf(["log"]),
    slotProps: import_prop_types74.default.object,
    slots: import_prop_types74.default.object,
    stroke: import_prop_types74.default.string,
    sx: import_prop_types74.default.oneOfType([import_prop_types74.default.arrayOf(import_prop_types74.default.oneOfType([import_prop_types74.default.func, import_prop_types74.default.object, import_prop_types74.default.bool])), import_prop_types74.default.func, import_prop_types74.default.object]),
    tickInterval: import_prop_types74.default.oneOfType([import_prop_types74.default.oneOf(["auto"]), import_prop_types74.default.array, import_prop_types74.default.func]),
    tickLabelInterval: import_prop_types74.default.oneOfType([import_prop_types74.default.oneOf(["auto"]), import_prop_types74.default.func]),
    tickLabelPlacement: import_prop_types74.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types74.default.object,
    tickMaxStep: import_prop_types74.default.number,
    tickMinStep: import_prop_types74.default.number,
    tickNumber: import_prop_types74.default.number,
    tickPlacement: import_prop_types74.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types74.default.number,
    valueFormatter: import_prop_types74.default.func,
    width: import_prop_types74.default.number
  }), import_prop_types74.default.shape({
    axis: import_prop_types74.default.oneOf(["y"]),
    classes: import_prop_types74.default.object,
    colorMap: import_prop_types74.default.oneOfType([import_prop_types74.default.shape({
      color: import_prop_types74.default.oneOfType([import_prop_types74.default.arrayOf(import_prop_types74.default.string.isRequired), import_prop_types74.default.func]).isRequired,
      max: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
      min: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
      type: import_prop_types74.default.oneOf(["continuous"]).isRequired
    }), import_prop_types74.default.shape({
      colors: import_prop_types74.default.arrayOf(import_prop_types74.default.string).isRequired,
      thresholds: import_prop_types74.default.arrayOf(import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]).isRequired).isRequired,
      type: import_prop_types74.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types74.default.array,
    dataKey: import_prop_types74.default.string,
    disableLine: import_prop_types74.default.bool,
    disableTicks: import_prop_types74.default.bool,
    domainLimit: import_prop_types74.default.oneOfType([import_prop_types74.default.oneOf(["nice", "strict"]), import_prop_types74.default.func]),
    fill: import_prop_types74.default.string,
    hideTooltip: import_prop_types74.default.bool,
    id: import_prop_types74.default.oneOfType([import_prop_types74.default.number, import_prop_types74.default.string]),
    ignoreTooltip: import_prop_types74.default.bool,
    label: import_prop_types74.default.string,
    labelStyle: import_prop_types74.default.object,
    max: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
    min: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
    offset: import_prop_types74.default.number,
    position: import_prop_types74.default.oneOf(["left", "none", "right"]),
    reverse: import_prop_types74.default.bool,
    scaleType: import_prop_types74.default.oneOf(["pow"]),
    slotProps: import_prop_types74.default.object,
    slots: import_prop_types74.default.object,
    stroke: import_prop_types74.default.string,
    sx: import_prop_types74.default.oneOfType([import_prop_types74.default.arrayOf(import_prop_types74.default.oneOfType([import_prop_types74.default.func, import_prop_types74.default.object, import_prop_types74.default.bool])), import_prop_types74.default.func, import_prop_types74.default.object]),
    tickInterval: import_prop_types74.default.oneOfType([import_prop_types74.default.oneOf(["auto"]), import_prop_types74.default.array, import_prop_types74.default.func]),
    tickLabelInterval: import_prop_types74.default.oneOfType([import_prop_types74.default.oneOf(["auto"]), import_prop_types74.default.func]),
    tickLabelPlacement: import_prop_types74.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types74.default.object,
    tickMaxStep: import_prop_types74.default.number,
    tickMinStep: import_prop_types74.default.number,
    tickNumber: import_prop_types74.default.number,
    tickPlacement: import_prop_types74.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types74.default.number,
    valueFormatter: import_prop_types74.default.func,
    width: import_prop_types74.default.number
  }), import_prop_types74.default.shape({
    axis: import_prop_types74.default.oneOf(["y"]),
    classes: import_prop_types74.default.object,
    colorMap: import_prop_types74.default.oneOfType([import_prop_types74.default.shape({
      color: import_prop_types74.default.oneOfType([import_prop_types74.default.arrayOf(import_prop_types74.default.string.isRequired), import_prop_types74.default.func]).isRequired,
      max: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
      min: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
      type: import_prop_types74.default.oneOf(["continuous"]).isRequired
    }), import_prop_types74.default.shape({
      colors: import_prop_types74.default.arrayOf(import_prop_types74.default.string).isRequired,
      thresholds: import_prop_types74.default.arrayOf(import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]).isRequired).isRequired,
      type: import_prop_types74.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types74.default.array,
    dataKey: import_prop_types74.default.string,
    disableLine: import_prop_types74.default.bool,
    disableTicks: import_prop_types74.default.bool,
    domainLimit: import_prop_types74.default.oneOfType([import_prop_types74.default.oneOf(["nice", "strict"]), import_prop_types74.default.func]),
    fill: import_prop_types74.default.string,
    hideTooltip: import_prop_types74.default.bool,
    id: import_prop_types74.default.oneOfType([import_prop_types74.default.number, import_prop_types74.default.string]),
    ignoreTooltip: import_prop_types74.default.bool,
    label: import_prop_types74.default.string,
    labelStyle: import_prop_types74.default.object,
    max: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
    min: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
    offset: import_prop_types74.default.number,
    position: import_prop_types74.default.oneOf(["left", "none", "right"]),
    reverse: import_prop_types74.default.bool,
    scaleType: import_prop_types74.default.oneOf(["sqrt"]),
    slotProps: import_prop_types74.default.object,
    slots: import_prop_types74.default.object,
    stroke: import_prop_types74.default.string,
    sx: import_prop_types74.default.oneOfType([import_prop_types74.default.arrayOf(import_prop_types74.default.oneOfType([import_prop_types74.default.func, import_prop_types74.default.object, import_prop_types74.default.bool])), import_prop_types74.default.func, import_prop_types74.default.object]),
    tickInterval: import_prop_types74.default.oneOfType([import_prop_types74.default.oneOf(["auto"]), import_prop_types74.default.array, import_prop_types74.default.func]),
    tickLabelInterval: import_prop_types74.default.oneOfType([import_prop_types74.default.oneOf(["auto"]), import_prop_types74.default.func]),
    tickLabelPlacement: import_prop_types74.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types74.default.object,
    tickMaxStep: import_prop_types74.default.number,
    tickMinStep: import_prop_types74.default.number,
    tickNumber: import_prop_types74.default.number,
    tickPlacement: import_prop_types74.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types74.default.number,
    valueFormatter: import_prop_types74.default.func,
    width: import_prop_types74.default.number
  }), import_prop_types74.default.shape({
    axis: import_prop_types74.default.oneOf(["y"]),
    classes: import_prop_types74.default.object,
    colorMap: import_prop_types74.default.oneOfType([import_prop_types74.default.shape({
      color: import_prop_types74.default.oneOfType([import_prop_types74.default.arrayOf(import_prop_types74.default.string.isRequired), import_prop_types74.default.func]).isRequired,
      max: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
      min: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
      type: import_prop_types74.default.oneOf(["continuous"]).isRequired
    }), import_prop_types74.default.shape({
      colors: import_prop_types74.default.arrayOf(import_prop_types74.default.string).isRequired,
      thresholds: import_prop_types74.default.arrayOf(import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]).isRequired).isRequired,
      type: import_prop_types74.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types74.default.array,
    dataKey: import_prop_types74.default.string,
    disableLine: import_prop_types74.default.bool,
    disableTicks: import_prop_types74.default.bool,
    domainLimit: import_prop_types74.default.oneOfType([import_prop_types74.default.oneOf(["nice", "strict"]), import_prop_types74.default.func]),
    fill: import_prop_types74.default.string,
    hideTooltip: import_prop_types74.default.bool,
    id: import_prop_types74.default.oneOfType([import_prop_types74.default.number, import_prop_types74.default.string]),
    ignoreTooltip: import_prop_types74.default.bool,
    label: import_prop_types74.default.string,
    labelStyle: import_prop_types74.default.object,
    max: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
    min: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
    offset: import_prop_types74.default.number,
    position: import_prop_types74.default.oneOf(["left", "none", "right"]),
    reverse: import_prop_types74.default.bool,
    scaleType: import_prop_types74.default.oneOf(["time"]),
    slotProps: import_prop_types74.default.object,
    slots: import_prop_types74.default.object,
    stroke: import_prop_types74.default.string,
    sx: import_prop_types74.default.oneOfType([import_prop_types74.default.arrayOf(import_prop_types74.default.oneOfType([import_prop_types74.default.func, import_prop_types74.default.object, import_prop_types74.default.bool])), import_prop_types74.default.func, import_prop_types74.default.object]),
    tickInterval: import_prop_types74.default.oneOfType([import_prop_types74.default.oneOf(["auto"]), import_prop_types74.default.array, import_prop_types74.default.func]),
    tickLabelInterval: import_prop_types74.default.oneOfType([import_prop_types74.default.oneOf(["auto"]), import_prop_types74.default.func]),
    tickLabelPlacement: import_prop_types74.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types74.default.object,
    tickMaxStep: import_prop_types74.default.number,
    tickMinStep: import_prop_types74.default.number,
    tickNumber: import_prop_types74.default.number,
    tickPlacement: import_prop_types74.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types74.default.number,
    valueFormatter: import_prop_types74.default.func,
    width: import_prop_types74.default.number
  }), import_prop_types74.default.shape({
    axis: import_prop_types74.default.oneOf(["y"]),
    classes: import_prop_types74.default.object,
    colorMap: import_prop_types74.default.oneOfType([import_prop_types74.default.shape({
      color: import_prop_types74.default.oneOfType([import_prop_types74.default.arrayOf(import_prop_types74.default.string.isRequired), import_prop_types74.default.func]).isRequired,
      max: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
      min: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
      type: import_prop_types74.default.oneOf(["continuous"]).isRequired
    }), import_prop_types74.default.shape({
      colors: import_prop_types74.default.arrayOf(import_prop_types74.default.string).isRequired,
      thresholds: import_prop_types74.default.arrayOf(import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]).isRequired).isRequired,
      type: import_prop_types74.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types74.default.array,
    dataKey: import_prop_types74.default.string,
    disableLine: import_prop_types74.default.bool,
    disableTicks: import_prop_types74.default.bool,
    domainLimit: import_prop_types74.default.oneOfType([import_prop_types74.default.oneOf(["nice", "strict"]), import_prop_types74.default.func]),
    fill: import_prop_types74.default.string,
    hideTooltip: import_prop_types74.default.bool,
    id: import_prop_types74.default.oneOfType([import_prop_types74.default.number, import_prop_types74.default.string]),
    ignoreTooltip: import_prop_types74.default.bool,
    label: import_prop_types74.default.string,
    labelStyle: import_prop_types74.default.object,
    max: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
    min: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
    offset: import_prop_types74.default.number,
    position: import_prop_types74.default.oneOf(["left", "none", "right"]),
    reverse: import_prop_types74.default.bool,
    scaleType: import_prop_types74.default.oneOf(["utc"]),
    slotProps: import_prop_types74.default.object,
    slots: import_prop_types74.default.object,
    stroke: import_prop_types74.default.string,
    sx: import_prop_types74.default.oneOfType([import_prop_types74.default.arrayOf(import_prop_types74.default.oneOfType([import_prop_types74.default.func, import_prop_types74.default.object, import_prop_types74.default.bool])), import_prop_types74.default.func, import_prop_types74.default.object]),
    tickInterval: import_prop_types74.default.oneOfType([import_prop_types74.default.oneOf(["auto"]), import_prop_types74.default.array, import_prop_types74.default.func]),
    tickLabelInterval: import_prop_types74.default.oneOfType([import_prop_types74.default.oneOf(["auto"]), import_prop_types74.default.func]),
    tickLabelPlacement: import_prop_types74.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types74.default.object,
    tickMaxStep: import_prop_types74.default.number,
    tickMinStep: import_prop_types74.default.number,
    tickNumber: import_prop_types74.default.number,
    tickPlacement: import_prop_types74.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types74.default.number,
    valueFormatter: import_prop_types74.default.func,
    width: import_prop_types74.default.number
  }), import_prop_types74.default.shape({
    axis: import_prop_types74.default.oneOf(["y"]),
    classes: import_prop_types74.default.object,
    colorMap: import_prop_types74.default.oneOfType([import_prop_types74.default.shape({
      color: import_prop_types74.default.oneOfType([import_prop_types74.default.arrayOf(import_prop_types74.default.string.isRequired), import_prop_types74.default.func]).isRequired,
      max: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
      min: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
      type: import_prop_types74.default.oneOf(["continuous"]).isRequired
    }), import_prop_types74.default.shape({
      colors: import_prop_types74.default.arrayOf(import_prop_types74.default.string).isRequired,
      thresholds: import_prop_types74.default.arrayOf(import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]).isRequired).isRequired,
      type: import_prop_types74.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types74.default.array,
    dataKey: import_prop_types74.default.string,
    disableLine: import_prop_types74.default.bool,
    disableTicks: import_prop_types74.default.bool,
    domainLimit: import_prop_types74.default.oneOfType([import_prop_types74.default.oneOf(["nice", "strict"]), import_prop_types74.default.func]),
    fill: import_prop_types74.default.string,
    hideTooltip: import_prop_types74.default.bool,
    id: import_prop_types74.default.oneOfType([import_prop_types74.default.number, import_prop_types74.default.string]),
    ignoreTooltip: import_prop_types74.default.bool,
    label: import_prop_types74.default.string,
    labelStyle: import_prop_types74.default.object,
    max: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
    min: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
    offset: import_prop_types74.default.number,
    position: import_prop_types74.default.oneOf(["left", "none", "right"]),
    reverse: import_prop_types74.default.bool,
    scaleType: import_prop_types74.default.oneOf(["linear"]),
    slotProps: import_prop_types74.default.object,
    slots: import_prop_types74.default.object,
    stroke: import_prop_types74.default.string,
    sx: import_prop_types74.default.oneOfType([import_prop_types74.default.arrayOf(import_prop_types74.default.oneOfType([import_prop_types74.default.func, import_prop_types74.default.object, import_prop_types74.default.bool])), import_prop_types74.default.func, import_prop_types74.default.object]),
    tickInterval: import_prop_types74.default.oneOfType([import_prop_types74.default.oneOf(["auto"]), import_prop_types74.default.array, import_prop_types74.default.func]),
    tickLabelInterval: import_prop_types74.default.oneOfType([import_prop_types74.default.oneOf(["auto"]), import_prop_types74.default.func]),
    tickLabelPlacement: import_prop_types74.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types74.default.object,
    tickMaxStep: import_prop_types74.default.number,
    tickMinStep: import_prop_types74.default.number,
    tickNumber: import_prop_types74.default.number,
    tickPlacement: import_prop_types74.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types74.default.number,
    valueFormatter: import_prop_types74.default.func,
    width: import_prop_types74.default.number
  })]).isRequired),
  /**
   * The configuration of the z-axes.
   */
  zAxis: import_prop_types74.default.arrayOf(import_prop_types74.default.shape({
    colorMap: import_prop_types74.default.oneOfType([import_prop_types74.default.shape({
      colors: import_prop_types74.default.arrayOf(import_prop_types74.default.string).isRequired,
      type: import_prop_types74.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types74.default.string,
      values: import_prop_types74.default.arrayOf(import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number, import_prop_types74.default.string]).isRequired)
    }), import_prop_types74.default.shape({
      color: import_prop_types74.default.oneOfType([import_prop_types74.default.arrayOf(import_prop_types74.default.string.isRequired), import_prop_types74.default.func]).isRequired,
      max: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
      min: import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]),
      type: import_prop_types74.default.oneOf(["continuous"]).isRequired
    }), import_prop_types74.default.shape({
      colors: import_prop_types74.default.arrayOf(import_prop_types74.default.string).isRequired,
      thresholds: import_prop_types74.default.arrayOf(import_prop_types74.default.oneOfType([import_prop_types74.default.instanceOf(Date), import_prop_types74.default.number]).isRequired).isRequired,
      type: import_prop_types74.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types74.default.array,
    dataKey: import_prop_types74.default.string,
    id: import_prop_types74.default.string,
    max: import_prop_types74.default.number,
    min: import_prop_types74.default.number
  }))
} : void 0;

// node_modules/@mui/x-charts/esm/SparkLineChart/SparkLineChart.js
var React134 = __toESM(require_react(), 1);
var import_prop_types76 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/ChartContainer/ChartContainer.js
var React133 = __toESM(require_react(), 1);
var import_prop_types75 = __toESM(require_prop_types(), 1);
var import_jsx_runtime91 = __toESM(require_jsx_runtime(), 1);
var ChartContainer = React133.forwardRef(function ChartContainer2(props, ref) {
  const {
    chartDataProviderProps,
    children: children2,
    chartsSurfaceProps
  } = useChartContainerProps(props, ref);
  return (0, import_jsx_runtime91.jsx)(ChartDataProvider, _extends({}, chartDataProviderProps, {
    children: (0, import_jsx_runtime91.jsx)(ChartsSurface, _extends({}, chartsSurfaceProps, {
      children: children2
    }))
  }));
});
true ? ChartContainer.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  apiRef: import_prop_types75.default.shape({
    current: import_prop_types75.default.object
  }),
  children: import_prop_types75.default.node,
  className: import_prop_types75.default.string,
  /**
   * Color palette used to colorize multiple series.
   * @default rainbowSurgePalette
   */
  colors: import_prop_types75.default.oneOfType([import_prop_types75.default.arrayOf(import_prop_types75.default.string), import_prop_types75.default.func]),
  /**
   * An array of objects that can be used to populate series and axes data using their `dataKey` property.
   */
  dataset: import_prop_types75.default.arrayOf(import_prop_types75.default.object),
  desc: import_prop_types75.default.string,
  /**
   * If `true`, the charts will not listen to the mouse move event.
   * It might break interactive features, but will improve performance.
   * @default false
   */
  disableAxisListener: import_prop_types75.default.bool,
  /**
   * If true, the voronoi interaction are ignored.
   */
  disableVoronoi: import_prop_types75.default.bool,
  /**
   * The height of the chart in px. If not defined, it takes the height of the parent element.
   */
  height: import_prop_types75.default.number,
  /**
   * The highlighted item.
   * Used when the highlight is controlled.
   */
  highlightedItem: import_prop_types75.default.shape({
    dataIndex: import_prop_types75.default.number,
    seriesId: import_prop_types75.default.oneOfType([import_prop_types75.default.number, import_prop_types75.default.string]).isRequired
  }),
  /**
   * This prop is used to help implement the accessibility logic.
   * If you don't provide this prop. It falls back to a randomly generated id.
   */
  id: import_prop_types75.default.string,
  /**
   * Localized text for chart components.
   */
  localeText: import_prop_types75.default.object,
  /**
   * The margin between the SVG and the drawing area.
   * It's used for leaving some space for extra information such as the x- and y-axis or legend.
   *
   * Accepts a `number` to be used on all sides or an object with the optional properties: `top`, `bottom`, `left`, and `right`.
   */
  margin: import_prop_types75.default.oneOfType([import_prop_types75.default.number, import_prop_types75.default.shape({
    bottom: import_prop_types75.default.number,
    left: import_prop_types75.default.number,
    right: import_prop_types75.default.number,
    top: import_prop_types75.default.number
  })]),
  /**
   * The function called for onClick events.
   * The second argument contains information about all line/bar elements at the current mouse position.
   * @param {MouseEvent} event The mouse event recorded on the `<svg/>` element.
   * @param {null | ChartsAxisData} data The data about the clicked axis and items associated with it.
   */
  onAxisClick: import_prop_types75.default.func,
  /**
   * The callback fired when the highlighted item changes.
   *
   * @param {HighlightItemData | null} highlightedItem  The newly highlighted item.
   */
  onHighlightChange: import_prop_types75.default.func,
  /**
   * Callback fired when clicking close to an item.
   * This is only available for scatter plot for now.
   * @param {MouseEvent} event Mouse event caught at the svg level
   * @param {ScatterItemIdentifier} scatterItemIdentifier Identify which item got clicked
   */
  onItemClick: import_prop_types75.default.func,
  /**
   * The configuration of the radial-axes.
   * If not provided, a default axis config is used.
   * An array of [[AxisConfig]] objects.
   */
  radiusAxis: import_prop_types75.default.arrayOf(import_prop_types75.default.shape({
    classes: import_prop_types75.default.object,
    colorMap: import_prop_types75.default.oneOfType([import_prop_types75.default.shape({
      color: import_prop_types75.default.oneOfType([import_prop_types75.default.arrayOf(import_prop_types75.default.string.isRequired), import_prop_types75.default.func]).isRequired,
      max: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
      min: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
      type: import_prop_types75.default.oneOf(["continuous"]).isRequired
    }), import_prop_types75.default.shape({
      colors: import_prop_types75.default.arrayOf(import_prop_types75.default.string).isRequired,
      thresholds: import_prop_types75.default.arrayOf(import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]).isRequired).isRequired,
      type: import_prop_types75.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types75.default.array,
    dataKey: import_prop_types75.default.string,
    disableLine: import_prop_types75.default.bool,
    disableTicks: import_prop_types75.default.bool,
    domainLimit: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["nice", "strict"]), import_prop_types75.default.func]),
    fill: import_prop_types75.default.string,
    height: import_prop_types75.default.number,
    hideTooltip: import_prop_types75.default.bool,
    id: import_prop_types75.default.oneOfType([import_prop_types75.default.number, import_prop_types75.default.string]).isRequired,
    ignoreTooltip: import_prop_types75.default.bool,
    label: import_prop_types75.default.string,
    labelStyle: import_prop_types75.default.object,
    max: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
    maxRadius: import_prop_types75.default.number,
    min: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
    minRadius: import_prop_types75.default.number,
    offset: import_prop_types75.default.number,
    position: import_prop_types75.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types75.default.bool,
    scaleType: import_prop_types75.default.oneOf(["linear"]),
    slotProps: import_prop_types75.default.object,
    slots: import_prop_types75.default.object,
    stroke: import_prop_types75.default.string,
    sx: import_prop_types75.default.oneOfType([import_prop_types75.default.arrayOf(import_prop_types75.default.oneOfType([import_prop_types75.default.func, import_prop_types75.default.object, import_prop_types75.default.bool])), import_prop_types75.default.func, import_prop_types75.default.object]),
    tickInterval: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["auto"]), import_prop_types75.default.array, import_prop_types75.default.func]),
    tickLabelInterval: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["auto"]), import_prop_types75.default.func]),
    tickLabelPlacement: import_prop_types75.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types75.default.object,
    tickMaxStep: import_prop_types75.default.number,
    tickMinStep: import_prop_types75.default.number,
    tickNumber: import_prop_types75.default.number,
    tickPlacement: import_prop_types75.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types75.default.number,
    valueFormatter: import_prop_types75.default.func
  })),
  /**
   * The configuration of the rotation-axes.
   * If not provided, a default axis config is used.
   * An array of [[AxisConfig]] objects.
   */
  rotationAxis: import_prop_types75.default.arrayOf(import_prop_types75.default.oneOfType([import_prop_types75.default.shape({
    barGapRatio: import_prop_types75.default.number,
    categoryGapRatio: import_prop_types75.default.number,
    classes: import_prop_types75.default.object,
    colorMap: import_prop_types75.default.oneOfType([import_prop_types75.default.shape({
      colors: import_prop_types75.default.arrayOf(import_prop_types75.default.string).isRequired,
      type: import_prop_types75.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types75.default.string,
      values: import_prop_types75.default.arrayOf(import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number, import_prop_types75.default.string]).isRequired)
    }), import_prop_types75.default.shape({
      color: import_prop_types75.default.oneOfType([import_prop_types75.default.arrayOf(import_prop_types75.default.string.isRequired), import_prop_types75.default.func]).isRequired,
      max: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
      min: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
      type: import_prop_types75.default.oneOf(["continuous"]).isRequired
    }), import_prop_types75.default.shape({
      colors: import_prop_types75.default.arrayOf(import_prop_types75.default.string).isRequired,
      thresholds: import_prop_types75.default.arrayOf(import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]).isRequired).isRequired,
      type: import_prop_types75.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types75.default.array,
    dataKey: import_prop_types75.default.string,
    disableLine: import_prop_types75.default.bool,
    disableTicks: import_prop_types75.default.bool,
    domainLimit: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["nice", "strict"]), import_prop_types75.default.func]),
    endAngle: import_prop_types75.default.number,
    fill: import_prop_types75.default.string,
    height: import_prop_types75.default.number,
    hideTooltip: import_prop_types75.default.bool,
    id: import_prop_types75.default.oneOfType([import_prop_types75.default.number, import_prop_types75.default.string]).isRequired,
    ignoreTooltip: import_prop_types75.default.bool,
    label: import_prop_types75.default.string,
    labelGap: import_prop_types75.default.number,
    labelStyle: import_prop_types75.default.object,
    max: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
    min: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
    offset: import_prop_types75.default.number,
    position: import_prop_types75.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types75.default.bool,
    scaleType: import_prop_types75.default.oneOf(["band"]),
    slotProps: import_prop_types75.default.object,
    slots: import_prop_types75.default.object,
    startAngle: import_prop_types75.default.number,
    stroke: import_prop_types75.default.string,
    sx: import_prop_types75.default.oneOfType([import_prop_types75.default.arrayOf(import_prop_types75.default.oneOfType([import_prop_types75.default.func, import_prop_types75.default.object, import_prop_types75.default.bool])), import_prop_types75.default.func, import_prop_types75.default.object]),
    tickInterval: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["auto"]), import_prop_types75.default.array, import_prop_types75.default.func]),
    tickLabelInterval: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["auto"]), import_prop_types75.default.func]),
    tickLabelPlacement: import_prop_types75.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types75.default.object,
    tickMaxStep: import_prop_types75.default.number,
    tickMinStep: import_prop_types75.default.number,
    tickNumber: import_prop_types75.default.number,
    tickPlacement: import_prop_types75.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types75.default.number,
    valueFormatter: import_prop_types75.default.func
  }), import_prop_types75.default.shape({
    classes: import_prop_types75.default.object,
    colorMap: import_prop_types75.default.oneOfType([import_prop_types75.default.shape({
      colors: import_prop_types75.default.arrayOf(import_prop_types75.default.string).isRequired,
      type: import_prop_types75.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types75.default.string,
      values: import_prop_types75.default.arrayOf(import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number, import_prop_types75.default.string]).isRequired)
    }), import_prop_types75.default.shape({
      color: import_prop_types75.default.oneOfType([import_prop_types75.default.arrayOf(import_prop_types75.default.string.isRequired), import_prop_types75.default.func]).isRequired,
      max: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
      min: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
      type: import_prop_types75.default.oneOf(["continuous"]).isRequired
    }), import_prop_types75.default.shape({
      colors: import_prop_types75.default.arrayOf(import_prop_types75.default.string).isRequired,
      thresholds: import_prop_types75.default.arrayOf(import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]).isRequired).isRequired,
      type: import_prop_types75.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types75.default.array,
    dataKey: import_prop_types75.default.string,
    disableLine: import_prop_types75.default.bool,
    disableTicks: import_prop_types75.default.bool,
    domainLimit: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["nice", "strict"]), import_prop_types75.default.func]),
    endAngle: import_prop_types75.default.number,
    fill: import_prop_types75.default.string,
    height: import_prop_types75.default.number,
    hideTooltip: import_prop_types75.default.bool,
    id: import_prop_types75.default.oneOfType([import_prop_types75.default.number, import_prop_types75.default.string]).isRequired,
    ignoreTooltip: import_prop_types75.default.bool,
    label: import_prop_types75.default.string,
    labelGap: import_prop_types75.default.number,
    labelStyle: import_prop_types75.default.object,
    max: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
    min: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
    offset: import_prop_types75.default.number,
    position: import_prop_types75.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types75.default.bool,
    scaleType: import_prop_types75.default.oneOf(["point"]),
    slotProps: import_prop_types75.default.object,
    slots: import_prop_types75.default.object,
    startAngle: import_prop_types75.default.number,
    stroke: import_prop_types75.default.string,
    sx: import_prop_types75.default.oneOfType([import_prop_types75.default.arrayOf(import_prop_types75.default.oneOfType([import_prop_types75.default.func, import_prop_types75.default.object, import_prop_types75.default.bool])), import_prop_types75.default.func, import_prop_types75.default.object]),
    tickInterval: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["auto"]), import_prop_types75.default.array, import_prop_types75.default.func]),
    tickLabelInterval: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["auto"]), import_prop_types75.default.func]),
    tickLabelPlacement: import_prop_types75.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types75.default.object,
    tickMaxStep: import_prop_types75.default.number,
    tickMinStep: import_prop_types75.default.number,
    tickNumber: import_prop_types75.default.number,
    tickPlacement: import_prop_types75.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types75.default.number,
    valueFormatter: import_prop_types75.default.func
  }), import_prop_types75.default.shape({
    classes: import_prop_types75.default.object,
    colorMap: import_prop_types75.default.oneOfType([import_prop_types75.default.shape({
      color: import_prop_types75.default.oneOfType([import_prop_types75.default.arrayOf(import_prop_types75.default.string.isRequired), import_prop_types75.default.func]).isRequired,
      max: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
      min: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
      type: import_prop_types75.default.oneOf(["continuous"]).isRequired
    }), import_prop_types75.default.shape({
      colors: import_prop_types75.default.arrayOf(import_prop_types75.default.string).isRequired,
      thresholds: import_prop_types75.default.arrayOf(import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]).isRequired).isRequired,
      type: import_prop_types75.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types75.default.array,
    dataKey: import_prop_types75.default.string,
    disableLine: import_prop_types75.default.bool,
    disableTicks: import_prop_types75.default.bool,
    domainLimit: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["nice", "strict"]), import_prop_types75.default.func]),
    endAngle: import_prop_types75.default.number,
    fill: import_prop_types75.default.string,
    height: import_prop_types75.default.number,
    hideTooltip: import_prop_types75.default.bool,
    id: import_prop_types75.default.oneOfType([import_prop_types75.default.number, import_prop_types75.default.string]).isRequired,
    ignoreTooltip: import_prop_types75.default.bool,
    label: import_prop_types75.default.string,
    labelGap: import_prop_types75.default.number,
    labelStyle: import_prop_types75.default.object,
    max: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
    min: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
    offset: import_prop_types75.default.number,
    position: import_prop_types75.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types75.default.bool,
    scaleType: import_prop_types75.default.oneOf(["log"]),
    slotProps: import_prop_types75.default.object,
    slots: import_prop_types75.default.object,
    startAngle: import_prop_types75.default.number,
    stroke: import_prop_types75.default.string,
    sx: import_prop_types75.default.oneOfType([import_prop_types75.default.arrayOf(import_prop_types75.default.oneOfType([import_prop_types75.default.func, import_prop_types75.default.object, import_prop_types75.default.bool])), import_prop_types75.default.func, import_prop_types75.default.object]),
    tickInterval: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["auto"]), import_prop_types75.default.array, import_prop_types75.default.func]),
    tickLabelInterval: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["auto"]), import_prop_types75.default.func]),
    tickLabelPlacement: import_prop_types75.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types75.default.object,
    tickMaxStep: import_prop_types75.default.number,
    tickMinStep: import_prop_types75.default.number,
    tickNumber: import_prop_types75.default.number,
    tickPlacement: import_prop_types75.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types75.default.number,
    valueFormatter: import_prop_types75.default.func
  }), import_prop_types75.default.shape({
    classes: import_prop_types75.default.object,
    colorMap: import_prop_types75.default.oneOfType([import_prop_types75.default.shape({
      color: import_prop_types75.default.oneOfType([import_prop_types75.default.arrayOf(import_prop_types75.default.string.isRequired), import_prop_types75.default.func]).isRequired,
      max: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
      min: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
      type: import_prop_types75.default.oneOf(["continuous"]).isRequired
    }), import_prop_types75.default.shape({
      colors: import_prop_types75.default.arrayOf(import_prop_types75.default.string).isRequired,
      thresholds: import_prop_types75.default.arrayOf(import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]).isRequired).isRequired,
      type: import_prop_types75.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types75.default.array,
    dataKey: import_prop_types75.default.string,
    disableLine: import_prop_types75.default.bool,
    disableTicks: import_prop_types75.default.bool,
    domainLimit: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["nice", "strict"]), import_prop_types75.default.func]),
    endAngle: import_prop_types75.default.number,
    fill: import_prop_types75.default.string,
    height: import_prop_types75.default.number,
    hideTooltip: import_prop_types75.default.bool,
    id: import_prop_types75.default.oneOfType([import_prop_types75.default.number, import_prop_types75.default.string]).isRequired,
    ignoreTooltip: import_prop_types75.default.bool,
    label: import_prop_types75.default.string,
    labelGap: import_prop_types75.default.number,
    labelStyle: import_prop_types75.default.object,
    max: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
    min: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
    offset: import_prop_types75.default.number,
    position: import_prop_types75.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types75.default.bool,
    scaleType: import_prop_types75.default.oneOf(["pow"]),
    slotProps: import_prop_types75.default.object,
    slots: import_prop_types75.default.object,
    startAngle: import_prop_types75.default.number,
    stroke: import_prop_types75.default.string,
    sx: import_prop_types75.default.oneOfType([import_prop_types75.default.arrayOf(import_prop_types75.default.oneOfType([import_prop_types75.default.func, import_prop_types75.default.object, import_prop_types75.default.bool])), import_prop_types75.default.func, import_prop_types75.default.object]),
    tickInterval: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["auto"]), import_prop_types75.default.array, import_prop_types75.default.func]),
    tickLabelInterval: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["auto"]), import_prop_types75.default.func]),
    tickLabelPlacement: import_prop_types75.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types75.default.object,
    tickMaxStep: import_prop_types75.default.number,
    tickMinStep: import_prop_types75.default.number,
    tickNumber: import_prop_types75.default.number,
    tickPlacement: import_prop_types75.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types75.default.number,
    valueFormatter: import_prop_types75.default.func
  }), import_prop_types75.default.shape({
    classes: import_prop_types75.default.object,
    colorMap: import_prop_types75.default.oneOfType([import_prop_types75.default.shape({
      color: import_prop_types75.default.oneOfType([import_prop_types75.default.arrayOf(import_prop_types75.default.string.isRequired), import_prop_types75.default.func]).isRequired,
      max: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
      min: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
      type: import_prop_types75.default.oneOf(["continuous"]).isRequired
    }), import_prop_types75.default.shape({
      colors: import_prop_types75.default.arrayOf(import_prop_types75.default.string).isRequired,
      thresholds: import_prop_types75.default.arrayOf(import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]).isRequired).isRequired,
      type: import_prop_types75.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types75.default.array,
    dataKey: import_prop_types75.default.string,
    disableLine: import_prop_types75.default.bool,
    disableTicks: import_prop_types75.default.bool,
    domainLimit: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["nice", "strict"]), import_prop_types75.default.func]),
    endAngle: import_prop_types75.default.number,
    fill: import_prop_types75.default.string,
    height: import_prop_types75.default.number,
    hideTooltip: import_prop_types75.default.bool,
    id: import_prop_types75.default.oneOfType([import_prop_types75.default.number, import_prop_types75.default.string]).isRequired,
    ignoreTooltip: import_prop_types75.default.bool,
    label: import_prop_types75.default.string,
    labelGap: import_prop_types75.default.number,
    labelStyle: import_prop_types75.default.object,
    max: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
    min: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
    offset: import_prop_types75.default.number,
    position: import_prop_types75.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types75.default.bool,
    scaleType: import_prop_types75.default.oneOf(["sqrt"]),
    slotProps: import_prop_types75.default.object,
    slots: import_prop_types75.default.object,
    startAngle: import_prop_types75.default.number,
    stroke: import_prop_types75.default.string,
    sx: import_prop_types75.default.oneOfType([import_prop_types75.default.arrayOf(import_prop_types75.default.oneOfType([import_prop_types75.default.func, import_prop_types75.default.object, import_prop_types75.default.bool])), import_prop_types75.default.func, import_prop_types75.default.object]),
    tickInterval: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["auto"]), import_prop_types75.default.array, import_prop_types75.default.func]),
    tickLabelInterval: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["auto"]), import_prop_types75.default.func]),
    tickLabelPlacement: import_prop_types75.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types75.default.object,
    tickMaxStep: import_prop_types75.default.number,
    tickMinStep: import_prop_types75.default.number,
    tickNumber: import_prop_types75.default.number,
    tickPlacement: import_prop_types75.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types75.default.number,
    valueFormatter: import_prop_types75.default.func
  }), import_prop_types75.default.shape({
    classes: import_prop_types75.default.object,
    colorMap: import_prop_types75.default.oneOfType([import_prop_types75.default.shape({
      color: import_prop_types75.default.oneOfType([import_prop_types75.default.arrayOf(import_prop_types75.default.string.isRequired), import_prop_types75.default.func]).isRequired,
      max: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
      min: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
      type: import_prop_types75.default.oneOf(["continuous"]).isRequired
    }), import_prop_types75.default.shape({
      colors: import_prop_types75.default.arrayOf(import_prop_types75.default.string).isRequired,
      thresholds: import_prop_types75.default.arrayOf(import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]).isRequired).isRequired,
      type: import_prop_types75.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types75.default.array,
    dataKey: import_prop_types75.default.string,
    disableLine: import_prop_types75.default.bool,
    disableTicks: import_prop_types75.default.bool,
    domainLimit: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["nice", "strict"]), import_prop_types75.default.func]),
    endAngle: import_prop_types75.default.number,
    fill: import_prop_types75.default.string,
    height: import_prop_types75.default.number,
    hideTooltip: import_prop_types75.default.bool,
    id: import_prop_types75.default.oneOfType([import_prop_types75.default.number, import_prop_types75.default.string]).isRequired,
    ignoreTooltip: import_prop_types75.default.bool,
    label: import_prop_types75.default.string,
    labelGap: import_prop_types75.default.number,
    labelStyle: import_prop_types75.default.object,
    max: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
    min: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
    offset: import_prop_types75.default.number,
    position: import_prop_types75.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types75.default.bool,
    scaleType: import_prop_types75.default.oneOf(["time"]),
    slotProps: import_prop_types75.default.object,
    slots: import_prop_types75.default.object,
    startAngle: import_prop_types75.default.number,
    stroke: import_prop_types75.default.string,
    sx: import_prop_types75.default.oneOfType([import_prop_types75.default.arrayOf(import_prop_types75.default.oneOfType([import_prop_types75.default.func, import_prop_types75.default.object, import_prop_types75.default.bool])), import_prop_types75.default.func, import_prop_types75.default.object]),
    tickInterval: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["auto"]), import_prop_types75.default.array, import_prop_types75.default.func]),
    tickLabelInterval: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["auto"]), import_prop_types75.default.func]),
    tickLabelPlacement: import_prop_types75.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types75.default.object,
    tickMaxStep: import_prop_types75.default.number,
    tickMinStep: import_prop_types75.default.number,
    tickNumber: import_prop_types75.default.number,
    tickPlacement: import_prop_types75.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types75.default.number,
    valueFormatter: import_prop_types75.default.func
  }), import_prop_types75.default.shape({
    classes: import_prop_types75.default.object,
    colorMap: import_prop_types75.default.oneOfType([import_prop_types75.default.shape({
      color: import_prop_types75.default.oneOfType([import_prop_types75.default.arrayOf(import_prop_types75.default.string.isRequired), import_prop_types75.default.func]).isRequired,
      max: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
      min: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
      type: import_prop_types75.default.oneOf(["continuous"]).isRequired
    }), import_prop_types75.default.shape({
      colors: import_prop_types75.default.arrayOf(import_prop_types75.default.string).isRequired,
      thresholds: import_prop_types75.default.arrayOf(import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]).isRequired).isRequired,
      type: import_prop_types75.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types75.default.array,
    dataKey: import_prop_types75.default.string,
    disableLine: import_prop_types75.default.bool,
    disableTicks: import_prop_types75.default.bool,
    domainLimit: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["nice", "strict"]), import_prop_types75.default.func]),
    endAngle: import_prop_types75.default.number,
    fill: import_prop_types75.default.string,
    height: import_prop_types75.default.number,
    hideTooltip: import_prop_types75.default.bool,
    id: import_prop_types75.default.oneOfType([import_prop_types75.default.number, import_prop_types75.default.string]).isRequired,
    ignoreTooltip: import_prop_types75.default.bool,
    label: import_prop_types75.default.string,
    labelGap: import_prop_types75.default.number,
    labelStyle: import_prop_types75.default.object,
    max: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
    min: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
    offset: import_prop_types75.default.number,
    position: import_prop_types75.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types75.default.bool,
    scaleType: import_prop_types75.default.oneOf(["utc"]),
    slotProps: import_prop_types75.default.object,
    slots: import_prop_types75.default.object,
    startAngle: import_prop_types75.default.number,
    stroke: import_prop_types75.default.string,
    sx: import_prop_types75.default.oneOfType([import_prop_types75.default.arrayOf(import_prop_types75.default.oneOfType([import_prop_types75.default.func, import_prop_types75.default.object, import_prop_types75.default.bool])), import_prop_types75.default.func, import_prop_types75.default.object]),
    tickInterval: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["auto"]), import_prop_types75.default.array, import_prop_types75.default.func]),
    tickLabelInterval: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["auto"]), import_prop_types75.default.func]),
    tickLabelPlacement: import_prop_types75.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types75.default.object,
    tickMaxStep: import_prop_types75.default.number,
    tickMinStep: import_prop_types75.default.number,
    tickNumber: import_prop_types75.default.number,
    tickPlacement: import_prop_types75.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types75.default.number,
    valueFormatter: import_prop_types75.default.func
  }), import_prop_types75.default.shape({
    classes: import_prop_types75.default.object,
    colorMap: import_prop_types75.default.oneOfType([import_prop_types75.default.shape({
      color: import_prop_types75.default.oneOfType([import_prop_types75.default.arrayOf(import_prop_types75.default.string.isRequired), import_prop_types75.default.func]).isRequired,
      max: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
      min: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
      type: import_prop_types75.default.oneOf(["continuous"]).isRequired
    }), import_prop_types75.default.shape({
      colors: import_prop_types75.default.arrayOf(import_prop_types75.default.string).isRequired,
      thresholds: import_prop_types75.default.arrayOf(import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]).isRequired).isRequired,
      type: import_prop_types75.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types75.default.array,
    dataKey: import_prop_types75.default.string,
    disableLine: import_prop_types75.default.bool,
    disableTicks: import_prop_types75.default.bool,
    domainLimit: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["nice", "strict"]), import_prop_types75.default.func]),
    endAngle: import_prop_types75.default.number,
    fill: import_prop_types75.default.string,
    height: import_prop_types75.default.number,
    hideTooltip: import_prop_types75.default.bool,
    id: import_prop_types75.default.oneOfType([import_prop_types75.default.number, import_prop_types75.default.string]).isRequired,
    ignoreTooltip: import_prop_types75.default.bool,
    label: import_prop_types75.default.string,
    labelGap: import_prop_types75.default.number,
    labelStyle: import_prop_types75.default.object,
    max: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
    min: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
    offset: import_prop_types75.default.number,
    position: import_prop_types75.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types75.default.bool,
    scaleType: import_prop_types75.default.oneOf(["linear"]),
    slotProps: import_prop_types75.default.object,
    slots: import_prop_types75.default.object,
    startAngle: import_prop_types75.default.number,
    stroke: import_prop_types75.default.string,
    sx: import_prop_types75.default.oneOfType([import_prop_types75.default.arrayOf(import_prop_types75.default.oneOfType([import_prop_types75.default.func, import_prop_types75.default.object, import_prop_types75.default.bool])), import_prop_types75.default.func, import_prop_types75.default.object]),
    tickInterval: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["auto"]), import_prop_types75.default.array, import_prop_types75.default.func]),
    tickLabelInterval: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["auto"]), import_prop_types75.default.func]),
    tickLabelPlacement: import_prop_types75.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types75.default.object,
    tickMaxStep: import_prop_types75.default.number,
    tickMinStep: import_prop_types75.default.number,
    tickNumber: import_prop_types75.default.number,
    tickPlacement: import_prop_types75.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types75.default.number,
    valueFormatter: import_prop_types75.default.func
  })]).isRequired),
  /**
   * The array of series to display.
   * Each type of series has its own specificity.
   * Please refer to the appropriate docs page to learn more about it.
   */
  series: import_prop_types75.default.arrayOf(import_prop_types75.default.object),
  /**
   * If `true`, animations are skipped.
   * If unset or `false`, the animations respects the user's `prefers-reduced-motion` setting.
   */
  skipAnimation: import_prop_types75.default.bool,
  sx: import_prop_types75.default.oneOfType([import_prop_types75.default.arrayOf(import_prop_types75.default.oneOfType([import_prop_types75.default.func, import_prop_types75.default.object, import_prop_types75.default.bool])), import_prop_types75.default.func, import_prop_types75.default.object]),
  theme: import_prop_types75.default.oneOf(["dark", "light"]),
  title: import_prop_types75.default.string,
  /**
   * Defines the maximal distance between a scatter point and the pointer that triggers the interaction.
   * If `undefined`, the radius is assumed to be infinite.
   */
  voronoiMaxRadius: import_prop_types75.default.number,
  /**
   * The width of the chart in px. If not defined, it takes the width of the parent element.
   */
  width: import_prop_types75.default.number,
  /**
   * The configuration of the x-axes.
   * If not provided, a default axis config is used.
   * An array of [[AxisConfig]] objects.
   */
  xAxis: import_prop_types75.default.arrayOf(import_prop_types75.default.oneOfType([import_prop_types75.default.shape({
    axis: import_prop_types75.default.oneOf(["x"]),
    barGapRatio: import_prop_types75.default.number,
    categoryGapRatio: import_prop_types75.default.number,
    classes: import_prop_types75.default.object,
    colorMap: import_prop_types75.default.oneOfType([import_prop_types75.default.shape({
      colors: import_prop_types75.default.arrayOf(import_prop_types75.default.string).isRequired,
      type: import_prop_types75.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types75.default.string,
      values: import_prop_types75.default.arrayOf(import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number, import_prop_types75.default.string]).isRequired)
    }), import_prop_types75.default.shape({
      color: import_prop_types75.default.oneOfType([import_prop_types75.default.arrayOf(import_prop_types75.default.string.isRequired), import_prop_types75.default.func]).isRequired,
      max: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
      min: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
      type: import_prop_types75.default.oneOf(["continuous"]).isRequired
    }), import_prop_types75.default.shape({
      colors: import_prop_types75.default.arrayOf(import_prop_types75.default.string).isRequired,
      thresholds: import_prop_types75.default.arrayOf(import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]).isRequired).isRequired,
      type: import_prop_types75.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types75.default.array,
    dataKey: import_prop_types75.default.string,
    disableLine: import_prop_types75.default.bool,
    disableTicks: import_prop_types75.default.bool,
    domainLimit: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["nice", "strict"]), import_prop_types75.default.func]),
    fill: import_prop_types75.default.string,
    height: import_prop_types75.default.number,
    hideTooltip: import_prop_types75.default.bool,
    id: import_prop_types75.default.oneOfType([import_prop_types75.default.number, import_prop_types75.default.string]),
    ignoreTooltip: import_prop_types75.default.bool,
    label: import_prop_types75.default.string,
    labelStyle: import_prop_types75.default.object,
    max: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
    min: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
    offset: import_prop_types75.default.number,
    position: import_prop_types75.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types75.default.bool,
    scaleType: import_prop_types75.default.oneOf(["band"]),
    slotProps: import_prop_types75.default.object,
    slots: import_prop_types75.default.object,
    stroke: import_prop_types75.default.string,
    sx: import_prop_types75.default.oneOfType([import_prop_types75.default.arrayOf(import_prop_types75.default.oneOfType([import_prop_types75.default.func, import_prop_types75.default.object, import_prop_types75.default.bool])), import_prop_types75.default.func, import_prop_types75.default.object]),
    tickInterval: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["auto"]), import_prop_types75.default.array, import_prop_types75.default.func]),
    tickLabelInterval: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["auto"]), import_prop_types75.default.func]),
    tickLabelMinGap: import_prop_types75.default.number,
    tickLabelPlacement: import_prop_types75.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types75.default.object,
    tickMaxStep: import_prop_types75.default.number,
    tickMinStep: import_prop_types75.default.number,
    tickNumber: import_prop_types75.default.number,
    tickPlacement: import_prop_types75.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types75.default.number,
    valueFormatter: import_prop_types75.default.func
  }), import_prop_types75.default.shape({
    axis: import_prop_types75.default.oneOf(["x"]),
    classes: import_prop_types75.default.object,
    colorMap: import_prop_types75.default.oneOfType([import_prop_types75.default.shape({
      colors: import_prop_types75.default.arrayOf(import_prop_types75.default.string).isRequired,
      type: import_prop_types75.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types75.default.string,
      values: import_prop_types75.default.arrayOf(import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number, import_prop_types75.default.string]).isRequired)
    }), import_prop_types75.default.shape({
      color: import_prop_types75.default.oneOfType([import_prop_types75.default.arrayOf(import_prop_types75.default.string.isRequired), import_prop_types75.default.func]).isRequired,
      max: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
      min: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
      type: import_prop_types75.default.oneOf(["continuous"]).isRequired
    }), import_prop_types75.default.shape({
      colors: import_prop_types75.default.arrayOf(import_prop_types75.default.string).isRequired,
      thresholds: import_prop_types75.default.arrayOf(import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]).isRequired).isRequired,
      type: import_prop_types75.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types75.default.array,
    dataKey: import_prop_types75.default.string,
    disableLine: import_prop_types75.default.bool,
    disableTicks: import_prop_types75.default.bool,
    domainLimit: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["nice", "strict"]), import_prop_types75.default.func]),
    fill: import_prop_types75.default.string,
    height: import_prop_types75.default.number,
    hideTooltip: import_prop_types75.default.bool,
    id: import_prop_types75.default.oneOfType([import_prop_types75.default.number, import_prop_types75.default.string]),
    ignoreTooltip: import_prop_types75.default.bool,
    label: import_prop_types75.default.string,
    labelStyle: import_prop_types75.default.object,
    max: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
    min: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
    offset: import_prop_types75.default.number,
    position: import_prop_types75.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types75.default.bool,
    scaleType: import_prop_types75.default.oneOf(["point"]),
    slotProps: import_prop_types75.default.object,
    slots: import_prop_types75.default.object,
    stroke: import_prop_types75.default.string,
    sx: import_prop_types75.default.oneOfType([import_prop_types75.default.arrayOf(import_prop_types75.default.oneOfType([import_prop_types75.default.func, import_prop_types75.default.object, import_prop_types75.default.bool])), import_prop_types75.default.func, import_prop_types75.default.object]),
    tickInterval: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["auto"]), import_prop_types75.default.array, import_prop_types75.default.func]),
    tickLabelInterval: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["auto"]), import_prop_types75.default.func]),
    tickLabelMinGap: import_prop_types75.default.number,
    tickLabelPlacement: import_prop_types75.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types75.default.object,
    tickMaxStep: import_prop_types75.default.number,
    tickMinStep: import_prop_types75.default.number,
    tickNumber: import_prop_types75.default.number,
    tickPlacement: import_prop_types75.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types75.default.number,
    valueFormatter: import_prop_types75.default.func
  }), import_prop_types75.default.shape({
    axis: import_prop_types75.default.oneOf(["x"]),
    classes: import_prop_types75.default.object,
    colorMap: import_prop_types75.default.oneOfType([import_prop_types75.default.shape({
      color: import_prop_types75.default.oneOfType([import_prop_types75.default.arrayOf(import_prop_types75.default.string.isRequired), import_prop_types75.default.func]).isRequired,
      max: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
      min: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
      type: import_prop_types75.default.oneOf(["continuous"]).isRequired
    }), import_prop_types75.default.shape({
      colors: import_prop_types75.default.arrayOf(import_prop_types75.default.string).isRequired,
      thresholds: import_prop_types75.default.arrayOf(import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]).isRequired).isRequired,
      type: import_prop_types75.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types75.default.array,
    dataKey: import_prop_types75.default.string,
    disableLine: import_prop_types75.default.bool,
    disableTicks: import_prop_types75.default.bool,
    domainLimit: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["nice", "strict"]), import_prop_types75.default.func]),
    fill: import_prop_types75.default.string,
    height: import_prop_types75.default.number,
    hideTooltip: import_prop_types75.default.bool,
    id: import_prop_types75.default.oneOfType([import_prop_types75.default.number, import_prop_types75.default.string]),
    ignoreTooltip: import_prop_types75.default.bool,
    label: import_prop_types75.default.string,
    labelStyle: import_prop_types75.default.object,
    max: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
    min: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
    offset: import_prop_types75.default.number,
    position: import_prop_types75.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types75.default.bool,
    scaleType: import_prop_types75.default.oneOf(["log"]),
    slotProps: import_prop_types75.default.object,
    slots: import_prop_types75.default.object,
    stroke: import_prop_types75.default.string,
    sx: import_prop_types75.default.oneOfType([import_prop_types75.default.arrayOf(import_prop_types75.default.oneOfType([import_prop_types75.default.func, import_prop_types75.default.object, import_prop_types75.default.bool])), import_prop_types75.default.func, import_prop_types75.default.object]),
    tickInterval: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["auto"]), import_prop_types75.default.array, import_prop_types75.default.func]),
    tickLabelInterval: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["auto"]), import_prop_types75.default.func]),
    tickLabelMinGap: import_prop_types75.default.number,
    tickLabelPlacement: import_prop_types75.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types75.default.object,
    tickMaxStep: import_prop_types75.default.number,
    tickMinStep: import_prop_types75.default.number,
    tickNumber: import_prop_types75.default.number,
    tickPlacement: import_prop_types75.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types75.default.number,
    valueFormatter: import_prop_types75.default.func
  }), import_prop_types75.default.shape({
    axis: import_prop_types75.default.oneOf(["x"]),
    classes: import_prop_types75.default.object,
    colorMap: import_prop_types75.default.oneOfType([import_prop_types75.default.shape({
      color: import_prop_types75.default.oneOfType([import_prop_types75.default.arrayOf(import_prop_types75.default.string.isRequired), import_prop_types75.default.func]).isRequired,
      max: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
      min: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
      type: import_prop_types75.default.oneOf(["continuous"]).isRequired
    }), import_prop_types75.default.shape({
      colors: import_prop_types75.default.arrayOf(import_prop_types75.default.string).isRequired,
      thresholds: import_prop_types75.default.arrayOf(import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]).isRequired).isRequired,
      type: import_prop_types75.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types75.default.array,
    dataKey: import_prop_types75.default.string,
    disableLine: import_prop_types75.default.bool,
    disableTicks: import_prop_types75.default.bool,
    domainLimit: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["nice", "strict"]), import_prop_types75.default.func]),
    fill: import_prop_types75.default.string,
    height: import_prop_types75.default.number,
    hideTooltip: import_prop_types75.default.bool,
    id: import_prop_types75.default.oneOfType([import_prop_types75.default.number, import_prop_types75.default.string]),
    ignoreTooltip: import_prop_types75.default.bool,
    label: import_prop_types75.default.string,
    labelStyle: import_prop_types75.default.object,
    max: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
    min: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
    offset: import_prop_types75.default.number,
    position: import_prop_types75.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types75.default.bool,
    scaleType: import_prop_types75.default.oneOf(["pow"]),
    slotProps: import_prop_types75.default.object,
    slots: import_prop_types75.default.object,
    stroke: import_prop_types75.default.string,
    sx: import_prop_types75.default.oneOfType([import_prop_types75.default.arrayOf(import_prop_types75.default.oneOfType([import_prop_types75.default.func, import_prop_types75.default.object, import_prop_types75.default.bool])), import_prop_types75.default.func, import_prop_types75.default.object]),
    tickInterval: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["auto"]), import_prop_types75.default.array, import_prop_types75.default.func]),
    tickLabelInterval: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["auto"]), import_prop_types75.default.func]),
    tickLabelMinGap: import_prop_types75.default.number,
    tickLabelPlacement: import_prop_types75.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types75.default.object,
    tickMaxStep: import_prop_types75.default.number,
    tickMinStep: import_prop_types75.default.number,
    tickNumber: import_prop_types75.default.number,
    tickPlacement: import_prop_types75.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types75.default.number,
    valueFormatter: import_prop_types75.default.func
  }), import_prop_types75.default.shape({
    axis: import_prop_types75.default.oneOf(["x"]),
    classes: import_prop_types75.default.object,
    colorMap: import_prop_types75.default.oneOfType([import_prop_types75.default.shape({
      color: import_prop_types75.default.oneOfType([import_prop_types75.default.arrayOf(import_prop_types75.default.string.isRequired), import_prop_types75.default.func]).isRequired,
      max: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
      min: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
      type: import_prop_types75.default.oneOf(["continuous"]).isRequired
    }), import_prop_types75.default.shape({
      colors: import_prop_types75.default.arrayOf(import_prop_types75.default.string).isRequired,
      thresholds: import_prop_types75.default.arrayOf(import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]).isRequired).isRequired,
      type: import_prop_types75.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types75.default.array,
    dataKey: import_prop_types75.default.string,
    disableLine: import_prop_types75.default.bool,
    disableTicks: import_prop_types75.default.bool,
    domainLimit: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["nice", "strict"]), import_prop_types75.default.func]),
    fill: import_prop_types75.default.string,
    height: import_prop_types75.default.number,
    hideTooltip: import_prop_types75.default.bool,
    id: import_prop_types75.default.oneOfType([import_prop_types75.default.number, import_prop_types75.default.string]),
    ignoreTooltip: import_prop_types75.default.bool,
    label: import_prop_types75.default.string,
    labelStyle: import_prop_types75.default.object,
    max: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
    min: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
    offset: import_prop_types75.default.number,
    position: import_prop_types75.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types75.default.bool,
    scaleType: import_prop_types75.default.oneOf(["sqrt"]),
    slotProps: import_prop_types75.default.object,
    slots: import_prop_types75.default.object,
    stroke: import_prop_types75.default.string,
    sx: import_prop_types75.default.oneOfType([import_prop_types75.default.arrayOf(import_prop_types75.default.oneOfType([import_prop_types75.default.func, import_prop_types75.default.object, import_prop_types75.default.bool])), import_prop_types75.default.func, import_prop_types75.default.object]),
    tickInterval: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["auto"]), import_prop_types75.default.array, import_prop_types75.default.func]),
    tickLabelInterval: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["auto"]), import_prop_types75.default.func]),
    tickLabelMinGap: import_prop_types75.default.number,
    tickLabelPlacement: import_prop_types75.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types75.default.object,
    tickMaxStep: import_prop_types75.default.number,
    tickMinStep: import_prop_types75.default.number,
    tickNumber: import_prop_types75.default.number,
    tickPlacement: import_prop_types75.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types75.default.number,
    valueFormatter: import_prop_types75.default.func
  }), import_prop_types75.default.shape({
    axis: import_prop_types75.default.oneOf(["x"]),
    classes: import_prop_types75.default.object,
    colorMap: import_prop_types75.default.oneOfType([import_prop_types75.default.shape({
      color: import_prop_types75.default.oneOfType([import_prop_types75.default.arrayOf(import_prop_types75.default.string.isRequired), import_prop_types75.default.func]).isRequired,
      max: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
      min: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
      type: import_prop_types75.default.oneOf(["continuous"]).isRequired
    }), import_prop_types75.default.shape({
      colors: import_prop_types75.default.arrayOf(import_prop_types75.default.string).isRequired,
      thresholds: import_prop_types75.default.arrayOf(import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]).isRequired).isRequired,
      type: import_prop_types75.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types75.default.array,
    dataKey: import_prop_types75.default.string,
    disableLine: import_prop_types75.default.bool,
    disableTicks: import_prop_types75.default.bool,
    domainLimit: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["nice", "strict"]), import_prop_types75.default.func]),
    fill: import_prop_types75.default.string,
    height: import_prop_types75.default.number,
    hideTooltip: import_prop_types75.default.bool,
    id: import_prop_types75.default.oneOfType([import_prop_types75.default.number, import_prop_types75.default.string]),
    ignoreTooltip: import_prop_types75.default.bool,
    label: import_prop_types75.default.string,
    labelStyle: import_prop_types75.default.object,
    max: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
    min: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
    offset: import_prop_types75.default.number,
    position: import_prop_types75.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types75.default.bool,
    scaleType: import_prop_types75.default.oneOf(["time"]),
    slotProps: import_prop_types75.default.object,
    slots: import_prop_types75.default.object,
    stroke: import_prop_types75.default.string,
    sx: import_prop_types75.default.oneOfType([import_prop_types75.default.arrayOf(import_prop_types75.default.oneOfType([import_prop_types75.default.func, import_prop_types75.default.object, import_prop_types75.default.bool])), import_prop_types75.default.func, import_prop_types75.default.object]),
    tickInterval: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["auto"]), import_prop_types75.default.array, import_prop_types75.default.func]),
    tickLabelInterval: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["auto"]), import_prop_types75.default.func]),
    tickLabelMinGap: import_prop_types75.default.number,
    tickLabelPlacement: import_prop_types75.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types75.default.object,
    tickMaxStep: import_prop_types75.default.number,
    tickMinStep: import_prop_types75.default.number,
    tickNumber: import_prop_types75.default.number,
    tickPlacement: import_prop_types75.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types75.default.number,
    valueFormatter: import_prop_types75.default.func
  }), import_prop_types75.default.shape({
    axis: import_prop_types75.default.oneOf(["x"]),
    classes: import_prop_types75.default.object,
    colorMap: import_prop_types75.default.oneOfType([import_prop_types75.default.shape({
      color: import_prop_types75.default.oneOfType([import_prop_types75.default.arrayOf(import_prop_types75.default.string.isRequired), import_prop_types75.default.func]).isRequired,
      max: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
      min: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
      type: import_prop_types75.default.oneOf(["continuous"]).isRequired
    }), import_prop_types75.default.shape({
      colors: import_prop_types75.default.arrayOf(import_prop_types75.default.string).isRequired,
      thresholds: import_prop_types75.default.arrayOf(import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]).isRequired).isRequired,
      type: import_prop_types75.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types75.default.array,
    dataKey: import_prop_types75.default.string,
    disableLine: import_prop_types75.default.bool,
    disableTicks: import_prop_types75.default.bool,
    domainLimit: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["nice", "strict"]), import_prop_types75.default.func]),
    fill: import_prop_types75.default.string,
    height: import_prop_types75.default.number,
    hideTooltip: import_prop_types75.default.bool,
    id: import_prop_types75.default.oneOfType([import_prop_types75.default.number, import_prop_types75.default.string]),
    ignoreTooltip: import_prop_types75.default.bool,
    label: import_prop_types75.default.string,
    labelStyle: import_prop_types75.default.object,
    max: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
    min: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
    offset: import_prop_types75.default.number,
    position: import_prop_types75.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types75.default.bool,
    scaleType: import_prop_types75.default.oneOf(["utc"]),
    slotProps: import_prop_types75.default.object,
    slots: import_prop_types75.default.object,
    stroke: import_prop_types75.default.string,
    sx: import_prop_types75.default.oneOfType([import_prop_types75.default.arrayOf(import_prop_types75.default.oneOfType([import_prop_types75.default.func, import_prop_types75.default.object, import_prop_types75.default.bool])), import_prop_types75.default.func, import_prop_types75.default.object]),
    tickInterval: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["auto"]), import_prop_types75.default.array, import_prop_types75.default.func]),
    tickLabelInterval: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["auto"]), import_prop_types75.default.func]),
    tickLabelMinGap: import_prop_types75.default.number,
    tickLabelPlacement: import_prop_types75.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types75.default.object,
    tickMaxStep: import_prop_types75.default.number,
    tickMinStep: import_prop_types75.default.number,
    tickNumber: import_prop_types75.default.number,
    tickPlacement: import_prop_types75.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types75.default.number,
    valueFormatter: import_prop_types75.default.func
  }), import_prop_types75.default.shape({
    axis: import_prop_types75.default.oneOf(["x"]),
    classes: import_prop_types75.default.object,
    colorMap: import_prop_types75.default.oneOfType([import_prop_types75.default.shape({
      color: import_prop_types75.default.oneOfType([import_prop_types75.default.arrayOf(import_prop_types75.default.string.isRequired), import_prop_types75.default.func]).isRequired,
      max: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
      min: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
      type: import_prop_types75.default.oneOf(["continuous"]).isRequired
    }), import_prop_types75.default.shape({
      colors: import_prop_types75.default.arrayOf(import_prop_types75.default.string).isRequired,
      thresholds: import_prop_types75.default.arrayOf(import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]).isRequired).isRequired,
      type: import_prop_types75.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types75.default.array,
    dataKey: import_prop_types75.default.string,
    disableLine: import_prop_types75.default.bool,
    disableTicks: import_prop_types75.default.bool,
    domainLimit: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["nice", "strict"]), import_prop_types75.default.func]),
    fill: import_prop_types75.default.string,
    height: import_prop_types75.default.number,
    hideTooltip: import_prop_types75.default.bool,
    id: import_prop_types75.default.oneOfType([import_prop_types75.default.number, import_prop_types75.default.string]),
    ignoreTooltip: import_prop_types75.default.bool,
    label: import_prop_types75.default.string,
    labelStyle: import_prop_types75.default.object,
    max: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
    min: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
    offset: import_prop_types75.default.number,
    position: import_prop_types75.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types75.default.bool,
    scaleType: import_prop_types75.default.oneOf(["linear"]),
    slotProps: import_prop_types75.default.object,
    slots: import_prop_types75.default.object,
    stroke: import_prop_types75.default.string,
    sx: import_prop_types75.default.oneOfType([import_prop_types75.default.arrayOf(import_prop_types75.default.oneOfType([import_prop_types75.default.func, import_prop_types75.default.object, import_prop_types75.default.bool])), import_prop_types75.default.func, import_prop_types75.default.object]),
    tickInterval: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["auto"]), import_prop_types75.default.array, import_prop_types75.default.func]),
    tickLabelInterval: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["auto"]), import_prop_types75.default.func]),
    tickLabelMinGap: import_prop_types75.default.number,
    tickLabelPlacement: import_prop_types75.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types75.default.object,
    tickMaxStep: import_prop_types75.default.number,
    tickMinStep: import_prop_types75.default.number,
    tickNumber: import_prop_types75.default.number,
    tickPlacement: import_prop_types75.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types75.default.number,
    valueFormatter: import_prop_types75.default.func
  })]).isRequired),
  /**
   * The configuration of the y-axes.
   * If not provided, a default axis config is used.
   * An array of [[AxisConfig]] objects.
   */
  yAxis: import_prop_types75.default.arrayOf(import_prop_types75.default.oneOfType([import_prop_types75.default.shape({
    axis: import_prop_types75.default.oneOf(["y"]),
    barGapRatio: import_prop_types75.default.number,
    categoryGapRatio: import_prop_types75.default.number,
    classes: import_prop_types75.default.object,
    colorMap: import_prop_types75.default.oneOfType([import_prop_types75.default.shape({
      colors: import_prop_types75.default.arrayOf(import_prop_types75.default.string).isRequired,
      type: import_prop_types75.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types75.default.string,
      values: import_prop_types75.default.arrayOf(import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number, import_prop_types75.default.string]).isRequired)
    }), import_prop_types75.default.shape({
      color: import_prop_types75.default.oneOfType([import_prop_types75.default.arrayOf(import_prop_types75.default.string.isRequired), import_prop_types75.default.func]).isRequired,
      max: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
      min: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
      type: import_prop_types75.default.oneOf(["continuous"]).isRequired
    }), import_prop_types75.default.shape({
      colors: import_prop_types75.default.arrayOf(import_prop_types75.default.string).isRequired,
      thresholds: import_prop_types75.default.arrayOf(import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]).isRequired).isRequired,
      type: import_prop_types75.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types75.default.array,
    dataKey: import_prop_types75.default.string,
    disableLine: import_prop_types75.default.bool,
    disableTicks: import_prop_types75.default.bool,
    domainLimit: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["nice", "strict"]), import_prop_types75.default.func]),
    fill: import_prop_types75.default.string,
    hideTooltip: import_prop_types75.default.bool,
    id: import_prop_types75.default.oneOfType([import_prop_types75.default.number, import_prop_types75.default.string]),
    ignoreTooltip: import_prop_types75.default.bool,
    label: import_prop_types75.default.string,
    labelStyle: import_prop_types75.default.object,
    max: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
    min: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
    offset: import_prop_types75.default.number,
    position: import_prop_types75.default.oneOf(["left", "none", "right"]),
    reverse: import_prop_types75.default.bool,
    scaleType: import_prop_types75.default.oneOf(["band"]),
    slotProps: import_prop_types75.default.object,
    slots: import_prop_types75.default.object,
    stroke: import_prop_types75.default.string,
    sx: import_prop_types75.default.oneOfType([import_prop_types75.default.arrayOf(import_prop_types75.default.oneOfType([import_prop_types75.default.func, import_prop_types75.default.object, import_prop_types75.default.bool])), import_prop_types75.default.func, import_prop_types75.default.object]),
    tickInterval: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["auto"]), import_prop_types75.default.array, import_prop_types75.default.func]),
    tickLabelInterval: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["auto"]), import_prop_types75.default.func]),
    tickLabelPlacement: import_prop_types75.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types75.default.object,
    tickMaxStep: import_prop_types75.default.number,
    tickMinStep: import_prop_types75.default.number,
    tickNumber: import_prop_types75.default.number,
    tickPlacement: import_prop_types75.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types75.default.number,
    valueFormatter: import_prop_types75.default.func,
    width: import_prop_types75.default.number
  }), import_prop_types75.default.shape({
    axis: import_prop_types75.default.oneOf(["y"]),
    classes: import_prop_types75.default.object,
    colorMap: import_prop_types75.default.oneOfType([import_prop_types75.default.shape({
      colors: import_prop_types75.default.arrayOf(import_prop_types75.default.string).isRequired,
      type: import_prop_types75.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types75.default.string,
      values: import_prop_types75.default.arrayOf(import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number, import_prop_types75.default.string]).isRequired)
    }), import_prop_types75.default.shape({
      color: import_prop_types75.default.oneOfType([import_prop_types75.default.arrayOf(import_prop_types75.default.string.isRequired), import_prop_types75.default.func]).isRequired,
      max: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
      min: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
      type: import_prop_types75.default.oneOf(["continuous"]).isRequired
    }), import_prop_types75.default.shape({
      colors: import_prop_types75.default.arrayOf(import_prop_types75.default.string).isRequired,
      thresholds: import_prop_types75.default.arrayOf(import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]).isRequired).isRequired,
      type: import_prop_types75.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types75.default.array,
    dataKey: import_prop_types75.default.string,
    disableLine: import_prop_types75.default.bool,
    disableTicks: import_prop_types75.default.bool,
    domainLimit: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["nice", "strict"]), import_prop_types75.default.func]),
    fill: import_prop_types75.default.string,
    hideTooltip: import_prop_types75.default.bool,
    id: import_prop_types75.default.oneOfType([import_prop_types75.default.number, import_prop_types75.default.string]),
    ignoreTooltip: import_prop_types75.default.bool,
    label: import_prop_types75.default.string,
    labelStyle: import_prop_types75.default.object,
    max: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
    min: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
    offset: import_prop_types75.default.number,
    position: import_prop_types75.default.oneOf(["left", "none", "right"]),
    reverse: import_prop_types75.default.bool,
    scaleType: import_prop_types75.default.oneOf(["point"]),
    slotProps: import_prop_types75.default.object,
    slots: import_prop_types75.default.object,
    stroke: import_prop_types75.default.string,
    sx: import_prop_types75.default.oneOfType([import_prop_types75.default.arrayOf(import_prop_types75.default.oneOfType([import_prop_types75.default.func, import_prop_types75.default.object, import_prop_types75.default.bool])), import_prop_types75.default.func, import_prop_types75.default.object]),
    tickInterval: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["auto"]), import_prop_types75.default.array, import_prop_types75.default.func]),
    tickLabelInterval: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["auto"]), import_prop_types75.default.func]),
    tickLabelPlacement: import_prop_types75.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types75.default.object,
    tickMaxStep: import_prop_types75.default.number,
    tickMinStep: import_prop_types75.default.number,
    tickNumber: import_prop_types75.default.number,
    tickPlacement: import_prop_types75.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types75.default.number,
    valueFormatter: import_prop_types75.default.func,
    width: import_prop_types75.default.number
  }), import_prop_types75.default.shape({
    axis: import_prop_types75.default.oneOf(["y"]),
    classes: import_prop_types75.default.object,
    colorMap: import_prop_types75.default.oneOfType([import_prop_types75.default.shape({
      color: import_prop_types75.default.oneOfType([import_prop_types75.default.arrayOf(import_prop_types75.default.string.isRequired), import_prop_types75.default.func]).isRequired,
      max: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
      min: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
      type: import_prop_types75.default.oneOf(["continuous"]).isRequired
    }), import_prop_types75.default.shape({
      colors: import_prop_types75.default.arrayOf(import_prop_types75.default.string).isRequired,
      thresholds: import_prop_types75.default.arrayOf(import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]).isRequired).isRequired,
      type: import_prop_types75.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types75.default.array,
    dataKey: import_prop_types75.default.string,
    disableLine: import_prop_types75.default.bool,
    disableTicks: import_prop_types75.default.bool,
    domainLimit: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["nice", "strict"]), import_prop_types75.default.func]),
    fill: import_prop_types75.default.string,
    hideTooltip: import_prop_types75.default.bool,
    id: import_prop_types75.default.oneOfType([import_prop_types75.default.number, import_prop_types75.default.string]),
    ignoreTooltip: import_prop_types75.default.bool,
    label: import_prop_types75.default.string,
    labelStyle: import_prop_types75.default.object,
    max: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
    min: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
    offset: import_prop_types75.default.number,
    position: import_prop_types75.default.oneOf(["left", "none", "right"]),
    reverse: import_prop_types75.default.bool,
    scaleType: import_prop_types75.default.oneOf(["log"]),
    slotProps: import_prop_types75.default.object,
    slots: import_prop_types75.default.object,
    stroke: import_prop_types75.default.string,
    sx: import_prop_types75.default.oneOfType([import_prop_types75.default.arrayOf(import_prop_types75.default.oneOfType([import_prop_types75.default.func, import_prop_types75.default.object, import_prop_types75.default.bool])), import_prop_types75.default.func, import_prop_types75.default.object]),
    tickInterval: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["auto"]), import_prop_types75.default.array, import_prop_types75.default.func]),
    tickLabelInterval: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["auto"]), import_prop_types75.default.func]),
    tickLabelPlacement: import_prop_types75.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types75.default.object,
    tickMaxStep: import_prop_types75.default.number,
    tickMinStep: import_prop_types75.default.number,
    tickNumber: import_prop_types75.default.number,
    tickPlacement: import_prop_types75.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types75.default.number,
    valueFormatter: import_prop_types75.default.func,
    width: import_prop_types75.default.number
  }), import_prop_types75.default.shape({
    axis: import_prop_types75.default.oneOf(["y"]),
    classes: import_prop_types75.default.object,
    colorMap: import_prop_types75.default.oneOfType([import_prop_types75.default.shape({
      color: import_prop_types75.default.oneOfType([import_prop_types75.default.arrayOf(import_prop_types75.default.string.isRequired), import_prop_types75.default.func]).isRequired,
      max: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
      min: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
      type: import_prop_types75.default.oneOf(["continuous"]).isRequired
    }), import_prop_types75.default.shape({
      colors: import_prop_types75.default.arrayOf(import_prop_types75.default.string).isRequired,
      thresholds: import_prop_types75.default.arrayOf(import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]).isRequired).isRequired,
      type: import_prop_types75.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types75.default.array,
    dataKey: import_prop_types75.default.string,
    disableLine: import_prop_types75.default.bool,
    disableTicks: import_prop_types75.default.bool,
    domainLimit: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["nice", "strict"]), import_prop_types75.default.func]),
    fill: import_prop_types75.default.string,
    hideTooltip: import_prop_types75.default.bool,
    id: import_prop_types75.default.oneOfType([import_prop_types75.default.number, import_prop_types75.default.string]),
    ignoreTooltip: import_prop_types75.default.bool,
    label: import_prop_types75.default.string,
    labelStyle: import_prop_types75.default.object,
    max: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
    min: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
    offset: import_prop_types75.default.number,
    position: import_prop_types75.default.oneOf(["left", "none", "right"]),
    reverse: import_prop_types75.default.bool,
    scaleType: import_prop_types75.default.oneOf(["pow"]),
    slotProps: import_prop_types75.default.object,
    slots: import_prop_types75.default.object,
    stroke: import_prop_types75.default.string,
    sx: import_prop_types75.default.oneOfType([import_prop_types75.default.arrayOf(import_prop_types75.default.oneOfType([import_prop_types75.default.func, import_prop_types75.default.object, import_prop_types75.default.bool])), import_prop_types75.default.func, import_prop_types75.default.object]),
    tickInterval: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["auto"]), import_prop_types75.default.array, import_prop_types75.default.func]),
    tickLabelInterval: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["auto"]), import_prop_types75.default.func]),
    tickLabelPlacement: import_prop_types75.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types75.default.object,
    tickMaxStep: import_prop_types75.default.number,
    tickMinStep: import_prop_types75.default.number,
    tickNumber: import_prop_types75.default.number,
    tickPlacement: import_prop_types75.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types75.default.number,
    valueFormatter: import_prop_types75.default.func,
    width: import_prop_types75.default.number
  }), import_prop_types75.default.shape({
    axis: import_prop_types75.default.oneOf(["y"]),
    classes: import_prop_types75.default.object,
    colorMap: import_prop_types75.default.oneOfType([import_prop_types75.default.shape({
      color: import_prop_types75.default.oneOfType([import_prop_types75.default.arrayOf(import_prop_types75.default.string.isRequired), import_prop_types75.default.func]).isRequired,
      max: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
      min: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
      type: import_prop_types75.default.oneOf(["continuous"]).isRequired
    }), import_prop_types75.default.shape({
      colors: import_prop_types75.default.arrayOf(import_prop_types75.default.string).isRequired,
      thresholds: import_prop_types75.default.arrayOf(import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]).isRequired).isRequired,
      type: import_prop_types75.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types75.default.array,
    dataKey: import_prop_types75.default.string,
    disableLine: import_prop_types75.default.bool,
    disableTicks: import_prop_types75.default.bool,
    domainLimit: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["nice", "strict"]), import_prop_types75.default.func]),
    fill: import_prop_types75.default.string,
    hideTooltip: import_prop_types75.default.bool,
    id: import_prop_types75.default.oneOfType([import_prop_types75.default.number, import_prop_types75.default.string]),
    ignoreTooltip: import_prop_types75.default.bool,
    label: import_prop_types75.default.string,
    labelStyle: import_prop_types75.default.object,
    max: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
    min: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
    offset: import_prop_types75.default.number,
    position: import_prop_types75.default.oneOf(["left", "none", "right"]),
    reverse: import_prop_types75.default.bool,
    scaleType: import_prop_types75.default.oneOf(["sqrt"]),
    slotProps: import_prop_types75.default.object,
    slots: import_prop_types75.default.object,
    stroke: import_prop_types75.default.string,
    sx: import_prop_types75.default.oneOfType([import_prop_types75.default.arrayOf(import_prop_types75.default.oneOfType([import_prop_types75.default.func, import_prop_types75.default.object, import_prop_types75.default.bool])), import_prop_types75.default.func, import_prop_types75.default.object]),
    tickInterval: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["auto"]), import_prop_types75.default.array, import_prop_types75.default.func]),
    tickLabelInterval: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["auto"]), import_prop_types75.default.func]),
    tickLabelPlacement: import_prop_types75.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types75.default.object,
    tickMaxStep: import_prop_types75.default.number,
    tickMinStep: import_prop_types75.default.number,
    tickNumber: import_prop_types75.default.number,
    tickPlacement: import_prop_types75.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types75.default.number,
    valueFormatter: import_prop_types75.default.func,
    width: import_prop_types75.default.number
  }), import_prop_types75.default.shape({
    axis: import_prop_types75.default.oneOf(["y"]),
    classes: import_prop_types75.default.object,
    colorMap: import_prop_types75.default.oneOfType([import_prop_types75.default.shape({
      color: import_prop_types75.default.oneOfType([import_prop_types75.default.arrayOf(import_prop_types75.default.string.isRequired), import_prop_types75.default.func]).isRequired,
      max: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
      min: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
      type: import_prop_types75.default.oneOf(["continuous"]).isRequired
    }), import_prop_types75.default.shape({
      colors: import_prop_types75.default.arrayOf(import_prop_types75.default.string).isRequired,
      thresholds: import_prop_types75.default.arrayOf(import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]).isRequired).isRequired,
      type: import_prop_types75.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types75.default.array,
    dataKey: import_prop_types75.default.string,
    disableLine: import_prop_types75.default.bool,
    disableTicks: import_prop_types75.default.bool,
    domainLimit: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["nice", "strict"]), import_prop_types75.default.func]),
    fill: import_prop_types75.default.string,
    hideTooltip: import_prop_types75.default.bool,
    id: import_prop_types75.default.oneOfType([import_prop_types75.default.number, import_prop_types75.default.string]),
    ignoreTooltip: import_prop_types75.default.bool,
    label: import_prop_types75.default.string,
    labelStyle: import_prop_types75.default.object,
    max: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
    min: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
    offset: import_prop_types75.default.number,
    position: import_prop_types75.default.oneOf(["left", "none", "right"]),
    reverse: import_prop_types75.default.bool,
    scaleType: import_prop_types75.default.oneOf(["time"]),
    slotProps: import_prop_types75.default.object,
    slots: import_prop_types75.default.object,
    stroke: import_prop_types75.default.string,
    sx: import_prop_types75.default.oneOfType([import_prop_types75.default.arrayOf(import_prop_types75.default.oneOfType([import_prop_types75.default.func, import_prop_types75.default.object, import_prop_types75.default.bool])), import_prop_types75.default.func, import_prop_types75.default.object]),
    tickInterval: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["auto"]), import_prop_types75.default.array, import_prop_types75.default.func]),
    tickLabelInterval: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["auto"]), import_prop_types75.default.func]),
    tickLabelPlacement: import_prop_types75.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types75.default.object,
    tickMaxStep: import_prop_types75.default.number,
    tickMinStep: import_prop_types75.default.number,
    tickNumber: import_prop_types75.default.number,
    tickPlacement: import_prop_types75.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types75.default.number,
    valueFormatter: import_prop_types75.default.func,
    width: import_prop_types75.default.number
  }), import_prop_types75.default.shape({
    axis: import_prop_types75.default.oneOf(["y"]),
    classes: import_prop_types75.default.object,
    colorMap: import_prop_types75.default.oneOfType([import_prop_types75.default.shape({
      color: import_prop_types75.default.oneOfType([import_prop_types75.default.arrayOf(import_prop_types75.default.string.isRequired), import_prop_types75.default.func]).isRequired,
      max: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
      min: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
      type: import_prop_types75.default.oneOf(["continuous"]).isRequired
    }), import_prop_types75.default.shape({
      colors: import_prop_types75.default.arrayOf(import_prop_types75.default.string).isRequired,
      thresholds: import_prop_types75.default.arrayOf(import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]).isRequired).isRequired,
      type: import_prop_types75.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types75.default.array,
    dataKey: import_prop_types75.default.string,
    disableLine: import_prop_types75.default.bool,
    disableTicks: import_prop_types75.default.bool,
    domainLimit: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["nice", "strict"]), import_prop_types75.default.func]),
    fill: import_prop_types75.default.string,
    hideTooltip: import_prop_types75.default.bool,
    id: import_prop_types75.default.oneOfType([import_prop_types75.default.number, import_prop_types75.default.string]),
    ignoreTooltip: import_prop_types75.default.bool,
    label: import_prop_types75.default.string,
    labelStyle: import_prop_types75.default.object,
    max: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
    min: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
    offset: import_prop_types75.default.number,
    position: import_prop_types75.default.oneOf(["left", "none", "right"]),
    reverse: import_prop_types75.default.bool,
    scaleType: import_prop_types75.default.oneOf(["utc"]),
    slotProps: import_prop_types75.default.object,
    slots: import_prop_types75.default.object,
    stroke: import_prop_types75.default.string,
    sx: import_prop_types75.default.oneOfType([import_prop_types75.default.arrayOf(import_prop_types75.default.oneOfType([import_prop_types75.default.func, import_prop_types75.default.object, import_prop_types75.default.bool])), import_prop_types75.default.func, import_prop_types75.default.object]),
    tickInterval: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["auto"]), import_prop_types75.default.array, import_prop_types75.default.func]),
    tickLabelInterval: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["auto"]), import_prop_types75.default.func]),
    tickLabelPlacement: import_prop_types75.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types75.default.object,
    tickMaxStep: import_prop_types75.default.number,
    tickMinStep: import_prop_types75.default.number,
    tickNumber: import_prop_types75.default.number,
    tickPlacement: import_prop_types75.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types75.default.number,
    valueFormatter: import_prop_types75.default.func,
    width: import_prop_types75.default.number
  }), import_prop_types75.default.shape({
    axis: import_prop_types75.default.oneOf(["y"]),
    classes: import_prop_types75.default.object,
    colorMap: import_prop_types75.default.oneOfType([import_prop_types75.default.shape({
      color: import_prop_types75.default.oneOfType([import_prop_types75.default.arrayOf(import_prop_types75.default.string.isRequired), import_prop_types75.default.func]).isRequired,
      max: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
      min: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
      type: import_prop_types75.default.oneOf(["continuous"]).isRequired
    }), import_prop_types75.default.shape({
      colors: import_prop_types75.default.arrayOf(import_prop_types75.default.string).isRequired,
      thresholds: import_prop_types75.default.arrayOf(import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]).isRequired).isRequired,
      type: import_prop_types75.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types75.default.array,
    dataKey: import_prop_types75.default.string,
    disableLine: import_prop_types75.default.bool,
    disableTicks: import_prop_types75.default.bool,
    domainLimit: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["nice", "strict"]), import_prop_types75.default.func]),
    fill: import_prop_types75.default.string,
    hideTooltip: import_prop_types75.default.bool,
    id: import_prop_types75.default.oneOfType([import_prop_types75.default.number, import_prop_types75.default.string]),
    ignoreTooltip: import_prop_types75.default.bool,
    label: import_prop_types75.default.string,
    labelStyle: import_prop_types75.default.object,
    max: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
    min: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
    offset: import_prop_types75.default.number,
    position: import_prop_types75.default.oneOf(["left", "none", "right"]),
    reverse: import_prop_types75.default.bool,
    scaleType: import_prop_types75.default.oneOf(["linear"]),
    slotProps: import_prop_types75.default.object,
    slots: import_prop_types75.default.object,
    stroke: import_prop_types75.default.string,
    sx: import_prop_types75.default.oneOfType([import_prop_types75.default.arrayOf(import_prop_types75.default.oneOfType([import_prop_types75.default.func, import_prop_types75.default.object, import_prop_types75.default.bool])), import_prop_types75.default.func, import_prop_types75.default.object]),
    tickInterval: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["auto"]), import_prop_types75.default.array, import_prop_types75.default.func]),
    tickLabelInterval: import_prop_types75.default.oneOfType([import_prop_types75.default.oneOf(["auto"]), import_prop_types75.default.func]),
    tickLabelPlacement: import_prop_types75.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types75.default.object,
    tickMaxStep: import_prop_types75.default.number,
    tickMinStep: import_prop_types75.default.number,
    tickNumber: import_prop_types75.default.number,
    tickPlacement: import_prop_types75.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types75.default.number,
    valueFormatter: import_prop_types75.default.func,
    width: import_prop_types75.default.number
  })]).isRequired),
  /**
   * The configuration of the z-axes.
   */
  zAxis: import_prop_types75.default.arrayOf(import_prop_types75.default.shape({
    colorMap: import_prop_types75.default.oneOfType([import_prop_types75.default.shape({
      colors: import_prop_types75.default.arrayOf(import_prop_types75.default.string).isRequired,
      type: import_prop_types75.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types75.default.string,
      values: import_prop_types75.default.arrayOf(import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number, import_prop_types75.default.string]).isRequired)
    }), import_prop_types75.default.shape({
      color: import_prop_types75.default.oneOfType([import_prop_types75.default.arrayOf(import_prop_types75.default.string.isRequired), import_prop_types75.default.func]).isRequired,
      max: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
      min: import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]),
      type: import_prop_types75.default.oneOf(["continuous"]).isRequired
    }), import_prop_types75.default.shape({
      colors: import_prop_types75.default.arrayOf(import_prop_types75.default.string).isRequired,
      thresholds: import_prop_types75.default.arrayOf(import_prop_types75.default.oneOfType([import_prop_types75.default.instanceOf(Date), import_prop_types75.default.number]).isRequired).isRequired,
      type: import_prop_types75.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types75.default.array,
    dataKey: import_prop_types75.default.string,
    id: import_prop_types75.default.string,
    max: import_prop_types75.default.number,
    min: import_prop_types75.default.number
  }))
} : void 0;

// node_modules/@mui/x-charts/esm/SparkLineChart/SparkLineChart.js
var import_jsx_runtime92 = __toESM(require_jsx_runtime(), 1);
var _excluded51 = ["xAxis", "yAxis", "width", "height", "margin", "color", "sx", "showTooltip", "showHighlight", "axisHighlight", "children", "slots", "slotProps", "data", "plotType", "valueFormatter", "area", "curve", "className", "disableClipping", "clipAreaOffset"];
var SPARK_LINE_DEFAULT_MARGIN = 5;
var SparkLineChart = React134.forwardRef(function SparkLineChart2(props, ref) {
  var _a, _b, _c;
  const {
    xAxis,
    yAxis,
    width: width2,
    height: height2,
    margin: margin2 = SPARK_LINE_DEFAULT_MARGIN,
    color: color3,
    sx,
    showTooltip,
    showHighlight,
    axisHighlight: inAxisHighlight,
    children: children2,
    slots,
    slotProps,
    data,
    plotType = "line",
    valueFormatter = (value) => value === null ? "" : value.toString(),
    area,
    curve = "linear",
    className,
    disableClipping,
    clipAreaOffset
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded51);
  const id = useId();
  const clipPathId = `${id}-clip-path`;
  const clipPathOffset = {
    top: (clipAreaOffset == null ? void 0 : clipAreaOffset.top) ?? 1,
    right: (clipAreaOffset == null ? void 0 : clipAreaOffset.right) ?? 1,
    bottom: (clipAreaOffset == null ? void 0 : clipAreaOffset.bottom) ?? 1,
    left: (clipAreaOffset == null ? void 0 : clipAreaOffset.left) ?? 1
  };
  const defaultXHighlight = showHighlight && plotType === "bar" ? {
    x: "band"
  } : {
    x: "none"
  };
  const axisHighlight = _extends({}, defaultXHighlight, inAxisHighlight);
  const Tooltip = ((_a = props.slots) == null ? void 0 : _a.tooltip) ?? ChartsTooltip;
  const colors = React134.useMemo(() => {
    if (color3 == null) {
      return void 0;
    }
    return typeof color3 === "function" ? (mode2) => [color3(mode2)] : [color3];
  }, [color3]);
  return (0, import_jsx_runtime92.jsxs)(ChartContainer, _extends({}, other, {
    ref,
    series: [_extends({
      type: plotType,
      data,
      valueFormatter
    }, plotType === "bar" ? {} : {
      area,
      curve,
      disableHighlight: !showHighlight
    })],
    width: width2,
    height: height2,
    margin: margin2,
    className,
    xAxis: [_extends({
      id: DEFAULT_X_AXIS_KEY,
      scaleType: plotType === "bar" ? "band" : "point",
      data: Array.from({
        length: data.length
      }, (_2, index2) => index2),
      hideTooltip: xAxis === void 0
    }, xAxis, {
      position: "none"
    })],
    yAxis: [_extends({
      id: DEFAULT_Y_AXIS_KEY
    }, yAxis, {
      position: "none"
    })],
    colors,
    sx,
    disableAxisListener: (!showTooltip || ((_b = slotProps == null ? void 0 : slotProps.tooltip) == null ? void 0 : _b.trigger) !== "axis") && (axisHighlight == null ? void 0 : axisHighlight.x) === "none" && (axisHighlight == null ? void 0 : axisHighlight.y) === "none",
    children: [(0, import_jsx_runtime92.jsxs)("g", {
      clipPath: `url(#${clipPathId})`,
      children: [plotType === "bar" && (0, import_jsx_runtime92.jsx)(BarPlot, {
        skipAnimation: true,
        slots,
        slotProps
      }), plotType === "line" && (0, import_jsx_runtime92.jsxs)(React134.Fragment, {
        children: [(0, import_jsx_runtime92.jsx)(AreaPlot, {
          skipAnimation: true,
          slots,
          slotProps
        }), (0, import_jsx_runtime92.jsx)(LinePlot, {
          skipAnimation: true,
          slots,
          slotProps
        })]
      })]
    }), plotType === "line" && (0, import_jsx_runtime92.jsx)(LineHighlightPlot, {
      slots,
      slotProps
    }), disableClipping ? null : (0, import_jsx_runtime92.jsx)(ChartsClipPath, {
      id: clipPathId,
      offset: clipPathOffset
    }), (0, import_jsx_runtime92.jsx)(ChartsAxisHighlight, _extends({}, axisHighlight)), showTooltip && (0, import_jsx_runtime92.jsx)(Tooltip, _extends({}, (_c = props.slotProps) == null ? void 0 : _c.tooltip)), children2]
  }));
});
true ? SparkLineChart.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  apiRef: import_prop_types76.default.shape({
    current: import_prop_types76.default.object
  }),
  /**
   * Set to `true` to fill spark line area.
   * Has no effect if plotType='bar'.
   * @default false
   */
  area: import_prop_types76.default.bool,
  axisHighlight: import_prop_types76.default.shape({
    x: import_prop_types76.default.oneOf(["band", "line", "none"]),
    y: import_prop_types76.default.oneOf(["band", "line", "none"])
  }),
  children: import_prop_types76.default.node,
  className: import_prop_types76.default.string,
  /**
   * The clipped area offset in pixels.
   *
   * This prevents partial clipping of lines when they are drawn on the edge of the drawing area.
   *
   * @default { top: 1, right: 1, bottom: 1, left: 1 }
   */
  clipAreaOffset: import_prop_types76.default.shape({
    bottom: import_prop_types76.default.number,
    left: import_prop_types76.default.number,
    right: import_prop_types76.default.number,
    top: import_prop_types76.default.number
  }),
  /**
   * Color used to colorize the sparkline.
   * @default rainbowSurgePalette[0]
   */
  color: import_prop_types76.default.oneOfType([import_prop_types76.default.func, import_prop_types76.default.string]),
  /**
   * @default 'linear'
   */
  curve: import_prop_types76.default.oneOf(["bumpX", "bumpY", "catmullRom", "linear", "monotoneX", "monotoneY", "natural", "step", "stepAfter", "stepBefore"]),
  /**
   * Data to plot.
   */
  data: import_prop_types76.default.arrayOf(import_prop_types76.default.number).isRequired,
  /**
   * An array of objects that can be used to populate series and axes data using their `dataKey` property.
   */
  dataset: import_prop_types76.default.arrayOf(import_prop_types76.default.object),
  desc: import_prop_types76.default.string,
  /**
   * If `true`, the charts will not listen to the mouse move event.
   * It might break interactive features, but will improve performance.
   * @default false
   */
  disableAxisListener: import_prop_types76.default.bool,
  /**
   * When `true`, the chart's drawing area will not be clipped and elements within can visually overflow the chart.
   *
   * @default false
   */
  disableClipping: import_prop_types76.default.bool,
  /**
   * If true, the voronoi interaction are ignored.
   */
  disableVoronoi: import_prop_types76.default.bool,
  /**
   * The height of the chart in px. If not defined, it takes the height of the parent element.
   */
  height: import_prop_types76.default.number,
  /**
   * The highlighted item.
   * Used when the highlight is controlled.
   */
  highlightedItem: import_prop_types76.default.shape({
    dataIndex: import_prop_types76.default.number,
    seriesId: import_prop_types76.default.oneOfType([import_prop_types76.default.number, import_prop_types76.default.string]).isRequired
  }),
  /**
   * This prop is used to help implement the accessibility logic.
   * If you don't provide this prop. It falls back to a randomly generated id.
   */
  id: import_prop_types76.default.string,
  /**
   * Localized text for chart components.
   */
  localeText: import_prop_types76.default.object,
  /**
   * The margin between the SVG and the drawing area.
   * It's used for leaving some space for extra information such as the x- and y-axis or legend.
   *
   * Accepts a `number` to be used on all sides or an object with the optional properties: `top`, `bottom`, `left`, and `right`.
   * @default 5
   */
  margin: import_prop_types76.default.oneOfType([import_prop_types76.default.number, import_prop_types76.default.shape({
    bottom: import_prop_types76.default.number,
    left: import_prop_types76.default.number,
    right: import_prop_types76.default.number,
    top: import_prop_types76.default.number
  })]),
  /**
   * The function called for onClick events.
   * The second argument contains information about all line/bar elements at the current mouse position.
   * @param {MouseEvent} event The mouse event recorded on the `<svg/>` element.
   * @param {null | ChartsAxisData} data The data about the clicked axis and items associated with it.
   */
  onAxisClick: import_prop_types76.default.func,
  /**
   * The callback fired when the highlighted item changes.
   *
   * @param {HighlightItemData | null} highlightedItem  The newly highlighted item.
   */
  onHighlightChange: import_prop_types76.default.func,
  /**
   * Callback fired when clicking close to an item.
   * This is only available for scatter plot for now.
   * @param {MouseEvent} event Mouse event caught at the svg level
   * @param {ScatterItemIdentifier} scatterItemIdentifier Identify which item got clicked
   */
  onItemClick: import_prop_types76.default.func,
  /**
   * Type of plot used.
   * @default 'line'
   */
  plotType: import_prop_types76.default.oneOf(["bar", "line"]),
  /**
   * Set to `true` to highlight the value.
   * With line, it shows a point.
   * With bar, it shows a highlight band.
   * @default false
   */
  showHighlight: import_prop_types76.default.bool,
  /**
   * Set to `true` to enable the tooltip in the sparkline.
   * @default false
   */
  showTooltip: import_prop_types76.default.bool,
  /**
   * If `true`, animations are skipped.
   * If unset or `false`, the animations respects the user's `prefers-reduced-motion` setting.
   */
  skipAnimation: import_prop_types76.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types76.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types76.default.object,
  sx: import_prop_types76.default.oneOfType([import_prop_types76.default.arrayOf(import_prop_types76.default.oneOfType([import_prop_types76.default.func, import_prop_types76.default.object, import_prop_types76.default.bool])), import_prop_types76.default.func, import_prop_types76.default.object]),
  theme: import_prop_types76.default.oneOf(["dark", "light"]),
  title: import_prop_types76.default.string,
  /**
   * Formatter used by the tooltip.
   * @param {number} value The value to format.
   * @returns {string} the formatted value.
   * @default (value: number | null) => (value === null ? '' : value.toString())
   */
  valueFormatter: import_prop_types76.default.func,
  /**
   * Defines the maximal distance between a scatter point and the pointer that triggers the interaction.
   * If `undefined`, the radius is assumed to be infinite.
   */
  voronoiMaxRadius: import_prop_types76.default.number,
  /**
   * The width of the chart in px. If not defined, it takes the width of the parent element.
   */
  width: import_prop_types76.default.number,
  /**
   * The xAxis configuration.
   * Notice it is a single [[AxisConfig]] object, not an array of configuration.
   */
  xAxis: import_prop_types76.default.oneOfType([import_prop_types76.default.shape({
    axis: import_prop_types76.default.oneOf(["x"]),
    barGapRatio: import_prop_types76.default.number,
    categoryGapRatio: import_prop_types76.default.number,
    classes: import_prop_types76.default.object,
    colorMap: import_prop_types76.default.oneOfType([import_prop_types76.default.shape({
      colors: import_prop_types76.default.arrayOf(import_prop_types76.default.string).isRequired,
      type: import_prop_types76.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types76.default.string,
      values: import_prop_types76.default.arrayOf(import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number, import_prop_types76.default.string]).isRequired)
    }), import_prop_types76.default.shape({
      color: import_prop_types76.default.oneOfType([import_prop_types76.default.arrayOf(import_prop_types76.default.string.isRequired), import_prop_types76.default.func]).isRequired,
      max: import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]),
      min: import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]),
      type: import_prop_types76.default.oneOf(["continuous"]).isRequired
    }), import_prop_types76.default.shape({
      colors: import_prop_types76.default.arrayOf(import_prop_types76.default.string).isRequired,
      thresholds: import_prop_types76.default.arrayOf(import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]).isRequired).isRequired,
      type: import_prop_types76.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types76.default.array,
    dataKey: import_prop_types76.default.string,
    disableLine: import_prop_types76.default.bool,
    disableTicks: import_prop_types76.default.bool,
    domainLimit: import_prop_types76.default.oneOfType([import_prop_types76.default.oneOf(["nice", "strict"]), import_prop_types76.default.func]),
    fill: import_prop_types76.default.string,
    height: import_prop_types76.default.number,
    hideTooltip: import_prop_types76.default.bool,
    id: import_prop_types76.default.oneOfType([import_prop_types76.default.number, import_prop_types76.default.string]),
    ignoreTooltip: import_prop_types76.default.bool,
    label: import_prop_types76.default.string,
    labelStyle: import_prop_types76.default.object,
    max: import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]),
    min: import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]),
    offset: import_prop_types76.default.number,
    position: import_prop_types76.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types76.default.bool,
    scaleType: import_prop_types76.default.oneOf(["band"]),
    slotProps: import_prop_types76.default.object,
    slots: import_prop_types76.default.object,
    stroke: import_prop_types76.default.string,
    sx: import_prop_types76.default.oneOfType([import_prop_types76.default.arrayOf(import_prop_types76.default.oneOfType([import_prop_types76.default.func, import_prop_types76.default.object, import_prop_types76.default.bool])), import_prop_types76.default.func, import_prop_types76.default.object]),
    tickInterval: import_prop_types76.default.oneOfType([import_prop_types76.default.oneOf(["auto"]), import_prop_types76.default.array, import_prop_types76.default.func]),
    tickLabelInterval: import_prop_types76.default.oneOfType([import_prop_types76.default.oneOf(["auto"]), import_prop_types76.default.func]),
    tickLabelMinGap: import_prop_types76.default.number,
    tickLabelPlacement: import_prop_types76.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types76.default.object,
    tickMaxStep: import_prop_types76.default.number,
    tickMinStep: import_prop_types76.default.number,
    tickNumber: import_prop_types76.default.number,
    tickPlacement: import_prop_types76.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types76.default.number,
    valueFormatter: import_prop_types76.default.func
  }), import_prop_types76.default.shape({
    axis: import_prop_types76.default.oneOf(["x"]),
    classes: import_prop_types76.default.object,
    colorMap: import_prop_types76.default.oneOfType([import_prop_types76.default.shape({
      colors: import_prop_types76.default.arrayOf(import_prop_types76.default.string).isRequired,
      type: import_prop_types76.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types76.default.string,
      values: import_prop_types76.default.arrayOf(import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number, import_prop_types76.default.string]).isRequired)
    }), import_prop_types76.default.shape({
      color: import_prop_types76.default.oneOfType([import_prop_types76.default.arrayOf(import_prop_types76.default.string.isRequired), import_prop_types76.default.func]).isRequired,
      max: import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]),
      min: import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]),
      type: import_prop_types76.default.oneOf(["continuous"]).isRequired
    }), import_prop_types76.default.shape({
      colors: import_prop_types76.default.arrayOf(import_prop_types76.default.string).isRequired,
      thresholds: import_prop_types76.default.arrayOf(import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]).isRequired).isRequired,
      type: import_prop_types76.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types76.default.array,
    dataKey: import_prop_types76.default.string,
    disableLine: import_prop_types76.default.bool,
    disableTicks: import_prop_types76.default.bool,
    domainLimit: import_prop_types76.default.oneOfType([import_prop_types76.default.oneOf(["nice", "strict"]), import_prop_types76.default.func]),
    fill: import_prop_types76.default.string,
    height: import_prop_types76.default.number,
    hideTooltip: import_prop_types76.default.bool,
    id: import_prop_types76.default.oneOfType([import_prop_types76.default.number, import_prop_types76.default.string]),
    ignoreTooltip: import_prop_types76.default.bool,
    label: import_prop_types76.default.string,
    labelStyle: import_prop_types76.default.object,
    max: import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]),
    min: import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]),
    offset: import_prop_types76.default.number,
    position: import_prop_types76.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types76.default.bool,
    scaleType: import_prop_types76.default.oneOf(["point"]),
    slotProps: import_prop_types76.default.object,
    slots: import_prop_types76.default.object,
    stroke: import_prop_types76.default.string,
    sx: import_prop_types76.default.oneOfType([import_prop_types76.default.arrayOf(import_prop_types76.default.oneOfType([import_prop_types76.default.func, import_prop_types76.default.object, import_prop_types76.default.bool])), import_prop_types76.default.func, import_prop_types76.default.object]),
    tickInterval: import_prop_types76.default.oneOfType([import_prop_types76.default.oneOf(["auto"]), import_prop_types76.default.array, import_prop_types76.default.func]),
    tickLabelInterval: import_prop_types76.default.oneOfType([import_prop_types76.default.oneOf(["auto"]), import_prop_types76.default.func]),
    tickLabelMinGap: import_prop_types76.default.number,
    tickLabelPlacement: import_prop_types76.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types76.default.object,
    tickMaxStep: import_prop_types76.default.number,
    tickMinStep: import_prop_types76.default.number,
    tickNumber: import_prop_types76.default.number,
    tickPlacement: import_prop_types76.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types76.default.number,
    valueFormatter: import_prop_types76.default.func
  }), import_prop_types76.default.shape({
    axis: import_prop_types76.default.oneOf(["x"]),
    classes: import_prop_types76.default.object,
    colorMap: import_prop_types76.default.oneOfType([import_prop_types76.default.shape({
      color: import_prop_types76.default.oneOfType([import_prop_types76.default.arrayOf(import_prop_types76.default.string.isRequired), import_prop_types76.default.func]).isRequired,
      max: import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]),
      min: import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]),
      type: import_prop_types76.default.oneOf(["continuous"]).isRequired
    }), import_prop_types76.default.shape({
      colors: import_prop_types76.default.arrayOf(import_prop_types76.default.string).isRequired,
      thresholds: import_prop_types76.default.arrayOf(import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]).isRequired).isRequired,
      type: import_prop_types76.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types76.default.array,
    dataKey: import_prop_types76.default.string,
    disableLine: import_prop_types76.default.bool,
    disableTicks: import_prop_types76.default.bool,
    domainLimit: import_prop_types76.default.oneOfType([import_prop_types76.default.oneOf(["nice", "strict"]), import_prop_types76.default.func]),
    fill: import_prop_types76.default.string,
    height: import_prop_types76.default.number,
    hideTooltip: import_prop_types76.default.bool,
    id: import_prop_types76.default.oneOfType([import_prop_types76.default.number, import_prop_types76.default.string]),
    ignoreTooltip: import_prop_types76.default.bool,
    label: import_prop_types76.default.string,
    labelStyle: import_prop_types76.default.object,
    max: import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]),
    min: import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]),
    offset: import_prop_types76.default.number,
    position: import_prop_types76.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types76.default.bool,
    scaleType: import_prop_types76.default.oneOf(["log"]),
    slotProps: import_prop_types76.default.object,
    slots: import_prop_types76.default.object,
    stroke: import_prop_types76.default.string,
    sx: import_prop_types76.default.oneOfType([import_prop_types76.default.arrayOf(import_prop_types76.default.oneOfType([import_prop_types76.default.func, import_prop_types76.default.object, import_prop_types76.default.bool])), import_prop_types76.default.func, import_prop_types76.default.object]),
    tickInterval: import_prop_types76.default.oneOfType([import_prop_types76.default.oneOf(["auto"]), import_prop_types76.default.array, import_prop_types76.default.func]),
    tickLabelInterval: import_prop_types76.default.oneOfType([import_prop_types76.default.oneOf(["auto"]), import_prop_types76.default.func]),
    tickLabelMinGap: import_prop_types76.default.number,
    tickLabelPlacement: import_prop_types76.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types76.default.object,
    tickMaxStep: import_prop_types76.default.number,
    tickMinStep: import_prop_types76.default.number,
    tickNumber: import_prop_types76.default.number,
    tickPlacement: import_prop_types76.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types76.default.number,
    valueFormatter: import_prop_types76.default.func
  }), import_prop_types76.default.shape({
    axis: import_prop_types76.default.oneOf(["x"]),
    classes: import_prop_types76.default.object,
    colorMap: import_prop_types76.default.oneOfType([import_prop_types76.default.shape({
      color: import_prop_types76.default.oneOfType([import_prop_types76.default.arrayOf(import_prop_types76.default.string.isRequired), import_prop_types76.default.func]).isRequired,
      max: import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]),
      min: import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]),
      type: import_prop_types76.default.oneOf(["continuous"]).isRequired
    }), import_prop_types76.default.shape({
      colors: import_prop_types76.default.arrayOf(import_prop_types76.default.string).isRequired,
      thresholds: import_prop_types76.default.arrayOf(import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]).isRequired).isRequired,
      type: import_prop_types76.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types76.default.array,
    dataKey: import_prop_types76.default.string,
    disableLine: import_prop_types76.default.bool,
    disableTicks: import_prop_types76.default.bool,
    domainLimit: import_prop_types76.default.oneOfType([import_prop_types76.default.oneOf(["nice", "strict"]), import_prop_types76.default.func]),
    fill: import_prop_types76.default.string,
    height: import_prop_types76.default.number,
    hideTooltip: import_prop_types76.default.bool,
    id: import_prop_types76.default.oneOfType([import_prop_types76.default.number, import_prop_types76.default.string]),
    ignoreTooltip: import_prop_types76.default.bool,
    label: import_prop_types76.default.string,
    labelStyle: import_prop_types76.default.object,
    max: import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]),
    min: import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]),
    offset: import_prop_types76.default.number,
    position: import_prop_types76.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types76.default.bool,
    scaleType: import_prop_types76.default.oneOf(["pow"]),
    slotProps: import_prop_types76.default.object,
    slots: import_prop_types76.default.object,
    stroke: import_prop_types76.default.string,
    sx: import_prop_types76.default.oneOfType([import_prop_types76.default.arrayOf(import_prop_types76.default.oneOfType([import_prop_types76.default.func, import_prop_types76.default.object, import_prop_types76.default.bool])), import_prop_types76.default.func, import_prop_types76.default.object]),
    tickInterval: import_prop_types76.default.oneOfType([import_prop_types76.default.oneOf(["auto"]), import_prop_types76.default.array, import_prop_types76.default.func]),
    tickLabelInterval: import_prop_types76.default.oneOfType([import_prop_types76.default.oneOf(["auto"]), import_prop_types76.default.func]),
    tickLabelMinGap: import_prop_types76.default.number,
    tickLabelPlacement: import_prop_types76.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types76.default.object,
    tickMaxStep: import_prop_types76.default.number,
    tickMinStep: import_prop_types76.default.number,
    tickNumber: import_prop_types76.default.number,
    tickPlacement: import_prop_types76.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types76.default.number,
    valueFormatter: import_prop_types76.default.func
  }), import_prop_types76.default.shape({
    axis: import_prop_types76.default.oneOf(["x"]),
    classes: import_prop_types76.default.object,
    colorMap: import_prop_types76.default.oneOfType([import_prop_types76.default.shape({
      color: import_prop_types76.default.oneOfType([import_prop_types76.default.arrayOf(import_prop_types76.default.string.isRequired), import_prop_types76.default.func]).isRequired,
      max: import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]),
      min: import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]),
      type: import_prop_types76.default.oneOf(["continuous"]).isRequired
    }), import_prop_types76.default.shape({
      colors: import_prop_types76.default.arrayOf(import_prop_types76.default.string).isRequired,
      thresholds: import_prop_types76.default.arrayOf(import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]).isRequired).isRequired,
      type: import_prop_types76.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types76.default.array,
    dataKey: import_prop_types76.default.string,
    disableLine: import_prop_types76.default.bool,
    disableTicks: import_prop_types76.default.bool,
    domainLimit: import_prop_types76.default.oneOfType([import_prop_types76.default.oneOf(["nice", "strict"]), import_prop_types76.default.func]),
    fill: import_prop_types76.default.string,
    height: import_prop_types76.default.number,
    hideTooltip: import_prop_types76.default.bool,
    id: import_prop_types76.default.oneOfType([import_prop_types76.default.number, import_prop_types76.default.string]),
    ignoreTooltip: import_prop_types76.default.bool,
    label: import_prop_types76.default.string,
    labelStyle: import_prop_types76.default.object,
    max: import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]),
    min: import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]),
    offset: import_prop_types76.default.number,
    position: import_prop_types76.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types76.default.bool,
    scaleType: import_prop_types76.default.oneOf(["sqrt"]),
    slotProps: import_prop_types76.default.object,
    slots: import_prop_types76.default.object,
    stroke: import_prop_types76.default.string,
    sx: import_prop_types76.default.oneOfType([import_prop_types76.default.arrayOf(import_prop_types76.default.oneOfType([import_prop_types76.default.func, import_prop_types76.default.object, import_prop_types76.default.bool])), import_prop_types76.default.func, import_prop_types76.default.object]),
    tickInterval: import_prop_types76.default.oneOfType([import_prop_types76.default.oneOf(["auto"]), import_prop_types76.default.array, import_prop_types76.default.func]),
    tickLabelInterval: import_prop_types76.default.oneOfType([import_prop_types76.default.oneOf(["auto"]), import_prop_types76.default.func]),
    tickLabelMinGap: import_prop_types76.default.number,
    tickLabelPlacement: import_prop_types76.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types76.default.object,
    tickMaxStep: import_prop_types76.default.number,
    tickMinStep: import_prop_types76.default.number,
    tickNumber: import_prop_types76.default.number,
    tickPlacement: import_prop_types76.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types76.default.number,
    valueFormatter: import_prop_types76.default.func
  }), import_prop_types76.default.shape({
    axis: import_prop_types76.default.oneOf(["x"]),
    classes: import_prop_types76.default.object,
    colorMap: import_prop_types76.default.oneOfType([import_prop_types76.default.shape({
      color: import_prop_types76.default.oneOfType([import_prop_types76.default.arrayOf(import_prop_types76.default.string.isRequired), import_prop_types76.default.func]).isRequired,
      max: import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]),
      min: import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]),
      type: import_prop_types76.default.oneOf(["continuous"]).isRequired
    }), import_prop_types76.default.shape({
      colors: import_prop_types76.default.arrayOf(import_prop_types76.default.string).isRequired,
      thresholds: import_prop_types76.default.arrayOf(import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]).isRequired).isRequired,
      type: import_prop_types76.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types76.default.array,
    dataKey: import_prop_types76.default.string,
    disableLine: import_prop_types76.default.bool,
    disableTicks: import_prop_types76.default.bool,
    domainLimit: import_prop_types76.default.oneOfType([import_prop_types76.default.oneOf(["nice", "strict"]), import_prop_types76.default.func]),
    fill: import_prop_types76.default.string,
    height: import_prop_types76.default.number,
    hideTooltip: import_prop_types76.default.bool,
    id: import_prop_types76.default.oneOfType([import_prop_types76.default.number, import_prop_types76.default.string]),
    ignoreTooltip: import_prop_types76.default.bool,
    label: import_prop_types76.default.string,
    labelStyle: import_prop_types76.default.object,
    max: import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]),
    min: import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]),
    offset: import_prop_types76.default.number,
    position: import_prop_types76.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types76.default.bool,
    scaleType: import_prop_types76.default.oneOf(["time"]),
    slotProps: import_prop_types76.default.object,
    slots: import_prop_types76.default.object,
    stroke: import_prop_types76.default.string,
    sx: import_prop_types76.default.oneOfType([import_prop_types76.default.arrayOf(import_prop_types76.default.oneOfType([import_prop_types76.default.func, import_prop_types76.default.object, import_prop_types76.default.bool])), import_prop_types76.default.func, import_prop_types76.default.object]),
    tickInterval: import_prop_types76.default.oneOfType([import_prop_types76.default.oneOf(["auto"]), import_prop_types76.default.array, import_prop_types76.default.func]),
    tickLabelInterval: import_prop_types76.default.oneOfType([import_prop_types76.default.oneOf(["auto"]), import_prop_types76.default.func]),
    tickLabelMinGap: import_prop_types76.default.number,
    tickLabelPlacement: import_prop_types76.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types76.default.object,
    tickMaxStep: import_prop_types76.default.number,
    tickMinStep: import_prop_types76.default.number,
    tickNumber: import_prop_types76.default.number,
    tickPlacement: import_prop_types76.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types76.default.number,
    valueFormatter: import_prop_types76.default.func
  }), import_prop_types76.default.shape({
    axis: import_prop_types76.default.oneOf(["x"]),
    classes: import_prop_types76.default.object,
    colorMap: import_prop_types76.default.oneOfType([import_prop_types76.default.shape({
      color: import_prop_types76.default.oneOfType([import_prop_types76.default.arrayOf(import_prop_types76.default.string.isRequired), import_prop_types76.default.func]).isRequired,
      max: import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]),
      min: import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]),
      type: import_prop_types76.default.oneOf(["continuous"]).isRequired
    }), import_prop_types76.default.shape({
      colors: import_prop_types76.default.arrayOf(import_prop_types76.default.string).isRequired,
      thresholds: import_prop_types76.default.arrayOf(import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]).isRequired).isRequired,
      type: import_prop_types76.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types76.default.array,
    dataKey: import_prop_types76.default.string,
    disableLine: import_prop_types76.default.bool,
    disableTicks: import_prop_types76.default.bool,
    domainLimit: import_prop_types76.default.oneOfType([import_prop_types76.default.oneOf(["nice", "strict"]), import_prop_types76.default.func]),
    fill: import_prop_types76.default.string,
    height: import_prop_types76.default.number,
    hideTooltip: import_prop_types76.default.bool,
    id: import_prop_types76.default.oneOfType([import_prop_types76.default.number, import_prop_types76.default.string]),
    ignoreTooltip: import_prop_types76.default.bool,
    label: import_prop_types76.default.string,
    labelStyle: import_prop_types76.default.object,
    max: import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]),
    min: import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]),
    offset: import_prop_types76.default.number,
    position: import_prop_types76.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types76.default.bool,
    scaleType: import_prop_types76.default.oneOf(["utc"]),
    slotProps: import_prop_types76.default.object,
    slots: import_prop_types76.default.object,
    stroke: import_prop_types76.default.string,
    sx: import_prop_types76.default.oneOfType([import_prop_types76.default.arrayOf(import_prop_types76.default.oneOfType([import_prop_types76.default.func, import_prop_types76.default.object, import_prop_types76.default.bool])), import_prop_types76.default.func, import_prop_types76.default.object]),
    tickInterval: import_prop_types76.default.oneOfType([import_prop_types76.default.oneOf(["auto"]), import_prop_types76.default.array, import_prop_types76.default.func]),
    tickLabelInterval: import_prop_types76.default.oneOfType([import_prop_types76.default.oneOf(["auto"]), import_prop_types76.default.func]),
    tickLabelMinGap: import_prop_types76.default.number,
    tickLabelPlacement: import_prop_types76.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types76.default.object,
    tickMaxStep: import_prop_types76.default.number,
    tickMinStep: import_prop_types76.default.number,
    tickNumber: import_prop_types76.default.number,
    tickPlacement: import_prop_types76.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types76.default.number,
    valueFormatter: import_prop_types76.default.func
  }), import_prop_types76.default.shape({
    axis: import_prop_types76.default.oneOf(["x"]),
    classes: import_prop_types76.default.object,
    colorMap: import_prop_types76.default.oneOfType([import_prop_types76.default.shape({
      color: import_prop_types76.default.oneOfType([import_prop_types76.default.arrayOf(import_prop_types76.default.string.isRequired), import_prop_types76.default.func]).isRequired,
      max: import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]),
      min: import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]),
      type: import_prop_types76.default.oneOf(["continuous"]).isRequired
    }), import_prop_types76.default.shape({
      colors: import_prop_types76.default.arrayOf(import_prop_types76.default.string).isRequired,
      thresholds: import_prop_types76.default.arrayOf(import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]).isRequired).isRequired,
      type: import_prop_types76.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types76.default.array,
    dataKey: import_prop_types76.default.string,
    disableLine: import_prop_types76.default.bool,
    disableTicks: import_prop_types76.default.bool,
    domainLimit: import_prop_types76.default.oneOfType([import_prop_types76.default.oneOf(["nice", "strict"]), import_prop_types76.default.func]),
    fill: import_prop_types76.default.string,
    height: import_prop_types76.default.number,
    hideTooltip: import_prop_types76.default.bool,
    id: import_prop_types76.default.oneOfType([import_prop_types76.default.number, import_prop_types76.default.string]),
    ignoreTooltip: import_prop_types76.default.bool,
    label: import_prop_types76.default.string,
    labelStyle: import_prop_types76.default.object,
    max: import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]),
    min: import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]),
    offset: import_prop_types76.default.number,
    position: import_prop_types76.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types76.default.bool,
    scaleType: import_prop_types76.default.oneOf(["linear"]),
    slotProps: import_prop_types76.default.object,
    slots: import_prop_types76.default.object,
    stroke: import_prop_types76.default.string,
    sx: import_prop_types76.default.oneOfType([import_prop_types76.default.arrayOf(import_prop_types76.default.oneOfType([import_prop_types76.default.func, import_prop_types76.default.object, import_prop_types76.default.bool])), import_prop_types76.default.func, import_prop_types76.default.object]),
    tickInterval: import_prop_types76.default.oneOfType([import_prop_types76.default.oneOf(["auto"]), import_prop_types76.default.array, import_prop_types76.default.func]),
    tickLabelInterval: import_prop_types76.default.oneOfType([import_prop_types76.default.oneOf(["auto"]), import_prop_types76.default.func]),
    tickLabelMinGap: import_prop_types76.default.number,
    tickLabelPlacement: import_prop_types76.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types76.default.object,
    tickMaxStep: import_prop_types76.default.number,
    tickMinStep: import_prop_types76.default.number,
    tickNumber: import_prop_types76.default.number,
    tickPlacement: import_prop_types76.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types76.default.number,
    valueFormatter: import_prop_types76.default.func
  })]),
  /**
   * The yAxis configuration.
   * Notice it is a single [[AxisConfig]] object, not an array of configuration.
   */
  yAxis: import_prop_types76.default.oneOfType([import_prop_types76.default.shape({
    axis: import_prop_types76.default.oneOf(["y"]),
    barGapRatio: import_prop_types76.default.number,
    categoryGapRatio: import_prop_types76.default.number,
    classes: import_prop_types76.default.object,
    colorMap: import_prop_types76.default.oneOfType([import_prop_types76.default.shape({
      colors: import_prop_types76.default.arrayOf(import_prop_types76.default.string).isRequired,
      type: import_prop_types76.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types76.default.string,
      values: import_prop_types76.default.arrayOf(import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number, import_prop_types76.default.string]).isRequired)
    }), import_prop_types76.default.shape({
      color: import_prop_types76.default.oneOfType([import_prop_types76.default.arrayOf(import_prop_types76.default.string.isRequired), import_prop_types76.default.func]).isRequired,
      max: import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]),
      min: import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]),
      type: import_prop_types76.default.oneOf(["continuous"]).isRequired
    }), import_prop_types76.default.shape({
      colors: import_prop_types76.default.arrayOf(import_prop_types76.default.string).isRequired,
      thresholds: import_prop_types76.default.arrayOf(import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]).isRequired).isRequired,
      type: import_prop_types76.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types76.default.array,
    dataKey: import_prop_types76.default.string,
    disableLine: import_prop_types76.default.bool,
    disableTicks: import_prop_types76.default.bool,
    domainLimit: import_prop_types76.default.oneOfType([import_prop_types76.default.oneOf(["nice", "strict"]), import_prop_types76.default.func]),
    fill: import_prop_types76.default.string,
    hideTooltip: import_prop_types76.default.bool,
    id: import_prop_types76.default.oneOfType([import_prop_types76.default.number, import_prop_types76.default.string]),
    ignoreTooltip: import_prop_types76.default.bool,
    label: import_prop_types76.default.string,
    labelStyle: import_prop_types76.default.object,
    max: import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]),
    min: import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]),
    offset: import_prop_types76.default.number,
    position: import_prop_types76.default.oneOf(["left", "none", "right"]),
    reverse: import_prop_types76.default.bool,
    scaleType: import_prop_types76.default.oneOf(["band"]),
    slotProps: import_prop_types76.default.object,
    slots: import_prop_types76.default.object,
    stroke: import_prop_types76.default.string,
    sx: import_prop_types76.default.oneOfType([import_prop_types76.default.arrayOf(import_prop_types76.default.oneOfType([import_prop_types76.default.func, import_prop_types76.default.object, import_prop_types76.default.bool])), import_prop_types76.default.func, import_prop_types76.default.object]),
    tickInterval: import_prop_types76.default.oneOfType([import_prop_types76.default.oneOf(["auto"]), import_prop_types76.default.array, import_prop_types76.default.func]),
    tickLabelInterval: import_prop_types76.default.oneOfType([import_prop_types76.default.oneOf(["auto"]), import_prop_types76.default.func]),
    tickLabelPlacement: import_prop_types76.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types76.default.object,
    tickMaxStep: import_prop_types76.default.number,
    tickMinStep: import_prop_types76.default.number,
    tickNumber: import_prop_types76.default.number,
    tickPlacement: import_prop_types76.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types76.default.number,
    valueFormatter: import_prop_types76.default.func,
    width: import_prop_types76.default.number
  }), import_prop_types76.default.shape({
    axis: import_prop_types76.default.oneOf(["y"]),
    classes: import_prop_types76.default.object,
    colorMap: import_prop_types76.default.oneOfType([import_prop_types76.default.shape({
      colors: import_prop_types76.default.arrayOf(import_prop_types76.default.string).isRequired,
      type: import_prop_types76.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types76.default.string,
      values: import_prop_types76.default.arrayOf(import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number, import_prop_types76.default.string]).isRequired)
    }), import_prop_types76.default.shape({
      color: import_prop_types76.default.oneOfType([import_prop_types76.default.arrayOf(import_prop_types76.default.string.isRequired), import_prop_types76.default.func]).isRequired,
      max: import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]),
      min: import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]),
      type: import_prop_types76.default.oneOf(["continuous"]).isRequired
    }), import_prop_types76.default.shape({
      colors: import_prop_types76.default.arrayOf(import_prop_types76.default.string).isRequired,
      thresholds: import_prop_types76.default.arrayOf(import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]).isRequired).isRequired,
      type: import_prop_types76.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types76.default.array,
    dataKey: import_prop_types76.default.string,
    disableLine: import_prop_types76.default.bool,
    disableTicks: import_prop_types76.default.bool,
    domainLimit: import_prop_types76.default.oneOfType([import_prop_types76.default.oneOf(["nice", "strict"]), import_prop_types76.default.func]),
    fill: import_prop_types76.default.string,
    hideTooltip: import_prop_types76.default.bool,
    id: import_prop_types76.default.oneOfType([import_prop_types76.default.number, import_prop_types76.default.string]),
    ignoreTooltip: import_prop_types76.default.bool,
    label: import_prop_types76.default.string,
    labelStyle: import_prop_types76.default.object,
    max: import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]),
    min: import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]),
    offset: import_prop_types76.default.number,
    position: import_prop_types76.default.oneOf(["left", "none", "right"]),
    reverse: import_prop_types76.default.bool,
    scaleType: import_prop_types76.default.oneOf(["point"]),
    slotProps: import_prop_types76.default.object,
    slots: import_prop_types76.default.object,
    stroke: import_prop_types76.default.string,
    sx: import_prop_types76.default.oneOfType([import_prop_types76.default.arrayOf(import_prop_types76.default.oneOfType([import_prop_types76.default.func, import_prop_types76.default.object, import_prop_types76.default.bool])), import_prop_types76.default.func, import_prop_types76.default.object]),
    tickInterval: import_prop_types76.default.oneOfType([import_prop_types76.default.oneOf(["auto"]), import_prop_types76.default.array, import_prop_types76.default.func]),
    tickLabelInterval: import_prop_types76.default.oneOfType([import_prop_types76.default.oneOf(["auto"]), import_prop_types76.default.func]),
    tickLabelPlacement: import_prop_types76.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types76.default.object,
    tickMaxStep: import_prop_types76.default.number,
    tickMinStep: import_prop_types76.default.number,
    tickNumber: import_prop_types76.default.number,
    tickPlacement: import_prop_types76.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types76.default.number,
    valueFormatter: import_prop_types76.default.func,
    width: import_prop_types76.default.number
  }), import_prop_types76.default.shape({
    axis: import_prop_types76.default.oneOf(["y"]),
    classes: import_prop_types76.default.object,
    colorMap: import_prop_types76.default.oneOfType([import_prop_types76.default.shape({
      color: import_prop_types76.default.oneOfType([import_prop_types76.default.arrayOf(import_prop_types76.default.string.isRequired), import_prop_types76.default.func]).isRequired,
      max: import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]),
      min: import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]),
      type: import_prop_types76.default.oneOf(["continuous"]).isRequired
    }), import_prop_types76.default.shape({
      colors: import_prop_types76.default.arrayOf(import_prop_types76.default.string).isRequired,
      thresholds: import_prop_types76.default.arrayOf(import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]).isRequired).isRequired,
      type: import_prop_types76.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types76.default.array,
    dataKey: import_prop_types76.default.string,
    disableLine: import_prop_types76.default.bool,
    disableTicks: import_prop_types76.default.bool,
    domainLimit: import_prop_types76.default.oneOfType([import_prop_types76.default.oneOf(["nice", "strict"]), import_prop_types76.default.func]),
    fill: import_prop_types76.default.string,
    hideTooltip: import_prop_types76.default.bool,
    id: import_prop_types76.default.oneOfType([import_prop_types76.default.number, import_prop_types76.default.string]),
    ignoreTooltip: import_prop_types76.default.bool,
    label: import_prop_types76.default.string,
    labelStyle: import_prop_types76.default.object,
    max: import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]),
    min: import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]),
    offset: import_prop_types76.default.number,
    position: import_prop_types76.default.oneOf(["left", "none", "right"]),
    reverse: import_prop_types76.default.bool,
    scaleType: import_prop_types76.default.oneOf(["log"]),
    slotProps: import_prop_types76.default.object,
    slots: import_prop_types76.default.object,
    stroke: import_prop_types76.default.string,
    sx: import_prop_types76.default.oneOfType([import_prop_types76.default.arrayOf(import_prop_types76.default.oneOfType([import_prop_types76.default.func, import_prop_types76.default.object, import_prop_types76.default.bool])), import_prop_types76.default.func, import_prop_types76.default.object]),
    tickInterval: import_prop_types76.default.oneOfType([import_prop_types76.default.oneOf(["auto"]), import_prop_types76.default.array, import_prop_types76.default.func]),
    tickLabelInterval: import_prop_types76.default.oneOfType([import_prop_types76.default.oneOf(["auto"]), import_prop_types76.default.func]),
    tickLabelPlacement: import_prop_types76.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types76.default.object,
    tickMaxStep: import_prop_types76.default.number,
    tickMinStep: import_prop_types76.default.number,
    tickNumber: import_prop_types76.default.number,
    tickPlacement: import_prop_types76.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types76.default.number,
    valueFormatter: import_prop_types76.default.func,
    width: import_prop_types76.default.number
  }), import_prop_types76.default.shape({
    axis: import_prop_types76.default.oneOf(["y"]),
    classes: import_prop_types76.default.object,
    colorMap: import_prop_types76.default.oneOfType([import_prop_types76.default.shape({
      color: import_prop_types76.default.oneOfType([import_prop_types76.default.arrayOf(import_prop_types76.default.string.isRequired), import_prop_types76.default.func]).isRequired,
      max: import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]),
      min: import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]),
      type: import_prop_types76.default.oneOf(["continuous"]).isRequired
    }), import_prop_types76.default.shape({
      colors: import_prop_types76.default.arrayOf(import_prop_types76.default.string).isRequired,
      thresholds: import_prop_types76.default.arrayOf(import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]).isRequired).isRequired,
      type: import_prop_types76.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types76.default.array,
    dataKey: import_prop_types76.default.string,
    disableLine: import_prop_types76.default.bool,
    disableTicks: import_prop_types76.default.bool,
    domainLimit: import_prop_types76.default.oneOfType([import_prop_types76.default.oneOf(["nice", "strict"]), import_prop_types76.default.func]),
    fill: import_prop_types76.default.string,
    hideTooltip: import_prop_types76.default.bool,
    id: import_prop_types76.default.oneOfType([import_prop_types76.default.number, import_prop_types76.default.string]),
    ignoreTooltip: import_prop_types76.default.bool,
    label: import_prop_types76.default.string,
    labelStyle: import_prop_types76.default.object,
    max: import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]),
    min: import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]),
    offset: import_prop_types76.default.number,
    position: import_prop_types76.default.oneOf(["left", "none", "right"]),
    reverse: import_prop_types76.default.bool,
    scaleType: import_prop_types76.default.oneOf(["pow"]),
    slotProps: import_prop_types76.default.object,
    slots: import_prop_types76.default.object,
    stroke: import_prop_types76.default.string,
    sx: import_prop_types76.default.oneOfType([import_prop_types76.default.arrayOf(import_prop_types76.default.oneOfType([import_prop_types76.default.func, import_prop_types76.default.object, import_prop_types76.default.bool])), import_prop_types76.default.func, import_prop_types76.default.object]),
    tickInterval: import_prop_types76.default.oneOfType([import_prop_types76.default.oneOf(["auto"]), import_prop_types76.default.array, import_prop_types76.default.func]),
    tickLabelInterval: import_prop_types76.default.oneOfType([import_prop_types76.default.oneOf(["auto"]), import_prop_types76.default.func]),
    tickLabelPlacement: import_prop_types76.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types76.default.object,
    tickMaxStep: import_prop_types76.default.number,
    tickMinStep: import_prop_types76.default.number,
    tickNumber: import_prop_types76.default.number,
    tickPlacement: import_prop_types76.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types76.default.number,
    valueFormatter: import_prop_types76.default.func,
    width: import_prop_types76.default.number
  }), import_prop_types76.default.shape({
    axis: import_prop_types76.default.oneOf(["y"]),
    classes: import_prop_types76.default.object,
    colorMap: import_prop_types76.default.oneOfType([import_prop_types76.default.shape({
      color: import_prop_types76.default.oneOfType([import_prop_types76.default.arrayOf(import_prop_types76.default.string.isRequired), import_prop_types76.default.func]).isRequired,
      max: import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]),
      min: import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]),
      type: import_prop_types76.default.oneOf(["continuous"]).isRequired
    }), import_prop_types76.default.shape({
      colors: import_prop_types76.default.arrayOf(import_prop_types76.default.string).isRequired,
      thresholds: import_prop_types76.default.arrayOf(import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]).isRequired).isRequired,
      type: import_prop_types76.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types76.default.array,
    dataKey: import_prop_types76.default.string,
    disableLine: import_prop_types76.default.bool,
    disableTicks: import_prop_types76.default.bool,
    domainLimit: import_prop_types76.default.oneOfType([import_prop_types76.default.oneOf(["nice", "strict"]), import_prop_types76.default.func]),
    fill: import_prop_types76.default.string,
    hideTooltip: import_prop_types76.default.bool,
    id: import_prop_types76.default.oneOfType([import_prop_types76.default.number, import_prop_types76.default.string]),
    ignoreTooltip: import_prop_types76.default.bool,
    label: import_prop_types76.default.string,
    labelStyle: import_prop_types76.default.object,
    max: import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]),
    min: import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]),
    offset: import_prop_types76.default.number,
    position: import_prop_types76.default.oneOf(["left", "none", "right"]),
    reverse: import_prop_types76.default.bool,
    scaleType: import_prop_types76.default.oneOf(["sqrt"]),
    slotProps: import_prop_types76.default.object,
    slots: import_prop_types76.default.object,
    stroke: import_prop_types76.default.string,
    sx: import_prop_types76.default.oneOfType([import_prop_types76.default.arrayOf(import_prop_types76.default.oneOfType([import_prop_types76.default.func, import_prop_types76.default.object, import_prop_types76.default.bool])), import_prop_types76.default.func, import_prop_types76.default.object]),
    tickInterval: import_prop_types76.default.oneOfType([import_prop_types76.default.oneOf(["auto"]), import_prop_types76.default.array, import_prop_types76.default.func]),
    tickLabelInterval: import_prop_types76.default.oneOfType([import_prop_types76.default.oneOf(["auto"]), import_prop_types76.default.func]),
    tickLabelPlacement: import_prop_types76.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types76.default.object,
    tickMaxStep: import_prop_types76.default.number,
    tickMinStep: import_prop_types76.default.number,
    tickNumber: import_prop_types76.default.number,
    tickPlacement: import_prop_types76.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types76.default.number,
    valueFormatter: import_prop_types76.default.func,
    width: import_prop_types76.default.number
  }), import_prop_types76.default.shape({
    axis: import_prop_types76.default.oneOf(["y"]),
    classes: import_prop_types76.default.object,
    colorMap: import_prop_types76.default.oneOfType([import_prop_types76.default.shape({
      color: import_prop_types76.default.oneOfType([import_prop_types76.default.arrayOf(import_prop_types76.default.string.isRequired), import_prop_types76.default.func]).isRequired,
      max: import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]),
      min: import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]),
      type: import_prop_types76.default.oneOf(["continuous"]).isRequired
    }), import_prop_types76.default.shape({
      colors: import_prop_types76.default.arrayOf(import_prop_types76.default.string).isRequired,
      thresholds: import_prop_types76.default.arrayOf(import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]).isRequired).isRequired,
      type: import_prop_types76.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types76.default.array,
    dataKey: import_prop_types76.default.string,
    disableLine: import_prop_types76.default.bool,
    disableTicks: import_prop_types76.default.bool,
    domainLimit: import_prop_types76.default.oneOfType([import_prop_types76.default.oneOf(["nice", "strict"]), import_prop_types76.default.func]),
    fill: import_prop_types76.default.string,
    hideTooltip: import_prop_types76.default.bool,
    id: import_prop_types76.default.oneOfType([import_prop_types76.default.number, import_prop_types76.default.string]),
    ignoreTooltip: import_prop_types76.default.bool,
    label: import_prop_types76.default.string,
    labelStyle: import_prop_types76.default.object,
    max: import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]),
    min: import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]),
    offset: import_prop_types76.default.number,
    position: import_prop_types76.default.oneOf(["left", "none", "right"]),
    reverse: import_prop_types76.default.bool,
    scaleType: import_prop_types76.default.oneOf(["time"]),
    slotProps: import_prop_types76.default.object,
    slots: import_prop_types76.default.object,
    stroke: import_prop_types76.default.string,
    sx: import_prop_types76.default.oneOfType([import_prop_types76.default.arrayOf(import_prop_types76.default.oneOfType([import_prop_types76.default.func, import_prop_types76.default.object, import_prop_types76.default.bool])), import_prop_types76.default.func, import_prop_types76.default.object]),
    tickInterval: import_prop_types76.default.oneOfType([import_prop_types76.default.oneOf(["auto"]), import_prop_types76.default.array, import_prop_types76.default.func]),
    tickLabelInterval: import_prop_types76.default.oneOfType([import_prop_types76.default.oneOf(["auto"]), import_prop_types76.default.func]),
    tickLabelPlacement: import_prop_types76.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types76.default.object,
    tickMaxStep: import_prop_types76.default.number,
    tickMinStep: import_prop_types76.default.number,
    tickNumber: import_prop_types76.default.number,
    tickPlacement: import_prop_types76.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types76.default.number,
    valueFormatter: import_prop_types76.default.func,
    width: import_prop_types76.default.number
  }), import_prop_types76.default.shape({
    axis: import_prop_types76.default.oneOf(["y"]),
    classes: import_prop_types76.default.object,
    colorMap: import_prop_types76.default.oneOfType([import_prop_types76.default.shape({
      color: import_prop_types76.default.oneOfType([import_prop_types76.default.arrayOf(import_prop_types76.default.string.isRequired), import_prop_types76.default.func]).isRequired,
      max: import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]),
      min: import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]),
      type: import_prop_types76.default.oneOf(["continuous"]).isRequired
    }), import_prop_types76.default.shape({
      colors: import_prop_types76.default.arrayOf(import_prop_types76.default.string).isRequired,
      thresholds: import_prop_types76.default.arrayOf(import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]).isRequired).isRequired,
      type: import_prop_types76.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types76.default.array,
    dataKey: import_prop_types76.default.string,
    disableLine: import_prop_types76.default.bool,
    disableTicks: import_prop_types76.default.bool,
    domainLimit: import_prop_types76.default.oneOfType([import_prop_types76.default.oneOf(["nice", "strict"]), import_prop_types76.default.func]),
    fill: import_prop_types76.default.string,
    hideTooltip: import_prop_types76.default.bool,
    id: import_prop_types76.default.oneOfType([import_prop_types76.default.number, import_prop_types76.default.string]),
    ignoreTooltip: import_prop_types76.default.bool,
    label: import_prop_types76.default.string,
    labelStyle: import_prop_types76.default.object,
    max: import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]),
    min: import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]),
    offset: import_prop_types76.default.number,
    position: import_prop_types76.default.oneOf(["left", "none", "right"]),
    reverse: import_prop_types76.default.bool,
    scaleType: import_prop_types76.default.oneOf(["utc"]),
    slotProps: import_prop_types76.default.object,
    slots: import_prop_types76.default.object,
    stroke: import_prop_types76.default.string,
    sx: import_prop_types76.default.oneOfType([import_prop_types76.default.arrayOf(import_prop_types76.default.oneOfType([import_prop_types76.default.func, import_prop_types76.default.object, import_prop_types76.default.bool])), import_prop_types76.default.func, import_prop_types76.default.object]),
    tickInterval: import_prop_types76.default.oneOfType([import_prop_types76.default.oneOf(["auto"]), import_prop_types76.default.array, import_prop_types76.default.func]),
    tickLabelInterval: import_prop_types76.default.oneOfType([import_prop_types76.default.oneOf(["auto"]), import_prop_types76.default.func]),
    tickLabelPlacement: import_prop_types76.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types76.default.object,
    tickMaxStep: import_prop_types76.default.number,
    tickMinStep: import_prop_types76.default.number,
    tickNumber: import_prop_types76.default.number,
    tickPlacement: import_prop_types76.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types76.default.number,
    valueFormatter: import_prop_types76.default.func,
    width: import_prop_types76.default.number
  }), import_prop_types76.default.shape({
    axis: import_prop_types76.default.oneOf(["y"]),
    classes: import_prop_types76.default.object,
    colorMap: import_prop_types76.default.oneOfType([import_prop_types76.default.shape({
      color: import_prop_types76.default.oneOfType([import_prop_types76.default.arrayOf(import_prop_types76.default.string.isRequired), import_prop_types76.default.func]).isRequired,
      max: import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]),
      min: import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]),
      type: import_prop_types76.default.oneOf(["continuous"]).isRequired
    }), import_prop_types76.default.shape({
      colors: import_prop_types76.default.arrayOf(import_prop_types76.default.string).isRequired,
      thresholds: import_prop_types76.default.arrayOf(import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]).isRequired).isRequired,
      type: import_prop_types76.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types76.default.array,
    dataKey: import_prop_types76.default.string,
    disableLine: import_prop_types76.default.bool,
    disableTicks: import_prop_types76.default.bool,
    domainLimit: import_prop_types76.default.oneOfType([import_prop_types76.default.oneOf(["nice", "strict"]), import_prop_types76.default.func]),
    fill: import_prop_types76.default.string,
    hideTooltip: import_prop_types76.default.bool,
    id: import_prop_types76.default.oneOfType([import_prop_types76.default.number, import_prop_types76.default.string]),
    ignoreTooltip: import_prop_types76.default.bool,
    label: import_prop_types76.default.string,
    labelStyle: import_prop_types76.default.object,
    max: import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]),
    min: import_prop_types76.default.oneOfType([import_prop_types76.default.instanceOf(Date), import_prop_types76.default.number]),
    offset: import_prop_types76.default.number,
    position: import_prop_types76.default.oneOf(["left", "none", "right"]),
    reverse: import_prop_types76.default.bool,
    scaleType: import_prop_types76.default.oneOf(["linear"]),
    slotProps: import_prop_types76.default.object,
    slots: import_prop_types76.default.object,
    stroke: import_prop_types76.default.string,
    sx: import_prop_types76.default.oneOfType([import_prop_types76.default.arrayOf(import_prop_types76.default.oneOfType([import_prop_types76.default.func, import_prop_types76.default.object, import_prop_types76.default.bool])), import_prop_types76.default.func, import_prop_types76.default.object]),
    tickInterval: import_prop_types76.default.oneOfType([import_prop_types76.default.oneOf(["auto"]), import_prop_types76.default.array, import_prop_types76.default.func]),
    tickLabelInterval: import_prop_types76.default.oneOfType([import_prop_types76.default.oneOf(["auto"]), import_prop_types76.default.func]),
    tickLabelPlacement: import_prop_types76.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types76.default.object,
    tickMaxStep: import_prop_types76.default.number,
    tickMinStep: import_prop_types76.default.number,
    tickNumber: import_prop_types76.default.number,
    tickPlacement: import_prop_types76.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types76.default.number,
    valueFormatter: import_prop_types76.default.func,
    width: import_prop_types76.default.number
  })])
} : void 0;

// node_modules/@mui/x-charts/esm/Gauge/Gauge.js
var React140 = __toESM(require_react(), 1);
var import_prop_types80 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/Gauge/GaugeContainer.js
var React136 = __toESM(require_react(), 1);
var import_prop_types77 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/Gauge/GaugeProvider.js
var React135 = __toESM(require_react(), 1);

// node_modules/@mui/x-charts/esm/Gauge/utils.js
function getPoint(angle) {
  const radAngle = deg2rad(angle);
  return [Math.sin(radAngle), -Math.cos(radAngle)];
}
function getArcRatios(startAngle, endAngle) {
  const points = [[0, 0], getPoint(startAngle), getPoint(endAngle)];
  const minAngle = Math.min(startAngle, endAngle);
  const maxAngle = Math.max(startAngle, endAngle);
  const initialAngle = Math.floor(minAngle / 90) * 90;
  for (let step = 1; step <= 4; step += 1) {
    const cardinalAngle = initialAngle + step * 90;
    if (cardinalAngle < maxAngle) {
      points.push(getPoint(cardinalAngle));
    }
  }
  const minX = Math.min(...points.map(([x3]) => x3));
  const maxX = Math.max(...points.map(([x3]) => x3));
  const minY = Math.min(...points.map(([, y3]) => y3));
  const maxY = Math.max(...points.map(([, y3]) => y3));
  return {
    cx: -minX / (maxX - minX),
    cy: -minY / (maxY - minY),
    minX,
    maxX,
    minY,
    maxY
  };
}
function getAvailableRadius(cx, cy, width2, height2, {
  minX,
  maxX,
  minY,
  maxY
}) {
  return Math.min(...[{
    ratio: Math.abs(minX),
    space: cx
  }, {
    ratio: Math.abs(maxX),
    space: width2 - cx
  }, {
    ratio: Math.abs(minY),
    space: cy
  }, {
    ratio: Math.abs(maxY),
    space: height2 - cy
  }].map(({
    ratio,
    space
  }) => {
    if (ratio < 1e-5) {
      return Infinity;
    }
    return space / ratio;
  }));
}

// node_modules/@mui/x-charts/esm/Gauge/GaugeProvider.js
var import_jsx_runtime93 = __toESM(require_jsx_runtime(), 1);
var GaugeContext = React135.createContext({
  value: null,
  valueMin: 0,
  valueMax: 0,
  startAngle: 0,
  endAngle: 0,
  innerRadius: 0,
  outerRadius: 0,
  cornerRadius: 0,
  cx: 0,
  cy: 0,
  maxRadius: 0,
  valueAngle: null
});
if (true) {
  GaugeContext.displayName = "GaugeContext";
}
function GaugeProvider(props) {
  const {
    value = null,
    valueMin = 0,
    valueMax = 100,
    startAngle = 0,
    endAngle = 360,
    outerRadius: outerRadiusParam,
    innerRadius: innerRadiusParam,
    cornerRadius: cornerRadiusParam,
    cx: cxParam,
    cy: cyParam,
    children: children2
  } = props;
  const {
    left: left3,
    top: top3,
    width: width2,
    height: height2
  } = useDrawingArea();
  const ratios = getArcRatios(startAngle, endAngle);
  const innerCx = cxParam ? getPercentageValue(cxParam, width2) : ratios.cx * width2;
  const innerCy = cyParam ? getPercentageValue(cyParam, height2) : ratios.cy * height2;
  let cx = left3 + innerCx;
  let cy = top3 + innerCy;
  const maxRadius = getAvailableRadius(innerCx, innerCy, width2, height2, ratios);
  if (cxParam === void 0) {
    const usedWidth = maxRadius * (ratios.maxX - ratios.minX);
    cx = left3 + (width2 - usedWidth) / 2 + ratios.cx * usedWidth;
  }
  if (cyParam === void 0) {
    const usedHeight = maxRadius * (ratios.maxY - ratios.minY);
    cy = top3 + (height2 - usedHeight) / 2 + ratios.cy * usedHeight;
  }
  const outerRadius = getPercentageValue(outerRadiusParam ?? maxRadius, maxRadius);
  const innerRadius = getPercentageValue(innerRadiusParam ?? "80%", maxRadius);
  const cornerRadius = getPercentageValue(cornerRadiusParam ?? 0, outerRadius - innerRadius);
  const contextValue = React135.useMemo(() => {
    const startAngleRad = deg2rad(startAngle);
    const endAngleRad = deg2rad(endAngle);
    return {
      value,
      valueMin,
      valueMax,
      startAngle: startAngleRad,
      endAngle: endAngleRad,
      outerRadius,
      innerRadius,
      cornerRadius,
      cx,
      cy,
      maxRadius,
      valueAngle: value === null ? null : startAngleRad + (endAngleRad - startAngleRad) * (value - valueMin) / (valueMax - valueMin)
    };
  }, [value, valueMin, valueMax, startAngle, endAngle, outerRadius, innerRadius, cornerRadius, cx, cy, maxRadius]);
  return (0, import_jsx_runtime93.jsx)(GaugeContext.Provider, {
    value: contextValue,
    children: children2
  });
}
function useGaugeState() {
  return React135.useContext(GaugeContext);
}

// node_modules/@mui/x-charts/esm/Gauge/GaugeContainer.js
var import_jsx_runtime94 = __toESM(require_jsx_runtime(), 1);
var _excluded52 = ["width", "height", "margin", "title", "desc", "value", "valueMin", "valueMax", "startAngle", "endAngle", "outerRadius", "innerRadius", "cornerRadius", "cx", "cy", "children"];
var GStyled = styled_default2("g")(({
  theme
}) => ({
  "& text": {
    fill: (theme.vars || theme).palette.text.primary
  }
}));
var GaugeContainer = React136.forwardRef(function GaugeContainer2(props, ref) {
  const {
    width: inWidth,
    height: inHeight,
    margin: margin2,
    title,
    desc,
    value,
    valueMin = 0,
    valueMax = 100,
    startAngle,
    endAngle,
    outerRadius,
    innerRadius,
    cornerRadius,
    cx,
    cy,
    children: children2
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded52);
  return (0, import_jsx_runtime94.jsx)(ChartProvider, {
    pluginParams: {
      width: inWidth,
      height: inHeight,
      margin: defaultizeMargin(margin2, {
        left: 10,
        right: 10,
        top: 10,
        bottom: 10
      })
    },
    plugins: [],
    children: (0, import_jsx_runtime94.jsx)(GaugeProvider, {
      value,
      valueMin,
      valueMax,
      startAngle,
      endAngle,
      outerRadius,
      innerRadius,
      cornerRadius,
      cx,
      cy,
      children: (0, import_jsx_runtime94.jsx)(ChartsSurface, _extends({
        title,
        desc,
        role: "meter",
        "aria-valuenow": value === null ? void 0 : value,
        "aria-valuemin": valueMin,
        "aria-valuemax": valueMax
      }, other, {
        ref,
        children: (0, import_jsx_runtime94.jsx)(GStyled, {
          "aria-hidden": "true",
          children: children2
        })
      }))
    })
  });
});
true ? GaugeContainer.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  children: import_prop_types77.default.node,
  className: import_prop_types77.default.string,
  /**
   * The radius applied to arc corners (similar to border radius).
   * Set it to '50%' to get rounded arc.
   * @default 0
   */
  cornerRadius: import_prop_types77.default.oneOfType([import_prop_types77.default.number, import_prop_types77.default.string]),
  /**
   * The x coordinate of the arc center.
   * Can be a number (in px) or a string with a percentage such as '50%'.
   * The '100%' is the width the drawing area.
   */
  cx: import_prop_types77.default.oneOfType([import_prop_types77.default.number, import_prop_types77.default.string]),
  /**
   * The y coordinate of the arc center.
   * Can be a number (in px) or a string with a percentage such as '50%'.
   * The '100%' is the height the drawing area.
   */
  cy: import_prop_types77.default.oneOfType([import_prop_types77.default.number, import_prop_types77.default.string]),
  desc: import_prop_types77.default.string,
  /**
   * The end angle (deg).
   * @default 360
   */
  endAngle: import_prop_types77.default.number,
  /**
   * The height of the chart in px. If not defined, it takes the height of the parent element.
   */
  height: import_prop_types77.default.number,
  /**
   * This prop is used to help implement the accessibility logic.
   * If you don't provide this prop. It falls back to a randomly generated id.
   */
  id: import_prop_types77.default.string,
  /**
   * The radius between circle center and the beginning of the arc.
   * Can be a number (in px) or a string with a percentage such as '50%'.
   * The '100%' is the maximal radius that fit into the drawing area.
   * @default '80%'
   */
  innerRadius: import_prop_types77.default.oneOfType([import_prop_types77.default.number, import_prop_types77.default.string]),
  /**
   * The margin between the SVG and the drawing area.
   * It's used for leaving some space for extra information such as the x- and y-axis or legend.
   *
   * Accepts a `number` to be used on all sides or an object with the optional properties: `top`, `bottom`, `left`, and `right`.
   */
  margin: import_prop_types77.default.oneOfType([import_prop_types77.default.number, import_prop_types77.default.shape({
    bottom: import_prop_types77.default.number,
    left: import_prop_types77.default.number,
    right: import_prop_types77.default.number,
    top: import_prop_types77.default.number
  })]),
  /**
   * The radius between circle center and the end of the arc.
   * Can be a number (in px) or a string with a percentage such as '50%'.
   * The '100%' is the maximal radius that fit into the drawing area.
   * @default '100%'
   */
  outerRadius: import_prop_types77.default.oneOfType([import_prop_types77.default.number, import_prop_types77.default.string]),
  /**
   * If `true`, animations are skipped.
   * If unset or `false`, the animations respects the user's `prefers-reduced-motion` setting.
   */
  skipAnimation: import_prop_types77.default.bool,
  /**
   * The start angle (deg).
   * @default 0
   */
  startAngle: import_prop_types77.default.number,
  sx: import_prop_types77.default.oneOfType([import_prop_types77.default.arrayOf(import_prop_types77.default.oneOfType([import_prop_types77.default.func, import_prop_types77.default.object, import_prop_types77.default.bool])), import_prop_types77.default.func, import_prop_types77.default.object]),
  title: import_prop_types77.default.string,
  /**
   * The value of the gauge.
   * Set to `null` to not display a value.
   */
  value: import_prop_types77.default.number,
  /**
   * The maximal value of the gauge.
   * @default 100
   */
  valueMax: import_prop_types77.default.number,
  /**
   * The minimal value of the gauge.
   * @default 0
   */
  valueMin: import_prop_types77.default.number,
  /**
   * The width of the chart in px. If not defined, it takes the width of the parent element.
   */
  width: import_prop_types77.default.number
} : void 0;

// node_modules/@mui/x-charts/esm/Gauge/GaugeValueArc.js
var React137 = __toESM(require_react(), 1);
var import_prop_types78 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/hooks/animation/useAnimateGaugeValueArc.js
function gaugeValueArcPropsInterpolator(from2, to) {
  const interpolateStartAngle = number_default(from2.startAngle, to.startAngle);
  const interpolateEndAngle = number_default(from2.endAngle, to.endAngle);
  const interpolateInnerRadius = number_default(from2.innerRadius, to.innerRadius);
  const interpolateOuterRadius = number_default(from2.outerRadius, to.outerRadius);
  const interpolateCornerRadius = number_default(from2.cornerRadius, to.cornerRadius);
  return (t) => {
    return {
      startAngle: interpolateStartAngle(t),
      endAngle: interpolateEndAngle(t),
      innerRadius: interpolateInnerRadius(t),
      outerRadius: interpolateOuterRadius(t),
      cornerRadius: interpolateCornerRadius(t)
    };
  };
}
function useAnimateGaugeValueArc(props) {
  return useAnimate({
    startAngle: props.startAngle,
    endAngle: props.endAngle,
    innerRadius: props.innerRadius,
    outerRadius: props.outerRadius,
    cornerRadius: props.cornerRadius
  }, {
    createInterpolator: gaugeValueArcPropsInterpolator,
    transformProps: (p2) => ({
      d: arc_default().cornerRadius(p2.cornerRadius)({
        innerRadius: p2.innerRadius,
        outerRadius: p2.outerRadius,
        startAngle: p2.startAngle,
        endAngle: p2.endAngle
      })
    }),
    applyProps(element, p2) {
      element.setAttribute("d", p2.d);
    },
    initialProps: {
      startAngle: props.startAngle,
      endAngle: props.startAngle,
      innerRadius: props.innerRadius,
      outerRadius: props.outerRadius,
      cornerRadius: props.cornerRadius
    },
    skip: props.skipAnimation,
    ref: props.ref
  });
}

// node_modules/@mui/x-charts/esm/Gauge/GaugeValueArc.js
var import_jsx_runtime95 = __toESM(require_jsx_runtime(), 1);
var _excluded53 = ["cx", "cy", "startAngle", "endAngle", "cornerRadius", "innerRadius", "outerRadius", "skipAnimation"];
var StyledPath = styled_default2("path", {
  name: "MuiGauge",
  slot: "ReferenceArc"
})(({
  theme
}) => ({
  fill: (theme.vars || theme).palette.primary.main
}));
function GaugeValueArc(props) {
  const {
    value,
    valueMin,
    valueMax,
    startAngle,
    endAngle,
    outerRadius,
    innerRadius,
    cornerRadius,
    cx,
    cy
  } = useGaugeState();
  if (value === null) {
    return null;
  }
  const valueAngle = startAngle + (value - valueMin) / (valueMax - valueMin) * (endAngle - startAngle);
  return (0, import_jsx_runtime95.jsx)(AnimatedGaugeValueArc, _extends({}, props, {
    cx,
    cy,
    startAngle,
    endAngle: valueAngle,
    cornerRadius,
    innerRadius,
    outerRadius
  }));
}
true ? GaugeValueArc.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  skipAnimation: import_prop_types78.default.bool
} : void 0;
function AnimatedGaugeValueArc(_ref) {
  let {
    cx,
    cy,
    startAngle,
    endAngle,
    cornerRadius,
    innerRadius,
    outerRadius,
    skipAnimation: inSkipAnimation
  } = _ref, other = _objectWithoutPropertiesLoose(_ref, _excluded53);
  const skipAnimation = useSkipAnimation(inSkipAnimation);
  const animatedProps = useAnimateGaugeValueArc({
    startAngle,
    endAngle,
    cornerRadius,
    innerRadius,
    outerRadius,
    skipAnimation
  });
  return (0, import_jsx_runtime95.jsx)(StyledPath, _extends({}, animatedProps, {
    transform: `translate(${cx}, ${cy})`
  }, other));
}
true ? AnimatedGaugeValueArc.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  cornerRadius: import_prop_types78.default.number.isRequired,
  cx: import_prop_types78.default.number.isRequired,
  cy: import_prop_types78.default.number.isRequired,
  endAngle: import_prop_types78.default.number.isRequired,
  innerRadius: import_prop_types78.default.number.isRequired,
  outerRadius: import_prop_types78.default.number.isRequired,
  skipAnimation: import_prop_types78.default.bool,
  startAngle: import_prop_types78.default.number.isRequired
} : void 0;

// node_modules/@mui/x-charts/esm/Gauge/GaugeReferenceArc.js
var React138 = __toESM(require_react(), 1);
var import_jsx_runtime96 = __toESM(require_jsx_runtime(), 1);
var StyledPath2 = styled_default2("path", {
  name: "MuiGauge",
  slot: "ReferenceArc"
})(({
  theme
}) => ({
  fill: (theme.vars || theme).palette.divider
}));
function GaugeReferenceArc(props) {
  const {
    startAngle,
    endAngle,
    outerRadius,
    innerRadius,
    cornerRadius,
    cx,
    cy
  } = useGaugeState();
  return (0, import_jsx_runtime96.jsx)(StyledPath2, _extends({
    transform: `translate(${cx}, ${cy})`,
    d: arc_default().cornerRadius(cornerRadius)({
      startAngle,
      endAngle,
      innerRadius,
      outerRadius
    })
  }, props));
}

// node_modules/@mui/x-charts/esm/Gauge/gaugeClasses.js
function getGaugeUtilityClass(slot) {
  return generateUtilityClass("MuiGauge", slot);
}
var gaugeClasses = generateUtilityClasses("MuiGauge", ["root", "valueArc", "referenceArc", "valueText"]);

// node_modules/@mui/x-charts/esm/Gauge/GaugeValueText.js
var React139 = __toESM(require_react(), 1);
var import_prop_types79 = __toESM(require_prop_types(), 1);
var import_jsx_runtime97 = __toESM(require_jsx_runtime(), 1);
var _excluded54 = ["text", "className"];
function defaultFormatter({
  value
}) {
  return value === null ? null : value.toLocaleString();
}
function GaugeValueText(props) {
  const {
    text = defaultFormatter,
    className
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded54);
  const {
    value,
    valueMin,
    valueMax,
    cx,
    cy
  } = useGaugeState();
  const formattedText = typeof text === "function" ? text({
    value,
    valueMin,
    valueMax
  }) : text;
  if (formattedText === null) {
    return null;
  }
  return (0, import_jsx_runtime97.jsx)("g", {
    className,
    children: (0, import_jsx_runtime97.jsx)(ChartsText, _extends({
      x: cx,
      y: cy,
      text: formattedText,
      style: {
        textAnchor: "middle",
        dominantBaseline: "central"
      }
    }, other))
  });
}
true ? GaugeValueText.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Height of a text line (in `em`).
   */
  lineHeight: import_prop_types79.default.number,
  /**
   * If `true`, the line width is computed.
   * @default false
   */
  needsComputation: import_prop_types79.default.bool,
  ownerState: import_prop_types79.default.any,
  /**
   * Style applied to text elements.
   */
  style: import_prop_types79.default.object,
  text: import_prop_types79.default.oneOfType([import_prop_types79.default.func, import_prop_types79.default.string])
} : void 0;

// node_modules/@mui/x-charts/esm/Gauge/Gauge.js
var import_jsx_runtime98 = __toESM(require_jsx_runtime(), 1);
var _excluded55 = ["text", "children", "classes", "className", "skipAnimation"];
var useUtilityClasses23 = (props) => {
  const {
    classes
  } = props;
  const slots = {
    root: ["root"],
    valueArc: ["valueArc"],
    referenceArc: ["referenceArc"],
    valueText: ["valueText"]
  };
  return composeClasses(slots, getGaugeUtilityClass, classes);
};
var Gauge = React140.forwardRef(function Gauge2(props, ref) {
  const {
    text,
    children: children2,
    className,
    skipAnimation
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded55);
  const classes = useUtilityClasses23(props);
  return (0, import_jsx_runtime98.jsxs)(GaugeContainer, _extends({}, other, {
    className: clsx_default(classes.root, className),
    ref,
    children: [(0, import_jsx_runtime98.jsx)(GaugeReferenceArc, {
      className: classes.referenceArc
    }), (0, import_jsx_runtime98.jsx)(GaugeValueArc, {
      className: classes.valueArc,
      skipAnimation
    }), (0, import_jsx_runtime98.jsx)(GaugeValueText, {
      className: classes.valueText,
      text
    }), children2]
  }));
});
true ? Gauge.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  children: import_prop_types80.default.node,
  classes: import_prop_types80.default.object,
  className: import_prop_types80.default.string,
  /**
   * The radius applied to arc corners (similar to border radius).
   * Set it to '50%' to get rounded arc.
   * @default 0
   */
  cornerRadius: import_prop_types80.default.oneOfType([import_prop_types80.default.number, import_prop_types80.default.string]),
  /**
   * The x coordinate of the arc center.
   * Can be a number (in px) or a string with a percentage such as '50%'.
   * The '100%' is the width the drawing area.
   */
  cx: import_prop_types80.default.oneOfType([import_prop_types80.default.number, import_prop_types80.default.string]),
  /**
   * The y coordinate of the arc center.
   * Can be a number (in px) or a string with a percentage such as '50%'.
   * The '100%' is the height the drawing area.
   */
  cy: import_prop_types80.default.oneOfType([import_prop_types80.default.number, import_prop_types80.default.string]),
  desc: import_prop_types80.default.string,
  /**
   * The end angle (deg).
   * @default 360
   */
  endAngle: import_prop_types80.default.number,
  /**
   * The height of the chart in px. If not defined, it takes the height of the parent element.
   */
  height: import_prop_types80.default.number,
  /**
   * This prop is used to help implement the accessibility logic.
   * If you don't provide this prop. It falls back to a randomly generated id.
   */
  id: import_prop_types80.default.string,
  /**
   * The radius between circle center and the beginning of the arc.
   * Can be a number (in px) or a string with a percentage such as '50%'.
   * The '100%' is the maximal radius that fit into the drawing area.
   * @default '80%'
   */
  innerRadius: import_prop_types80.default.oneOfType([import_prop_types80.default.number, import_prop_types80.default.string]),
  /**
   * The margin between the SVG and the drawing area.
   * It's used for leaving some space for extra information such as the x- and y-axis or legend.
   *
   * Accepts a `number` to be used on all sides or an object with the optional properties: `top`, `bottom`, `left`, and `right`.
   */
  margin: import_prop_types80.default.oneOfType([import_prop_types80.default.number, import_prop_types80.default.shape({
    bottom: import_prop_types80.default.number,
    left: import_prop_types80.default.number,
    right: import_prop_types80.default.number,
    top: import_prop_types80.default.number
  })]),
  /**
   * The radius between circle center and the end of the arc.
   * Can be a number (in px) or a string with a percentage such as '50%'.
   * The '100%' is the maximal radius that fit into the drawing area.
   * @default '100%'
   */
  outerRadius: import_prop_types80.default.oneOfType([import_prop_types80.default.number, import_prop_types80.default.string]),
  /**
   * If `true`, animations are skipped.
   * If unset or `false`, the animations respects the user's `prefers-reduced-motion` setting.
   */
  skipAnimation: import_prop_types80.default.bool,
  /**
   * The start angle (deg).
   * @default 0
   */
  startAngle: import_prop_types80.default.number,
  sx: import_prop_types80.default.oneOfType([import_prop_types80.default.arrayOf(import_prop_types80.default.oneOfType([import_prop_types80.default.func, import_prop_types80.default.object, import_prop_types80.default.bool])), import_prop_types80.default.func, import_prop_types80.default.object]),
  text: import_prop_types80.default.oneOfType([import_prop_types80.default.func, import_prop_types80.default.string]),
  title: import_prop_types80.default.string,
  /**
   * The value of the gauge.
   * Set to `null` to not display a value.
   */
  value: import_prop_types80.default.number,
  /**
   * The maximal value of the gauge.
   * @default 100
   */
  valueMax: import_prop_types80.default.number,
  /**
   * The minimal value of the gauge.
   * @default 0
   */
  valueMin: import_prop_types80.default.number,
  /**
   * The width of the chart in px. If not defined, it takes the width of the parent element.
   */
  width: import_prop_types80.default.number
} : void 0;

// node_modules/@mui/x-charts/esm/RadarChart/RadarChart.js
var React152 = __toESM(require_react(), 1);
var import_prop_types87 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/RadarChart/useRadarChartProps.js
var _excluded56 = ["series", "radar", "width", "height", "margin", "colors", "sx", "children", "slots", "slotProps", "skipAnimation", "loading", "highlightedItem", "onHighlightChange", "hideLegend", "divisions", "shape", "stripeColor", "highlight"];
var useRadarChartProps = (props) => {
  const {
    series,
    radar,
    width: width2,
    height: height2,
    margin: margin2,
    colors,
    sx,
    children: children2,
    slots,
    slotProps,
    skipAnimation,
    loading,
    highlightedItem,
    onHighlightChange,
    divisions,
    shape: shape2,
    stripeColor,
    highlight = "axis"
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded56);
  const radarDataProviderProps = {
    series,
    radar,
    highlight,
    width: width2,
    height: height2,
    margin: margin2,
    colors,
    highlightedItem,
    onHighlightChange,
    skipAnimation
  };
  const overlayProps = {
    slots,
    slotProps,
    loading
  };
  const legendProps = {
    slots,
    slotProps
  };
  const chartsWrapperProps = {
    sx
  };
  const radarGrid = {
    divisions,
    shape: shape2,
    stripeColor
  };
  const chartsSurfaceProps = other;
  return {
    highlight,
    chartsWrapperProps,
    chartsSurfaceProps,
    radarDataProviderProps,
    radarGrid,
    overlayProps,
    legendProps,
    children: children2
  };
};

// node_modules/@mui/x-charts/esm/RadarChart/RadarGrid/RadarGrid.js
var React145 = __toESM(require_react(), 1);
var import_prop_types81 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/RadarChart/RadarGrid/useRadarGridData.js
function useRadarGridData() {
  const {
    instance
  } = useChartContext();
  const rotationScale = useRotationScale();
  const {
    radiusAxis
  } = useRadiusAxes();
  const drawingArea = useDrawingArea();
  const cx = drawingArea.left + drawingArea.width / 2;
  const cy = drawingArea.top + drawingArea.height / 2;
  if (!rotationScale || rotationScale.domain().length === 0) {
    return null;
  }
  const metrics = rotationScale.domain();
  const angles = metrics.map((key) => rotationScale(key));
  return {
    center: {
      x: cx,
      y: cy
    },
    corners: metrics.map((metric, dataIndex) => {
      const radiusScale = radiusAxis[metric].scale;
      const r3 = radiusScale.range()[1];
      const angle = angles[dataIndex];
      const [x3, y3] = instance.polar2svg(r3, angle);
      return {
        x: x3,
        y: y3
      };
    }),
    radius: radiusAxis[metrics[0]].scale.range()[1]
  };
}

// node_modules/@mui/x-charts/esm/RadarChart/RadarGrid/SharpRadarGrid.js
var React141 = __toESM(require_react(), 1);
var import_jsx_runtime99 = __toESM(require_jsx_runtime(), 1);
function SharpRadarGrid(props) {
  const {
    center,
    corners,
    divisions,
    strokeColor,
    classes
  } = props;
  const divisionRatio = Array.from({
    length: divisions
  }, (_2, index2) => (index2 + 1) / divisions);
  return (0, import_jsx_runtime99.jsxs)(React141.Fragment, {
    children: [corners.map(({
      x: x3,
      y: y3
    }, i2) => (0, import_jsx_runtime99.jsx)("path", {
      d: `M ${center.x} ${center.y} L ${x3} ${y3}`,
      stroke: strokeColor,
      strokeWidth: 1,
      strokeOpacity: 0.3,
      fill: "none",
      className: classes == null ? void 0 : classes.radial
    }, i2)), divisionRatio.map((ratio) => (0, import_jsx_runtime99.jsx)("path", {
      d: `M ${corners.map(({
        x: x3,
        y: y3
      }) => `${center.x * (1 - ratio) + ratio * x3} ${center.y * (1 - ratio) + ratio * y3}`).join(" L ")} Z`,
      stroke: strokeColor,
      strokeWidth: 1,
      strokeOpacity: 0.3,
      fill: "none",
      className: classes == null ? void 0 : classes.divider
    }, ratio))]
  });
}

// node_modules/@mui/x-charts/esm/RadarChart/RadarGrid/CircularRadarGrid.js
var React142 = __toESM(require_react(), 1);
var import_jsx_runtime100 = __toESM(require_jsx_runtime(), 1);
function CircularRadarGrid(props) {
  const {
    center,
    corners,
    divisions,
    radius,
    strokeColor,
    classes
  } = props;
  const divisionRadius = Array.from({
    length: divisions
  }, (_2, index2) => radius * (index2 + 1) / divisions);
  return (0, import_jsx_runtime100.jsxs)(React142.Fragment, {
    children: [corners.map(({
      x: x3,
      y: y3
    }, i2) => (0, import_jsx_runtime100.jsx)("path", {
      d: `M ${center.x} ${center.y} L ${x3} ${y3}`,
      stroke: strokeColor,
      strokeWidth: 1,
      strokeOpacity: 0.3,
      fill: "none",
      className: classes == null ? void 0 : classes.radial
    }, i2)), divisionRadius.map((r3) => (0, import_jsx_runtime100.jsx)("circle", {
      cx: center.x,
      cy: center.y,
      r: r3,
      stroke: strokeColor,
      strokeWidth: 1,
      strokeOpacity: 0.3,
      fill: "none",
      className: classes == null ? void 0 : classes.divider
    }, r3))]
  });
}

// node_modules/@mui/x-charts/esm/RadarChart/RadarGrid/SharpRadarStripes.js
var React143 = __toESM(require_react(), 1);
var import_jsx_runtime101 = __toESM(require_jsx_runtime(), 1);
var getPath2 = (corners, center, outerRatio, innerRatio) => ["M", [...corners, corners[0]].map(({
  x: x3,
  y: y3
}) => `${center.x * (1 - outerRatio) + outerRatio * x3} ${center.y * (1 - outerRatio) + outerRatio * y3}`).join(" L "), "L", [...corners, corners[0]].reverse().map(({
  x: x3,
  y: y3
}) => `${center.x * (1 - innerRatio) + innerRatio * x3} ${center.y * (1 - innerRatio) + innerRatio * y3}`).join(" L "), "Z"].join(" ");
function SharpRadarStripes(props) {
  const {
    center,
    corners,
    divisions,
    stripeColor,
    classes
  } = props;
  const divisionRatio = Array.from({
    length: divisions
  }, (_2, index2) => (index2 + 1) / divisions);
  return (0, import_jsx_runtime101.jsx)(React143.Fragment, {
    children: divisionRatio.map((ratio, index2) => {
      const smallerRatio = divisionRatio[index2 - 1] ?? 0;
      return (0, import_jsx_runtime101.jsx)("path", {
        d: getPath2(corners, center, ratio, smallerRatio),
        stroke: "none",
        fill: (stripeColor == null ? void 0 : stripeColor(index2)) ?? "none",
        fillOpacity: 0.1,
        className: classes == null ? void 0 : classes.stripe
      }, ratio);
    })
  });
}

// node_modules/@mui/x-charts/esm/RadarChart/RadarGrid/CircularRadarStripes.js
var React144 = __toESM(require_react(), 1);
var import_jsx_runtime102 = __toESM(require_jsx_runtime(), 1);
var getPath3 = (center, outerRadius, innerRadius) => [`M ${center.x - outerRadius} ${center.y}`, `A ${outerRadius} ${outerRadius} 0 1 0 ${center.x + outerRadius} ${center.y}`, `A ${outerRadius} ${outerRadius} 0 1 0 ${center.x - outerRadius} ${center.y} Z`, `M ${center.x - innerRadius} ${center.y}`, `A ${innerRadius} ${innerRadius} 0 1 0 ${center.x + innerRadius} ${center.y}`, `A ${innerRadius} ${innerRadius} 0 1 0 ${center.x - innerRadius} ${center.y} Z`].join("");
function CircularRadarStripes(props) {
  const {
    center,
    divisions,
    radius,
    stripeColor,
    classes
  } = props;
  const divisionRadius = Array.from({
    length: divisions
  }, (_2, index2) => radius * (index2 + 1) / divisions);
  return (0, import_jsx_runtime102.jsx)(React144.Fragment, {
    children: divisionRadius.map((r3, index2) => {
      const smallerRadius = divisionRadius[index2 - 1] ?? 0;
      return (0, import_jsx_runtime102.jsx)("path", {
        d: getPath3(center, r3, smallerRadius),
        fillRule: "evenodd",
        fill: (stripeColor == null ? void 0 : stripeColor(index2)) ?? "none",
        fillOpacity: 0.1,
        className: classes == null ? void 0 : classes.stripe
      }, r3);
    })
  });
}

// node_modules/@mui/x-charts/esm/RadarChart/RadarGrid/radarGridClasses.js
function getRadarGridUtilityClass(slot) {
  return generateUtilityClass("MuiRadarGrid", slot);
}
var chartsGridClasses2 = generateUtilityClasses("MuiRadarGrid", ["radial", "divider", "stripe"]);
var useUtilityClasses24 = (classes) => {
  const slots = {
    radial: ["radial"],
    divider: ["divider"],
    stripe: ["stripe"]
  };
  return composeClasses(slots, getRadarGridUtilityClass, classes);
};

// node_modules/@mui/x-charts/esm/RadarChart/RadarGrid/RadarGrid.js
var import_jsx_runtime103 = __toESM(require_jsx_runtime(), 1);
function RadarGrid(props) {
  const theme = useTheme4();
  const {
    divisions = 5,
    shape: shape2 = "sharp",
    stripeColor = (index2) => index2 % 2 === 1 ? (theme.vars || theme).palette.text.secondary : "none"
  } = props;
  const gridData = useRadarGridData();
  const classes = useUtilityClasses24(props.classes);
  if (gridData === null) {
    return null;
  }
  const {
    center,
    corners,
    radius
  } = gridData;
  return shape2 === "sharp" ? (0, import_jsx_runtime103.jsxs)(React145.Fragment, {
    children: [stripeColor && (0, import_jsx_runtime103.jsx)(SharpRadarStripes, {
      divisions,
      corners,
      center,
      radius,
      stripeColor,
      classes
    }), (0, import_jsx_runtime103.jsx)(SharpRadarGrid, {
      divisions,
      corners,
      center,
      radius,
      strokeColor: (theme.vars || theme).palette.text.primary,
      classes
    })]
  }) : (0, import_jsx_runtime103.jsxs)(React145.Fragment, {
    children: [stripeColor && (0, import_jsx_runtime103.jsx)(CircularRadarStripes, {
      divisions,
      corners,
      center,
      radius,
      stripeColor,
      classes
    }), (0, import_jsx_runtime103.jsx)(CircularRadarGrid, {
      divisions,
      corners,
      center,
      radius,
      strokeColor: (theme.vars || theme).palette.text.primary,
      classes
    })]
  });
}
true ? RadarGrid.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types81.default.object,
  /**
   * The number of divisions in the radar grid.
   * @default 5
   */
  divisions: import_prop_types81.default.number,
  /**
   * The grid shape.
   * @default 'sharp'
   */
  shape: import_prop_types81.default.oneOf(["circular", "sharp"]),
  /**
   * Get stripe fill color. Set it to `null` to remove stripes
   * @param {number} index The index of the stripe band.
   * @returns {string} The color to fill the stripe.
   * @default (index) => index % 2 === 1 ? (theme.vars || theme).palette.text.secondary : 'none'
   */
  stripeColor: import_prop_types81.default.func
} : void 0;

// node_modules/@mui/x-charts/esm/RadarChart/RadarDataProvider/RadarDataProvider.js
var React146 = __toESM(require_react(), 1);
var import_prop_types82 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/RadarChart/seriesConfig/formatter.js
var formatter = (params) => {
  const {
    seriesOrder,
    series
  } = params;
  return {
    seriesOrder,
    series: defaultizeValueFormatter(series, (v3) => v3 == null ? "" : v3.toLocaleString())
  };
};
var formatter_default = formatter;

// node_modules/@mui/x-charts/esm/RadarChart/seriesConfig/getColor.js
var getColor5 = (series) => {
  return () => series.color;
};
var getColor_default5 = getColor5;

// node_modules/@mui/x-charts/esm/RadarChart/seriesConfig/extremums.js
var radiusExtremumGetter = ({
  series,
  axisIndex
}) => {
  return Object.keys(series).filter((seriesId) => series[seriesId].type === "radar").reduce((acc, seriesId) => {
    const {
      data
    } = series[seriesId];
    return [Math.min(data[axisIndex], acc[0]), Math.max(data[axisIndex], acc[1])];
  }, [Infinity, -Infinity]);
};
var rotationExtremumGetter = ({
  axis
}) => {
  const min4 = Math.min(...axis.data ?? []);
  const max4 = Math.max(...axis.data ?? []);
  return [min4, max4];
};

// node_modules/@mui/x-charts/esm/RadarChart/seriesConfig/legend.js
var legendGetter5 = (params) => {
  const {
    seriesOrder,
    series
  } = params;
  return seriesOrder.reduce((acc, seriesId) => {
    const formattedLabel = getLabel(series[seriesId].label, "legend");
    if (formattedLabel === void 0) {
      return acc;
    }
    acc.push({
      id: seriesId,
      seriesId,
      color: series[seriesId].color,
      label: formattedLabel,
      markType: series[seriesId].labelMarkType ?? "square"
    });
    return acc;
  }, []);
};
var legend_default5 = legendGetter5;

// node_modules/@mui/x-charts/esm/RadarChart/seriesConfig/tooltip.js
var tooltipGetter5 = (params) => {
  const {
    series,
    axesConfig,
    getColor: getColor6,
    identifier: identifier2
  } = params;
  const rotationAxis = axesConfig.rotation;
  if (!identifier2 || !rotationAxis) {
    return null;
  }
  const label = getLabel(series.label, "tooltip");
  const formatter2 = (v3) => {
    var _a;
    return ((_a = rotationAxis.valueFormatter) == null ? void 0 : _a.call(rotationAxis, v3, {
      location: "tooltip",
      scale: rotationAxis.scale
    })) ?? (v3 == null ? "" : v3.toLocaleString());
  };
  return {
    identifier: identifier2,
    color: getColor6(),
    label,
    markType: series.labelMarkType,
    values: series.data.map((value, dataIndex) => {
      var _a;
      return {
        value,
        formattedValue: series.valueFormatter(value, {
          dataIndex
        }),
        markType: series.labelMarkType,
        label: formatter2((_a = rotationAxis == null ? void 0 : rotationAxis.data) == null ? void 0 : _a[dataIndex])
      };
    })
  };
};
var axisTooltipGetter3 = (series) => {
  return Object.values(series).map(() => ({
    direction: "rotation",
    axisId: void 0
  }));
};
var tooltip_default5 = tooltipGetter5;

// node_modules/@mui/x-charts/esm/RadarChart/seriesConfig/getSeriesWithDefaultValues.js
var getSeriesWithDefaultValues5 = (seriesData, seriesIndex, colors) => {
  return _extends({
    id: seriesData.id ?? `auto-generated-id-${seriesIndex}`,
    color: colors[seriesIndex % colors.length]
  }, seriesData);
};
var getSeriesWithDefaultValues_default5 = getSeriesWithDefaultValues5;

// node_modules/@mui/x-charts/esm/RadarChart/seriesConfig/index.js
var radarSeriesConfig = {
  colorProcessor: getColor_default5,
  seriesProcessor: formatter_default,
  legendGetter: legend_default5,
  tooltipGetter: tooltip_default5,
  axisTooltipGetter: axisTooltipGetter3,
  getSeriesWithDefaultValues: getSeriesWithDefaultValues_default5,
  radiusExtremumGetter,
  rotationExtremumGetter
};

// node_modules/@mui/x-charts/esm/RadarChart/RadarDataProvider/RadarDataProvider.js
var import_jsx_runtime104 = __toESM(require_jsx_runtime(), 1);
var _excluded57 = ["series", "children", "width", "height", "colors", "highlightedItem", "onHighlightChange", "className", "skipAnimation", "margin", "radar", "highlight"];
var RADAR_SERIES_CONFIG = {
  radar: radarSeriesConfig
};
var RADAR_PLUGINS = [useChartPolarAxis, useChartInteraction, useChartHighlight];
var DEFAULT_RADAR_MARGIN = {
  top: 30,
  bottom: 30,
  left: 50,
  right: 50
};
function RadarDataProvider(props) {
  const {
    series,
    children: children2,
    width: width2,
    height: height2,
    colors,
    highlightedItem,
    onHighlightChange,
    skipAnimation,
    margin: margin2,
    radar,
    highlight
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded57);
  const rotationAxes = React146.useMemo(() => [{
    id: "radar-rotation-axis",
    scaleType: "point",
    data: radar.metrics.map((metric) => typeof metric === "string" ? metric : metric.name),
    startAngle: radar.startAngle,
    endAngle: radar.startAngle !== void 0 ? radar.startAngle + 360 : void 0,
    labelGap: radar.labelGap,
    valueFormatter: (name, {
      location
    }) => {
      var _a;
      return ((_a = radar.labelFormatter) == null ? void 0 : _a.call(radar, name, {
        location
      })) ?? name;
    }
  }], [radar]);
  const radiusAxis = React146.useMemo(() => radar.metrics.map((m2) => {
    const {
      name,
      min: min4 = 0,
      max: max4 = radar.max
    } = typeof m2 === "string" ? {
      name: m2
    } : m2;
    return {
      id: name,
      label: name,
      scaleType: "linear",
      min: min4,
      max: max4
    };
  }), [radar]);
  const defaultizedSeries = React146.useMemo(() => series.map((s3) => _extends({
    type: "radar",
    highlightScope: s3.highlightScope ?? (highlight === "series" ? {
      highlight: "series",
      fade: "global"
    } : void 0)
  }, s3)), [series, highlight]);
  const defaultizedMargin = React146.useMemo(() => defaultizeMargin(margin2, DEFAULT_RADAR_MARGIN), [margin2]);
  return (0, import_jsx_runtime104.jsx)(ChartDataProvider, _extends({}, other, {
    series: defaultizedSeries,
    width: width2,
    height: height2,
    margin: defaultizedMargin,
    colors,
    highlightedItem,
    onHighlightChange,
    skipAnimation,
    plugins: RADAR_PLUGINS,
    rotationAxis: rotationAxes,
    radiusAxis,
    seriesConfig: RADAR_SERIES_CONFIG,
    children: children2
  }));
}
true ? RadarDataProvider.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  apiRef: import_prop_types82.default.shape({
    current: import_prop_types82.default.object
  }),
  children: import_prop_types82.default.node,
  className: import_prop_types82.default.string,
  /**
   * Color palette used to colorize multiple series.
   * @default rainbowSurgePalette
   */
  colors: import_prop_types82.default.oneOfType([import_prop_types82.default.arrayOf(import_prop_types82.default.string), import_prop_types82.default.func]),
  desc: import_prop_types82.default.string,
  /**
   * If `true`, the charts will not listen to the mouse move event.
   * It might break interactive features, but will improve performance.
   * @default false
   */
  disableAxisListener: import_prop_types82.default.bool,
  /**
   * The height of the chart in px. If not defined, it takes the height of the parent element.
   */
  height: import_prop_types82.default.number,
  /**
   * Indicates if the chart should highlight items per axis or per series.
   * @default 'axis'
   */
  highlight: import_prop_types82.default.oneOf(["axis", "none", "series"]),
  /**
   * The highlighted item.
   * Used when the highlight is controlled.
   */
  highlightedItem: import_prop_types82.default.shape({
    dataIndex: import_prop_types82.default.number,
    seriesId: import_prop_types82.default.oneOfType([import_prop_types82.default.number, import_prop_types82.default.string]).isRequired
  }),
  /**
   * This prop is used to help implement the accessibility logic.
   * If you don't provide this prop. It falls back to a randomly generated id.
   */
  id: import_prop_types82.default.string,
  /**
   * Localized text for chart components.
   */
  localeText: import_prop_types82.default.object,
  /**
   * The margin between the SVG and the drawing area.
   * It's used for leaving some space for extra information such as the x- and y-axis or legend.
   *
   * Accepts a `number` to be used on all sides or an object with the optional properties: `top`, `bottom`, `left`, and `right`.
   */
  margin: import_prop_types82.default.oneOfType([import_prop_types82.default.number, import_prop_types82.default.shape({
    bottom: import_prop_types82.default.number,
    left: import_prop_types82.default.number,
    right: import_prop_types82.default.number,
    top: import_prop_types82.default.number
  })]),
  /**
   * The callback fired when the highlighted item changes.
   *
   * @param {HighlightItemData | null} highlightedItem  The newly highlighted item.
   */
  onHighlightChange: import_prop_types82.default.func,
  /**
   * The configuration of the radar scales.
   */
  radar: import_prop_types82.default.shape({
    labelFormatter: import_prop_types82.default.func,
    labelGap: import_prop_types82.default.number,
    max: import_prop_types82.default.number,
    metrics: import_prop_types82.default.oneOfType([import_prop_types82.default.arrayOf(import_prop_types82.default.string), import_prop_types82.default.arrayOf(import_prop_types82.default.shape({
      max: import_prop_types82.default.number,
      min: import_prop_types82.default.number,
      name: import_prop_types82.default.string.isRequired
    }))]).isRequired,
    startAngle: import_prop_types82.default.number
  }).isRequired,
  /**
   * The series to display in the bar chart.
   * An array of [[RadarSeriesType]] objects.
   */
  series: import_prop_types82.default.arrayOf(import_prop_types82.default.object).isRequired,
  /**
   * The configuration helpers used to compute attributes according to the series type.
   * @ignore Unstable props for internal usage.
   */
  seriesConfig: import_prop_types82.default.object,
  /**
   * If `true`, animations are skipped.
   * If unset or `false`, the animations respects the user's `prefers-reduced-motion` setting.
   */
  skipAnimation: import_prop_types82.default.bool,
  sx: import_prop_types82.default.oneOfType([import_prop_types82.default.arrayOf(import_prop_types82.default.oneOfType([import_prop_types82.default.func, import_prop_types82.default.object, import_prop_types82.default.bool])), import_prop_types82.default.func, import_prop_types82.default.object]),
  theme: import_prop_types82.default.oneOf(["dark", "light"]),
  title: import_prop_types82.default.string,
  /**
   * The width of the chart in px. If not defined, it takes the width of the parent element.
   */
  width: import_prop_types82.default.number
} : void 0;

// node_modules/@mui/x-charts/esm/RadarChart/RadarSeriesPlot/RadarSeriesPlot.js
var React149 = __toESM(require_react(), 1);
var import_prop_types85 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/hooks/useRadarSeries.js
var useSelectorSeries5 = createSeriesSelectorsOfType("radar");
var useSelectorSeriesContext5 = createAllSeriesSelectorOfType("radar");
function useRadarSeries(seriesIds) {
  return useSelectorSeries5(seriesIds);
}

// node_modules/@mui/x-charts/esm/RadarChart/RadarSeriesPlot/useRadarSeriesData.js
function useRadarSeriesData(querySeriesId) {
  const {
    instance
  } = useChartContext();
  const rotationScale = useRotationScale();
  const {
    radiusAxis
  } = useRadiusAxes();
  const radarSeries = useRadarSeries(querySeriesId === void 0 ? void 0 : [querySeriesId]);
  const {
    isFaded: isItemFaded,
    isHighlighted: isItemHighlighted
  } = useItemHighlightedGetter();
  const metrics = (rotationScale == null ? void 0 : rotationScale.domain()) ?? [];
  const angles = metrics.map((key) => rotationScale == null ? void 0 : rotationScale(key));
  return radarSeries.map((series) => {
    const seriesId = series.id;
    const isSeriesHighlighted = isItemHighlighted({
      seriesId
    });
    const isSeriesFaded = !isSeriesHighlighted && isItemFaded({
      seriesId
    });
    return _extends({}, series, {
      seriesId: series.id,
      isSeriesHighlighted,
      isSeriesFaded,
      points: series.data.map((value, dataIndex) => {
        const highlighted = isItemHighlighted({
          seriesId,
          dataIndex
        });
        const faded = !highlighted && isItemFaded({
          seriesId,
          dataIndex
        });
        const r3 = radiusAxis[metrics[dataIndex]].scale(value);
        const angle = angles[dataIndex];
        const [x3, y3] = instance.polar2svg(r3, angle);
        return {
          x: x3,
          y: y3,
          isItemHighlighted: highlighted,
          isItemFaded: faded,
          dataIndex
        };
      })
    });
  });
}

// node_modules/@mui/x-charts/esm/RadarChart/RadarSeriesPlot/radarSeriesPlotClasses.js
function getRadarSeriesPlotUtilityClass(slot) {
  return generateUtilityClass("MuiRadarSeriesPlot", slot);
}
var radarSeriesPlotClasses = generateUtilityClasses("MuiRadarSeriesPlot", ["root", "area", "mark", "highlighted", "faded"]);
var useUtilityClasses25 = (classes) => {
  const slots = {
    root: ["root"],
    area: ["area"],
    mark: ["mark"],
    highlighted: ["highlighted"],
    faded: ["faded"]
  };
  return composeClasses(slots, getRadarSeriesPlotUtilityClass, classes);
};

// node_modules/@mui/x-charts/esm/RadarChart/RadarSeriesPlot/RadarSeriesArea.js
var React147 = __toESM(require_react(), 1);
var import_prop_types83 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/RadarChart/RadarSeriesPlot/getAreaPath.js
function getAreaPath(points) {
  return `M ${points.map((p2) => `${p2.x} ${p2.y}`).join("L")} Z`;
}

// node_modules/@mui/x-charts/esm/RadarChart/RadarSeriesPlot/RadarSeriesArea.js
var import_jsx_runtime105 = __toESM(require_jsx_runtime(), 1);
var _excluded58 = ["seriesId"];
function getPathProps(params) {
  const {
    isHighlighted,
    isFaded,
    seriesId,
    classes,
    points,
    fillArea,
    color: color3
  } = params;
  const isItemHighlighted = isHighlighted({
    seriesId
  });
  const isItemFaded = !isItemHighlighted && isFaded({
    seriesId
  });
  return {
    d: getAreaPath(points),
    fill: fillArea ? color3 : "transparent",
    stroke: color3,
    className: clsx_default(classes.area, isItemHighlighted && classes.highlighted || isItemFaded && classes.faded),
    strokeOpacity: isItemFaded ? 0.5 : 1,
    fillOpacity: isItemHighlighted && 0.4 || isItemFaded && 0.1 || 0.2,
    strokeWidth: !fillArea && isItemHighlighted ? 2 : 1
  };
}
function RadarSeriesArea(props) {
  const {
    seriesId
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded58);
  const seriesCoordinates = useRadarSeriesData(seriesId);
  const interactionProps = useInteractionAllItemProps(seriesCoordinates);
  const {
    isFaded,
    isHighlighted
  } = useItemHighlightedGetter();
  const classes = useUtilityClasses25(props.classes);
  return (0, import_jsx_runtime105.jsx)(React147.Fragment, {
    children: seriesCoordinates == null ? void 0 : seriesCoordinates.map(({
      seriesId: id,
      points,
      color: color3,
      fillArea
    }, seriesIndex) => {
      return (0, import_jsx_runtime105.jsx)("path", _extends({}, getPathProps({
        seriesId: id,
        points,
        color: color3,
        fillArea,
        isFaded,
        isHighlighted,
        classes
      }), interactionProps[seriesIndex], other), id);
    })
  });
}
true ? RadarSeriesArea.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types83.default.object,
  /**
   * The id of the series to display.
   * If undefined all series are displayed.
   */
  seriesId: import_prop_types83.default.string
} : void 0;

// node_modules/@mui/x-charts/esm/RadarChart/RadarSeriesPlot/RadarSeriesMarks.js
var React148 = __toESM(require_react(), 1);
var import_prop_types84 = __toESM(require_prop_types(), 1);
var import_jsx_runtime106 = __toESM(require_jsx_runtime(), 1);
var _excluded59 = ["seriesId"];
function getCircleProps(params) {
  const {
    isHighlighted,
    isFaded,
    seriesId,
    classes,
    point: point6,
    fillArea,
    color: color3
  } = params;
  const isItemHighlighted = isHighlighted({
    seriesId
  });
  const isItemFaded = !isItemHighlighted && isFaded({
    seriesId
  });
  return {
    cx: point6.x,
    cy: point6.y,
    r: 3,
    fill: color3,
    stroke: color3,
    opacity: fillArea && isItemFaded ? 0.5 : 1,
    pointerEvents: "none",
    className: clsx(classes.mark, isItemHighlighted && classes.highlighted || isItemFaded && classes.faded)
  };
}
function RadarSeriesMarks(props) {
  const other = _objectWithoutPropertiesLoose(props, _excluded59);
  const seriesCoordinates = useRadarSeriesData(props.seriesId);
  const classes = useUtilityClasses25(props.classes);
  const {
    isFaded,
    isHighlighted
  } = useItemHighlightedGetter();
  return (0, import_jsx_runtime106.jsx)(React148.Fragment, {
    children: seriesCoordinates == null ? void 0 : seriesCoordinates.map(({
      seriesId: id,
      points,
      color: color3,
      hideMark,
      fillArea
    }) => {
      if (hideMark) {
        return null;
      }
      return (0, import_jsx_runtime106.jsx)("g", {
        children: points.map((point6, index2) => (0, import_jsx_runtime106.jsx)("circle", _extends({}, getCircleProps({
          seriesId: id,
          point: point6,
          color: color3,
          fillArea,
          isFaded,
          isHighlighted,
          classes
        }), other), index2))
      }, id);
    })
  });
}
true ? RadarSeriesMarks.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types84.default.object,
  /**
   * The id of the series to display.
   * If undefined all series are displayed.
   */
  seriesId: import_prop_types84.default.string
} : void 0;

// node_modules/@mui/x-charts/esm/RadarChart/RadarSeriesPlot/RadarSeriesPlot.js
var import_jsx_runtime107 = __toESM(require_jsx_runtime(), 1);
function RadarSeriesPlot(props) {
  const seriesCoordinates = useRadarSeriesData(props.seriesId);
  const interactionProps = useInteractionAllItemProps(seriesCoordinates);
  const {
    isFaded,
    isHighlighted
  } = useItemHighlightedGetter();
  const classes = useUtilityClasses25(props.classes);
  return (0, import_jsx_runtime107.jsx)("g", {
    className: classes.root,
    children: seriesCoordinates == null ? void 0 : seriesCoordinates.map(({
      seriesId,
      points,
      color: color3,
      hideMark,
      fillArea
    }, seriesIndex) => {
      return (0, import_jsx_runtime107.jsxs)("g", {
        children: [(0, import_jsx_runtime107.jsx)("path", _extends({}, getPathProps({
          seriesId,
          points,
          color: color3,
          fillArea,
          isFaded,
          isHighlighted,
          classes
        }), interactionProps[seriesIndex]), seriesId), !hideMark && points.map((point6, index2) => (0, import_jsx_runtime107.jsx)("circle", _extends({}, getCircleProps({
          seriesId,
          point: point6,
          color: color3,
          fillArea,
          isFaded,
          isHighlighted,
          classes
        })), index2))]
      }, seriesId);
    })
  });
}
true ? RadarSeriesPlot.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types85.default.object,
  /**
   * The id of the series to display.
   * If undefined all series are displayed.
   */
  seriesId: import_prop_types85.default.string
} : void 0;

// node_modules/@mui/x-charts/esm/RadarChart/RadarAxisHighlight/RadarAxisHighlight.js
var React150 = __toESM(require_react(), 1);
var import_prop_types86 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/RadarChart/RadarAxisHighlight/useRadarAxisHighlight.js
function useRadarAxisHighlight(params) {
  const {
    includesNeighbors = false
  } = params ?? {};
  const radarSeries = useRadarSeries();
  const rotationScale = useRotationScale();
  const {
    radiusAxis,
    radiusAxisIds
  } = useRadiusAxes();
  const {
    instance
  } = useChartContext();
  const store = useStore();
  const rotationAxisIndex = useSelector(store, selectorChartsInteractionRotationAxisIndex);
  const rotationAxisValue = useSelector(store, selectorChartsInteractionRotationAxisValue);
  const center = useSelector(store, selectorChartPolarCenter);
  const highlightedIndex = rotationAxisIndex;
  if (!rotationScale) {
    return null;
  }
  if (highlightedIndex === null || highlightedIndex === -1) {
    return null;
  }
  if (radarSeries === void 0 || radarSeries.length === 0) {
    return null;
  }
  const metric = radiusAxisIds[highlightedIndex];
  const radiusScale = radiusAxis[metric].scale;
  const angle = rotationScale(rotationAxisValue);
  const radius = radiusScale.range()[1];
  return {
    center,
    radius,
    instance,
    highlightedIndex,
    highlightedMetric: metric,
    highlightedAngle: angle,
    series: radarSeries,
    points: radarSeries.map((series) => {
      const value = series.data[highlightedIndex];
      const r3 = radiusScale(value);
      const [x3, y3] = instance.polar2svg(r3, angle);
      const retrunedValue = {
        highlighted: {
          x: x3,
          y: y3,
          r: r3,
          angle,
          value
        }
      };
      if (!includesNeighbors) {
        return retrunedValue;
      }
      const dataLength = series.data.length;
      const prevIndex = (dataLength + highlightedIndex - 1) % dataLength;
      const nextIndex = (highlightedIndex + 1) % dataLength;
      const prevValue = series.data[prevIndex];
      const nextValue = series.data[nextIndex];
      if (prevValue != null) {
        const prevR = radiusAxis[radiusAxisIds[prevIndex]].scale(prevValue);
        const prevAngle = rotationScale(rotationScale.domain()[prevIndex]);
        const [px, py] = instance.polar2svg(prevR, prevAngle);
        retrunedValue.previous = {
          x: px,
          y: py,
          r: prevR,
          angle: prevAngle,
          value: prevValue
        };
      }
      if (nextValue != null) {
        const nextR = radiusAxis[radiusAxisIds[nextIndex]].scale(nextValue);
        const nextAngle = rotationScale(rotationScale.domain()[nextIndex]);
        const [nx, ny] = instance.polar2svg(nextR, nextAngle);
        retrunedValue.next = {
          x: nx,
          y: ny,
          r: nextR,
          angle: nextAngle,
          value: nextValue
        };
      }
      return retrunedValue;
    })
  };
}

// node_modules/@mui/x-charts/esm/RadarChart/RadarAxisHighlight/radarAxisHighlightClasses.js
function getRadarAxisHighlightUtilityClass(slot) {
  return generateUtilityClass("MuiRadarAxisHighlight", slot);
}
var chartsAxisHighlightClasses2 = generateUtilityClasses("MuiRadarAxisHighlight", ["root", "line", "dot"]);

// node_modules/@mui/x-charts/esm/RadarChart/RadarAxisHighlight/RadarAxisHighlight.js
var import_jsx_runtime108 = __toESM(require_jsx_runtime(), 1);
var useUtilityClasses26 = (classes) => {
  const slots = {
    root: ["root"],
    line: ["line"],
    dot: ["dot"]
  };
  return composeClasses(slots, getRadarAxisHighlightUtilityClass, classes);
};
var highlightMarkShadow = {
  r: 7,
  opacity: 0.3
};
var highlightMark = {
  r: 3,
  opacity: 1
};
function RadarAxisHighlight(props) {
  const classes = useUtilityClasses26(props.classes);
  const theme = useTheme4();
  const data = useRadarAxisHighlight();
  if (data === null) {
    return null;
  }
  const {
    center,
    series,
    points,
    radius,
    highlightedAngle,
    instance
  } = data;
  const [x3, y3] = instance.polar2svg(radius, highlightedAngle);
  return (0, import_jsx_runtime108.jsxs)("g", {
    className: classes.root,
    children: [(0, import_jsx_runtime108.jsx)("path", {
      d: `M ${center.cx} ${center.cy} L ${x3} ${y3}`,
      stroke: (theme.vars || theme).palette.text.primary,
      strokeWidth: 1,
      className: classes.line,
      pointerEvents: "none",
      strokeDasharray: "4 4"
    }), points.map(({
      highlighted
    }, seriesIndex) => {
      return (0, import_jsx_runtime108.jsx)("circle", _extends({
        fill: series[seriesIndex].color,
        cx: highlighted.x,
        cy: highlighted.y,
        className: classes.dot,
        pointerEvents: "none"
      }, series[seriesIndex].hideMark ? highlightMark : highlightMarkShadow), series[seriesIndex].id);
    })]
  });
}
true ? RadarAxisHighlight.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types86.default.object
} : void 0;

// node_modules/@mui/x-charts/esm/RadarChart/RadarMetricLabels/RadarMetricLabels.js
var React151 = __toESM(require_react(), 1);

// node_modules/@mui/x-charts/esm/RadarChart/RadarMetricLabels/useRadarMetricData.js
function useRadarMetricData() {
  const rotationAxis = useRotationAxis();
  const {
    scale: rotationScale,
    valueFormatter,
    labelGap = 10
  } = rotationAxis;
  const {
    radiusAxis
  } = useRadiusAxes();
  const drawingArea = useDrawingArea();
  const cx = drawingArea.left + drawingArea.width / 2;
  const cy = drawingArea.top + drawingArea.height / 2;
  const metrics = rotationScale.domain();
  const angles = metrics.map((key) => rotationScale(key));
  return {
    corners: metrics.map((metric, dataIndex) => {
      const radiusScale = radiusAxis[metric].scale;
      const r3 = radiusScale.range()[1] + labelGap;
      const angle = angles[dataIndex];
      return {
        x: cx + r3 * Math.sin(angle),
        y: cy - r3 * Math.cos(angle),
        angle: rad2deg(angle),
        label: (valueFormatter == null ? void 0 : valueFormatter(metric, {
          location: "tick",
          scale: rotationScale
        })) ?? metric
      };
    })
  };
}

// node_modules/@mui/x-charts/esm/RadarChart/RadarMetricLabels/RadarMetricLabels.js
var import_jsx_runtime109 = __toESM(require_jsx_runtime(), 1);
function RadarMetricLabels() {
  const {
    corners
  } = useRadarMetricData();
  const theme = useTheme4();
  return (0, import_jsx_runtime109.jsx)(React151.Fragment, {
    children: corners.map(({
      x: x3,
      y: y3,
      angle,
      label
    }, i2) => (0, import_jsx_runtime109.jsx)(ChartsText, {
      x: x3,
      y: y3,
      fontSize: 14,
      fill: (theme.vars || theme).palette.text.primary,
      stroke: "none",
      text: label,
      style: _extends({}, theme.typography.caption, {
        fontSize: 12,
        lineHeight: 1.25,
        textAnchor: getDefaultTextAnchor(180 + angle),
        dominantBaseline: getDefaultBaseline(180 + angle)
      })
    }, i2))
  });
}

// node_modules/@mui/x-charts/esm/RadarChart/RadarChart.js
var import_jsx_runtime110 = __toESM(require_jsx_runtime(), 1);
var RadarChart = React152.forwardRef(function RadarChart2(inProps, ref) {
  var _a, _b;
  const props = useThemeProps2({
    props: inProps,
    name: "MuiRadarChart"
  });
  const {
    chartsWrapperProps,
    chartsSurfaceProps,
    radarDataProviderProps,
    radarGrid,
    overlayProps,
    legendProps,
    highlight,
    children: children2
  } = useRadarChartProps(props);
  const Tooltip = ((_a = props.slots) == null ? void 0 : _a.tooltip) ?? ChartsTooltip;
  return (0, import_jsx_runtime110.jsx)(RadarDataProvider, _extends({}, radarDataProviderProps, {
    children: (0, import_jsx_runtime110.jsxs)(ChartsWrapper, _extends({}, chartsWrapperProps, {
      children: [!props.hideLegend && (0, import_jsx_runtime110.jsx)(ChartsLegend, _extends({}, legendProps)), (0, import_jsx_runtime110.jsxs)(ChartsSurface, _extends({}, chartsSurfaceProps, {
        ref,
        children: [(0, import_jsx_runtime110.jsx)(RadarGrid, _extends({}, radarGrid)), (0, import_jsx_runtime110.jsx)(RadarMetricLabels, {}), (0, import_jsx_runtime110.jsx)(RadarSeriesArea, {}), highlight === "axis" && (0, import_jsx_runtime110.jsx)(RadarAxisHighlight, {}), (0, import_jsx_runtime110.jsx)(RadarSeriesMarks, {}), (0, import_jsx_runtime110.jsx)(ChartsOverlay, _extends({}, overlayProps)), !props.loading && (0, import_jsx_runtime110.jsx)(Tooltip, _extends({}, (_b = props.slotProps) == null ? void 0 : _b.tooltip)), children2]
      }))]
    }))
  }));
});
true ? RadarChart.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  apiRef: import_prop_types87.default.shape({
    current: import_prop_types87.default.object
  }),
  children: import_prop_types87.default.node,
  className: import_prop_types87.default.string,
  /**
   * Color palette used to colorize multiple series.
   * @default rainbowSurgePalette
   */
  colors: import_prop_types87.default.oneOfType([import_prop_types87.default.arrayOf(import_prop_types87.default.string), import_prop_types87.default.func]),
  desc: import_prop_types87.default.string,
  /**
   * If `true`, the charts will not listen to the mouse move event.
   * It might break interactive features, but will improve performance.
   * @default false
   */
  disableAxisListener: import_prop_types87.default.bool,
  /**
   * The number of divisions in the radar grid.
   * @default 5
   */
  divisions: import_prop_types87.default.number,
  /**
   * The height of the chart in px. If not defined, it takes the height of the parent element.
   */
  height: import_prop_types87.default.number,
  /**
   * If `true`, the legend is not rendered.
   */
  hideLegend: import_prop_types87.default.bool,
  /**
   * Indicates if the chart should highlight items per axis or per series.
   * @default 'axis'
   */
  highlight: import_prop_types87.default.oneOf(["axis", "none", "series"]),
  /**
   * The highlighted item.
   * Used when the highlight is controlled.
   */
  highlightedItem: import_prop_types87.default.shape({
    dataIndex: import_prop_types87.default.number,
    seriesId: import_prop_types87.default.oneOfType([import_prop_types87.default.number, import_prop_types87.default.string]).isRequired
  }),
  /**
   * This prop is used to help implement the accessibility logic.
   * If you don't provide this prop. It falls back to a randomly generated id.
   */
  id: import_prop_types87.default.string,
  /**
   * If `true`, a loading overlay is displayed.
   * @default false
   */
  loading: import_prop_types87.default.bool,
  /**
   * Localized text for chart components.
   */
  localeText: import_prop_types87.default.object,
  /**
   * The margin between the SVG and the drawing area.
   * It's used for leaving some space for extra information such as the x- and y-axis or legend.
   *
   * Accepts a `number` to be used on all sides or an object with the optional properties: `top`, `bottom`, `left`, and `right`.
   */
  margin: import_prop_types87.default.oneOfType([import_prop_types87.default.number, import_prop_types87.default.shape({
    bottom: import_prop_types87.default.number,
    left: import_prop_types87.default.number,
    right: import_prop_types87.default.number,
    top: import_prop_types87.default.number
  })]),
  /**
   * The callback fired when the highlighted item changes.
   *
   * @param {HighlightItemData | null} highlightedItem  The newly highlighted item.
   */
  onHighlightChange: import_prop_types87.default.func,
  /**
   * The configuration of the radar scales.
   */
  radar: import_prop_types87.default.shape({
    labelFormatter: import_prop_types87.default.func,
    labelGap: import_prop_types87.default.number,
    max: import_prop_types87.default.number,
    metrics: import_prop_types87.default.oneOfType([import_prop_types87.default.arrayOf(import_prop_types87.default.string), import_prop_types87.default.arrayOf(import_prop_types87.default.shape({
      max: import_prop_types87.default.number,
      min: import_prop_types87.default.number,
      name: import_prop_types87.default.string.isRequired
    }))]).isRequired,
    startAngle: import_prop_types87.default.number
  }).isRequired,
  /**
   * The series to display in the bar chart.
   * An array of [[RadarSeriesType]] objects.
   */
  series: import_prop_types87.default.arrayOf(import_prop_types87.default.object).isRequired,
  /**
   * The grid shape.
   * @default 'sharp'
   */
  shape: import_prop_types87.default.oneOf(["circular", "sharp"]),
  /**
   * If `true`, animations are skipped.
   * If unset or `false`, the animations respects the user's `prefers-reduced-motion` setting.
   */
  skipAnimation: import_prop_types87.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types87.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types87.default.object,
  /**
   * Get stripe fill color. Set it to `null` to remove stripes
   * @param {number} index The index of the stripe band.
   * @returns {string} The color to fill the stripe.
   * @default (index) => index % 2 === 1 ? (theme.vars || theme).palette.text.secondary : 'none'
   */
  stripeColor: import_prop_types87.default.func,
  sx: import_prop_types87.default.oneOfType([import_prop_types87.default.arrayOf(import_prop_types87.default.oneOfType([import_prop_types87.default.func, import_prop_types87.default.object, import_prop_types87.default.bool])), import_prop_types87.default.func, import_prop_types87.default.object]),
  theme: import_prop_types87.default.oneOf(["dark", "light"]),
  title: import_prop_types87.default.string,
  /**
   * The width of the chart in px. If not defined, it takes the width of the parent element.
   */
  width: import_prop_types87.default.number
} : void 0;

// node_modules/@mui/x-charts/esm/Toolbar/Toolbar.js
var React153 = __toESM(require_react(), 1);
var import_jsx_runtime111 = __toESM(require_jsx_runtime(), 1);
var ToolbarRoot = styled_default2("div", {
  name: "MuiChartsToolbar",
  slot: "Root"
})(({
  theme
}) => ({
  flex: 0,
  display: "flex",
  alignItems: "center",
  justifyContent: "end",
  gap: theme.spacing(0.25),
  padding: theme.spacing(0.5),
  minHeight: 44,
  boxSizing: "border-box",
  border: `1px solid ${(theme.vars || theme).palette.divider}`,
  borderRadius: 4
}));
function Toolbar({
  children: children2
}) {
  return (0, import_jsx_runtime111.jsx)(ToolbarRoot, {
    children: children2
  });
}

// node_modules/@mui/x-charts/esm/Toolbar/ToolbarButton.js
var import_prop_types101 = __toESM(require_prop_types(), 1);
var React170 = __toESM(require_react(), 1);

// node_modules/@mui/material/esm/IconButton/IconButton.js
var React169 = __toESM(require_react(), 1);
var import_prop_types100 = __toESM(require_prop_types(), 1);

// node_modules/@mui/material/esm/utils/createSvgIcon.js
var React155 = __toESM(require_react(), 1);

// node_modules/@mui/material/esm/SvgIcon/SvgIcon.js
var React154 = __toESM(require_react(), 1);
var import_prop_types88 = __toESM(require_prop_types(), 1);

// node_modules/@mui/material/esm/SvgIcon/svgIconClasses.js
function getSvgIconUtilityClass(slot) {
  return generateUtilityClass("MuiSvgIcon", slot);
}
var svgIconClasses = generateUtilityClasses("MuiSvgIcon", ["root", "colorPrimary", "colorSecondary", "colorAction", "colorError", "colorDisabled", "fontSizeInherit", "fontSizeSmall", "fontSizeMedium", "fontSizeLarge"]);

// node_modules/@mui/material/esm/SvgIcon/SvgIcon.js
var import_jsx_runtime112 = __toESM(require_jsx_runtime(), 1);
var useUtilityClasses27 = (ownerState) => {
  const {
    color: color3,
    fontSize: fontSize2,
    classes
  } = ownerState;
  const slots = {
    root: ["root", color3 !== "inherit" && `color${capitalize_default(color3)}`, `fontSize${capitalize_default(fontSize2)}`]
  };
  return composeClasses(slots, getSvgIconUtilityClass, classes);
};
var SvgIconRoot = styled_default2("svg", {
  name: "MuiSvgIcon",
  slot: "Root",
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [styles.root, ownerState.color !== "inherit" && styles[`color${capitalize_default(ownerState.color)}`], styles[`fontSize${capitalize_default(ownerState.fontSize)}`]];
  }
})(memoTheme_default(({
  theme
}) => {
  var _a, _b, _c, _d, _e2, _f, _g, _h, _i, _j, _k, _l, _m, _n;
  return {
    userSelect: "none",
    width: "1em",
    height: "1em",
    display: "inline-block",
    flexShrink: 0,
    transition: (_d = (_a = theme.transitions) == null ? void 0 : _a.create) == null ? void 0 : _d.call(_a, "fill", {
      duration: (_c = (_b = (theme.vars ?? theme).transitions) == null ? void 0 : _b.duration) == null ? void 0 : _c.shorter
    }),
    variants: [
      {
        props: (props) => !props.hasSvgAsChild,
        style: {
          // the <svg> will define the property that has `currentColor`
          // for example heroicons uses fill="none" and stroke="currentColor"
          fill: "currentColor"
        }
      },
      {
        props: {
          fontSize: "inherit"
        },
        style: {
          fontSize: "inherit"
        }
      },
      {
        props: {
          fontSize: "small"
        },
        style: {
          fontSize: ((_f = (_e2 = theme.typography) == null ? void 0 : _e2.pxToRem) == null ? void 0 : _f.call(_e2, 20)) || "1.25rem"
        }
      },
      {
        props: {
          fontSize: "medium"
        },
        style: {
          fontSize: ((_h = (_g = theme.typography) == null ? void 0 : _g.pxToRem) == null ? void 0 : _h.call(_g, 24)) || "1.5rem"
        }
      },
      {
        props: {
          fontSize: "large"
        },
        style: {
          fontSize: ((_j = (_i = theme.typography) == null ? void 0 : _i.pxToRem) == null ? void 0 : _j.call(_i, 35)) || "2.1875rem"
        }
      },
      // TODO v5 deprecate color prop, v6 remove for sx
      ...Object.entries((theme.vars ?? theme).palette).filter(([, value]) => value && value.main).map(([color3]) => {
        var _a2, _b2;
        return {
          props: {
            color: color3
          },
          style: {
            color: (_b2 = (_a2 = (theme.vars ?? theme).palette) == null ? void 0 : _a2[color3]) == null ? void 0 : _b2.main
          }
        };
      }),
      {
        props: {
          color: "action"
        },
        style: {
          color: (_l = (_k = (theme.vars ?? theme).palette) == null ? void 0 : _k.action) == null ? void 0 : _l.active
        }
      },
      {
        props: {
          color: "disabled"
        },
        style: {
          color: (_n = (_m = (theme.vars ?? theme).palette) == null ? void 0 : _m.action) == null ? void 0 : _n.disabled
        }
      },
      {
        props: {
          color: "inherit"
        },
        style: {
          color: void 0
        }
      }
    ]
  };
}));
var SvgIcon = React154.forwardRef(function SvgIcon2(inProps, ref) {
  const props = useDefaultProps2({
    props: inProps,
    name: "MuiSvgIcon"
  });
  const {
    children: children2,
    className,
    color: color3 = "inherit",
    component = "svg",
    fontSize: fontSize2 = "medium",
    htmlColor,
    inheritViewBox = false,
    titleAccess,
    viewBox = "0 0 24 24",
    ...other
  } = props;
  const hasSvgAsChild = React154.isValidElement(children2) && children2.type === "svg";
  const ownerState = {
    ...props,
    color: color3,
    component,
    fontSize: fontSize2,
    instanceFontSize: inProps.fontSize,
    inheritViewBox,
    viewBox,
    hasSvgAsChild
  };
  const more = {};
  if (!inheritViewBox) {
    more.viewBox = viewBox;
  }
  const classes = useUtilityClasses27(ownerState);
  return (0, import_jsx_runtime112.jsxs)(SvgIconRoot, {
    as: component,
    className: clsx_default(classes.root, className),
    focusable: "false",
    color: htmlColor,
    "aria-hidden": titleAccess ? void 0 : true,
    role: titleAccess ? "img" : void 0,
    ref,
    ...more,
    ...other,
    ...hasSvgAsChild && children2.props,
    ownerState,
    children: [hasSvgAsChild ? children2.props.children : children2, titleAccess ? (0, import_jsx_runtime112.jsx)("title", {
      children: titleAccess
    }) : null]
  });
});
true ? SvgIcon.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * Node passed into the SVG element.
   */
  children: import_prop_types88.default.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types88.default.object,
  /**
   * @ignore
   */
  className: import_prop_types88.default.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).
   * You can use the `htmlColor` prop to apply a color attribute to the SVG element.
   * @default 'inherit'
   */
  color: import_prop_types88.default.oneOfType([import_prop_types88.default.oneOf(["inherit", "action", "disabled", "primary", "secondary", "error", "info", "success", "warning"]), import_prop_types88.default.string]),
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: import_prop_types88.default.elementType,
  /**
   * The fontSize applied to the icon. Defaults to 24px, but can be configure to inherit font size.
   * @default 'medium'
   */
  fontSize: import_prop_types88.default.oneOfType([import_prop_types88.default.oneOf(["inherit", "large", "medium", "small"]), import_prop_types88.default.string]),
  /**
   * Applies a color attribute to the SVG element.
   */
  htmlColor: import_prop_types88.default.string,
  /**
   * If `true`, the root node will inherit the custom `component`'s viewBox and the `viewBox`
   * prop will be ignored.
   * Useful when you want to reference a custom `component` and have `SvgIcon` pass that
   * `component`'s viewBox to the root node.
   * @default false
   */
  inheritViewBox: import_prop_types88.default.bool,
  /**
   * The shape-rendering attribute. The behavior of the different options is described on the
   * [MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/SVG/Reference/Attribute/shape-rendering).
   * If you are having issues with blurry icons you should investigate this prop.
   */
  shapeRendering: import_prop_types88.default.string,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types88.default.oneOfType([import_prop_types88.default.arrayOf(import_prop_types88.default.oneOfType([import_prop_types88.default.func, import_prop_types88.default.object, import_prop_types88.default.bool])), import_prop_types88.default.func, import_prop_types88.default.object]),
  /**
   * Provides a human-readable title for the element that contains it.
   * https://www.w3.org/TR/SVG-access/#Equivalent
   */
  titleAccess: import_prop_types88.default.string,
  /**
   * Allows you to redefine what the coordinates without units mean inside an SVG element.
   * For example, if the SVG element is 500 (width) by 200 (height),
   * and you pass viewBox="0 0 50 20",
   * this means that the coordinates inside the SVG will go from the top left corner (0,0)
   * to bottom right (50,20) and each unit will be worth 10px.
   * @default '0 0 24 24'
   */
  viewBox: import_prop_types88.default.string
} : void 0;
SvgIcon.muiName = "SvgIcon";

// node_modules/@mui/material/esm/utils/createSvgIcon.js
var import_jsx_runtime113 = __toESM(require_jsx_runtime(), 1);

// node_modules/@mui/material/esm/utils/useId.js
var useId_default = useId;

// node_modules/@mui/utils/esm/useControlled/useControlled.js
var React156 = __toESM(require_react(), 1);

// node_modules/@mui/material/esm/utils/useEventCallback.js
var useEventCallback_default2 = useEventCallback_default;

// node_modules/@mui/material/esm/utils/useForkRef.js
var useForkRef_default = useForkRef;

// node_modules/@mui/material/esm/ButtonBase/ButtonBase.js
var React167 = __toESM(require_react(), 1);
var import_prop_types98 = __toESM(require_prop_types(), 1);

// node_modules/@mui/utils/esm/elementTypeAcceptingRef/elementTypeAcceptingRef.js
var import_prop_types89 = __toESM(require_prop_types(), 1);
function isClassComponent(elementType) {
  const {
    prototype = {}
  } = elementType;
  return Boolean(prototype.isReactComponent);
}
function elementTypeAcceptingRef(props, propName, componentName, location, propFullName) {
  const propValue = props[propName];
  const safePropName = propFullName || propName;
  if (propValue == null || // When server-side rendering React doesn't warn either.
  // This is not an accurate check for SSR.
  // This is only in place for emotion compat.
  // TODO: Revisit once https://github.com/facebook/react/issues/20047 is resolved.
  typeof window === "undefined") {
    return null;
  }
  let warningHint;
  if (typeof propValue === "function" && !isClassComponent(propValue)) {
    warningHint = "Did you accidentally provide a plain function component instead?";
  }
  if (warningHint !== void 0) {
    return new Error(`Invalid ${location} \`${safePropName}\` supplied to \`${componentName}\`. Expected an element type that can hold a ref. ${warningHint} For more information see https://mui.com/r/caveat-with-refs-guide`);
  }
  return null;
}
var elementTypeAcceptingRef_default = chainPropTypes(import_prop_types89.default.elementType, elementTypeAcceptingRef);

// node_modules/@mui/utils/esm/isFocusVisible/isFocusVisible.js
function isFocusVisible(element) {
  try {
    return element.matches(":focus-visible");
  } catch (error) {
    if (!/jsdom/.test(window.navigator.userAgent)) {
      console.warn(["MUI: The `:focus-visible` pseudo class is not supported in this browser.", "Some components rely on this feature to work properly."].join("\n"));
    }
  }
  return false;
}

// node_modules/@mui/material/esm/useLazyRipple/useLazyRipple.js
var React157 = __toESM(require_react(), 1);
var LazyRipple = class _LazyRipple {
  constructor() {
    __publicField(this, "mountEffect", () => {
      if (this.shouldMount && !this.didMount) {
        if (this.ref.current !== null) {
          this.didMount = true;
          this.mounted.resolve();
        }
      }
    });
    this.ref = {
      current: null
    };
    this.mounted = null;
    this.didMount = false;
    this.shouldMount = false;
    this.setShouldMount = null;
  }
  /** React ref to the ripple instance */
  /** If the ripple component should be mounted */
  /** Promise that resolves when the ripple component is mounted */
  /** If the ripple component has been mounted */
  /** React state hook setter */
  static create() {
    return new _LazyRipple();
  }
  static use() {
    const ripple = useLazyRef(_LazyRipple.create).current;
    const [shouldMount, setShouldMount] = React157.useState(false);
    ripple.shouldMount = shouldMount;
    ripple.setShouldMount = setShouldMount;
    React157.useEffect(ripple.mountEffect, [shouldMount]);
    return ripple;
  }
  mount() {
    if (!this.mounted) {
      this.mounted = createControlledPromise();
      this.shouldMount = true;
      this.setShouldMount(this.shouldMount);
    }
    return this.mounted;
  }
  /* Ripple API */
  start(...args) {
    this.mount().then(() => {
      var _a;
      return (_a = this.ref.current) == null ? void 0 : _a.start(...args);
    });
  }
  stop(...args) {
    this.mount().then(() => {
      var _a;
      return (_a = this.ref.current) == null ? void 0 : _a.stop(...args);
    });
  }
  pulsate(...args) {
    this.mount().then(() => {
      var _a;
      return (_a = this.ref.current) == null ? void 0 : _a.pulsate(...args);
    });
  }
};
function useLazyRipple() {
  return LazyRipple.use();
}
function createControlledPromise() {
  let resolve;
  let reject;
  const p2 = new Promise((resolveFn, rejectFn) => {
    resolve = resolveFn;
    reject = rejectFn;
  });
  p2.resolve = resolve;
  p2.reject = reject;
  return p2;
}

// node_modules/@mui/material/esm/ButtonBase/TouchRipple.js
var React166 = __toESM(require_react(), 1);
var import_prop_types97 = __toESM(require_prop_types(), 1);

// node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(t, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e3) {
    return t4.__proto__ = e3, t4;
  }, _setPrototypeOf(t, e);
}

// node_modules/@babel/runtime/helpers/esm/inheritsLoose.js
function _inheritsLoose(t, o2) {
  t.prototype = Object.create(o2.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o2);
}

// node_modules/react-transition-group/esm/CSSTransition.js
var import_prop_types92 = __toESM(require_prop_types());

// node_modules/dom-helpers/esm/hasClass.js
function hasClass(element, className) {
  if (element.classList) return !!className && element.classList.contains(className);
  return (" " + (element.className.baseVal || element.className) + " ").indexOf(" " + className + " ") !== -1;
}

// node_modules/dom-helpers/esm/addClass.js
function addClass(element, className) {
  if (element.classList) element.classList.add(className);
  else if (!hasClass(element, className)) if (typeof element.className === "string") element.className = element.className + " " + className;
  else element.setAttribute("class", (element.className && element.className.baseVal || "") + " " + className);
}

// node_modules/dom-helpers/esm/removeClass.js
function replaceClassName(origClass, classToRemove) {
  return origClass.replace(new RegExp("(^|\\s)" + classToRemove + "(?:\\s|$)", "g"), "$1").replace(/\s+/g, " ").replace(/^\s*|\s*$/g, "");
}
function removeClass(element, className) {
  if (element.classList) {
    element.classList.remove(className);
  } else if (typeof element.className === "string") {
    element.className = replaceClassName(element.className, className);
  } else {
    element.setAttribute("class", replaceClassName(element.className && element.className.baseVal || "", className));
  }
}

// node_modules/react-transition-group/esm/CSSTransition.js
var import_react4 = __toESM(require_react());

// node_modules/react-transition-group/esm/Transition.js
var import_prop_types91 = __toESM(require_prop_types());
var import_react3 = __toESM(require_react());
var import_react_dom = __toESM(require_react_dom());

// node_modules/react-transition-group/esm/config.js
var config_default = {
  disabled: false
};

// node_modules/react-transition-group/esm/utils/PropTypes.js
var import_prop_types90 = __toESM(require_prop_types());
var timeoutsShape = true ? import_prop_types90.default.oneOfType([import_prop_types90.default.number, import_prop_types90.default.shape({
  enter: import_prop_types90.default.number,
  exit: import_prop_types90.default.number,
  appear: import_prop_types90.default.number
}).isRequired]) : null;
var classNamesShape = true ? import_prop_types90.default.oneOfType([import_prop_types90.default.string, import_prop_types90.default.shape({
  enter: import_prop_types90.default.string,
  exit: import_prop_types90.default.string,
  active: import_prop_types90.default.string
}), import_prop_types90.default.shape({
  enter: import_prop_types90.default.string,
  enterDone: import_prop_types90.default.string,
  enterActive: import_prop_types90.default.string,
  exit: import_prop_types90.default.string,
  exitDone: import_prop_types90.default.string,
  exitActive: import_prop_types90.default.string
})]) : null;

// node_modules/react-transition-group/esm/TransitionGroupContext.js
var import_react2 = __toESM(require_react());
var TransitionGroupContext_default = import_react2.default.createContext(null);

// node_modules/react-transition-group/esm/utils/reflow.js
var forceReflow = function forceReflow2(node2) {
  return node2.scrollTop;
};

// node_modules/react-transition-group/esm/Transition.js
var UNMOUNTED = "unmounted";
var EXITED = "exited";
var ENTERING = "entering";
var ENTERED = "entered";
var EXITING = "exiting";
var Transition2 = function(_React$Component) {
  _inheritsLoose(Transition3, _React$Component);
  function Transition3(props, context) {
    var _this;
    _this = _React$Component.call(this, props, context) || this;
    var parentGroup = context;
    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
    var initialStatus;
    _this.appearStatus = null;
    if (props.in) {
      if (appear) {
        initialStatus = EXITED;
        _this.appearStatus = ENTERING;
      } else {
        initialStatus = ENTERED;
      }
    } else {
      if (props.unmountOnExit || props.mountOnEnter) {
        initialStatus = UNMOUNTED;
      } else {
        initialStatus = EXITED;
      }
    }
    _this.state = {
      status: initialStatus
    };
    _this.nextCallback = null;
    return _this;
  }
  Transition3.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
    var nextIn = _ref.in;
    if (nextIn && prevState.status === UNMOUNTED) {
      return {
        status: EXITED
      };
    }
    return null;
  };
  var _proto = Transition3.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.updateStatus(true, this.appearStatus);
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var nextStatus = null;
    if (prevProps !== this.props) {
      var status = this.state.status;
      if (this.props.in) {
        if (status !== ENTERING && status !== ENTERED) {
          nextStatus = ENTERING;
        }
      } else {
        if (status === ENTERING || status === ENTERED) {
          nextStatus = EXITING;
        }
      }
    }
    this.updateStatus(false, nextStatus);
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.cancelNextCallback();
  };
  _proto.getTimeouts = function getTimeouts() {
    var timeout3 = this.props.timeout;
    var exit, enter, appear;
    exit = enter = appear = timeout3;
    if (timeout3 != null && typeof timeout3 !== "number") {
      exit = timeout3.exit;
      enter = timeout3.enter;
      appear = timeout3.appear !== void 0 ? timeout3.appear : enter;
    }
    return {
      exit,
      enter,
      appear
    };
  };
  _proto.updateStatus = function updateStatus(mounting, nextStatus) {
    if (mounting === void 0) {
      mounting = false;
    }
    if (nextStatus !== null) {
      this.cancelNextCallback();
      if (nextStatus === ENTERING) {
        if (this.props.unmountOnExit || this.props.mountOnEnter) {
          var node2 = this.props.nodeRef ? this.props.nodeRef.current : import_react_dom.default.findDOMNode(this);
          if (node2) forceReflow(node2);
        }
        this.performEnter(mounting);
      } else {
        this.performExit();
      }
    } else if (this.props.unmountOnExit && this.state.status === EXITED) {
      this.setState({
        status: UNMOUNTED
      });
    }
  };
  _proto.performEnter = function performEnter(mounting) {
    var _this2 = this;
    var enter = this.props.enter;
    var appearing = this.context ? this.context.isMounting : mounting;
    var _ref2 = this.props.nodeRef ? [appearing] : [import_react_dom.default.findDOMNode(this), appearing], maybeNode = _ref2[0], maybeAppearing = _ref2[1];
    var timeouts = this.getTimeouts();
    var enterTimeout = appearing ? timeouts.appear : timeouts.enter;
    if (!mounting && !enter || config_default.disabled) {
      this.safeSetState({
        status: ENTERED
      }, function() {
        _this2.props.onEntered(maybeNode);
      });
      return;
    }
    this.props.onEnter(maybeNode, maybeAppearing);
    this.safeSetState({
      status: ENTERING
    }, function() {
      _this2.props.onEntering(maybeNode, maybeAppearing);
      _this2.onTransitionEnd(enterTimeout, function() {
        _this2.safeSetState({
          status: ENTERED
        }, function() {
          _this2.props.onEntered(maybeNode, maybeAppearing);
        });
      });
    });
  };
  _proto.performExit = function performExit() {
    var _this3 = this;
    var exit = this.props.exit;
    var timeouts = this.getTimeouts();
    var maybeNode = this.props.nodeRef ? void 0 : import_react_dom.default.findDOMNode(this);
    if (!exit || config_default.disabled) {
      this.safeSetState({
        status: EXITED
      }, function() {
        _this3.props.onExited(maybeNode);
      });
      return;
    }
    this.props.onExit(maybeNode);
    this.safeSetState({
      status: EXITING
    }, function() {
      _this3.props.onExiting(maybeNode);
      _this3.onTransitionEnd(timeouts.exit, function() {
        _this3.safeSetState({
          status: EXITED
        }, function() {
          _this3.props.onExited(maybeNode);
        });
      });
    });
  };
  _proto.cancelNextCallback = function cancelNextCallback() {
    if (this.nextCallback !== null) {
      this.nextCallback.cancel();
      this.nextCallback = null;
    }
  };
  _proto.safeSetState = function safeSetState(nextState, callback) {
    callback = this.setNextCallback(callback);
    this.setState(nextState, callback);
  };
  _proto.setNextCallback = function setNextCallback(callback) {
    var _this4 = this;
    var active = true;
    this.nextCallback = function(event) {
      if (active) {
        active = false;
        _this4.nextCallback = null;
        callback(event);
      }
    };
    this.nextCallback.cancel = function() {
      active = false;
    };
    return this.nextCallback;
  };
  _proto.onTransitionEnd = function onTransitionEnd(timeout3, handler) {
    this.setNextCallback(handler);
    var node2 = this.props.nodeRef ? this.props.nodeRef.current : import_react_dom.default.findDOMNode(this);
    var doesNotHaveTimeoutOrListener = timeout3 == null && !this.props.addEndListener;
    if (!node2 || doesNotHaveTimeoutOrListener) {
      setTimeout(this.nextCallback, 0);
      return;
    }
    if (this.props.addEndListener) {
      var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node2, this.nextCallback], maybeNode = _ref3[0], maybeNextCallback = _ref3[1];
      this.props.addEndListener(maybeNode, maybeNextCallback);
    }
    if (timeout3 != null) {
      setTimeout(this.nextCallback, timeout3);
    }
  };
  _proto.render = function render() {
    var status = this.state.status;
    if (status === UNMOUNTED) {
      return null;
    }
    var _this$props = this.props, children2 = _this$props.children, _in = _this$props.in, _mountOnEnter = _this$props.mountOnEnter, _unmountOnExit = _this$props.unmountOnExit, _appear = _this$props.appear, _enter = _this$props.enter, _exit = _this$props.exit, _timeout = _this$props.timeout, _addEndListener = _this$props.addEndListener, _onEnter = _this$props.onEnter, _onEntering = _this$props.onEntering, _onEntered = _this$props.onEntered, _onExit = _this$props.onExit, _onExiting = _this$props.onExiting, _onExited = _this$props.onExited, _nodeRef = _this$props.nodeRef, childProps = _objectWithoutPropertiesLoose(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
    return (
      // allows for nested Transitions
      import_react3.default.createElement(TransitionGroupContext_default.Provider, {
        value: null
      }, typeof children2 === "function" ? children2(status, childProps) : import_react3.default.cloneElement(import_react3.default.Children.only(children2), childProps))
    );
  };
  return Transition3;
}(import_react3.default.Component);
Transition2.contextType = TransitionGroupContext_default;
Transition2.propTypes = true ? {
  /**
   * A React reference to DOM element that need to transition:
   * https://stackoverflow.com/a/51127130/4671932
   *
   *   - When `nodeRef` prop is used, `node` is not passed to callback functions
   *      (e.g. `onEnter`) because user already has direct access to the node.
   *   - When changing `key` prop of `Transition` in a `TransitionGroup` a new
   *     `nodeRef` need to be provided to `Transition` with changed `key` prop
   *     (see
   *     [test/CSSTransition-test.js](https://github.com/reactjs/react-transition-group/blob/13435f897b3ab71f6e19d724f145596f5910581c/test/CSSTransition-test.js#L362-L437)).
   */
  nodeRef: import_prop_types91.default.shape({
    current: typeof Element === "undefined" ? import_prop_types91.default.any : function(propValue, key, componentName, location, propFullName, secret) {
      var value = propValue[key];
      return import_prop_types91.default.instanceOf(value && "ownerDocument" in value ? value.ownerDocument.defaultView.Element : Element)(propValue, key, componentName, location, propFullName, secret);
    }
  }),
  /**
   * A `function` child can be used instead of a React element. This function is
   * called with the current transition status (`'entering'`, `'entered'`,
   * `'exiting'`, `'exited'`), which can be used to apply context
   * specific props to a component.
   *
   * ```jsx
   * <Transition in={this.state.in} timeout={150}>
   *   {state => (
   *     <MyComponent className={`fade fade-${state}`} />
   *   )}
   * </Transition>
   * ```
   */
  children: import_prop_types91.default.oneOfType([import_prop_types91.default.func.isRequired, import_prop_types91.default.element.isRequired]).isRequired,
  /**
   * Show the component; triggers the enter or exit states
   */
  in: import_prop_types91.default.bool,
  /**
   * By default the child component is mounted immediately along with
   * the parent `Transition` component. If you want to "lazy mount" the component on the
   * first `in={true}` you can set `mountOnEnter`. After the first enter transition the component will stay
   * mounted, even on "exited", unless you also specify `unmountOnExit`.
   */
  mountOnEnter: import_prop_types91.default.bool,
  /**
   * By default the child component stays mounted after it reaches the `'exited'` state.
   * Set `unmountOnExit` if you'd prefer to unmount the component after it finishes exiting.
   */
  unmountOnExit: import_prop_types91.default.bool,
  /**
   * By default the child component does not perform the enter transition when
   * it first mounts, regardless of the value of `in`. If you want this
   * behavior, set both `appear` and `in` to `true`.
   *
   * > **Note**: there are no special appear states like `appearing`/`appeared`, this prop
   * > only adds an additional enter transition. However, in the
   * > `<CSSTransition>` component that first enter transition does result in
   * > additional `.appear-*` classes, that way you can choose to style it
   * > differently.
   */
  appear: import_prop_types91.default.bool,
  /**
   * Enable or disable enter transitions.
   */
  enter: import_prop_types91.default.bool,
  /**
   * Enable or disable exit transitions.
   */
  exit: import_prop_types91.default.bool,
  /**
   * The duration of the transition, in milliseconds.
   * Required unless `addEndListener` is provided.
   *
   * You may specify a single timeout for all transitions:
   *
   * ```jsx
   * timeout={500}
   * ```
   *
   * or individually:
   *
   * ```jsx
   * timeout={{
   *  appear: 500,
   *  enter: 300,
   *  exit: 500,
   * }}
   * ```
   *
   * - `appear` defaults to the value of `enter`
   * - `enter` defaults to `0`
   * - `exit` defaults to `0`
   *
   * @type {number | { enter?: number, exit?: number, appear?: number }}
   */
  timeout: function timeout2(props) {
    var pt2 = timeoutsShape;
    if (!props.addEndListener) pt2 = pt2.isRequired;
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return pt2.apply(void 0, [props].concat(args));
  },
  /**
   * Add a custom transition end trigger. Called with the transitioning
   * DOM node and a `done` callback. Allows for more fine grained transition end
   * logic. Timeouts are still used as a fallback if provided.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * ```jsx
   * addEndListener={(node, done) => {
   *   // use the css transitionend event to mark the finish of a transition
   *   node.addEventListener('transitionend', done, false);
   * }}
   * ```
   */
  addEndListener: import_prop_types91.default.func,
  /**
   * Callback fired before the "entering" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool) -> void
   */
  onEnter: import_prop_types91.default.func,
  /**
   * Callback fired after the "entering" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntering: import_prop_types91.default.func,
  /**
   * Callback fired after the "entered" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool) -> void
   */
  onEntered: import_prop_types91.default.func,
  /**
   * Callback fired before the "exiting" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExit: import_prop_types91.default.func,
  /**
   * Callback fired after the "exiting" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExiting: import_prop_types91.default.func,
  /**
   * Callback fired after the "exited" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExited: import_prop_types91.default.func
} : {};
function noop3() {
}
Transition2.defaultProps = {
  in: false,
  mountOnEnter: false,
  unmountOnExit: false,
  appear: false,
  enter: true,
  exit: true,
  onEnter: noop3,
  onEntering: noop3,
  onEntered: noop3,
  onExit: noop3,
  onExiting: noop3,
  onExited: noop3
};
Transition2.UNMOUNTED = UNMOUNTED;
Transition2.EXITED = EXITED;
Transition2.ENTERING = ENTERING;
Transition2.ENTERED = ENTERED;
Transition2.EXITING = EXITING;
var Transition_default = Transition2;

// node_modules/react-transition-group/esm/CSSTransition.js
var _addClass = function addClass2(node2, classes) {
  return node2 && classes && classes.split(" ").forEach(function(c3) {
    return addClass(node2, c3);
  });
};
var removeClass2 = function removeClass3(node2, classes) {
  return node2 && classes && classes.split(" ").forEach(function(c3) {
    return removeClass(node2, c3);
  });
};
var CSSTransition = function(_React$Component) {
  _inheritsLoose(CSSTransition2, _React$Component);
  function CSSTransition2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.appliedClasses = {
      appear: {},
      enter: {},
      exit: {}
    };
    _this.onEnter = function(maybeNode, maybeAppearing) {
      var _this$resolveArgument = _this.resolveArguments(maybeNode, maybeAppearing), node2 = _this$resolveArgument[0], appearing = _this$resolveArgument[1];
      _this.removeClasses(node2, "exit");
      _this.addClass(node2, appearing ? "appear" : "enter", "base");
      if (_this.props.onEnter) {
        _this.props.onEnter(maybeNode, maybeAppearing);
      }
    };
    _this.onEntering = function(maybeNode, maybeAppearing) {
      var _this$resolveArgument2 = _this.resolveArguments(maybeNode, maybeAppearing), node2 = _this$resolveArgument2[0], appearing = _this$resolveArgument2[1];
      var type = appearing ? "appear" : "enter";
      _this.addClass(node2, type, "active");
      if (_this.props.onEntering) {
        _this.props.onEntering(maybeNode, maybeAppearing);
      }
    };
    _this.onEntered = function(maybeNode, maybeAppearing) {
      var _this$resolveArgument3 = _this.resolveArguments(maybeNode, maybeAppearing), node2 = _this$resolveArgument3[0], appearing = _this$resolveArgument3[1];
      var type = appearing ? "appear" : "enter";
      _this.removeClasses(node2, type);
      _this.addClass(node2, type, "done");
      if (_this.props.onEntered) {
        _this.props.onEntered(maybeNode, maybeAppearing);
      }
    };
    _this.onExit = function(maybeNode) {
      var _this$resolveArgument4 = _this.resolveArguments(maybeNode), node2 = _this$resolveArgument4[0];
      _this.removeClasses(node2, "appear");
      _this.removeClasses(node2, "enter");
      _this.addClass(node2, "exit", "base");
      if (_this.props.onExit) {
        _this.props.onExit(maybeNode);
      }
    };
    _this.onExiting = function(maybeNode) {
      var _this$resolveArgument5 = _this.resolveArguments(maybeNode), node2 = _this$resolveArgument5[0];
      _this.addClass(node2, "exit", "active");
      if (_this.props.onExiting) {
        _this.props.onExiting(maybeNode);
      }
    };
    _this.onExited = function(maybeNode) {
      var _this$resolveArgument6 = _this.resolveArguments(maybeNode), node2 = _this$resolveArgument6[0];
      _this.removeClasses(node2, "exit");
      _this.addClass(node2, "exit", "done");
      if (_this.props.onExited) {
        _this.props.onExited(maybeNode);
      }
    };
    _this.resolveArguments = function(maybeNode, maybeAppearing) {
      return _this.props.nodeRef ? [_this.props.nodeRef.current, maybeNode] : [maybeNode, maybeAppearing];
    };
    _this.getClassNames = function(type) {
      var classNames = _this.props.classNames;
      var isStringClassNames = typeof classNames === "string";
      var prefix2 = isStringClassNames && classNames ? classNames + "-" : "";
      var baseClassName = isStringClassNames ? "" + prefix2 + type : classNames[type];
      var activeClassName = isStringClassNames ? baseClassName + "-active" : classNames[type + "Active"];
      var doneClassName = isStringClassNames ? baseClassName + "-done" : classNames[type + "Done"];
      return {
        baseClassName,
        activeClassName,
        doneClassName
      };
    };
    return _this;
  }
  var _proto = CSSTransition2.prototype;
  _proto.addClass = function addClass3(node2, type, phase) {
    var className = this.getClassNames(type)[phase + "ClassName"];
    var _this$getClassNames = this.getClassNames("enter"), doneClassName = _this$getClassNames.doneClassName;
    if (type === "appear" && phase === "done" && doneClassName) {
      className += " " + doneClassName;
    }
    if (phase === "active") {
      if (node2) forceReflow(node2);
    }
    if (className) {
      this.appliedClasses[type][phase] = className;
      _addClass(node2, className);
    }
  };
  _proto.removeClasses = function removeClasses(node2, type) {
    var _this$appliedClasses$ = this.appliedClasses[type], baseClassName = _this$appliedClasses$.base, activeClassName = _this$appliedClasses$.active, doneClassName = _this$appliedClasses$.done;
    this.appliedClasses[type] = {};
    if (baseClassName) {
      removeClass2(node2, baseClassName);
    }
    if (activeClassName) {
      removeClass2(node2, activeClassName);
    }
    if (doneClassName) {
      removeClass2(node2, doneClassName);
    }
  };
  _proto.render = function render() {
    var _this$props = this.props, _2 = _this$props.classNames, props = _objectWithoutPropertiesLoose(_this$props, ["classNames"]);
    return import_react4.default.createElement(Transition_default, _extends({}, props, {
      onEnter: this.onEnter,
      onEntered: this.onEntered,
      onEntering: this.onEntering,
      onExit: this.onExit,
      onExiting: this.onExiting,
      onExited: this.onExited
    }));
  };
  return CSSTransition2;
}(import_react4.default.Component);
CSSTransition.defaultProps = {
  classNames: ""
};
CSSTransition.propTypes = true ? _extends({}, Transition_default.propTypes, {
  /**
   * The animation classNames applied to the component as it appears, enters,
   * exits or has finished the transition. A single name can be provided, which
   * will be suffixed for each stage, e.g. `classNames="fade"` applies:
   *
   * - `fade-appear`, `fade-appear-active`, `fade-appear-done`
   * - `fade-enter`, `fade-enter-active`, `fade-enter-done`
   * - `fade-exit`, `fade-exit-active`, `fade-exit-done`
   *
   * A few details to note about how these classes are applied:
   *
   * 1. They are _joined_ with the ones that are already defined on the child
   *    component, so if you want to add some base styles, you can use
   *    `className` without worrying that it will be overridden.
   *
   * 2. If the transition component mounts with `in={false}`, no classes are
   *    applied yet. You might be expecting `*-exit-done`, but if you think
   *    about it, a component cannot finish exiting if it hasn't entered yet.
   *
   * 2. `fade-appear-done` and `fade-enter-done` will _both_ be applied. This
   *    allows you to define different behavior for when appearing is done and
   *    when regular entering is done, using selectors like
   *    `.fade-enter-done:not(.fade-appear-done)`. For example, you could apply
   *    an epic entrance animation when element first appears in the DOM using
   *    [Animate.css](https://daneden.github.io/animate.css/). Otherwise you can
   *    simply use `fade-enter-done` for defining both cases.
   *
   * Each individual classNames can also be specified independently like:
   *
   * ```js
   * classNames={{
   *  appear: 'my-appear',
   *  appearActive: 'my-active-appear',
   *  appearDone: 'my-done-appear',
   *  enter: 'my-enter',
   *  enterActive: 'my-active-enter',
   *  enterDone: 'my-done-enter',
   *  exit: 'my-exit',
   *  exitActive: 'my-active-exit',
   *  exitDone: 'my-done-exit',
   * }}
   * ```
   *
   * If you want to set these classes using CSS Modules:
   *
   * ```js
   * import styles from './styles.css';
   * ```
   *
   * you might want to use camelCase in your CSS file, that way could simply
   * spread them instead of listing them one by one:
   *
   * ```js
   * classNames={{ ...styles }}
   * ```
   *
   * @type {string | {
   *  appear?: string,
   *  appearActive?: string,
   *  appearDone?: string,
   *  enter?: string,
   *  enterActive?: string,
   *  enterDone?: string,
   *  exit?: string,
   *  exitActive?: string,
   *  exitDone?: string,
   * }}
   */
  classNames: classNamesShape,
  /**
   * A `<Transition>` callback fired immediately after the 'enter' or 'appear' class is
   * applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEnter: import_prop_types92.default.func,
  /**
   * A `<Transition>` callback fired immediately after the 'enter-active' or
   * 'appear-active' class is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntering: import_prop_types92.default.func,
  /**
   * A `<Transition>` callback fired immediately after the 'enter' or
   * 'appear' classes are **removed** and the `done` class is added to the DOM node.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntered: import_prop_types92.default.func,
  /**
   * A `<Transition>` callback fired immediately after the 'exit' class is
   * applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement)
   */
  onExit: import_prop_types92.default.func,
  /**
   * A `<Transition>` callback fired immediately after the 'exit-active' is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement)
   */
  onExiting: import_prop_types92.default.func,
  /**
   * A `<Transition>` callback fired immediately after the 'exit' classes
   * are **removed** and the `exit-done` class is added to the DOM node.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement)
   */
  onExited: import_prop_types92.default.func
}) : {};

// node_modules/react-transition-group/esm/ReplaceTransition.js
var import_prop_types94 = __toESM(require_prop_types());
var import_react7 = __toESM(require_react());
var import_react_dom2 = __toESM(require_react_dom());

// node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized(e) {
  if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}

// node_modules/react-transition-group/esm/TransitionGroup.js
var import_prop_types93 = __toESM(require_prop_types());
var import_react6 = __toESM(require_react());

// node_modules/react-transition-group/esm/utils/ChildMapping.js
var import_react5 = __toESM(require_react());
function getChildMapping(children2, mapFn) {
  var mapper = function mapper2(child) {
    return mapFn && (0, import_react5.isValidElement)(child) ? mapFn(child) : child;
  };
  var result = /* @__PURE__ */ Object.create(null);
  if (children2) import_react5.Children.map(children2, function(c3) {
    return c3;
  }).forEach(function(child) {
    result[child.key] = mapper(child);
  });
  return result;
}
function mergeChildMappings(prev2, next2) {
  prev2 = prev2 || {};
  next2 = next2 || {};
  function getValueForKey(key) {
    return key in next2 ? next2[key] : prev2[key];
  }
  var nextKeysPending = /* @__PURE__ */ Object.create(null);
  var pendingKeys = [];
  for (var prevKey in prev2) {
    if (prevKey in next2) {
      if (pendingKeys.length) {
        nextKeysPending[prevKey] = pendingKeys;
        pendingKeys = [];
      }
    } else {
      pendingKeys.push(prevKey);
    }
  }
  var i2;
  var childMapping = {};
  for (var nextKey in next2) {
    if (nextKeysPending[nextKey]) {
      for (i2 = 0; i2 < nextKeysPending[nextKey].length; i2++) {
        var pendingNextKey = nextKeysPending[nextKey][i2];
        childMapping[nextKeysPending[nextKey][i2]] = getValueForKey(pendingNextKey);
      }
    }
    childMapping[nextKey] = getValueForKey(nextKey);
  }
  for (i2 = 0; i2 < pendingKeys.length; i2++) {
    childMapping[pendingKeys[i2]] = getValueForKey(pendingKeys[i2]);
  }
  return childMapping;
}
function getProp(child, prop, props) {
  return props[prop] != null ? props[prop] : child.props[prop];
}
function getInitialChildMapping(props, onExited) {
  return getChildMapping(props.children, function(child) {
    return (0, import_react5.cloneElement)(child, {
      onExited: onExited.bind(null, child),
      in: true,
      appear: getProp(child, "appear", props),
      enter: getProp(child, "enter", props),
      exit: getProp(child, "exit", props)
    });
  });
}
function getNextChildMapping(nextProps, prevChildMapping, onExited) {
  var nextChildMapping = getChildMapping(nextProps.children);
  var children2 = mergeChildMappings(prevChildMapping, nextChildMapping);
  Object.keys(children2).forEach(function(key) {
    var child = children2[key];
    if (!(0, import_react5.isValidElement)(child)) return;
    var hasPrev = key in prevChildMapping;
    var hasNext = key in nextChildMapping;
    var prevChild = prevChildMapping[key];
    var isLeaving = (0, import_react5.isValidElement)(prevChild) && !prevChild.props.in;
    if (hasNext && (!hasPrev || isLeaving)) {
      children2[key] = (0, import_react5.cloneElement)(child, {
        onExited: onExited.bind(null, child),
        in: true,
        exit: getProp(child, "exit", nextProps),
        enter: getProp(child, "enter", nextProps)
      });
    } else if (!hasNext && hasPrev && !isLeaving) {
      children2[key] = (0, import_react5.cloneElement)(child, {
        in: false
      });
    } else if (hasNext && hasPrev && (0, import_react5.isValidElement)(prevChild)) {
      children2[key] = (0, import_react5.cloneElement)(child, {
        onExited: onExited.bind(null, child),
        in: prevChild.props.in,
        exit: getProp(child, "exit", nextProps),
        enter: getProp(child, "enter", nextProps)
      });
    }
  });
  return children2;
}

// node_modules/react-transition-group/esm/TransitionGroup.js
var values2 = Object.values || function(obj) {
  return Object.keys(obj).map(function(k3) {
    return obj[k3];
  });
};
var defaultProps3 = {
  component: "div",
  childFactory: function childFactory(child) {
    return child;
  }
};
var TransitionGroup = function(_React$Component) {
  _inheritsLoose(TransitionGroup2, _React$Component);
  function TransitionGroup2(props, context) {
    var _this;
    _this = _React$Component.call(this, props, context) || this;
    var handleExited = _this.handleExited.bind(_assertThisInitialized(_this));
    _this.state = {
      contextValue: {
        isMounting: true
      },
      handleExited,
      firstRender: true
    };
    return _this;
  }
  var _proto = TransitionGroup2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.mounted = true;
    this.setState({
      contextValue: {
        isMounting: false
      }
    });
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.mounted = false;
  };
  TransitionGroup2.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref) {
    var prevChildMapping = _ref.children, handleExited = _ref.handleExited, firstRender = _ref.firstRender;
    return {
      children: firstRender ? getInitialChildMapping(nextProps, handleExited) : getNextChildMapping(nextProps, prevChildMapping, handleExited),
      firstRender: false
    };
  };
  _proto.handleExited = function handleExited(child, node2) {
    var currentChildMapping = getChildMapping(this.props.children);
    if (child.key in currentChildMapping) return;
    if (child.props.onExited) {
      child.props.onExited(node2);
    }
    if (this.mounted) {
      this.setState(function(state) {
        var children2 = _extends({}, state.children);
        delete children2[child.key];
        return {
          children: children2
        };
      });
    }
  };
  _proto.render = function render() {
    var _this$props = this.props, Component = _this$props.component, childFactory2 = _this$props.childFactory, props = _objectWithoutPropertiesLoose(_this$props, ["component", "childFactory"]);
    var contextValue = this.state.contextValue;
    var children2 = values2(this.state.children).map(childFactory2);
    delete props.appear;
    delete props.enter;
    delete props.exit;
    if (Component === null) {
      return import_react6.default.createElement(TransitionGroupContext_default.Provider, {
        value: contextValue
      }, children2);
    }
    return import_react6.default.createElement(TransitionGroupContext_default.Provider, {
      value: contextValue
    }, import_react6.default.createElement(Component, props, children2));
  };
  return TransitionGroup2;
}(import_react6.default.Component);
TransitionGroup.propTypes = true ? {
  /**
   * `<TransitionGroup>` renders a `<div>` by default. You can change this
   * behavior by providing a `component` prop.
   * If you use React v16+ and would like to avoid a wrapping `<div>` element
   * you can pass in `component={null}`. This is useful if the wrapping div
   * borks your css styles.
   */
  component: import_prop_types93.default.any,
  /**
   * A set of `<Transition>` components, that are toggled `in` and out as they
   * leave. the `<TransitionGroup>` will inject specific transition props, so
   * remember to spread them through if you are wrapping the `<Transition>` as
   * with our `<Fade>` example.
   *
   * While this component is meant for multiple `Transition` or `CSSTransition`
   * children, sometimes you may want to have a single transition child with
   * content that you want to be transitioned out and in when you change it
   * (e.g. routes, images etc.) In that case you can change the `key` prop of
   * the transition child as you change its content, this will cause
   * `TransitionGroup` to transition the child out and back in.
   */
  children: import_prop_types93.default.node,
  /**
   * A convenience prop that enables or disables appear animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */
  appear: import_prop_types93.default.bool,
  /**
   * A convenience prop that enables or disables enter animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */
  enter: import_prop_types93.default.bool,
  /**
   * A convenience prop that enables or disables exit animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */
  exit: import_prop_types93.default.bool,
  /**
   * You may need to apply reactive updates to a child as it is exiting.
   * This is generally done by using `cloneElement` however in the case of an exiting
   * child the element has already been removed and not accessible to the consumer.
   *
   * If you do need to update a child as it leaves you can provide a `childFactory`
   * to wrap every child, even the ones that are leaving.
   *
   * @type Function(child: ReactElement) -> ReactElement
   */
  childFactory: import_prop_types93.default.func
} : {};
TransitionGroup.defaultProps = defaultProps3;
var TransitionGroup_default = TransitionGroup;

// node_modules/react-transition-group/esm/ReplaceTransition.js
var ReplaceTransition = function(_React$Component) {
  _inheritsLoose(ReplaceTransition2, _React$Component);
  function ReplaceTransition2() {
    var _this;
    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {
      _args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(_args)) || this;
    _this.handleEnter = function() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return _this.handleLifecycle("onEnter", 0, args);
    };
    _this.handleEntering = function() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      return _this.handleLifecycle("onEntering", 0, args);
    };
    _this.handleEntered = function() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      return _this.handleLifecycle("onEntered", 0, args);
    };
    _this.handleExit = function() {
      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }
      return _this.handleLifecycle("onExit", 1, args);
    };
    _this.handleExiting = function() {
      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        args[_key6] = arguments[_key6];
      }
      return _this.handleLifecycle("onExiting", 1, args);
    };
    _this.handleExited = function() {
      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        args[_key7] = arguments[_key7];
      }
      return _this.handleLifecycle("onExited", 1, args);
    };
    return _this;
  }
  var _proto = ReplaceTransition2.prototype;
  _proto.handleLifecycle = function handleLifecycle(handler, idx, originalArgs) {
    var _child$props;
    var children2 = this.props.children;
    var child = import_react7.default.Children.toArray(children2)[idx];
    if (child.props[handler]) (_child$props = child.props)[handler].apply(_child$props, originalArgs);
    if (this.props[handler]) {
      var maybeNode = child.props.nodeRef ? void 0 : import_react_dom2.default.findDOMNode(this);
      this.props[handler](maybeNode);
    }
  };
  _proto.render = function render() {
    var _this$props = this.props, children2 = _this$props.children, inProp = _this$props.in, props = _objectWithoutPropertiesLoose(_this$props, ["children", "in"]);
    var _React$Children$toArr = import_react7.default.Children.toArray(children2), first = _React$Children$toArr[0], second2 = _React$Children$toArr[1];
    delete props.onEnter;
    delete props.onEntering;
    delete props.onEntered;
    delete props.onExit;
    delete props.onExiting;
    delete props.onExited;
    return import_react7.default.createElement(TransitionGroup_default, props, inProp ? import_react7.default.cloneElement(first, {
      key: "first",
      onEnter: this.handleEnter,
      onEntering: this.handleEntering,
      onEntered: this.handleEntered
    }) : import_react7.default.cloneElement(second2, {
      key: "second",
      onEnter: this.handleExit,
      onEntering: this.handleExiting,
      onEntered: this.handleExited
    }));
  };
  return ReplaceTransition2;
}(import_react7.default.Component);
ReplaceTransition.propTypes = true ? {
  in: import_prop_types94.default.bool.isRequired,
  children: function children(props, propName) {
    if (import_react7.default.Children.count(props[propName]) !== 2) return new Error('"' + propName + '" must be exactly two transition components.');
    return null;
  }
} : {};

// node_modules/react-transition-group/esm/SwitchTransition.js
var import_react8 = __toESM(require_react());
var import_prop_types95 = __toESM(require_prop_types());
var _leaveRenders;
var _enterRenders;
function areChildrenDifferent(oldChildren, newChildren) {
  if (oldChildren === newChildren) return false;
  if (import_react8.default.isValidElement(oldChildren) && import_react8.default.isValidElement(newChildren) && oldChildren.key != null && oldChildren.key === newChildren.key) {
    return false;
  }
  return true;
}
var modes = {
  out: "out-in",
  in: "in-out"
};
var callHook = function callHook2(element, name, cb) {
  return function() {
    var _element$props;
    element.props[name] && (_element$props = element.props)[name].apply(_element$props, arguments);
    cb();
  };
};
var leaveRenders = (_leaveRenders = {}, _leaveRenders[modes.out] = function(_ref) {
  var current = _ref.current, changeState = _ref.changeState;
  return import_react8.default.cloneElement(current, {
    in: false,
    onExited: callHook(current, "onExited", function() {
      changeState(ENTERING, null);
    })
  });
}, _leaveRenders[modes.in] = function(_ref2) {
  var current = _ref2.current, changeState = _ref2.changeState, children2 = _ref2.children;
  return [current, import_react8.default.cloneElement(children2, {
    in: true,
    onEntered: callHook(children2, "onEntered", function() {
      changeState(ENTERING);
    })
  })];
}, _leaveRenders);
var enterRenders = (_enterRenders = {}, _enterRenders[modes.out] = function(_ref3) {
  var children2 = _ref3.children, changeState = _ref3.changeState;
  return import_react8.default.cloneElement(children2, {
    in: true,
    onEntered: callHook(children2, "onEntered", function() {
      changeState(ENTERED, import_react8.default.cloneElement(children2, {
        in: true
      }));
    })
  });
}, _enterRenders[modes.in] = function(_ref4) {
  var current = _ref4.current, children2 = _ref4.children, changeState = _ref4.changeState;
  return [import_react8.default.cloneElement(current, {
    in: false,
    onExited: callHook(current, "onExited", function() {
      changeState(ENTERED, import_react8.default.cloneElement(children2, {
        in: true
      }));
    })
  }), import_react8.default.cloneElement(children2, {
    in: true
  })];
}, _enterRenders);
var SwitchTransition = function(_React$Component) {
  _inheritsLoose(SwitchTransition2, _React$Component);
  function SwitchTransition2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.state = {
      status: ENTERED,
      current: null
    };
    _this.appeared = false;
    _this.changeState = function(status, current) {
      if (current === void 0) {
        current = _this.state.current;
      }
      _this.setState({
        status,
        current
      });
    };
    return _this;
  }
  var _proto = SwitchTransition2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.appeared = true;
  };
  SwitchTransition2.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {
    if (props.children == null) {
      return {
        current: null
      };
    }
    if (state.status === ENTERING && props.mode === modes.in) {
      return {
        status: ENTERING
      };
    }
    if (state.current && areChildrenDifferent(state.current, props.children)) {
      return {
        status: EXITING
      };
    }
    return {
      current: import_react8.default.cloneElement(props.children, {
        in: true
      })
    };
  };
  _proto.render = function render() {
    var _this$props = this.props, children2 = _this$props.children, mode2 = _this$props.mode, _this$state = this.state, status = _this$state.status, current = _this$state.current;
    var data = {
      children: children2,
      current,
      changeState: this.changeState,
      status
    };
    var component;
    switch (status) {
      case ENTERING:
        component = enterRenders[mode2](data);
        break;
      case EXITING:
        component = leaveRenders[mode2](data);
        break;
      case ENTERED:
        component = current;
    }
    return import_react8.default.createElement(TransitionGroupContext_default.Provider, {
      value: {
        isMounting: !this.appeared
      }
    }, component);
  };
  return SwitchTransition2;
}(import_react8.default.Component);
SwitchTransition.propTypes = true ? {
  /**
   * Transition modes.
   * `out-in`: Current element transitions out first, then when complete, the new element transitions in.
   * `in-out`: New element transitions in first, then when complete, the current element transitions out.
   *
   * @type {'out-in'|'in-out'}
   */
  mode: import_prop_types95.default.oneOf([modes.in, modes.out]),
  /**
   * Any `Transition` or `CSSTransition` component.
   */
  children: import_prop_types95.default.oneOfType([import_prop_types95.default.element.isRequired])
} : {};
SwitchTransition.defaultProps = {
  mode: modes.out
};

// node_modules/@mui/utils/esm/useOnMount/useOnMount.js
var React164 = __toESM(require_react(), 1);
var EMPTY = [];
function useOnMount(fn2) {
  React164.useEffect(fn2, EMPTY);
}

// node_modules/@mui/utils/esm/useTimeout/useTimeout.js
var Timeout = class _Timeout {
  constructor() {
    __publicField(this, "currentId", null);
    __publicField(this, "clear", () => {
      if (this.currentId !== null) {
        clearTimeout(this.currentId);
        this.currentId = null;
      }
    });
    __publicField(this, "disposeEffect", () => {
      return this.clear;
    });
  }
  static create() {
    return new _Timeout();
  }
  /**
   * Executes `fn` after `delay`, clearing any previously scheduled call.
   */
  start(delay, fn2) {
    this.clear();
    this.currentId = setTimeout(() => {
      this.currentId = null;
      fn2();
    }, delay);
  }
};
function useTimeout() {
  const timeout3 = useLazyRef(Timeout.create).current;
  useOnMount(timeout3.disposeEffect);
  return timeout3;
}

// node_modules/@mui/material/esm/ButtonBase/Ripple.js
var React165 = __toESM(require_react(), 1);
var import_prop_types96 = __toESM(require_prop_types(), 1);
var import_jsx_runtime114 = __toESM(require_jsx_runtime(), 1);
function Ripple(props) {
  const {
    className,
    classes,
    pulsate = false,
    rippleX,
    rippleY,
    rippleSize,
    in: inProp,
    onExited,
    timeout: timeout3
  } = props;
  const [leaving, setLeaving] = React165.useState(false);
  const rippleClassName = clsx_default(className, classes.ripple, classes.rippleVisible, pulsate && classes.ripplePulsate);
  const rippleStyles = {
    width: rippleSize,
    height: rippleSize,
    top: -(rippleSize / 2) + rippleY,
    left: -(rippleSize / 2) + rippleX
  };
  const childClassName = clsx_default(classes.child, leaving && classes.childLeaving, pulsate && classes.childPulsate);
  if (!inProp && !leaving) {
    setLeaving(true);
  }
  React165.useEffect(() => {
    if (!inProp && onExited != null) {
      const timeoutId = setTimeout(onExited, timeout3);
      return () => {
        clearTimeout(timeoutId);
      };
    }
    return void 0;
  }, [onExited, inProp, timeout3]);
  return (0, import_jsx_runtime114.jsx)("span", {
    className: rippleClassName,
    style: rippleStyles,
    children: (0, import_jsx_runtime114.jsx)("span", {
      className: childClassName
    })
  });
}
true ? Ripple.propTypes = {
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types96.default.object.isRequired,
  className: import_prop_types96.default.string,
  /**
   * @ignore - injected from TransitionGroup
   */
  in: import_prop_types96.default.bool,
  /**
   * @ignore - injected from TransitionGroup
   */
  onExited: import_prop_types96.default.func,
  /**
   * If `true`, the ripple pulsates, typically indicating the keyboard focus state of an element.
   */
  pulsate: import_prop_types96.default.bool,
  /**
   * Diameter of the ripple.
   */
  rippleSize: import_prop_types96.default.number,
  /**
   * Horizontal position of the ripple center.
   */
  rippleX: import_prop_types96.default.number,
  /**
   * Vertical position of the ripple center.
   */
  rippleY: import_prop_types96.default.number,
  /**
   * exit delay
   */
  timeout: import_prop_types96.default.number.isRequired
} : void 0;
var Ripple_default = Ripple;

// node_modules/@mui/material/esm/ButtonBase/touchRippleClasses.js
var touchRippleClasses = generateUtilityClasses("MuiTouchRipple", ["root", "ripple", "rippleVisible", "ripplePulsate", "child", "childLeaving", "childPulsate"]);
var touchRippleClasses_default = touchRippleClasses;

// node_modules/@mui/material/esm/ButtonBase/TouchRipple.js
var import_jsx_runtime115 = __toESM(require_jsx_runtime(), 1);
var DURATION = 550;
var DELAY_RIPPLE = 80;
var enterKeyframe = mt`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`;
var exitKeyframe = mt`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`;
var pulsateKeyframe = mt`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`;
var TouchRippleRoot = styled_default2("span", {
  name: "MuiTouchRipple",
  slot: "Root"
})({
  overflow: "hidden",
  pointerEvents: "none",
  position: "absolute",
  zIndex: 0,
  top: 0,
  right: 0,
  bottom: 0,
  left: 0,
  borderRadius: "inherit"
});
var TouchRippleRipple = styled_default2(Ripple_default, {
  name: "MuiTouchRipple",
  slot: "Ripple"
})`
  opacity: 0;
  position: absolute;

  &.${touchRippleClasses_default.rippleVisible} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${enterKeyframe};
    animation-duration: ${DURATION}ms;
    animation-timing-function: ${({
  theme
}) => theme.transitions.easing.easeInOut};
  }

  &.${touchRippleClasses_default.ripplePulsate} {
    animation-duration: ${({
  theme
}) => theme.transitions.duration.shorter}ms;
  }

  & .${touchRippleClasses_default.child} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${touchRippleClasses_default.childLeaving} {
    opacity: 0;
    animation-name: ${exitKeyframe};
    animation-duration: ${DURATION}ms;
    animation-timing-function: ${({
  theme
}) => theme.transitions.easing.easeInOut};
  }

  & .${touchRippleClasses_default.childPulsate} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${pulsateKeyframe};
    animation-duration: 2500ms;
    animation-timing-function: ${({
  theme
}) => theme.transitions.easing.easeInOut};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`;
var TouchRipple = React166.forwardRef(function TouchRipple2(inProps, ref) {
  const props = useDefaultProps2({
    props: inProps,
    name: "MuiTouchRipple"
  });
  const {
    center: centerProp = false,
    classes = {},
    className,
    ...other
  } = props;
  const [ripples, setRipples] = React166.useState([]);
  const nextKey = React166.useRef(0);
  const rippleCallback = React166.useRef(null);
  React166.useEffect(() => {
    if (rippleCallback.current) {
      rippleCallback.current();
      rippleCallback.current = null;
    }
  }, [ripples]);
  const ignoringMouseDown = React166.useRef(false);
  const startTimer = useTimeout();
  const startTimerCommit = React166.useRef(null);
  const container = React166.useRef(null);
  const startCommit = React166.useCallback((params) => {
    const {
      pulsate: pulsate2,
      rippleX,
      rippleY,
      rippleSize,
      cb
    } = params;
    setRipples((oldRipples) => [...oldRipples, (0, import_jsx_runtime115.jsx)(TouchRippleRipple, {
      classes: {
        ripple: clsx_default(classes.ripple, touchRippleClasses_default.ripple),
        rippleVisible: clsx_default(classes.rippleVisible, touchRippleClasses_default.rippleVisible),
        ripplePulsate: clsx_default(classes.ripplePulsate, touchRippleClasses_default.ripplePulsate),
        child: clsx_default(classes.child, touchRippleClasses_default.child),
        childLeaving: clsx_default(classes.childLeaving, touchRippleClasses_default.childLeaving),
        childPulsate: clsx_default(classes.childPulsate, touchRippleClasses_default.childPulsate)
      },
      timeout: DURATION,
      pulsate: pulsate2,
      rippleX,
      rippleY,
      rippleSize
    }, nextKey.current)]);
    nextKey.current += 1;
    rippleCallback.current = cb;
  }, [classes]);
  const start2 = React166.useCallback((event = {}, options = {}, cb = () => {
  }) => {
    const {
      pulsate: pulsate2 = false,
      center = centerProp || options.pulsate,
      fakeElement = false
      // For test purposes
    } = options;
    if ((event == null ? void 0 : event.type) === "mousedown" && ignoringMouseDown.current) {
      ignoringMouseDown.current = false;
      return;
    }
    if ((event == null ? void 0 : event.type) === "touchstart") {
      ignoringMouseDown.current = true;
    }
    const element = fakeElement ? null : container.current;
    const rect = element ? element.getBoundingClientRect() : {
      width: 0,
      height: 0,
      left: 0,
      top: 0
    };
    let rippleX;
    let rippleY;
    let rippleSize;
    if (center || event === void 0 || event.clientX === 0 && event.clientY === 0 || !event.clientX && !event.touches) {
      rippleX = Math.round(rect.width / 2);
      rippleY = Math.round(rect.height / 2);
    } else {
      const {
        clientX,
        clientY
      } = event.touches && event.touches.length > 0 ? event.touches[0] : event;
      rippleX = Math.round(clientX - rect.left);
      rippleY = Math.round(clientY - rect.top);
    }
    if (center) {
      rippleSize = Math.sqrt((2 * rect.width ** 2 + rect.height ** 2) / 3);
      if (rippleSize % 2 === 0) {
        rippleSize += 1;
      }
    } else {
      const sizeX = Math.max(Math.abs((element ? element.clientWidth : 0) - rippleX), rippleX) * 2 + 2;
      const sizeY = Math.max(Math.abs((element ? element.clientHeight : 0) - rippleY), rippleY) * 2 + 2;
      rippleSize = Math.sqrt(sizeX ** 2 + sizeY ** 2);
    }
    if (event == null ? void 0 : event.touches) {
      if (startTimerCommit.current === null) {
        startTimerCommit.current = () => {
          startCommit({
            pulsate: pulsate2,
            rippleX,
            rippleY,
            rippleSize,
            cb
          });
        };
        startTimer.start(DELAY_RIPPLE, () => {
          if (startTimerCommit.current) {
            startTimerCommit.current();
            startTimerCommit.current = null;
          }
        });
      }
    } else {
      startCommit({
        pulsate: pulsate2,
        rippleX,
        rippleY,
        rippleSize,
        cb
      });
    }
  }, [centerProp, startCommit, startTimer]);
  const pulsate = React166.useCallback(() => {
    start2({}, {
      pulsate: true
    });
  }, [start2]);
  const stop = React166.useCallback((event, cb) => {
    startTimer.clear();
    if ((event == null ? void 0 : event.type) === "touchend" && startTimerCommit.current) {
      startTimerCommit.current();
      startTimerCommit.current = null;
      startTimer.start(0, () => {
        stop(event, cb);
      });
      return;
    }
    startTimerCommit.current = null;
    setRipples((oldRipples) => {
      if (oldRipples.length > 0) {
        return oldRipples.slice(1);
      }
      return oldRipples;
    });
    rippleCallback.current = cb;
  }, [startTimer]);
  React166.useImperativeHandle(ref, () => ({
    pulsate,
    start: start2,
    stop
  }), [pulsate, start2, stop]);
  return (0, import_jsx_runtime115.jsx)(TouchRippleRoot, {
    className: clsx_default(touchRippleClasses_default.root, classes.root, className),
    ref: container,
    ...other,
    children: (0, import_jsx_runtime115.jsx)(TransitionGroup_default, {
      component: null,
      exit: true,
      children: ripples
    })
  });
});
true ? TouchRipple.propTypes = {
  /**
   * If `true`, the ripple starts at the center of the component
   * rather than at the point of interaction.
   */
  center: import_prop_types97.default.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types97.default.object,
  /**
   * @ignore
   */
  className: import_prop_types97.default.string
} : void 0;
var TouchRipple_default = TouchRipple;

// node_modules/@mui/material/esm/ButtonBase/buttonBaseClasses.js
function getButtonBaseUtilityClass(slot) {
  return generateUtilityClass("MuiButtonBase", slot);
}
var buttonBaseClasses = generateUtilityClasses("MuiButtonBase", ["root", "disabled", "focusVisible"]);
var buttonBaseClasses_default = buttonBaseClasses;

// node_modules/@mui/material/esm/ButtonBase/ButtonBase.js
var import_jsx_runtime116 = __toESM(require_jsx_runtime(), 1);
var useUtilityClasses28 = (ownerState) => {
  const {
    disabled,
    focusVisible,
    focusVisibleClassName,
    classes
  } = ownerState;
  const slots = {
    root: ["root", disabled && "disabled", focusVisible && "focusVisible"]
  };
  const composedClasses = composeClasses(slots, getButtonBaseUtilityClass, classes);
  if (focusVisible && focusVisibleClassName) {
    composedClasses.root += ` ${focusVisibleClassName}`;
  }
  return composedClasses;
};
var ButtonBaseRoot = styled_default2("button", {
  name: "MuiButtonBase",
  slot: "Root"
})({
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "center",
  position: "relative",
  boxSizing: "border-box",
  WebkitTapHighlightColor: "transparent",
  backgroundColor: "transparent",
  // Reset default value
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0,
  border: 0,
  margin: 0,
  // Remove the margin in Safari
  borderRadius: 0,
  padding: 0,
  // Remove the padding in Firefox
  cursor: "pointer",
  userSelect: "none",
  verticalAlign: "middle",
  MozAppearance: "none",
  // Reset
  WebkitAppearance: "none",
  // Reset
  textDecoration: "none",
  // So we take precedent over the style of a native <a /> element.
  color: "inherit",
  "&::-moz-focus-inner": {
    borderStyle: "none"
    // Remove Firefox dotted outline.
  },
  [`&.${buttonBaseClasses_default.disabled}`]: {
    pointerEvents: "none",
    // Disable link interactions
    cursor: "default"
  },
  "@media print": {
    colorAdjust: "exact"
  }
});
var ButtonBase = React167.forwardRef(function ButtonBase2(inProps, ref) {
  const props = useDefaultProps2({
    props: inProps,
    name: "MuiButtonBase"
  });
  const {
    action,
    centerRipple = false,
    children: children2,
    className,
    component = "button",
    disabled = false,
    disableRipple = false,
    disableTouchRipple = false,
    focusRipple = false,
    focusVisibleClassName,
    LinkComponent = "a",
    onBlur,
    onClick,
    onContextMenu,
    onDragLeave,
    onFocus,
    onFocusVisible,
    onKeyDown,
    onKeyUp,
    onMouseDown,
    onMouseLeave,
    onMouseUp,
    onTouchEnd,
    onTouchMove,
    onTouchStart,
    tabIndex = 0,
    TouchRippleProps,
    touchRippleRef,
    type,
    ...other
  } = props;
  const buttonRef = React167.useRef(null);
  const ripple = useLazyRipple();
  const handleRippleRef = useForkRef_default(ripple.ref, touchRippleRef);
  const [focusVisible, setFocusVisible] = React167.useState(false);
  if (disabled && focusVisible) {
    setFocusVisible(false);
  }
  React167.useImperativeHandle(action, () => ({
    focusVisible: () => {
      setFocusVisible(true);
      buttonRef.current.focus();
    }
  }), []);
  const enableTouchRipple = ripple.shouldMount && !disableRipple && !disabled;
  React167.useEffect(() => {
    if (focusVisible && focusRipple && !disableRipple) {
      ripple.pulsate();
    }
  }, [disableRipple, focusRipple, focusVisible, ripple]);
  const handleMouseDown = useRippleHandler(ripple, "start", onMouseDown, disableTouchRipple);
  const handleContextMenu = useRippleHandler(ripple, "stop", onContextMenu, disableTouchRipple);
  const handleDragLeave = useRippleHandler(ripple, "stop", onDragLeave, disableTouchRipple);
  const handleMouseUp = useRippleHandler(ripple, "stop", onMouseUp, disableTouchRipple);
  const handleMouseLeave = useRippleHandler(ripple, "stop", (event) => {
    if (focusVisible) {
      event.preventDefault();
    }
    if (onMouseLeave) {
      onMouseLeave(event);
    }
  }, disableTouchRipple);
  const handleTouchStart = useRippleHandler(ripple, "start", onTouchStart, disableTouchRipple);
  const handleTouchEnd = useRippleHandler(ripple, "stop", onTouchEnd, disableTouchRipple);
  const handleTouchMove = useRippleHandler(ripple, "stop", onTouchMove, disableTouchRipple);
  const handleBlur = useRippleHandler(ripple, "stop", (event) => {
    if (!isFocusVisible(event.target)) {
      setFocusVisible(false);
    }
    if (onBlur) {
      onBlur(event);
    }
  }, false);
  const handleFocus = useEventCallback_default2((event) => {
    if (!buttonRef.current) {
      buttonRef.current = event.currentTarget;
    }
    if (isFocusVisible(event.target)) {
      setFocusVisible(true);
      if (onFocusVisible) {
        onFocusVisible(event);
      }
    }
    if (onFocus) {
      onFocus(event);
    }
  });
  const isNonNativeButton = () => {
    const button = buttonRef.current;
    return component && component !== "button" && !(button.tagName === "A" && button.href);
  };
  const handleKeyDown = useEventCallback_default2((event) => {
    if (focusRipple && !event.repeat && focusVisible && event.key === " ") {
      ripple.stop(event, () => {
        ripple.start(event);
      });
    }
    if (event.target === event.currentTarget && isNonNativeButton() && event.key === " ") {
      event.preventDefault();
    }
    if (onKeyDown) {
      onKeyDown(event);
    }
    if (event.target === event.currentTarget && isNonNativeButton() && event.key === "Enter" && !disabled) {
      event.preventDefault();
      if (onClick) {
        onClick(event);
      }
    }
  });
  const handleKeyUp = useEventCallback_default2((event) => {
    if (focusRipple && event.key === " " && focusVisible && !event.defaultPrevented) {
      ripple.stop(event, () => {
        ripple.pulsate(event);
      });
    }
    if (onKeyUp) {
      onKeyUp(event);
    }
    if (onClick && event.target === event.currentTarget && isNonNativeButton() && event.key === " " && !event.defaultPrevented) {
      onClick(event);
    }
  });
  let ComponentProp = component;
  if (ComponentProp === "button" && (other.href || other.to)) {
    ComponentProp = LinkComponent;
  }
  const buttonProps = {};
  if (ComponentProp === "button") {
    buttonProps.type = type === void 0 ? "button" : type;
    buttonProps.disabled = disabled;
  } else {
    if (!other.href && !other.to) {
      buttonProps.role = "button";
    }
    if (disabled) {
      buttonProps["aria-disabled"] = disabled;
    }
  }
  const handleRef = useForkRef_default(ref, buttonRef);
  const ownerState = {
    ...props,
    centerRipple,
    component,
    disabled,
    disableRipple,
    disableTouchRipple,
    focusRipple,
    tabIndex,
    focusVisible
  };
  const classes = useUtilityClasses28(ownerState);
  return (0, import_jsx_runtime116.jsxs)(ButtonBaseRoot, {
    as: ComponentProp,
    className: clsx_default(classes.root, className),
    ownerState,
    onBlur: handleBlur,
    onClick,
    onContextMenu: handleContextMenu,
    onFocus: handleFocus,
    onKeyDown: handleKeyDown,
    onKeyUp: handleKeyUp,
    onMouseDown: handleMouseDown,
    onMouseLeave: handleMouseLeave,
    onMouseUp: handleMouseUp,
    onDragLeave: handleDragLeave,
    onTouchEnd: handleTouchEnd,
    onTouchMove: handleTouchMove,
    onTouchStart: handleTouchStart,
    ref: handleRef,
    tabIndex: disabled ? -1 : tabIndex,
    type,
    ...buttonProps,
    ...other,
    children: [children2, enableTouchRipple ? (0, import_jsx_runtime116.jsx)(TouchRipple_default, {
      ref: handleRippleRef,
      center: centerRipple,
      ...TouchRippleProps
    }) : null]
  });
});
function useRippleHandler(ripple, rippleAction, eventCallback, skipRippleAction = false) {
  return useEventCallback_default2((event) => {
    if (eventCallback) {
      eventCallback(event);
    }
    if (!skipRippleAction) {
      ripple[rippleAction](event);
    }
    return true;
  });
}
true ? ButtonBase.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * A ref for imperative actions.
   * It currently only supports `focusVisible()` action.
   */
  action: refType_default,
  /**
   * If `true`, the ripples are centered.
   * They won't start at the cursor interaction position.
   * @default false
   */
  centerRipple: import_prop_types98.default.bool,
  /**
   * The content of the component.
   */
  children: import_prop_types98.default.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types98.default.object,
  /**
   * @ignore
   */
  className: import_prop_types98.default.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: elementTypeAcceptingRef_default,
  /**
   * If `true`, the component is disabled.
   * @default false
   */
  disabled: import_prop_types98.default.bool,
  /**
   * If `true`, the ripple effect is disabled.
   *
   *  Without a ripple there is no styling for :focus-visible by default. Be sure
   * to highlight the element by applying separate styles with the `.Mui-focusVisible` class.
   * @default false
   */
  disableRipple: import_prop_types98.default.bool,
  /**
   * If `true`, the touch ripple effect is disabled.
   * @default false
   */
  disableTouchRipple: import_prop_types98.default.bool,
  /**
   * If `true`, the base button will have a keyboard focus ripple.
   * @default false
   */
  focusRipple: import_prop_types98.default.bool,
  /**
   * This prop can help identify which element has keyboard focus.
   * The class name will be applied when the element gains the focus through keyboard interaction.
   * It's a polyfill for the [CSS :focus-visible selector](https://drafts.csswg.org/selectors-4/#the-focus-visible-pseudo).
   * The rationale for using this feature [is explained here](https://github.com/WICG/focus-visible/blob/HEAD/explainer.md).
   * A [polyfill can be used](https://github.com/WICG/focus-visible) to apply a `focus-visible` class to other components
   * if needed.
   */
  focusVisibleClassName: import_prop_types98.default.string,
  /**
   * @ignore
   */
  href: import_prop_types98.default.any,
  /**
   * The component used to render a link when the `href` prop is provided.
   * @default 'a'
   */
  LinkComponent: import_prop_types98.default.elementType,
  /**
   * @ignore
   */
  onBlur: import_prop_types98.default.func,
  /**
   * @ignore
   */
  onClick: import_prop_types98.default.func,
  /**
   * @ignore
   */
  onContextMenu: import_prop_types98.default.func,
  /**
   * @ignore
   */
  onDragLeave: import_prop_types98.default.func,
  /**
   * @ignore
   */
  onFocus: import_prop_types98.default.func,
  /**
   * Callback fired when the component is focused with a keyboard.
   * We trigger a `onFocus` callback too.
   */
  onFocusVisible: import_prop_types98.default.func,
  /**
   * @ignore
   */
  onKeyDown: import_prop_types98.default.func,
  /**
   * @ignore
   */
  onKeyUp: import_prop_types98.default.func,
  /**
   * @ignore
   */
  onMouseDown: import_prop_types98.default.func,
  /**
   * @ignore
   */
  onMouseLeave: import_prop_types98.default.func,
  /**
   * @ignore
   */
  onMouseUp: import_prop_types98.default.func,
  /**
   * @ignore
   */
  onTouchEnd: import_prop_types98.default.func,
  /**
   * @ignore
   */
  onTouchMove: import_prop_types98.default.func,
  /**
   * @ignore
   */
  onTouchStart: import_prop_types98.default.func,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types98.default.oneOfType([import_prop_types98.default.arrayOf(import_prop_types98.default.oneOfType([import_prop_types98.default.func, import_prop_types98.default.object, import_prop_types98.default.bool])), import_prop_types98.default.func, import_prop_types98.default.object]),
  /**
   * @default 0
   */
  tabIndex: import_prop_types98.default.number,
  /**
   * Props applied to the `TouchRipple` element.
   */
  TouchRippleProps: import_prop_types98.default.object,
  /**
   * A ref that points to the `TouchRipple` element.
   */
  touchRippleRef: import_prop_types98.default.oneOfType([import_prop_types98.default.func, import_prop_types98.default.shape({
    current: import_prop_types98.default.shape({
      pulsate: import_prop_types98.default.func.isRequired,
      start: import_prop_types98.default.func.isRequired,
      stop: import_prop_types98.default.func.isRequired
    })
  })]),
  /**
   * @ignore
   */
  type: import_prop_types98.default.oneOfType([import_prop_types98.default.oneOf(["button", "reset", "submit"]), import_prop_types98.default.string])
} : void 0;
var ButtonBase_default = ButtonBase;

// node_modules/@mui/material/esm/CircularProgress/CircularProgress.js
var React168 = __toESM(require_react(), 1);
var import_prop_types99 = __toESM(require_prop_types(), 1);

// node_modules/@mui/material/esm/CircularProgress/circularProgressClasses.js
function getCircularProgressUtilityClass(slot) {
  return generateUtilityClass("MuiCircularProgress", slot);
}
var circularProgressClasses = generateUtilityClasses("MuiCircularProgress", ["root", "determinate", "indeterminate", "colorPrimary", "colorSecondary", "svg", "circle", "circleDeterminate", "circleIndeterminate", "circleDisableShrink"]);

// node_modules/@mui/material/esm/CircularProgress/CircularProgress.js
var import_jsx_runtime117 = __toESM(require_jsx_runtime(), 1);
var SIZE = 44;
var circularRotateKeyframe = mt`
  0% {
    transform: rotate(0deg);
  }

  100% {
    transform: rotate(360deg);
  }
`;
var circularDashKeyframe = mt`
  0% {
    stroke-dasharray: 1px, 200px;
    stroke-dashoffset: 0;
  }

  50% {
    stroke-dasharray: 100px, 200px;
    stroke-dashoffset: -15px;
  }

  100% {
    stroke-dasharray: 1px, 200px;
    stroke-dashoffset: -126px;
  }
`;
var rotateAnimation = typeof circularRotateKeyframe !== "string" ? lt`
        animation: ${circularRotateKeyframe} 1.4s linear infinite;
      ` : null;
var dashAnimation = typeof circularDashKeyframe !== "string" ? lt`
        animation: ${circularDashKeyframe} 1.4s ease-in-out infinite;
      ` : null;
var useUtilityClasses29 = (ownerState) => {
  const {
    classes,
    variant,
    color: color3,
    disableShrink
  } = ownerState;
  const slots = {
    root: ["root", variant, `color${capitalize_default(color3)}`],
    svg: ["svg"],
    circle: ["circle", `circle${capitalize_default(variant)}`, disableShrink && "circleDisableShrink"]
  };
  return composeClasses(slots, getCircularProgressUtilityClass, classes);
};
var CircularProgressRoot = styled_default2("span", {
  name: "MuiCircularProgress",
  slot: "Root",
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [styles.root, styles[ownerState.variant], styles[`color${capitalize_default(ownerState.color)}`]];
  }
})(memoTheme_default(({
  theme
}) => ({
  display: "inline-block",
  variants: [{
    props: {
      variant: "determinate"
    },
    style: {
      transition: theme.transitions.create("transform")
    }
  }, {
    props: {
      variant: "indeterminate"
    },
    style: rotateAnimation || {
      animation: `${circularRotateKeyframe} 1.4s linear infinite`
    }
  }, ...Object.entries(theme.palette).filter(createSimplePaletteValueFilter()).map(([color3]) => ({
    props: {
      color: color3
    },
    style: {
      color: (theme.vars || theme).palette[color3].main
    }
  }))]
})));
var CircularProgressSVG = styled_default2("svg", {
  name: "MuiCircularProgress",
  slot: "Svg"
})({
  display: "block"
  // Keeps the progress centered
});
var CircularProgressCircle = styled_default2("circle", {
  name: "MuiCircularProgress",
  slot: "Circle",
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [styles.circle, styles[`circle${capitalize_default(ownerState.variant)}`], ownerState.disableShrink && styles.circleDisableShrink];
  }
})(memoTheme_default(({
  theme
}) => ({
  stroke: "currentColor",
  variants: [{
    props: {
      variant: "determinate"
    },
    style: {
      transition: theme.transitions.create("stroke-dashoffset")
    }
  }, {
    props: {
      variant: "indeterminate"
    },
    style: {
      // Some default value that looks fine waiting for the animation to kicks in.
      strokeDasharray: "80px, 200px",
      strokeDashoffset: 0
      // Add the unit to fix a Edge 16 and below bug.
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.variant === "indeterminate" && !ownerState.disableShrink,
    style: dashAnimation || {
      // At runtime for Pigment CSS, `bufferAnimation` will be null and the generated keyframe will be used.
      animation: `${circularDashKeyframe} 1.4s ease-in-out infinite`
    }
  }]
})));
var CircularProgress = React168.forwardRef(function CircularProgress2(inProps, ref) {
  const props = useDefaultProps2({
    props: inProps,
    name: "MuiCircularProgress"
  });
  const {
    className,
    color: color3 = "primary",
    disableShrink = false,
    size = 40,
    style: style4,
    thickness = 3.6,
    value = 0,
    variant = "indeterminate",
    ...other
  } = props;
  const ownerState = {
    ...props,
    color: color3,
    disableShrink,
    size,
    thickness,
    value,
    variant
  };
  const classes = useUtilityClasses29(ownerState);
  const circleStyle = {};
  const rootStyle = {};
  const rootProps = {};
  if (variant === "determinate") {
    const circumference = 2 * Math.PI * ((SIZE - thickness) / 2);
    circleStyle.strokeDasharray = circumference.toFixed(3);
    rootProps["aria-valuenow"] = Math.round(value);
    circleStyle.strokeDashoffset = `${((100 - value) / 100 * circumference).toFixed(3)}px`;
    rootStyle.transform = "rotate(-90deg)";
  }
  return (0, import_jsx_runtime117.jsx)(CircularProgressRoot, {
    className: clsx_default(classes.root, className),
    style: {
      width: size,
      height: size,
      ...rootStyle,
      ...style4
    },
    ownerState,
    ref,
    role: "progressbar",
    ...rootProps,
    ...other,
    children: (0, import_jsx_runtime117.jsx)(CircularProgressSVG, {
      className: classes.svg,
      ownerState,
      viewBox: `${SIZE / 2} ${SIZE / 2} ${SIZE} ${SIZE}`,
      children: (0, import_jsx_runtime117.jsx)(CircularProgressCircle, {
        className: classes.circle,
        style: circleStyle,
        ownerState,
        cx: SIZE,
        cy: SIZE,
        r: (SIZE - thickness) / 2,
        fill: "none",
        strokeWidth: thickness
      })
    })
  });
});
true ? CircularProgress.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types99.default.object,
  /**
   * @ignore
   */
  className: import_prop_types99.default.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).
   * @default 'primary'
   */
  color: import_prop_types99.default.oneOfType([import_prop_types99.default.oneOf(["inherit", "primary", "secondary", "error", "info", "success", "warning"]), import_prop_types99.default.string]),
  /**
   * If `true`, the shrink animation is disabled.
   * This only works if variant is `indeterminate`.
   * @default false
   */
  disableShrink: chainPropTypes(import_prop_types99.default.bool, (props) => {
    if (props.disableShrink && props.variant && props.variant !== "indeterminate") {
      return new Error("MUI: You have provided the `disableShrink` prop with a variant other than `indeterminate`. This will have no effect.");
    }
    return null;
  }),
  /**
   * The size of the component.
   * If using a number, the pixel unit is assumed.
   * If using a string, you need to provide the CSS unit, for example '3rem'.
   * @default 40
   */
  size: import_prop_types99.default.oneOfType([import_prop_types99.default.number, import_prop_types99.default.string]),
  /**
   * @ignore
   */
  style: import_prop_types99.default.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types99.default.oneOfType([import_prop_types99.default.arrayOf(import_prop_types99.default.oneOfType([import_prop_types99.default.func, import_prop_types99.default.object, import_prop_types99.default.bool])), import_prop_types99.default.func, import_prop_types99.default.object]),
  /**
   * The thickness of the circle.
   * @default 3.6
   */
  thickness: import_prop_types99.default.number,
  /**
   * The value of the progress indicator for the determinate variant.
   * Value between 0 and 100.
   * @default 0
   */
  value: import_prop_types99.default.number,
  /**
   * The variant to use.
   * Use indeterminate when there is no progress value.
   * @default 'indeterminate'
   */
  variant: import_prop_types99.default.oneOf(["determinate", "indeterminate"])
} : void 0;
var CircularProgress_default = CircularProgress;

// node_modules/@mui/material/esm/IconButton/iconButtonClasses.js
function getIconButtonUtilityClass(slot) {
  return generateUtilityClass("MuiIconButton", slot);
}
var iconButtonClasses = generateUtilityClasses("MuiIconButton", ["root", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorError", "colorInfo", "colorSuccess", "colorWarning", "edgeStart", "edgeEnd", "sizeSmall", "sizeMedium", "sizeLarge", "loading", "loadingIndicator", "loadingWrapper"]);
var iconButtonClasses_default = iconButtonClasses;

// node_modules/@mui/material/esm/IconButton/IconButton.js
var import_jsx_runtime118 = __toESM(require_jsx_runtime(), 1);
var useUtilityClasses30 = (ownerState) => {
  const {
    classes,
    disabled,
    color: color3,
    edge,
    size,
    loading
  } = ownerState;
  const slots = {
    root: ["root", loading && "loading", disabled && "disabled", color3 !== "default" && `color${capitalize_default(color3)}`, edge && `edge${capitalize_default(edge)}`, `size${capitalize_default(size)}`],
    loadingIndicator: ["loadingIndicator"],
    loadingWrapper: ["loadingWrapper"]
  };
  return composeClasses(slots, getIconButtonUtilityClass, classes);
};
var IconButtonRoot = styled_default2(ButtonBase_default, {
  name: "MuiIconButton",
  slot: "Root",
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [styles.root, ownerState.loading && styles.loading, ownerState.color !== "default" && styles[`color${capitalize_default(ownerState.color)}`], ownerState.edge && styles[`edge${capitalize_default(ownerState.edge)}`], styles[`size${capitalize_default(ownerState.size)}`]];
  }
})(memoTheme_default(({
  theme
}) => ({
  textAlign: "center",
  flex: "0 0 auto",
  fontSize: theme.typography.pxToRem(24),
  padding: 8,
  borderRadius: "50%",
  color: (theme.vars || theme).palette.action.active,
  transition: theme.transitions.create("background-color", {
    duration: theme.transitions.duration.shortest
  }),
  variants: [{
    props: (props) => !props.disableRipple,
    style: {
      "--IconButton-hoverBg": theme.vars ? `rgba(${theme.vars.palette.action.activeChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette.action.active, theme.palette.action.hoverOpacity),
      "&:hover": {
        backgroundColor: "var(--IconButton-hoverBg)",
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      }
    }
  }, {
    props: {
      edge: "start"
    },
    style: {
      marginLeft: -12
    }
  }, {
    props: {
      edge: "start",
      size: "small"
    },
    style: {
      marginLeft: -3
    }
  }, {
    props: {
      edge: "end"
    },
    style: {
      marginRight: -12
    }
  }, {
    props: {
      edge: "end",
      size: "small"
    },
    style: {
      marginRight: -3
    }
  }]
})), memoTheme_default(({
  theme
}) => ({
  variants: [{
    props: {
      color: "inherit"
    },
    style: {
      color: "inherit"
    }
  }, ...Object.entries(theme.palette).filter(createSimplePaletteValueFilter()).map(([color3]) => ({
    props: {
      color: color3
    },
    style: {
      color: (theme.vars || theme).palette[color3].main
    }
  })), ...Object.entries(theme.palette).filter(createSimplePaletteValueFilter()).map(([color3]) => ({
    props: {
      color: color3
    },
    style: {
      "--IconButton-hoverBg": theme.vars ? `rgba(${(theme.vars || theme).palette[color3].mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha((theme.vars || theme).palette[color3].main, theme.palette.action.hoverOpacity)
    }
  })), {
    props: {
      size: "small"
    },
    style: {
      padding: 5,
      fontSize: theme.typography.pxToRem(18)
    }
  }, {
    props: {
      size: "large"
    },
    style: {
      padding: 12,
      fontSize: theme.typography.pxToRem(28)
    }
  }],
  [`&.${iconButtonClasses_default.disabled}`]: {
    backgroundColor: "transparent",
    color: (theme.vars || theme).palette.action.disabled
  },
  [`&.${iconButtonClasses_default.loading}`]: {
    color: "transparent"
  }
})));
var IconButtonLoadingIndicator = styled_default2("span", {
  name: "MuiIconButton",
  slot: "LoadingIndicator"
})(({
  theme
}) => ({
  display: "none",
  position: "absolute",
  visibility: "visible",
  top: "50%",
  left: "50%",
  transform: "translate(-50%, -50%)",
  color: (theme.vars || theme).palette.action.disabled,
  variants: [{
    props: {
      loading: true
    },
    style: {
      display: "flex"
    }
  }]
}));
var IconButton = React169.forwardRef(function IconButton2(inProps, ref) {
  const props = useDefaultProps2({
    props: inProps,
    name: "MuiIconButton"
  });
  const {
    edge = false,
    children: children2,
    className,
    color: color3 = "default",
    disabled = false,
    disableFocusRipple = false,
    size = "medium",
    id: idProp,
    loading = null,
    loadingIndicator: loadingIndicatorProp,
    ...other
  } = props;
  const loadingId = useId_default(idProp);
  const loadingIndicator = loadingIndicatorProp ?? (0, import_jsx_runtime118.jsx)(CircularProgress_default, {
    "aria-labelledby": loadingId,
    color: "inherit",
    size: 16
  });
  const ownerState = {
    ...props,
    edge,
    color: color3,
    disabled,
    disableFocusRipple,
    loading,
    loadingIndicator,
    size
  };
  const classes = useUtilityClasses30(ownerState);
  return (0, import_jsx_runtime118.jsxs)(IconButtonRoot, {
    id: loading ? loadingId : idProp,
    className: clsx_default(classes.root, className),
    centerRipple: true,
    focusRipple: !disableFocusRipple,
    disabled: disabled || loading,
    ref,
    ...other,
    ownerState,
    children: [typeof loading === "boolean" && // use plain HTML span to minimize the runtime overhead
    (0, import_jsx_runtime118.jsx)("span", {
      className: classes.loadingWrapper,
      style: {
        display: "contents"
      },
      children: (0, import_jsx_runtime118.jsx)(IconButtonLoadingIndicator, {
        className: classes.loadingIndicator,
        ownerState,
        children: loading && loadingIndicator
      })
    }), children2]
  });
});
true ? IconButton.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * The icon to display.
   */
  children: chainPropTypes(import_prop_types100.default.node, (props) => {
    const found = React169.Children.toArray(props.children).some((child) => React169.isValidElement(child) && child.props.onClick);
    if (found) {
      return new Error(["MUI: You are providing an onClick event listener to a child of a button element.", "Prefer applying it to the IconButton directly.", "This guarantees that the whole <button> will be responsive to click events."].join("\n"));
    }
    return null;
  }),
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types100.default.object,
  /**
   * @ignore
   */
  className: import_prop_types100.default.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).
   * @default 'default'
   */
  color: import_prop_types100.default.oneOfType([import_prop_types100.default.oneOf(["inherit", "default", "primary", "secondary", "error", "info", "success", "warning"]), import_prop_types100.default.string]),
  /**
   * If `true`, the component is disabled.
   * @default false
   */
  disabled: import_prop_types100.default.bool,
  /**
   * If `true`, the  keyboard focus ripple is disabled.
   * @default false
   */
  disableFocusRipple: import_prop_types100.default.bool,
  /**
   * If `true`, the ripple effect is disabled.
   *
   *  Without a ripple there is no styling for :focus-visible by default. Be sure
   * to highlight the element by applying separate styles with the `.Mui-focusVisible` class.
   * @default false
   */
  disableRipple: import_prop_types100.default.bool,
  /**
   * If given, uses a negative margin to counteract the padding on one
   * side (this is often helpful for aligning the left or right
   * side of the icon with content above or below, without ruining the border
   * size and shape).
   * @default false
   */
  edge: import_prop_types100.default.oneOf(["end", "start", false]),
  /**
   * @ignore
   */
  id: import_prop_types100.default.string,
  /**
   * If `true`, the loading indicator is visible and the button is disabled.
   * If `true | false`, the loading wrapper is always rendered before the children to prevent [Google Translation Crash](https://github.com/mui/material-ui/issues/27853).
   * @default null
   */
  loading: import_prop_types100.default.bool,
  /**
   * Element placed before the children if the button is in loading state.
   * The node should contain an element with `role="progressbar"` with an accessible name.
   * By default, it renders a `CircularProgress` that is labeled by the button itself.
   * @default <CircularProgress color="inherit" size={16} />
   */
  loadingIndicator: import_prop_types100.default.node,
  /**
   * The size of the component.
   * `small` is equivalent to the dense button styling.
   * @default 'medium'
   */
  size: import_prop_types100.default.oneOfType([import_prop_types100.default.oneOf(["small", "medium", "large"]), import_prop_types100.default.string]),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types100.default.oneOfType([import_prop_types100.default.arrayOf(import_prop_types100.default.oneOfType([import_prop_types100.default.func, import_prop_types100.default.object, import_prop_types100.default.bool])), import_prop_types100.default.func, import_prop_types100.default.object])
} : void 0;
var IconButton_default = IconButton;

// node_modules/@mui/x-charts/esm/internals/material/index.js
var baseSlots = {
  baseIconButton: IconButton_default
};
var iconSlots = {};
var defaultSlotsMaterial = _extends({}, baseSlots, iconSlots);

// node_modules/@mui/x-charts/esm/Toolbar/ToolbarButton.js
var import_jsx_runtime119 = __toESM(require_jsx_runtime(), 1);
var ToolbarButton = React170.forwardRef(function ToolbarButton2(props, ref) {
  const IconButton3 = defaultSlotsMaterial.baseIconButton;
  return (0, import_jsx_runtime119.jsx)(IconButton3, _extends({
    ref
  }, props));
});
true ? ToolbarButton.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  className: import_prop_types101.default.string,
  style: import_prop_types101.default.object
} : void 0;
export {
  AXIS_LABEL_DEFAULT_HEIGHT,
  AnimatedArea,
  AnimatedLine,
  AreaElement,
  AreaPlot,
  BarChart,
  BarElement,
  BarLabel,
  BarPlot,
  ChartContainer,
  ChartDataProvider,
  ChartsAxis,
  ChartsAxisHighlight,
  ChartsAxisHighlightPath,
  ChartsAxisTooltipContent,
  ChartsClipPath,
  ChartsGrid,
  ChartsItemTooltipContent,
  ChartsLabelMark,
  ChartsLegend,
  ChartsLocalizationProvider,
  ChartsReferenceLine,
  ChartsSurface,
  ChartsText,
  ChartsTooltip,
  ChartsTooltipCell,
  ChartsTooltipContainer,
  ChartsTooltipPaper,
  ChartsTooltipRow,
  ChartsTooltipTable,
  ChartsXAxis,
  ChartsYAxis,
  ContinuousColorLegend,
  DEFAULT_AXIS_SIZE_HEIGHT,
  DEFAULT_AXIS_SIZE_WIDTH,
  DEFAULT_MARGINS,
  DEFAULT_RADIUS_AXIS_KEY,
  DEFAULT_ROTATION_AXIS_KEY,
  DEFAULT_X_AXIS_KEY,
  DEFAULT_Y_AXIS_KEY,
  Gauge,
  GaugeContainer,
  GaugeReferenceArc,
  GaugeValueArc,
  GaugeValueText,
  LineChart,
  LineElement,
  LineHighlightElement,
  LineHighlightPlot,
  LinePlot,
  MarkElement,
  MarkPlot,
  PieArc,
  PieArcLabel,
  PieArcLabelPlot,
  PieArcPlot,
  PieChart,
  PiePlot,
  PiecewiseColorLegend,
  RadarAxisHighlight,
  RadarGrid,
  RadarMetricLabels,
  RadarSeriesArea,
  RadarSeriesMarks,
  RadarSeriesPlot,
  Scatter,
  ScatterChart,
  ScatterMarker,
  ScatterPlot,
  SparkLineChart,
  Toolbar,
  ToolbarButton,
  RadarChart as Unstable_RadarChart,
  RadarDataProvider as Unstable_RadarDataProvider,
  areaElementClasses,
  axisClasses,
  barElementClasses,
  barLabelClasses,
  bluePalette,
  bluePaletteDark,
  bluePaletteLight,
  blueberryTwilightPalette,
  blueberryTwilightPaletteDark,
  blueberryTwilightPaletteLight,
  chartsAxisHighlightClasses,
  chartsGridClasses,
  chartsTooltipClasses,
  cheerfulFiestaPalette,
  cheerfulFiestaPaletteDark,
  cheerfulFiestaPaletteLight,
  continuousColorLegendClasses,
  cyanPalette,
  cyanPaletteDark,
  cyanPaletteLight,
  gaugeClasses,
  getAreaElementUtilityClass,
  getAxisHighlightUtilityClass,
  getAxisUtilityClass,
  getBarElementUtilityClass,
  getBarLabelUtilityClass,
  getChartsGridUtilityClass,
  getChartsTooltipUtilityClass,
  getGaugeUtilityClass,
  getHighlightElementUtilityClass,
  getLineElementUtilityClass,
  getMarkElementUtilityClass,
  getPieArcLabelUtilityClass,
  getPieArcUtilityClass,
  getPieCoordinates,
  getReferenceLineUtilityClass,
  getValueToPositionMapper,
  greenPalette,
  greenPaletteDark,
  greenPaletteLight,
  isBarSeries,
  isDefaultizedBarSeries,
  labelClasses,
  labelGradientClasses,
  labelMarkClasses,
  legendClasses,
  lineElementClasses,
  lineHighlightElementClasses,
  mangoFusionPalette,
  mangoFusionPaletteDark,
  mangoFusionPaletteLight,
  markElementClasses,
  orangePalette,
  orangePaletteDark,
  orangePaletteLight,
  pieArcClasses,
  pieArcLabelClasses,
  piecewiseColorDefaultLabelFormatter,
  piecewiseColorLegendClasses,
  pinkPalette,
  pinkPaletteDark,
  pinkPaletteLight,
  purplePalette,
  purplePaletteDark,
  purplePaletteLight,
  radarSeriesPlotClasses,
  rainbowSurgePalette,
  rainbowSurgePaletteDark,
  rainbowSurgePaletteLight,
  redPalette,
  redPaletteDark,
  redPaletteLight,
  referenceLineClasses,
  strawberrySkyPalette,
  strawberrySkyPaletteDark,
  strawberrySkyPaletteLight,
  useAnimate,
  useAnimateArea,
  useAnimateBar,
  useAnimateBarLabel,
  useAnimateLine,
  useAnimatePieArc,
  useAnimatePieArcLabel,
  useAxesTooltip,
  useAxisTooltip,
  useBarSeries,
  useBarSeriesContext,
  useChartGradientId,
  useChartGradientIdObjectBound,
  useChartId2 as useChartId,
  useChartRootRef,
  useChartsLocalization,
  useDrawingArea,
  useGaugeState,
  useItemHighlighted,
  useItemHighlightedGetter,
  useItemTooltip,
  useLegend,
  useLineSeries,
  useLineSeriesContext,
  useMouseTracker,
  usePieSeries,
  usePieSeriesContext,
  useRadarItemTooltip,
  useRadiusAxes,
  useRadiusAxis,
  useRadiusScale,
  useRotationAxes,
  useRotationAxis,
  useRotationScale,
  useScatterSeries,
  useScatterSeriesContext,
  useSeries,
  useSvgRef,
  useUtilityClasses15 as useUtilityClasses,
  useXAxes,
  useXAxis,
  useXColorScale,
  useXScale,
  useYAxes,
  useYAxis,
  useYColorScale,
  useYScale,
  useZAxes,
  useZAxis,
  useZColorScale,
  yellowPalette,
  yellowPaletteDark,
  yellowPaletteLight
};
/*! Bundled license information:

use-sync-external-store/cjs/use-sync-external-store-with-selector.development.js:
  (**
   * @license React
   * use-sync-external-store-with-selector.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-is/cjs/react-is.development.js:
  (**
   * @license React
   * react-is.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@mui/styled-engine-sc/esm/index.js:
  (**
   * @mui/styled-engine-sc v7.1.0
   *
   * @license MIT
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@mui/private-theming/esm/index.js:
  (**
   * @mui/private-theming v7.1.0
   *
   * @license MIT
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@mui/system/esm/index.js:
  (**
   * @mui/system v7.1.0
   *
   * @license MIT
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@mui/x-charts/esm/index.js:
  (**
   * @mui/x-charts v8.3.0
   *
   * @license MIT
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=@mui_x-charts.js.map
